.TH "CoolMQTT" 3 "Thu Jul 13 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CoolMQTT \- This class handles the mqtt client\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CoolMQTT\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "int \fBconnect\fP (uint16_t keepAlive)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data, int logInterval)"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "void \fBconfig\fP (const char \fBmqttServer\fP[], const char \fBinTopic\fP[], const char \fBoutTopic\fP[], const char \fBuser\fP[], int \fBbufferSize\fP)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBcallback\fP (char *topic, byte *payload, unsigned int length)"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "int \fBstate\fP ()"
.br
.ti -1c
.RI "bool \fBmqttLoop\fP ()"
.br
.ti -1c
.RI "String \fBgetUser\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char \fBmqttServer\fP [50] ={'0'}"
.br
.ti -1c
.RI "String \fBmsg\fP =''"
.br
.ti -1c
.RI "char \fBinTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBoutTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBuser\fP [50] ={'0'}"
.br
.ti -1c
.RI "int \fBbufferSize\fP =3000"
.br
.ti -1c
.RI "WiFiClient \fBespClient\fP"
.br
.ti -1c
.RI "PubSubClient \fBclient\fP"
.br
.ti -1c
.RI "bool \fBnewMsg\fP =0"
.br
.ti -1c
.RI "unsigned long \fBpreviousLogTime\fP =0"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class handles the mqtt client\&. 
.PP
Definition at line 22 of file CoolMQTT\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void CoolMQTT::begin ()"
\fBCoolMQTT::begin()\fP: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size 
.PP
Definition at line 39 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, callback(), client, espClient, and mqttServer\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
40 { 
41 
42 #if DEBUG == 1 
43 
44     Serial\&.println( F("Entering CoolMQTT\&.begin()") );
45     Serial\&.println();
46 
47 #endif
48 
49     client\&.setClient(espClient);
50     client\&.setServer(mqttServer, 1883);  
51     client\&.setCallback([this] (char* topic, byte* payload, unsigned int length) { this->callback(topic, payload, length); });
52     client\&.setBufferSize((unsigned short)bufferSize);
53 
54 }
.fi
.SS "void CoolMQTT::callback (char * topic, byte * payload, unsigned int length)"
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic\&.
.PP
Arguments are automatically assigned in client\&.setCallback() 
.PP
Definition at line 279 of file CoolMQTT\&.cpp\&.
.PP
References msg, newMsg, and temp\&.
.PP
Referenced by begin()\&.
.PP
.nf
280 {
281 
282 #if DEBUG == 1
283 
284     Serial\&.println( F("Entering CoolMQTT\&.callback() ") );
285     Serial\&.println();
286 
287 #endif 
288 
289     if(this->newMsg==false)
290     {
291         char temp[length+1];
292 
293     #if DEBUG == 1
294 
295         Serial\&.println( F("received temp msg : ") );
296 
297     #endif
298         
299         for (int i = 0; i < length; i++) 
300         {
301             temp[i]=(char)payload[i];
302         
303         #if DEBUG == 1 
304 
305             Serial\&.print( (char)payload[i] );
306         
307         #endif
308 
309         }
310     
311     #if DEBUG == 1 
312 
313         Serial\&.println();
314         Serial\&.println( F("storing new message : ") );
315         Serial\&.println();
316     
317     #endif
318 
319         this->newMsg=true;
320 
321         temp[length+1]='\0';
322 
323         this->msg=String(temp);
324         this->msg\&.remove(length,1);
325     
326     #if DEBUG == 1 
327 
328         Serial\&.println( F("stored message : ") );
329         Serial\&.println(this->msg);
330     
331     #endif
332 
333     }
334     else
335     {
336     
337     #if DEBUG == 1
338 
339         Serial\&.println( F("did not read last message") );
340     
341     #endif 
342         
343     }
344 
345 }
.fi
.SS "void CoolMQTT::config (const char mqttServer[], const char inTopic[], const char outTopic[], const char user[], int bufferSize)"
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client 
.PP
Definition at line 585 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
586 {
587 
588 #if DEBUG == 1
589 
590     Serial\&.println( F("Entering CoolMQTT\&.config() , no SPIFFS variant") );
591     Serial\&.println();
592 
593 #endif
594 
595     for(int i =0;i< 50 ;i++)
596     {
597         this->mqttServer[i]=mqttServer[i];
598         this->inTopic[i]=inTopic[i];
599         this->outTopic[i]=outTopic[i];
600         this->user[i]=user[i];
601     }
602     this->bufferSize=bufferSize;
603     
604 
605 }
.fi
.SS "bool CoolMQTT::config ()"
\fBCoolMQTT::config()\fP: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 393 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, inTopic, mqttServer, outTopic, and user\&.
.PP
.nf
394 {
395 
396 #if DEBUG == 1 
397 
398     Serial\&.println( F("Entering CoolMQTT\&.config()") );
399     Serial\&.println();
400 
401 #endif
402 
403     //read config file
404     //update data
405     File configFile = SPIFFS\&.open("/mqttConfig\&.json", "r");
406 
407     if (!configFile) 
408     {
409     
410     #if DEBUG == 1 
411 
412         Serial\&.println( F("failed to read /mqttConfig\&.json") );
413         Serial\&.println();
414 
415     #endif
416 
417         return(false);
418     }
419     else
420     {
421         size_t size = configFile\&.size();
422         // Allocate a buffer to store contents of the file\&.
423         std::unique_ptr<char[]> buf(new char[size]);
424 
425         configFile\&.readBytes(buf\&.get(), size);
426         DynamicJsonBuffer jsonBuffer;
427         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
428         if (!json\&.success()) 
429         {
430         
431         #if DEBUG == 1 
432 
433             Serial\&.println( F("failed to parse json ") );
434             Serial\&.println();
435         
436         #endif
437             
438             return(false);
439         } 
440         else
441         {
442         
443         #if DEBUG == 1 
444         
445             Serial\&.println( F("configuration json is ") );
446             json\&.printTo(Serial);
447             Serial\&.println();
448 
449         #endif
450 
451             if(json["mqttServer"]\&.success() )
452             {           
453                 const char* tempmqttServer = json["mqttServer"]; 
454                 for(int i =0;i< 50 ;i++)
455                 {
456                     mqttServer[i]=tempmqttServer[i];
457                 }
458             }
459             else
460             {
461                 for(int i =0;i< 50 ;i++)
462                 {
463                     this->mqttServer[i]=this->mqttServer[i];
464                 }
465 
466             }
467             json["mqttServer"]=this->mqttServer;
468 
469             
470             if(json["inTopic"]\&.success() )
471             {
472                 const char* tempInTopic = json["inTopic"]; 
473                 for(int i =0;i< 50;i++)
474                 {
475                     inTopic[i]=tempInTopic[i];
476                 }
477             }
478             else
479             {
480                 String tempMAC = WiFi\&.macAddress();
481                 tempMAC\&.replace(":","");
482                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC\&.c_str());    
483             
484             #if DEBUG == 1              
485                 
486                 Serial\&.print( F("Set Incomming MQTT Channel to : ") );
487                 Serial\&.println(inTopic);
488             
489             #endif  
490 
491             }
492             json["inTopic"]=this->inTopic;
493             
494             
495             if(json["outTopic"]\&.success() )
496             {
497                 const char* tempOutTopic = json["outTopic"]; 
498                 for(int i =0;i<50;i++)
499                 {
500                     outTopic[i]=tempOutTopic[i];
501                 }
502             }
503             else
504             {
505                 String tempMAC = WiFi\&.macAddress();
506                 tempMAC\&.replace(":","");
507                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC\&.c_str());
508             
509             #if DEBUG == 1 
510 
511                 Serial\&.print( F("Set Outgoing MQTT Channel to : ") );
512                 Serial\&.println(outTopic);
513             
514             #endif
515 
516             }
517             json["outTopic"]=this->outTopic;
518         
519             
520             if(json["user"]\&.success() )
521             {               
522                 const char* tempUser = json["user"]; 
523                 for(int i =0;i<50;i++)
524                 {
525                     user[i]=tempUser[i];
526                 }
527             }
528             else
529             {
530                 for(int i=0;i<50;i++)
531                 {
532                     this->user[i]=this->user[i];
533                 }               
534             }
535             json["user"]=this->user;
536             
537             if(json["bufferSize"]\&.success() )
538             {
539                 int tempBufferSize = json["bufferSize"]; 
540                 bufferSize=tempBufferSize;
541             }
542             else
543             {
544                 this->bufferSize=this->bufferSize;
545             }
546             json["bufferSize"]=this->bufferSize;
547 
548             configFile\&.close();
549             configFile = SPIFFS\&.open("/mqttConfig\&.json", "w");
550             if(!configFile)
551             {
552             
553             #if DEBUG == 1 
554 
555                 Serial\&.println( F("failed to write to /mqttConfig\&.json") );
556             
557             #endif
558 
559                 return(false);              
560             }
561             
562             json\&.printTo(configFile);
563             configFile\&.close();
564 
565         #if DEBUG == 1 
566 
567             Serial\&.println( F("saved configuration is :") );
568             json\&.printTo(Serial);
569             Serial\&.println();
570         
571         #endif
572 
573             return(true); 
574         }
575     }   
576     
577 
578 }
.fi
.SS "int CoolMQTT::connect (uint16_t keepAlive)"
CoolMQTT::connect( time to keep the connection alive ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time\&.
.PP
\fBReturns:\fP
.RS 4
mqtt client state 
.RE
.PP

.PP
Definition at line 95 of file CoolMQTT\&.cpp\&.
.PP
References client, inTopic, state(), and user\&.
.PP
Referenced by CoolBoard::connect()\&.
.PP
.nf
96 {       
97 
98     int i=0;
99 
100 #if DEBUG == 1 
101 
102     Serial\&.println( F("Entering CoolMQTT\&.connect()") );
103     Serial\&.println( F("MQTT connecting\&.\&.\&.") );
104 
105 #endif
106 
107     while( ( !this->client\&.connected() ) && ( i<100 ) ) 
108     {
109         // Attempt to connect
110         if( this->client\&.connect( this-> user, keepAlive ) )
111         {
112             client\&.subscribe( this->inTopic );
113 
114         #if DEBUG == 1 
115 
116             Serial\&.println( F("MQTT connected") );
117             Serial\&.println( F(" subscribed , leavin ") ) ;
118         
119         #endif
120 
121             return( this->state() );
122         }
123 
124         else
125         {
126         
127         #if DEBUG == 1 
128 
129             Serial\&.println( F("not connected , retrying") );
130         
131         #endif
132 
133             
134         }
135 
136     delay(5);
137     i++;
138     }
139     
140     return( this->state() );
141 
142 }
.fi
.SS "String CoolMQTT::getUser ()"
\fBCoolMQTT::getUser()\fP: This method is provided to get the user name 
.PP
Definition at line 648 of file CoolMQTT\&.cpp\&.
.PP
References user\&.
.PP
Referenced by CoolBoard::userData()\&.
.PP
.nf
649 {
650 
651 #if DEBUG == 1 
652     Serial\&.println( F("Entering CoolMQTT\&.getUser()") );
653     Serial\&.println();
654     
655     Serial\&.print( F("user : ") );
656     Serial\&.println(this->user);
657 
658 #endif
659 
660     return String(this->user);
661 }
.fi
.SS "bool CoolMQTT::mqttLoop ()"
\fBCoolMQTT::mqttLoop()\fP: This method is provided to allow the client to process the data
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 244 of file CoolMQTT\&.cpp\&.
.PP
References client\&.
.PP
Referenced by CoolBoard::onLineMode(), and CoolBoard::update()\&.
.PP
.nf
245 {
246 
247     unsigned long lastTime=millis();
248 
249 #if DEBUG == 1
250 
251     Serial\&.println( F("Entering CoolMQTT\&.mqttLoop()") );
252     Serial\&.println();
253 
254 #endif  
255 
256     while( ( millis() - lastTime ) < 5000)
257     {
258         this->client\&.loop(); 
259     }
260 
261 #if DEBUG == 1 
262     
263     Serial\&.print( F("loop result : ") );
264     Serial\&.println( this->client\&.loop() );
265     Serial\&.println();
266 
267 #endif
268 
269     return( this->client\&.loop() );
270 }
.fi
.SS "void CoolMQTT::printConf ()"
\fBCoolMQTT::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 612 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, inTopic, mqttServer, outTopic, and user\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
613 {
614 
615 #if DEBUG == 1 
616 
617     Serial\&.println( F("Entering CoolMQTT\&.printConf()") );
618     Serial\&.println();    
619 
620 #endif
621     
622     Serial\&.println("MQTT configuration ");
623 
624     Serial\&.print("mqttServer : ");
625     Serial\&.println(this->mqttServer);
626 
627     Serial\&.print("inTopic : ");
628     Serial\&.println(this->inTopic);
629 
630     Serial\&.print("outTopic : ");
631     Serial\&.println(this->outTopic);
632 
633     Serial\&.print("user : ");
634     Serial\&.println(this->user);
635 
636     Serial\&.print("bufferSize : ");
637     Serial\&.println(this->bufferSize);
638 
639     Serial\&.println();
640 
641 
642 }
.fi
.SS "bool CoolMQTT::publish (const char * data)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 152 of file CoolMQTT\&.cpp\&.
.PP
References client, and outTopic\&.
.PP
Referenced by CoolBoard::onLineMode(), publish(), and CoolBoard::update()\&.
.PP
.nf
153 {
154 
155 #if DEBUG == 1 
156 
157     Serial\&.println( F("Entering CoolMQTT\&.publish()") );
158     Serial\&.println();
159     //data is in JSON, publish it directly
160 
161     Serial\&.println( F("data to publish : ") );
162     Serial\&.println(data);
163     Serial\&.print( F("data size : ") );
164     Serial\&.println(strlen(data));
165 
166     Serial\&.println();
167 
168 #endif
169     
170 
171     bool pub=client\&.publish( this->outTopic,(byte*) data,strlen(data),false  );
172 
173 #if DEBUG == 1 
174 
175     Serial\&.print( F("success : ") );
176     Serial\&.println(pub); 
177 
178 #endif
179 
180     return(pub);
181 
182 }
.fi
.SS "bool CoolMQTT::publish (const char * data, int logInterval)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval ms
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 192 of file CoolMQTT\&.cpp\&.
.PP
References previousLogTime, and publish()\&.
.PP
.nf
193 {
194 
195 #if DEBUG == 1 
196 
197     Serial\&.println( F("Entering CoolMQTT\&.publish() every logInterval ") );
198     Serial\&.println();
199 
200 #endif 
201     
202     if( ( millis() - ( this->previousLogTime)  ) >=( logInterval ) )
203     {
204     
205     #if DEBUG == 1
206 
207         Serial\&.println( F("log Interval has passed ") );
208         Serial\&.println();
209     
210     #endif
211 
212         this->publish(data);
213 
214         this->previousLogTime=millis();
215     
216     #if DEBUG == 1 
217 
218         Serial\&.print( F("last log time : ") );
219         Serial\&.println(this->previousLogTime);
220 
221     #endif
222 
223         return(true);
224     }
225 
226 #if DEBUG == 1 
227 
228     Serial\&.println( F("log Interval still didn't pass ") );  
229     Serial\&.println();
230 
231 #endif
232 
233     return(false);
234 }
.fi
.SS "String CoolMQTT::read ()"
\fBCoolMQTT::read()\fP: This method is provided to return the last read message\&. 
.PP
Definition at line 352 of file CoolMQTT\&.cpp\&.
.PP
References msg, and newMsg\&.
.PP
Referenced by CoolBoard::onLineMode()\&.
.PP
.nf
353 {   
354 
355 #if DEBUG == 1 
356 
357     Serial\&.println( F("Entering CoolMQTT\&.read()") );
358     Serial\&.println();
359 
360 #endif 
361 
362     if(this->newMsg==true)
363     {
364         
365         this->newMsg=false;
366 
367 #if DEBUG == 1 
368         Serial\&.println( F("received new message") );
369         Serial\&.println( F("message : ") );
370         Serial\&.println(this->msg);
371         Serial\&.println();
372 
373 #endif
374 
375         return(this->msg);
376         
377     }
378     return("");
379 
380 }
.fi
.SS "int CoolMQTT::state ()"
\fBCoolMQTT::state()\fP: This method is provided to return the mqtt client's state\&. 
.PP
\fBReturns:\fP
.RS 4
mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect 
.RE
.PP

.PP
Definition at line 72 of file CoolMQTT\&.cpp\&.
.PP
References client\&.
.PP
Referenced by connect(), and CoolBoard::connect()\&.
.PP
.nf
73 {
74 
75 #if DEBUG == 1 
76 
77     Serial\&.println( F("Entering CoolMQTT\&.state()") );
78     Serial\&.println();    
79     Serial\&.print( F("state : ") );
80     Serial\&.println( this->client\&.state() );
81 
82 #endif
83     
84     return( this->client\&.state() );
85 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int CoolMQTT::bufferSize =3000\fC [private]\fP"

.PP
Definition at line 56 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), config(), and printConf()\&.
.SS "PubSubClient CoolMQTT::client\fC [private]\fP"

.PP
Definition at line 58 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), connect(), mqttLoop(), publish(), and state()\&.
.SS "WiFiClient CoolMQTT::espClient\fC [private]\fP"

.PP
Definition at line 57 of file CoolMQTT\&.h\&.
.PP
Referenced by begin()\&.
.SS "char CoolMQTT::inTopic[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 53 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), connect(), and printConf()\&.
.SS "char CoolMQTT::mqttServer[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 51 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), config(), and printConf()\&.
.SS "String CoolMQTT::msg =''\fC [private]\fP"

.PP
Definition at line 52 of file CoolMQTT\&.h\&.
.PP
Referenced by callback(), and read()\&.
.SS "bool CoolMQTT::newMsg =0\fC [private]\fP"

.PP
Definition at line 59 of file CoolMQTT\&.h\&.
.PP
Referenced by callback(), and read()\&.
.SS "char CoolMQTT::outTopic[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 54 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), printConf(), and publish()\&.
.SS "unsigned long CoolMQTT::previousLogTime =0\fC [private]\fP"

.PP
Definition at line 60 of file CoolMQTT\&.h\&.
.PP
Referenced by publish()\&.
.SS "char CoolMQTT::user[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 55 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), connect(), getUser(), and printConf()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
