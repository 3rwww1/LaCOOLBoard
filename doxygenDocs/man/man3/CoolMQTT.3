.TH "CoolMQTT" 3 "Mon Aug 7 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CoolMQTT \- This class handles the mqtt client\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CoolMQTT\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "int \fBconnect\fP (unsigned long keepAlive)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data, unsigned long logInterval)"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "void \fBconfig\fP (const char \fBmqttServer\fP[], const char \fBinTopic\fP[], const char \fBoutTopic\fP[], const char \fBuser\fP[], int \fBbufferSize\fP)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBcallback\fP (char *topic, byte *payload, unsigned int length)"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "int \fBstate\fP ()"
.br
.ti -1c
.RI "bool \fBmqttLoop\fP ()"
.br
.ti -1c
.RI "String \fBgetUser\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char \fBmqttServer\fP [50] ={'0'}"
.br
.ti -1c
.RI "String \fBmsg\fP =''"
.br
.ti -1c
.RI "char \fBinTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBoutTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBuser\fP [50] ={'0'}"
.br
.ti -1c
.RI "int \fBbufferSize\fP =3000"
.br
.ti -1c
.RI "WiFiClient \fBespClient\fP"
.br
.ti -1c
.RI "PubSubClient \fBclient\fP"
.br
.ti -1c
.RI "bool \fBnewMsg\fP =0"
.br
.ti -1c
.RI "unsigned long \fBpreviousLogTime\fP =0"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class handles the mqtt client\&. 
.PP
Definition at line 22 of file CoolMQTT\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void CoolMQTT::begin ()"
\fBCoolMQTT::begin()\fP: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size 
.PP
Definition at line 39 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, callback(), client, espClient, and mqttServer\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
40 { 
41 
42 #if DEBUG == 1 
43 
44     Serial\&.println( F("Entering CoolMQTT\&.begin()") );
45     Serial\&.println();
46 
47 #endif
48 
49     client\&.setClient(espClient);
50     client\&.setServer(mqttServer, 1883);  
51     client\&.setCallback([this] (char* topic, byte* payload, unsigned int length) { this->callback(topic, payload, length); });
52     client\&.setBufferSize((unsigned short)bufferSize);
53 
54 }
.fi
.SS "void CoolMQTT::callback (char * topic, byte * payload, unsigned int length)"
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic\&.
.PP
Arguments are automatically assigned in client\&.setCallback() 
.PP
Definition at line 280 of file CoolMQTT\&.cpp\&.
.PP
References msg, newMsg, and temp\&.
.PP
Referenced by begin()\&.
.PP
.nf
281 {
282 
283 #if DEBUG == 1
284 
285     Serial\&.println( F("Entering CoolMQTT\&.callback() ") );
286     Serial\&.println();
287 
288 #endif 
289 
290     if(this->newMsg==false)
291     {
292         char temp[length+1];
293 
294     #if DEBUG == 1
295 
296         Serial\&.println( F("received temp msg : ") );
297         
298     #endif
299         
300         for (unsigned int i = 0; i < length; i++) 
301         {
302             temp[i]=(char)payload[i];
303         
304         #if DEBUG == 1 
305 
306             Serial\&.print( (char)payload[i] );
307         
308         #endif
309 
310         }
311     
312     #if DEBUG == 1 
313 
314         Serial\&.println();
315         Serial\&.println( F("storing new message : ") );
316 
317         Serial\&.print(F("length : "));
318         Serial\&.println(length);
319         
320         Serial\&.print(F("size : "));
321         Serial\&.print(sizeof(payload));
322         Serial\&.println();
323     
324     #endif
325 
326         this->newMsg=true;
327 
328         temp[length+1]='\0';
329 
330         this->msg=String(temp);
331         this->msg\&.remove(length,1);
332     
333     #if DEBUG == 1 
334 
335         Serial\&.println( F("stored message : ") );
336         Serial\&.println(this->msg);
337     
338     #endif
339 
340     }
341     else
342     {
343     
344     #if DEBUG == 1
345 
346         Serial\&.println( F("did not read last message") );
347     
348     #endif 
349         
350     }
351 
352 }
.fi
.SS "void CoolMQTT::config (const char mqttServer[], const char inTopic[], const char outTopic[], const char user[], int bufferSize)"
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client 
.PP
Definition at line 597 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
598 {
599 
600 #if DEBUG == 1
601 
602     Serial\&.println( F("Entering CoolMQTT\&.config() , no SPIFFS variant") );
603     Serial\&.println();
604 
605 #endif
606 
607     for(int i =0;i< 50 ;i++)
608     {
609         this->mqttServer[i]=mqttServer[i];
610         this->inTopic[i]=inTopic[i];
611         this->outTopic[i]=outTopic[i];
612         this->user[i]=user[i];
613     }
614     this->bufferSize=bufferSize;
615     
616 
617 }
.fi
.SS "bool CoolMQTT::config ()"
\fBCoolMQTT::config()\fP: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 400 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, inTopic, mqttServer, outTopic, and user\&.
.PP
.nf
401 {
402 
403 #if DEBUG == 1 
404 
405     Serial\&.println( F("Entering CoolMQTT\&.config()") );
406     Serial\&.println();
407 
408 #endif
409 
410     //read config file
411     //update data
412     File configFile = SPIFFS\&.open("/mqttConfig\&.json", "r");
413 
414     if (!configFile) 
415     {
416     
417     #if DEBUG == 1 
418 
419         Serial\&.println( F("failed to read /mqttConfig\&.json") );
420         Serial\&.println();
421 
422     #endif
423 
424         return(false);
425     }
426     else
427     {
428         size_t size = configFile\&.size();
429         // Allocate a buffer to store contents of the file\&.
430         std::unique_ptr<char[]> buf(new char[size]);
431 
432         configFile\&.readBytes(buf\&.get(), size);
433         DynamicJsonBuffer jsonBuffer;
434         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
435         if (!json\&.success()) 
436         {
437         
438         #if DEBUG == 1 
439 
440             Serial\&.println( F("failed to parse json ") );
441             Serial\&.println();
442         
443         #endif
444             
445             return(false);
446         } 
447         else
448         {
449         
450         #if DEBUG == 1 
451         
452             Serial\&.println( F("configuration json is ") );
453             json\&.printTo(Serial);
454             Serial\&.println();
455 
456             Serial\&.print(F("jsonBuffer size: "));
457             Serial\&.println(jsonBuffer\&.size());
458             Serial\&.println();
459 
460 
461         #endif
462 
463             if(json["mqttServer"]\&.success() )
464             {           
465                 const char* tempmqttServer = json["mqttServer"]; 
466                 for(int i =0;i< 50 ;i++)
467                 {
468                     mqttServer[i]=tempmqttServer[i];
469                 }
470             }
471             else
472             {
473                 for(int i =0;i< 50 ;i++)
474                 {
475                     this->mqttServer[i]=this->mqttServer[i];
476                 }
477 
478             }
479             json["mqttServer"]=this->mqttServer;
480 
481             
482             if(json["inTopic"]\&.success() )
483             {
484                 const char* tempInTopic = json["inTopic"]; 
485                 for(int i =0;i< 50;i++)
486                 {
487                     inTopic[i]=tempInTopic[i];
488                 }
489             }
490             else
491             {
492                 String tempMAC = WiFi\&.macAddress();
493                 tempMAC\&.replace(":","");
494                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC\&.c_str());    
495             
496             #if DEBUG == 1              
497                 
498                 Serial\&.print( F("Set Incomming MQTT Channel to : ") );
499                 Serial\&.println(inTopic);
500             
501             #endif  
502 
503             }
504             json["inTopic"]=this->inTopic;
505             
506             
507             if(json["outTopic"]\&.success() )
508             {
509                 const char* tempOutTopic = json["outTopic"]; 
510                 for(int i =0;i<50;i++)
511                 {
512                     outTopic[i]=tempOutTopic[i];
513                 }
514             }
515             else
516             {
517                 String tempMAC = WiFi\&.macAddress();
518                 tempMAC\&.replace(":","");
519                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC\&.c_str());
520             
521             #if DEBUG == 1 
522 
523                 Serial\&.print( F("Set Outgoing MQTT Channel to : ") );
524                 Serial\&.println(outTopic);
525             
526             #endif
527 
528             }
529             json["outTopic"]=this->outTopic;
530         
531             
532             if(json["user"]\&.success() )
533             {               
534                 const char* tempUser = json["user"]; 
535                 for(int i =0;i<50;i++)
536                 {
537                     user[i]=tempUser[i];
538                 }
539             }
540             else
541             {
542                 for(int i=0;i<50;i++)
543                 {
544                     this->user[i]=this->user[i];
545                 }               
546             }
547             json["user"]=this->user;
548             
549             if(json["bufferSize"]\&.success() )
550             {
551                 int tempBufferSize = json["bufferSize"]; 
552                 bufferSize=tempBufferSize;
553             }
554             else
555             {
556                 this->bufferSize=this->bufferSize;
557             }
558             json["bufferSize"]=this->bufferSize;
559 
560             configFile\&.close();
561             configFile = SPIFFS\&.open("/mqttConfig\&.json", "w");
562             if(!configFile)
563             {
564             
565             #if DEBUG == 1 
566 
567                 Serial\&.println( F("failed to write to /mqttConfig\&.json") );
568             
569             #endif
570 
571                 return(false);              
572             }
573             
574             json\&.printTo(configFile);
575             configFile\&.close();
576 
577         #if DEBUG == 1 
578 
579             Serial\&.println( F("saved configuration is :") );
580             json\&.printTo(Serial);
581             Serial\&.println();
582         
583         #endif
584 
585             return(true); 
586         }
587     }   
588     
589 
590 }
.fi
.SS "int CoolMQTT::connect (unsigned long keepAlive)"
CoolMQTT::connect( time to keep the connection alive in seconds ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time\&.
.PP
\fBReturns:\fP
.RS 4
mqtt client state 
.RE
.PP

.PP
Definition at line 95 of file CoolMQTT\&.cpp\&.
.PP
References client, inTopic, state(), and user\&.
.PP
Referenced by CoolBoard::connect()\&.
.PP
.nf
96 {       
97 
98     int i=0;
99 
100 #if DEBUG == 1 
101 
102     Serial\&.println( F("Entering CoolMQTT\&.connect()") );
103     Serial\&.println( F("MQTT connecting\&.\&.\&.") );
104 
105 #endif
106     
107     while( ( !this->client\&.connected() ) && ( i<100 ) ) 
108     {
109         // Attempt to connect
110         if( this->client\&.connect( this-> user,keepAlive*10  ) )
111         {
112             client\&.subscribe( this->inTopic );
113 
114         #if DEBUG == 1 
115 
116             Serial\&.println( F("MQTT connected") );
117             Serial\&.println( F(" subscribed , leavin ") ) ;
118         
119         #endif
120 
121             return( this->state() );
122         }
123 
124         else
125         {
126         
127         #if DEBUG == 1 
128 
129             Serial\&.println( F("not connected , retrying") );
130         
131         #endif
132 
133             
134         }
135 
136     delay(5);
137     i++;
138     }
139     
140     return( this->state() );
141 
142 }
.fi
.SS "String CoolMQTT::getUser ()"
\fBCoolMQTT::getUser()\fP: This method is provided to get the user name 
.PP
Definition at line 660 of file CoolMQTT\&.cpp\&.
.PP
References user\&.
.PP
Referenced by CoolBoard::userData()\&.
.PP
.nf
661 {
662 
663 #if DEBUG == 1 
664     Serial\&.println( F("Entering CoolMQTT\&.getUser()") );
665     Serial\&.println();
666     
667     Serial\&.print( F("user : ") );
668     Serial\&.println(this->user);
669 
670 #endif
671 
672     return String(this->user);
673 }
.fi
.SS "bool CoolMQTT::mqttLoop ()"
\fBCoolMQTT::mqttLoop()\fP: This method is provided to allow the client to process the data
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 244 of file CoolMQTT\&.cpp\&.
.PP
References client\&.
.PP
Referenced by CoolBoard::onLineMode(), and CoolBoard::update()\&.
.PP
.nf
245 {
246 
247     unsigned long lastTime=millis();
248 
249 #if DEBUG == 1
250 
251     Serial\&.println( F("Entering CoolMQTT\&.mqttLoop()") );
252     Serial\&.println();
253 
254 #endif  
255 
256     while( ( millis() - lastTime ) < 1000)
257     {
258         this->client\&.loop();
259         yield();
260     }
261 
262 #if DEBUG == 1 
263     
264     Serial\&.print( F("loop result : ") );
265     Serial\&.println( this->client\&.loop() );
266     Serial\&.println();
267 
268 #endif
269 
270     return( this->client\&.loop() );
271 }
.fi
.SS "void CoolMQTT::printConf ()"
\fBCoolMQTT::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 624 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, inTopic, mqttServer, outTopic, and user\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
625 {
626 
627 #if DEBUG == 1 
628 
629     Serial\&.println( F("Entering CoolMQTT\&.printConf()") );
630     Serial\&.println();    
631 
632 #endif
633     
634     Serial\&.println("MQTT configuration ");
635 
636     Serial\&.print("mqttServer : ");
637     Serial\&.println(this->mqttServer);
638 
639     Serial\&.print("inTopic : ");
640     Serial\&.println(this->inTopic);
641 
642     Serial\&.print("outTopic : ");
643     Serial\&.println(this->outTopic);
644 
645     Serial\&.print("user : ");
646     Serial\&.println(this->user);
647 
648     Serial\&.print("bufferSize : ");
649     Serial\&.println(this->bufferSize);
650 
651     Serial\&.println();
652 
653 
654 }
.fi
.SS "bool CoolMQTT::publish (const char * data)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 152 of file CoolMQTT\&.cpp\&.
.PP
References client, and outTopic\&.
.PP
Referenced by CoolBoard::onLineMode(), publish(), and CoolBoard::update()\&.
.PP
.nf
153 {
154 
155 #if DEBUG == 1 
156 
157     Serial\&.println( F("Entering CoolMQTT\&.publish()") );
158     Serial\&.println();
159     //data is in JSON, publish it directly
160 
161     Serial\&.println( F("data to publish : ") );
162     Serial\&.println(data);
163     Serial\&.print( F("data size : ") );
164     Serial\&.println(strlen(data));
165 
166     Serial\&.println();
167 
168 #endif
169     
170 
171     bool pub=client\&.publish( this->outTopic,(byte*) data,strlen(data),false  );
172 
173 #if DEBUG == 1 
174 
175     Serial\&.print( F("success : ") );
176     Serial\&.println(pub); 
177 
178 #endif
179 
180     return(pub);
181 
182 }
.fi
.SS "bool CoolMQTT::publish (const char * data, unsigned long logInterval)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval in seconds
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 192 of file CoolMQTT\&.cpp\&.
.PP
References previousLogTime, and publish()\&.
.PP
.nf
193 {
194 
195 #if DEBUG == 1 
196 
197     Serial\&.println( F("Entering CoolMQTT\&.publish() every logInterval ") );
198     Serial\&.println();
199 
200 #endif 
201     //log interval is passed in seconds, logInteral*1000 = logInterval in ms
202     if( ( millis() - ( this->previousLogTime)  ) >= ( logInterval*1000 ) )
203     {
204     
205     #if DEBUG == 1
206 
207         Serial\&.println( F("log Interval has passed ") );
208         Serial\&.println();
209     
210     #endif
211 
212         this->publish(data);
213 
214         this->previousLogTime=millis();
215     
216     #if DEBUG == 1 
217 
218         Serial\&.print( F("last log time : ") );
219         Serial\&.println(this->previousLogTime);
220 
221     #endif
222 
223         return(true);
224     }
225 
226 #if DEBUG == 1 
227 
228     Serial\&.println( F("log Interval still didn't pass ") );  
229     Serial\&.println();
230 
231 #endif
232 
233     return(false);
234 }
.fi
.SS "String CoolMQTT::read ()"
\fBCoolMQTT::read()\fP: This method is provided to return the last read message\&. 
.PP
Definition at line 359 of file CoolMQTT\&.cpp\&.
.PP
References msg, and newMsg\&.
.PP
Referenced by CoolBoard::onLineMode()\&.
.PP
.nf
360 {   
361 
362 #if DEBUG == 1 
363 
364     Serial\&.println( F("Entering CoolMQTT\&.read()") );
365     Serial\&.println();
366 
367 #endif 
368 
369     if(this->newMsg==true)
370     {
371         
372         this->newMsg=false;
373 
374 #if DEBUG == 1 
375         Serial\&.println( F("received new message") );
376         Serial\&.println( F("message : ") );
377         Serial\&.println(this->msg);
378         Serial\&.println();
379 
380 #endif
381 
382         return(this->msg);
383         
384     }
385     return("");
386 
387 }
.fi
.SS "int CoolMQTT::state ()"
\fBCoolMQTT::state()\fP: This method is provided to return the mqtt client's state\&. 
.PP
\fBReturns:\fP
.RS 4
mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect 
.RE
.PP

.PP
Definition at line 72 of file CoolMQTT\&.cpp\&.
.PP
References client\&.
.PP
Referenced by connect(), CoolBoard::connect(), CoolBoard::isConnected(), and CoolBoard::offLineMode()\&.
.PP
.nf
73 {
74 
75 #if DEBUG == 1 
76 
77     Serial\&.println( F("Entering CoolMQTT\&.state()") );
78     Serial\&.println();    
79     Serial\&.print( F("state : ") );
80     Serial\&.println( this->client\&.state() );
81 
82 #endif
83     
84     return( this->client\&.state() );
85 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int CoolMQTT::bufferSize =3000\fC [private]\fP"

.PP
Definition at line 63 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), config(), and printConf()\&.
.SS "PubSubClient CoolMQTT::client\fC [private]\fP"

.PP
Definition at line 67 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), connect(), mqttLoop(), publish(), and state()\&.
.SS "WiFiClient CoolMQTT::espClient\fC [private]\fP"

.PP
Definition at line 65 of file CoolMQTT\&.h\&.
.PP
Referenced by begin()\&.
.SS "char CoolMQTT::inTopic[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 57 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), connect(), and printConf()\&.
.SS "char CoolMQTT::mqttServer[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 53 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), config(), and printConf()\&.
.SS "String CoolMQTT::msg =''\fC [private]\fP"

.PP
Definition at line 55 of file CoolMQTT\&.h\&.
.PP
Referenced by callback(), and read()\&.
.SS "bool CoolMQTT::newMsg =0\fC [private]\fP"

.PP
Definition at line 69 of file CoolMQTT\&.h\&.
.PP
Referenced by callback(), and read()\&.
.SS "char CoolMQTT::outTopic[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 59 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), printConf(), and publish()\&.
.SS "unsigned long CoolMQTT::previousLogTime =0\fC [private]\fP"

.PP
Definition at line 71 of file CoolMQTT\&.h\&.
.PP
Referenced by publish()\&.
.SS "char CoolMQTT::user[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 61 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), connect(), getUser(), and printConf()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
