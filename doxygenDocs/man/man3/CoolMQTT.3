.TH "CoolMQTT" 3 "Mon Jul 31 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CoolMQTT \- This class handles the mqtt client\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CoolMQTT\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "int \fBconnect\fP (uint16_t keepAlive)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data, int logInterval)"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "void \fBconfig\fP (const char \fBmqttServer\fP[], const char \fBinTopic\fP[], const char \fBoutTopic\fP[], const char \fBuser\fP[], int \fBbufferSize\fP)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBcallback\fP (char *topic, byte *payload, unsigned int length)"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "int \fBstate\fP ()"
.br
.ti -1c
.RI "bool \fBmqttLoop\fP ()"
.br
.ti -1c
.RI "String \fBgetUser\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char \fBmqttServer\fP [50] ={'0'}"
.br
.ti -1c
.RI "String \fBmsg\fP =''"
.br
.ti -1c
.RI "char \fBinTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBoutTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBuser\fP [50] ={'0'}"
.br
.ti -1c
.RI "int \fBbufferSize\fP =3000"
.br
.ti -1c
.RI "WiFiClient \fBespClient\fP"
.br
.ti -1c
.RI "PubSubClient \fBclient\fP"
.br
.ti -1c
.RI "bool \fBnewMsg\fP =0"
.br
.ti -1c
.RI "unsigned long \fBpreviousLogTime\fP =0"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class handles the mqtt client\&. 
.PP
Definition at line 22 of file CoolMQTT\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void CoolMQTT::begin ()"
\fBCoolMQTT::begin()\fP: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size 
.PP
Definition at line 39 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, callback(), client, espClient, and mqttServer\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
40 { 
41 
42 #if DEBUG == 1 
43 
44     Serial\&.println( F("Entering CoolMQTT\&.begin()") );
45     Serial\&.println();
46 
47 #endif
48 
49     client\&.setClient(espClient);
50     client\&.setServer(mqttServer, 1883);  
51     client\&.setCallback([this] (char* topic, byte* payload, unsigned int length) { this->callback(topic, payload, length); });
52     client\&.setBufferSize((unsigned short)bufferSize);
53 
54 }
.fi
.SS "void CoolMQTT::callback (char * topic, byte * payload, unsigned int length)"
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic\&.
.PP
Arguments are automatically assigned in client\&.setCallback() 
.PP
Definition at line 279 of file CoolMQTT\&.cpp\&.
.PP
References msg, newMsg, and temp\&.
.PP
Referenced by begin()\&.
.PP
.nf
280 {
281 
282 #if DEBUG == 1
283 
284     Serial\&.println( F("Entering CoolMQTT\&.callback() ") );
285     Serial\&.println();
286 
287 #endif 
288 
289     if(this->newMsg==false)
290     {
291         char temp[length+1];
292 
293     #if DEBUG == 1
294 
295         Serial\&.println( F("received temp msg : ") );
296         
297     #endif
298         
299         for (int i = 0; i < length; i++) 
300         {
301             temp[i]=(char)payload[i];
302         
303         #if DEBUG == 1 
304 
305             Serial\&.print( (char)payload[i] );
306         
307         #endif
308 
309         }
310     
311     #if DEBUG == 1 
312 
313         Serial\&.println();
314         Serial\&.println( F("storing new message : ") );
315 
316         Serial\&.print(F("length : "));
317         Serial\&.println(length);
318         
319         Serial\&.print(F("size : "));
320         Serial\&.print(sizeof(payload));
321         Serial\&.println();
322     
323     #endif
324 
325         this->newMsg=true;
326 
327         temp[length+1]='\0';
328 
329         this->msg=String(temp);
330         this->msg\&.remove(length,1);
331     
332     #if DEBUG == 1 
333 
334         Serial\&.println( F("stored message : ") );
335         Serial\&.println(this->msg);
336     
337     #endif
338 
339     }
340     else
341     {
342     
343     #if DEBUG == 1
344 
345         Serial\&.println( F("did not read last message") );
346     
347     #endif 
348         
349     }
350 
351 }
.fi
.SS "void CoolMQTT::config (const char mqttServer[], const char inTopic[], const char outTopic[], const char user[], int bufferSize)"
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client 
.PP
Definition at line 596 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
597 {
598 
599 #if DEBUG == 1
600 
601     Serial\&.println( F("Entering CoolMQTT\&.config() , no SPIFFS variant") );
602     Serial\&.println();
603 
604 #endif
605 
606     for(int i =0;i< 50 ;i++)
607     {
608         this->mqttServer[i]=mqttServer[i];
609         this->inTopic[i]=inTopic[i];
610         this->outTopic[i]=outTopic[i];
611         this->user[i]=user[i];
612     }
613     this->bufferSize=bufferSize;
614     
615 
616 }
.fi
.SS "bool CoolMQTT::config ()"
\fBCoolMQTT::config()\fP: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 399 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, inTopic, mqttServer, outTopic, and user\&.
.PP
.nf
400 {
401 
402 #if DEBUG == 1 
403 
404     Serial\&.println( F("Entering CoolMQTT\&.config()") );
405     Serial\&.println();
406 
407 #endif
408 
409     //read config file
410     //update data
411     File configFile = SPIFFS\&.open("/mqttConfig\&.json", "r");
412 
413     if (!configFile) 
414     {
415     
416     #if DEBUG == 1 
417 
418         Serial\&.println( F("failed to read /mqttConfig\&.json") );
419         Serial\&.println();
420 
421     #endif
422 
423         return(false);
424     }
425     else
426     {
427         size_t size = configFile\&.size();
428         // Allocate a buffer to store contents of the file\&.
429         std::unique_ptr<char[]> buf(new char[size]);
430 
431         configFile\&.readBytes(buf\&.get(), size);
432         DynamicJsonBuffer jsonBuffer;
433         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
434         if (!json\&.success()) 
435         {
436         
437         #if DEBUG == 1 
438 
439             Serial\&.println( F("failed to parse json ") );
440             Serial\&.println();
441         
442         #endif
443             
444             return(false);
445         } 
446         else
447         {
448         
449         #if DEBUG == 1 
450         
451             Serial\&.println( F("configuration json is ") );
452             json\&.printTo(Serial);
453             Serial\&.println();
454 
455             Serial\&.print(F("jsonBuffer size: "));
456             Serial\&.println(jsonBuffer\&.size());
457             Serial\&.println();
458 
459 
460         #endif
461 
462             if(json["mqttServer"]\&.success() )
463             {           
464                 const char* tempmqttServer = json["mqttServer"]; 
465                 for(int i =0;i< 50 ;i++)
466                 {
467                     mqttServer[i]=tempmqttServer[i];
468                 }
469             }
470             else
471             {
472                 for(int i =0;i< 50 ;i++)
473                 {
474                     this->mqttServer[i]=this->mqttServer[i];
475                 }
476 
477             }
478             json["mqttServer"]=this->mqttServer;
479 
480             
481             if(json["inTopic"]\&.success() )
482             {
483                 const char* tempInTopic = json["inTopic"]; 
484                 for(int i =0;i< 50;i++)
485                 {
486                     inTopic[i]=tempInTopic[i];
487                 }
488             }
489             else
490             {
491                 String tempMAC = WiFi\&.macAddress();
492                 tempMAC\&.replace(":","");
493                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC\&.c_str());    
494             
495             #if DEBUG == 1              
496                 
497                 Serial\&.print( F("Set Incomming MQTT Channel to : ") );
498                 Serial\&.println(inTopic);
499             
500             #endif  
501 
502             }
503             json["inTopic"]=this->inTopic;
504             
505             
506             if(json["outTopic"]\&.success() )
507             {
508                 const char* tempOutTopic = json["outTopic"]; 
509                 for(int i =0;i<50;i++)
510                 {
511                     outTopic[i]=tempOutTopic[i];
512                 }
513             }
514             else
515             {
516                 String tempMAC = WiFi\&.macAddress();
517                 tempMAC\&.replace(":","");
518                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC\&.c_str());
519             
520             #if DEBUG == 1 
521 
522                 Serial\&.print( F("Set Outgoing MQTT Channel to : ") );
523                 Serial\&.println(outTopic);
524             
525             #endif
526 
527             }
528             json["outTopic"]=this->outTopic;
529         
530             
531             if(json["user"]\&.success() )
532             {               
533                 const char* tempUser = json["user"]; 
534                 for(int i =0;i<50;i++)
535                 {
536                     user[i]=tempUser[i];
537                 }
538             }
539             else
540             {
541                 for(int i=0;i<50;i++)
542                 {
543                     this->user[i]=this->user[i];
544                 }               
545             }
546             json["user"]=this->user;
547             
548             if(json["bufferSize"]\&.success() )
549             {
550                 int tempBufferSize = json["bufferSize"]; 
551                 bufferSize=tempBufferSize;
552             }
553             else
554             {
555                 this->bufferSize=this->bufferSize;
556             }
557             json["bufferSize"]=this->bufferSize;
558 
559             configFile\&.close();
560             configFile = SPIFFS\&.open("/mqttConfig\&.json", "w");
561             if(!configFile)
562             {
563             
564             #if DEBUG == 1 
565 
566                 Serial\&.println( F("failed to write to /mqttConfig\&.json") );
567             
568             #endif
569 
570                 return(false);              
571             }
572             
573             json\&.printTo(configFile);
574             configFile\&.close();
575 
576         #if DEBUG == 1 
577 
578             Serial\&.println( F("saved configuration is :") );
579             json\&.printTo(Serial);
580             Serial\&.println();
581         
582         #endif
583 
584             return(true); 
585         }
586     }   
587     
588 
589 }
.fi
.SS "int CoolMQTT::connect (uint16_t keepAlive)"
CoolMQTT::connect( time to keep the connection alive ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time\&.
.PP
\fBReturns:\fP
.RS 4
mqtt client state 
.RE
.PP

.PP
Definition at line 95 of file CoolMQTT\&.cpp\&.
.PP
References client, inTopic, state(), and user\&.
.PP
Referenced by CoolBoard::connect()\&.
.PP
.nf
96 {       
97 
98     int i=0;
99 
100 #if DEBUG == 1 
101 
102     Serial\&.println( F("Entering CoolMQTT\&.connect()") );
103     Serial\&.println( F("MQTT connecting\&.\&.\&.") );
104 
105 #endif
106 
107     while( ( !this->client\&.connected() ) && ( i<100 ) ) 
108     {
109         // Attempt to connect
110         if( this->client\&.connect( this-> user, keepAlive ) )
111         {
112             client\&.subscribe( this->inTopic );
113 
114         #if DEBUG == 1 
115 
116             Serial\&.println( F("MQTT connected") );
117             Serial\&.println( F(" subscribed , leavin ") ) ;
118         
119         #endif
120 
121             return( this->state() );
122         }
123 
124         else
125         {
126         
127         #if DEBUG == 1 
128 
129             Serial\&.println( F("not connected , retrying") );
130         
131         #endif
132 
133             
134         }
135 
136     delay(5);
137     i++;
138     }
139     
140     return( this->state() );
141 
142 }
.fi
.SS "String CoolMQTT::getUser ()"
\fBCoolMQTT::getUser()\fP: This method is provided to get the user name 
.PP
Definition at line 659 of file CoolMQTT\&.cpp\&.
.PP
References user\&.
.PP
Referenced by CoolBoard::userData()\&.
.PP
.nf
660 {
661 
662 #if DEBUG == 1 
663     Serial\&.println( F("Entering CoolMQTT\&.getUser()") );
664     Serial\&.println();
665     
666     Serial\&.print( F("user : ") );
667     Serial\&.println(this->user);
668 
669 #endif
670 
671     return String(this->user);
672 }
.fi
.SS "bool CoolMQTT::mqttLoop ()"
\fBCoolMQTT::mqttLoop()\fP: This method is provided to allow the client to process the data
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 244 of file CoolMQTT\&.cpp\&.
.PP
References client\&.
.PP
Referenced by CoolBoard::onLineMode(), and CoolBoard::update()\&.
.PP
.nf
245 {
246 
247     unsigned long lastTime=millis();
248 
249 #if DEBUG == 1
250 
251     Serial\&.println( F("Entering CoolMQTT\&.mqttLoop()") );
252     Serial\&.println();
253 
254 #endif  
255 
256     while( ( millis() - lastTime ) < 5000)
257     {
258         this->client\&.loop(); 
259     }
260 
261 #if DEBUG == 1 
262     
263     Serial\&.print( F("loop result : ") );
264     Serial\&.println( this->client\&.loop() );
265     Serial\&.println();
266 
267 #endif
268 
269     return( this->client\&.loop() );
270 }
.fi
.SS "void CoolMQTT::printConf ()"
\fBCoolMQTT::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 623 of file CoolMQTT\&.cpp\&.
.PP
References bufferSize, inTopic, mqttServer, outTopic, and user\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
624 {
625 
626 #if DEBUG == 1 
627 
628     Serial\&.println( F("Entering CoolMQTT\&.printConf()") );
629     Serial\&.println();    
630 
631 #endif
632     
633     Serial\&.println("MQTT configuration ");
634 
635     Serial\&.print("mqttServer : ");
636     Serial\&.println(this->mqttServer);
637 
638     Serial\&.print("inTopic : ");
639     Serial\&.println(this->inTopic);
640 
641     Serial\&.print("outTopic : ");
642     Serial\&.println(this->outTopic);
643 
644     Serial\&.print("user : ");
645     Serial\&.println(this->user);
646 
647     Serial\&.print("bufferSize : ");
648     Serial\&.println(this->bufferSize);
649 
650     Serial\&.println();
651 
652 
653 }
.fi
.SS "bool CoolMQTT::publish (const char * data)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 152 of file CoolMQTT\&.cpp\&.
.PP
References client, and outTopic\&.
.PP
Referenced by CoolBoard::onLineMode(), publish(), and CoolBoard::update()\&.
.PP
.nf
153 {
154 
155 #if DEBUG == 1 
156 
157     Serial\&.println( F("Entering CoolMQTT\&.publish()") );
158     Serial\&.println();
159     //data is in JSON, publish it directly
160 
161     Serial\&.println( F("data to publish : ") );
162     Serial\&.println(data);
163     Serial\&.print( F("data size : ") );
164     Serial\&.println(strlen(data));
165 
166     Serial\&.println();
167 
168 #endif
169     
170 
171     bool pub=client\&.publish( this->outTopic,(byte*) data,strlen(data),false  );
172 
173 #if DEBUG == 1 
174 
175     Serial\&.print( F("success : ") );
176     Serial\&.println(pub); 
177 
178 #endif
179 
180     return(pub);
181 
182 }
.fi
.SS "bool CoolMQTT::publish (const char * data, int logInterval)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval ms
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 192 of file CoolMQTT\&.cpp\&.
.PP
References previousLogTime, and publish()\&.
.PP
.nf
193 {
194 
195 #if DEBUG == 1 
196 
197     Serial\&.println( F("Entering CoolMQTT\&.publish() every logInterval ") );
198     Serial\&.println();
199 
200 #endif 
201     
202     if( ( millis() - ( this->previousLogTime)  ) >=( logInterval ) )
203     {
204     
205     #if DEBUG == 1
206 
207         Serial\&.println( F("log Interval has passed ") );
208         Serial\&.println();
209     
210     #endif
211 
212         this->publish(data);
213 
214         this->previousLogTime=millis();
215     
216     #if DEBUG == 1 
217 
218         Serial\&.print( F("last log time : ") );
219         Serial\&.println(this->previousLogTime);
220 
221     #endif
222 
223         return(true);
224     }
225 
226 #if DEBUG == 1 
227 
228     Serial\&.println( F("log Interval still didn't pass ") );  
229     Serial\&.println();
230 
231 #endif
232 
233     return(false);
234 }
.fi
.SS "String CoolMQTT::read ()"
\fBCoolMQTT::read()\fP: This method is provided to return the last read message\&. 
.PP
Definition at line 358 of file CoolMQTT\&.cpp\&.
.PP
References msg, and newMsg\&.
.PP
Referenced by CoolBoard::onLineMode()\&.
.PP
.nf
359 {   
360 
361 #if DEBUG == 1 
362 
363     Serial\&.println( F("Entering CoolMQTT\&.read()") );
364     Serial\&.println();
365 
366 #endif 
367 
368     if(this->newMsg==true)
369     {
370         
371         this->newMsg=false;
372 
373 #if DEBUG == 1 
374         Serial\&.println( F("received new message") );
375         Serial\&.println( F("message : ") );
376         Serial\&.println(this->msg);
377         Serial\&.println();
378 
379 #endif
380 
381         return(this->msg);
382         
383     }
384     return("");
385 
386 }
.fi
.SS "int CoolMQTT::state ()"
\fBCoolMQTT::state()\fP: This method is provided to return the mqtt client's state\&. 
.PP
\fBReturns:\fP
.RS 4
mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect 
.RE
.PP

.PP
Definition at line 72 of file CoolMQTT\&.cpp\&.
.PP
References client\&.
.PP
Referenced by connect(), and CoolBoard::connect()\&.
.PP
.nf
73 {
74 
75 #if DEBUG == 1 
76 
77     Serial\&.println( F("Entering CoolMQTT\&.state()") );
78     Serial\&.println();    
79     Serial\&.print( F("state : ") );
80     Serial\&.println( this->client\&.state() );
81 
82 #endif
83     
84     return( this->client\&.state() );
85 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int CoolMQTT::bufferSize =3000\fC [private]\fP"

.PP
Definition at line 63 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), config(), and printConf()\&.
.SS "PubSubClient CoolMQTT::client\fC [private]\fP"

.PP
Definition at line 67 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), connect(), mqttLoop(), publish(), and state()\&.
.SS "WiFiClient CoolMQTT::espClient\fC [private]\fP"

.PP
Definition at line 65 of file CoolMQTT\&.h\&.
.PP
Referenced by begin()\&.
.SS "char CoolMQTT::inTopic[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 57 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), connect(), and printConf()\&.
.SS "char CoolMQTT::mqttServer[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 53 of file CoolMQTT\&.h\&.
.PP
Referenced by begin(), config(), and printConf()\&.
.SS "String CoolMQTT::msg =''\fC [private]\fP"

.PP
Definition at line 55 of file CoolMQTT\&.h\&.
.PP
Referenced by callback(), and read()\&.
.SS "bool CoolMQTT::newMsg =0\fC [private]\fP"

.PP
Definition at line 69 of file CoolMQTT\&.h\&.
.PP
Referenced by callback(), and read()\&.
.SS "char CoolMQTT::outTopic[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 59 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), printConf(), and publish()\&.
.SS "unsigned long CoolMQTT::previousLogTime =0\fC [private]\fP"

.PP
Definition at line 71 of file CoolMQTT\&.h\&.
.PP
Referenced by publish()\&.
.SS "char CoolMQTT::user[50] ={'0'}\fC [private]\fP"

.PP
Definition at line 61 of file CoolMQTT\&.h\&.
.PP
Referenced by config(), connect(), getUser(), and printConf()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
