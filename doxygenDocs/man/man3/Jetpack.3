.TH "Jetpack" 3 "Thu Jul 13 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP =0"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 21 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 32 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
33 {
34 
35 #if DEBUG == 1 
36  
37     Serial\&.println( F("Entering Jetpack\&.begin() ") );
38     Serial\&.println();
39 
40 #endif
41 
42     pinMode(EnI2C,OUTPUT);
43     pinMode(dataPin,OUTPUT);
44     pinMode(clockPin,OUTPUT);
45     
46     
47 
48 }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 341 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::inverted, Jetpack::state::low, Jetpack::state::temporal, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
342 {
343 
344 #if DEBUG == 1 
345 
346     Serial\&.println( F("Entering Jetpack\&.config() ") );
347     Serial\&.println();
348 
349 #endif
350 
351     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
352 
353     if (!jetPackConfig) 
354     {
355 
356     #if DEBUG == 1 
357 
358         Serial\&.println( F("failed to read /jetPackConfig\&.json ") );
359         Serial\&.println();
360 
361     #endif
362 
363         return(false);
364     }
365     else
366     {
367         size_t size = jetPackConfig\&.size();
368         // Allocate a buffer to store contents of the file\&.
369         std::unique_ptr<char[]> buf(new char[size]);
370 
371         jetPackConfig\&.readBytes(buf\&.get(), size);
372         DynamicJsonBuffer jsonBuffer;
373         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
374         if (!json\&.success()) 
375         {
376         
377         #if DEBUG == 1 
378 
379             Serial\&.println( F("failed to parse jetpack config json from file ") );
380             Serial\&.println();
381 
382         #endif
383 
384             return(false);
385         } 
386         else
387         { 
388         
389         #if DEBUG == 1 
390 
391             Serial\&.println( F("read configuration file : ") );
392             json\&.printTo(Serial);
393             Serial\&.println();
394         
395         #endif
396   
397             if(json["ActorsNumber"]\&.success() )
398             {
399                 this->actorsNumber = json["ActorsNumber"]; 
400             
401                 for(int i=0;i<8;i++)
402                 {   if(json[String("Act")+String(i)]\&.success())
403                     {
404                         if(json[String("Act")+String(i)]["actif"]\&.success() )
405                         {
406                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
407                         }
408                         else
409                         {
410                             this->actors[i]\&.actif=this->actors[i]\&.actif;
411                         }
412                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
413 
414 
415                         if(json[String("Act")+String(i)]["low"]\&.success() )
416                         {                   
417                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
418                         }
419                         else
420                         {
421                             this->actors[i]\&.low=this->actors[i]\&.low;                  
422                         }
423                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
424     
425                     
426                         if(json[String("Act")+String(i)]["high"]\&.success() )
427                         {               
428                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
429                         }
430                         else
431                         {
432                             this->actors[i]\&.high=this->actors[i]\&.high;
433                         }
434                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
435 
436                     
437                         if(json[String("Act")+String(i)]["type"]\&.success() )
438                         {               
439                             this->actors[i]\&.type=String( json[String("Act")+String(i)]["type"]\&.as<const char*>() ); 
440                         }
441                         else
442                         {
443                             this->actors[i]\&.type=this->actors[i]\&.type;
444                         }
445                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type\&.c_str();
446 
447 
448                         if(json[String("Act")+String(i)]["temporal"]\&.success() )
449                         {
450                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];                                                  
451                         }
452                         else
453                         {
454                             this->actors[i]\&.temporal=this->actors[i]\&.temporal; 
455                         }   
456                         json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
457 
458                         
459                         if(json[String("Act")+String(i)]["inverted"]\&.success() )
460                         {
461                             this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"];                                                  
462                         }
463                         else
464                         {
465                             this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"]; 
466                         }   
467                         json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
468 
469                         
470                          
471                     }
472                     else
473                     {
474                         this->actors[i]=this->actors[i];
475                     }
476                     
477                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
478                     json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
479                     json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
480                     json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
481                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
482                     json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted; 
483                 }
484             }
485             else
486             {
487                 this->actorsNumber=this->actorsNumber;
488             }
489             json["actorsNumber"]=this->actorsNumber;
490 
491             jetPackConfig\&.close();           
492             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
493             if(!jetPackConfig)
494             {
495             
496             #if DEBUG == 1 
497 
498                 Serial\&.println( F("failed to write to /jetPackConfig\&.json ") );
499                 Serial\&.println();
500             
501             #endif
502                 
503                 return(false);          
504             }  
505 
506             json\&.printTo(jetPackConfig);
507             jetPackConfig\&.close();
508 
509         #if DEBUG == 1 
510             
511             Serial\&.println(F("saved configuration : "));
512             json\&.printTo(Serial );
513             Serial\&.println();        
514         
515         #endif
516 
517             return(true); 
518         }
519     }   
520     
521 
522 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 134 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, Jetpack::state::actifTime, action, actors, Jetpack::state::inactifTime, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
135 {
136 
137 #if DEBUG == 1 
138 
139     Serial\&.println( F("Entering Jetpack\&.doAction()") );
140     Serial\&.println();
141 
142     Serial\&.println( F("input data is :") );
143     Serial\&.println(data);
144     Serial\&.println();
145 
146     Serial\&.println( F("input size is :") );  
147     Serial\&.println(JSON_SIZE);
148     Serial\&.println();
149 
150 #endif 
151 
152     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
153     JsonObject& root = jsonBuffer\&.parseObject(data);
154     
155     if (!root\&.success()) 
156     {
157     
158     #if DEBUG == 1 
159 
160         Serial\&.println( F("failed to parse json object ") );
161         Serial\&.println();
162     
163     #endif 
164 
165     }
166     else
167     {
168     
169     #if DEBUG == 1 
170 
171         Serial\&.println( F("created Json object :") );
172         root\&.printTo(Serial);
173         Serial\&.println();
174     
175     #endif 
176 
177         //invert the current action state for each actor
178         //if the value is outside the limits
179         for(int i=0;i<8;i++)
180         {
181             //check if the actor is actif 
182             if(this->actors[i]\&.actif==1)
183             {   
184                 //if the actor is not temporal
185                 if( this->actors[i]\&.temporal==0 ) 
186                 {   
187                     //regular actor
188                     if( (this->actors[i]\&.inverted) == 0 )
189                     {
190                         //measure >= high limit : stop actor
191                         if( ( root[this->actors[i]\&.type] ) >= ( this->actors[i]\&.high ) )  
192                         {   
193                             bitWrite( this->action , i , 0 ) ;  
194                         }
195                         //measure <= low limit : start actor
196                         else if( ( root[ this->actors[i]\&.type ] ) <= ( this->actors[i]\&.low ) )
197                         {
198                             bitWrite( this->action , i , 1 ) ;                  
199                         }
200                     }
201                     //inverted actor
202                     else if( (this->actors[i]\&.inverted) == 1 )
203                     {
204                         //measure >= high limit : start actor
205                         if( ( root[this->actors[i]\&.type] ) >= ( this->actors[i]\&.high ) )  
206                         {   
207                             bitWrite( this->action , i , 1 ) ;  
208                         }
209                         //measure <= low limit : stop actor
210                         else if( ( root[ this->actors[i]\&.type ] ) <= ( this->actors[i]\&.low ) )
211                         {
212                             bitWrite( this->action , i , 0 ) ;                  
213                         }
214 
215                     
216                     }
217                 }
218 
219                 //if the actor is temporal
220                 else
221                 {
222                     //actor of type hour
223                     if( ( this->actors[i]\&.type ) == ( "hour" ) )     
224                     {
225                     
226                     #if DEBUG == 1
227                         
228                         Serial\&.println("hour actor ");
229                         Serial\&.println(i);
230                         Serial\&.println();
231                     #endif
232 
233                         //time >= high : stop actor
234                         if( ( root[this->actors[i]\&.type] ) >= ( this->actors[i]\&.high ) )  
235                         {
236                         
237                         #if DEBUG == 1 
238                             
239                             Serial\&.print("deactive ");
240                             Serial\&.println(i);
241                         
242                         #endif  
243                             bitWrite( this->action , i , 0 ) ;  
244                         }
245                         //time >= low : start actor
246                         else if( ( root[ this->actors[i]\&.type ] ) >= ( this->actors[i]\&.low ) )
247                         {
248                         
249                         #if DEBUG == 1 
250                         
251                             Serial\&.print("active ");
252                             Serial\&.println(i);
253                         
254                         #endif
255                             bitWrite( this->action , i , 1 ) ;                  
256                         }
257                         
258                     }
259                     //actor not of type hour
260                     else if( ( this->actors[i]\&.type ) != ( "hour" ) )     
261                     {
262                     
263                     #if DEBUG == 1 
264                         
265                         Serial\&.println("not hour temporal actor");
266                         Serial\&.println(this->actors[i]\&.type);
267                         Serial\&.println(i);
268                         Serial\&.println();
269                     
270                     #endif
271                         //if the actor was actif for highTime or more :
272                         if( ( millis()- this->actors[i]\&.actifTime  ) >= ( this->actors[i]\&.high  ) )
273                         {
274                             //stop the actor
275                             bitWrite( this->action , i , 0) ;
276 
277                             //make the actor inactif:
278                             this->actors[i]\&.actif=0;
279 
280                             //start the low timer
281                             this->actors[i]\&.inactifTime=millis();                
282                         }
283                     }           
284                             
285                 }
286             }
287             //check if actor is inactif
288             else if(this->actors[i]\&.actif==0)
289             {   //check if actor is temporal
290                 if(this->actors[i]\&.temporal==1)
291                 {
292                     //if the actor was inactif for lowTime or more :
293                     if( ( millis() - this->actors[i]\&.inactifTime ) >= ( this->actors[i]\&.low  ) )
294                     {
295                         //start the actor
296                         bitWrite( this->action , i , 1) ;
297 
298                         //make the actor actif:
299                         this->actors[i]\&.actif=1;
300 
301                         //start the low timer
302                         this->actors[i]\&.actifTime=millis();
303 
304                     #if DEBUG == 1 
305                         
306                         Serial\&.println("inactif temporal actor");
307                         Serial\&.println(this->actors[i]\&.type);
308                         Serial\&.print("temporal : ");
309                         Serial\&.println(this->actors[i]\&.temporal);
310                         Serial\&.println(i);
311                         Serial\&.println();
312                     
313                     #endif
314                 
315                     }           
316             
317                 }
318             }
319         }
320     
321     #if DEBUG == 1 
322 
323         Serial\&.println( F("new action is : ") );
324         Serial\&.println(this->action,BIN);
325         Serial\&.println();
326     
327     #endif 
328 
329         this->write(this->action);
330 
331     } 
332 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 530 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
531 {
532 
533 #if DEBUG == 1 
534 
535     Serial\&.println( F("Enter Jetpack\&.printConf() ") );
536     Serial\&.println();
537 
538 #endif 
539     Serial\&.println( "Jetpack configuration " ) ;
540 
541     Serial\&.print( "actorsNumber : " );
542     Serial\&.println(this->actorsNumber);
543  
544         for(int i=0;i<this->actorsNumber;i++)
545     {   
546         Serial\&.print("actor N°");
547         Serial\&.print(i);
548         Serial\&.print(" actif :");
549         Serial\&.println(this->actors[i]\&.actif);
550 
551         Serial\&.print("actor N°");
552         Serial\&.print(i);
553         Serial\&.print(" low :");
554         Serial\&.println(this->actors[i]\&.low);
555 
556         Serial\&.print("actor N°");
557         Serial\&.print(i);
558         Serial\&.print(" high :");
559         Serial\&.println(this->actors[i]\&.high);
560 
561         Serial\&.print("actor N°");
562         Serial\&.print(i);
563         Serial\&.print(" type :");
564         Serial\&.println(this->actors[i]\&.type);
565         
566         Serial\&.print("actor N°");
567         Serial\&.print(i);
568         Serial\&.print(" temporal :");
569         Serial\&.println(this->actors[i]\&.temporal);
570 
571         Serial\&.print("actor N°");
572         Serial\&.print(i);
573         Serial\&.print(" inverted :");
574         Serial\&.println(this->actors[i]\&.inverted);
575 
576  
577 
578     }
579 
580     Serial\&.println();
581 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 59 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
60 {
61 
62 #if DEBUG == 1
63 
64     Serial\&.println( F("Entering Jetpack\&.write()") );
65     Serial\&.println();
66 
67     Serial\&.println( F("writing this action : ") );
68     Serial\&.println(action,BIN);
69     Serial\&.println();
70 
71 #endif 
72 
73     this->action=action;
74 
75     
76     digitalWrite(EnI2C, LOW);
77     
78     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
79 
80     digitalWrite(EnI2C, HIGH);
81 
82 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 89 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
90 {
91 
92 #if DEBUG == 1 
93 
94     Serial\&.println( F("Entering Jetpack\&.writeBit() ") );
95 
96     Serial\&.print( F("Writing ") );
97     Serial\&.print(state);
98 
99     Serial\&.print( F("to pin N°") );
100     Serial\&.print(pin);
101 
102     Serial\&.println();
103 
104 #endif
105 
106     bitWrite(this->action, pin, state);
107     digitalWrite(EnI2C, LOW);
108     
109     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
110 
111     digitalWrite(EnI2C, HIGH);
112 
113 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 39 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber =0\fC [private]\fP"

.PP
Definition at line 41 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 63 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 65 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 67 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
