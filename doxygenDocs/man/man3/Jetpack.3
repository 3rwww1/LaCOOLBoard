.TH "Jetpack" 3 "Wed Jul 5 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP =0"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 21 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 24 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
25  { 
26     Serial\&.println("Entering Jetpack\&.begin() ");
27     Serial\&.println();
28 
29     pinMode(EnI2C,OUTPUT);
30     pinMode(dataPin,OUTPUT);
31     pinMode(clockPin,OUTPUT);
32     
33     
34 
35  }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 202 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::low, Jetpack::state::temporal, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
203 {
204     Serial\&.println("Entering Jetpack\&.config() ");
205     Serial\&.println();
206 
207     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
208 
209     if (!jetPackConfig) 
210     {
211         Serial\&.println("failed to read /jetPackConfig\&.json ");
212         Serial\&.println();
213 
214         return(false);
215     }
216     else
217     {
218         size_t size = jetPackConfig\&.size();
219         // Allocate a buffer to store contents of the file\&.
220         std::unique_ptr<char[]> buf(new char[size]);
221 
222         jetPackConfig\&.readBytes(buf\&.get(), size);
223         DynamicJsonBuffer jsonBuffer;
224         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
225         if (!json\&.success()) 
226         {
227             Serial\&.println("failed to parse jetpack config json from file ");
228             Serial\&.println();
229 
230             return(false);
231         } 
232         else
233         {   
234             Serial\&.println("read configuration file : ");
235             json\&.printTo(Serial);
236             Serial\&.println();
237   
238             if(json["ActorsNumber"]\&.success() )
239             {
240                 this->actorsNumber = json["ActorsNumber"]; 
241             
242                 for(int i=0;i<8;i++)
243                 {   if(json[String("Act")+String(i)]\&.success())
244                     {
245                         if(json[String("Act")+String(i)]["actif"]\&.success() )
246                         {
247                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
248                         }
249                         else
250                         {
251                             this->actors[i]\&.actif=this->actors[i]\&.actif;
252                         }
253                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
254 
255 
256                         if(json[String("Act")+String(i)]["low"]\&.success() )
257                         {                   
258                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
259                         }
260                         else
261                         {
262                             this->actors[i]\&.low=this->actors[i]\&.low;                  
263                         }
264                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
265     
266                     
267                         if(json[String("Act")+String(i)]["high"]\&.success() )
268                         {               
269                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
270                         }
271                         else
272                         {
273                             this->actors[i]\&.high=this->actors[i]\&.high;
274                         }
275                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
276 
277                     
278                         if(json[String("Act")+String(i)]["type"]\&.success() )
279                         {               
280                             this->actors[i]\&.type=json[String("Act")+String(i)]["type"]; 
281                         }
282                         else
283                         {
284                             this->actors[i]\&.type=this->actors[i]\&.type;
285                         }
286                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
287 
288                         if(json[String("Act")+String(i)]["temporal"]\&.success() )
289                         {
290                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];                                                  
291                         }
292                         else
293                         {
294                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"]; 
295                         }   
296                         json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
297                     }
298                     else
299                     {
300                         this->actors[i]=this->actors[i];
301                     }
302                     
303                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
304                     json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
305                     json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
306                     json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
307                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
308                 }
309             }
310             else
311             {
312                 this->actorsNumber=this->actorsNumber;
313             }
314             json["actorsNumber"]=this->actorsNumber;
315 
316             jetPackConfig\&.close();           
317             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
318             if(!jetPackConfig)
319             {
320                 Serial\&.println("failed to write to /jetPackConfig\&.json ");
321                 Serial\&.println();
322                 
323                 return(false);          
324             }  
325 
326             json\&.printTo(jetPackConfig);
327             jetPackConfig\&.close();
328             
329             Serial\&.println("saved configuration : ");
330             json\&.printTo(Serial );
331             Serial\&.println();        
332             
333             return(true); 
334         }
335     }   
336     
337 
338 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 105 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, Jetpack::state::actifTime, action, actors, Jetpack::state::inactifTime, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
106 {
107     Serial\&.println("Entering Jetpack\&.doAction()");
108     Serial\&.println();
109 
110     Serial\&.println("input data is :");
111     Serial\&.println(data);
112     Serial\&.println();
113 
114     Serial\&.println("input size is :");   
115     Serial\&.println(JSON_SIZE);
116     Serial\&.println();
117 
118     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
119     JsonObject& root = jsonBuffer\&.parseObject(data);
120     
121     if (!root\&.success()) 
122     {
123         Serial\&.println("failed to parse json object ");
124         Serial\&.println();
125     }
126     else
127     {
128         Serial\&.println("created Json object :");
129         root\&.printTo(Serial);
130         Serial\&.println();
131 
132         //invert the current action state for each actor
133         //if the value is outside the limits
134         for(int i=0;i<8;i++)
135         {
136             //check if the actor is actif 
137             if(this->actors[i]\&.actif==1)
138             {   
139                 //if the actor is not temporal
140                 if( this->actors[i]\&.temporal==0 ) 
141                 {
142                     if( ( ( root[this->actors[i]\&.type] ) > ( this->actors[i]\&.high ) ) || ( ( root[ this->actors[i]\&.type ] ) < ( this->actors[i]\&.low ) ) )   
143                     {   
144                         bitWrite( this->action , i , !( bitRead(this->action, i ) ) );  
145                     }
146                 }
147                 //if the actor is temporal
148                 else
149                 {   //if the actor was actif for highTime or more :
150                     if( ( millis()- this->actors[i]\&.actifTime  ) >= ( this->actors[i]\&.high  ) )
151                     {
152                         //stop the actor
153                         bitWrite( this->action , i , 0) ;
154 
155                         //make the actor inactif:
156                         this->actors[i]\&.actif=0;
157 
158                         //start the low timer
159                         this->actors[i]\&.inactifTime=millis();                
160                     }           
161                             
162                 }
163             }
164             //check if actor is inactif
165             else
166             {   //check if actor is temporal
167                 if(this->actors[i]\&.temporal==1)
168                 {
169                     //if the actor was inactif for lowTime or more :
170                     if( ( millis() - this->actors[i]\&.inactifTime ) >= ( this->actors[i]\&.low  ) )
171                     {
172                         //start the actor
173                         bitWrite( this->action , i , 1) ;
174 
175                         //make the actor actif:
176                         this->actors[i]\&.actif=1;
177 
178                         //start the low timer
179                         this->actors[i]\&.actifTime=millis();              
180                     }           
181             
182                 }
183             }
184         }
185 
186         Serial\&.println("new action is : ");
187         Serial\&.println(this->action);
188         Serial\&.println();
189 
190         this->write(this->action);
191 
192     } 
193 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 346 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
347 {
348     Serial\&.println("Enter Jetpack\&.printConf() ");
349     Serial\&.println();
350     
351     Serial\&.print("actorsNumber : ");
352     Serial\&.println(this->actorsNumber);
353  
354         for(int i=0;i<this->actorsNumber;i++)
355     {   
356         Serial\&.print("actor N°");
357         Serial\&.print(i);
358         Serial\&.print(" actif :");
359         Serial\&.println(this->actors[0]\&.actif);
360 
361         Serial\&.print("actor N°");
362         Serial\&.print(i);
363         Serial\&.print(" low :");
364         Serial\&.println(this->actors[0]\&.low);
365 
366         Serial\&.print("actor N°");
367         Serial\&.print(i);
368         Serial\&.print(" high :");
369         Serial\&.println(this->actors[0]\&.high);
370 
371         Serial\&.print("actor N°");
372         Serial\&.print(i);
373         Serial\&.print(" type :");
374         Serial\&.println(this->actors[0]\&.type);
375         
376         Serial\&.print("actor N°");
377         Serial\&.print(i);
378         Serial\&.print(" temporal :");
379         Serial\&.println(this->actors[0]\&.temporal);
380  
381 
382     }
383 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 46 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
47 {
48     Serial\&.println("Entering Jetpack\&.write()");
49     Serial\&.println();
50 
51     Serial\&.println("writing this action : ");
52     Serial\&.println(action,HEX);
53     Serial\&.println();
54 
55     this->action=action;
56 
57     
58     digitalWrite(EnI2C, LOW);
59     
60     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
61 
62     digitalWrite(EnI2C, HIGH);
63 
64 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 71 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
72 {
73     Serial\&.println("Entering Jetpack\&.writeBit() ");
74     Serial\&.print("Writing ");Serial\&.print(state);Serial\&.print("to pin N°");Serial\&.print(pin);
75     Serial\&.println();
76 
77     bitWrite(this->action, pin, state);
78     digitalWrite(EnI2C, LOW);
79     
80     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
81 
82     digitalWrite(EnI2C, HIGH);
83 
84 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 39 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber =0\fC [private]\fP"

.PP
Definition at line 41 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 61 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 63 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 65 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
