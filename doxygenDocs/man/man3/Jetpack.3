.TH "Jetpack" 3 "Mon Jul 10 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP =0"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 21 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 30 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
31 {
32 
33 #if DEBUG == 1 
34  
35     Serial\&.println("Entering Jetpack\&.begin() ");
36     Serial\&.println();
37 
38 #endif
39 
40     pinMode(EnI2C,OUTPUT);
41     pinMode(dataPin,OUTPUT);
42     pinMode(clockPin,OUTPUT);
43     
44     
45 
46 }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 249 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::low, Jetpack::state::temporal, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
250 {
251 
252 #if DEBUG == 1 
253 
254     Serial\&.println("Entering Jetpack\&.config() ");
255     Serial\&.println();
256 
257 #endif
258 
259     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
260 
261     if (!jetPackConfig) 
262     {
263 
264     #if DEBUG == 1 
265 
266         Serial\&.println("failed to read /jetPackConfig\&.json ");
267         Serial\&.println();
268 
269     #endif
270 
271         return(false);
272     }
273     else
274     {
275         size_t size = jetPackConfig\&.size();
276         // Allocate a buffer to store contents of the file\&.
277         std::unique_ptr<char[]> buf(new char[size]);
278 
279         jetPackConfig\&.readBytes(buf\&.get(), size);
280         DynamicJsonBuffer jsonBuffer;
281         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
282         if (!json\&.success()) 
283         {
284         
285         #if DEBUG == 1 
286 
287             Serial\&.println("failed to parse jetpack config json from file ");
288             Serial\&.println();
289 
290         #endif
291 
292             return(false);
293         } 
294         else
295         { 
296         
297         #if DEBUG == 1 
298 
299             Serial\&.println("read configuration file : ");
300             json\&.printTo(Serial);
301             Serial\&.println();
302         
303         #endif
304   
305             if(json["ActorsNumber"]\&.success() )
306             {
307                 this->actorsNumber = json["ActorsNumber"]; 
308             
309                 for(int i=0;i<8;i++)
310                 {   if(json[String("Act")+String(i)]\&.success())
311                     {
312                         if(json[String("Act")+String(i)]["actif"]\&.success() )
313                         {
314                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
315                         }
316                         else
317                         {
318                             this->actors[i]\&.actif=this->actors[i]\&.actif;
319                         }
320                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
321 
322 
323                         if(json[String("Act")+String(i)]["low"]\&.success() )
324                         {                   
325                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
326                         }
327                         else
328                         {
329                             this->actors[i]\&.low=this->actors[i]\&.low;                  
330                         }
331                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
332     
333                     
334                         if(json[String("Act")+String(i)]["high"]\&.success() )
335                         {               
336                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
337                         }
338                         else
339                         {
340                             this->actors[i]\&.high=this->actors[i]\&.high;
341                         }
342                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
343 
344                     
345                         if(json[String("Act")+String(i)]["type"]\&.success() )
346                         {               
347                             this->actors[i]\&.type=json[String("Act")+String(i)]["type"]; 
348                         }
349                         else
350                         {
351                             this->actors[i]\&.type=this->actors[i]\&.type;
352                         }
353                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
354 
355                         if(json[String("Act")+String(i)]["temporal"]\&.success() )
356                         {
357                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];                                                  
358                         }
359                         else
360                         {
361                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"]; 
362                         }   
363                         json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
364                     }
365                     else
366                     {
367                         this->actors[i]=this->actors[i];
368                     }
369                     
370                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
371                     json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
372                     json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
373                     json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
374                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
375                 }
376             }
377             else
378             {
379                 this->actorsNumber=this->actorsNumber;
380             }
381             json["actorsNumber"]=this->actorsNumber;
382 
383             jetPackConfig\&.close();           
384             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
385             if(!jetPackConfig)
386             {
387             
388             #if DEBUG == 1 
389 
390                 Serial\&.println("failed to write to /jetPackConfig\&.json ");
391                 Serial\&.println();
392             
393             #endif
394                 
395                 return(false);          
396             }  
397 
398             json\&.printTo(jetPackConfig);
399             jetPackConfig\&.close();
400 
401         #if DEBUG == 1 
402             
403             Serial\&.println("saved configuration : ");
404             json\&.printTo(Serial );
405             Serial\&.println();        
406         
407         #endif
408 
409             return(true); 
410         }
411     }   
412     
413 
414 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 132 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, Jetpack::state::actifTime, action, actors, Jetpack::state::inactifTime, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
133 {
134 
135 #if DEBUG == 1 
136 
137     Serial\&.println("Entering Jetpack\&.doAction()");
138     Serial\&.println();
139 
140     Serial\&.println("input data is :");
141     Serial\&.println(data);
142     Serial\&.println();
143 
144     Serial\&.println("input size is :");   
145     Serial\&.println(JSON_SIZE);
146     Serial\&.println();
147 
148 #endif 
149 
150     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
151     JsonObject& root = jsonBuffer\&.parseObject(data);
152     
153     if (!root\&.success()) 
154     {
155     
156     #if DEBUG == 1 
157 
158         Serial\&.println("failed to parse json object ");
159         Serial\&.println();
160     
161     #endif 
162 
163     }
164     else
165     {
166     
167     #if DEBUG == 1 
168 
169         Serial\&.println("created Json object :");
170         root\&.printTo(Serial);
171         Serial\&.println();
172     
173     #endif 
174 
175         //invert the current action state for each actor
176         //if the value is outside the limits
177         for(int i=0;i<8;i++)
178         {
179             //check if the actor is actif 
180             if(this->actors[i]\&.actif==1)
181             {   
182                 //if the actor is not temporal
183                 if( this->actors[i]\&.temporal==0 ) 
184                 {
185                     if( ( ( root[this->actors[i]\&.type] ) > ( this->actors[i]\&.high ) ) || ( ( root[ this->actors[i]\&.type ] ) < ( this->actors[i]\&.low ) ) )   
186                     {   
187                         bitWrite( this->action , i , !( bitRead(this->action, i ) ) );  
188                     }
189                 }
190                 //if the actor is temporal
191                 else
192                 {   //if the actor was actif for highTime or more :
193                     if( ( millis()- this->actors[i]\&.actifTime  ) >= ( this->actors[i]\&.high  ) )
194                     {
195                         //stop the actor
196                         bitWrite( this->action , i , 0) ;
197 
198                         //make the actor inactif:
199                         this->actors[i]\&.actif=0;
200 
201                         //start the low timer
202                         this->actors[i]\&.inactifTime=millis();                
203                     }           
204                             
205                 }
206             }
207             //check if actor is inactif
208             else
209             {   //check if actor is temporal
210                 if(this->actors[i]\&.temporal==1)
211                 {
212                     //if the actor was inactif for lowTime or more :
213                     if( ( millis() - this->actors[i]\&.inactifTime ) >= ( this->actors[i]\&.low  ) )
214                     {
215                         //start the actor
216                         bitWrite( this->action , i , 1) ;
217 
218                         //make the actor actif:
219                         this->actors[i]\&.actif=1;
220 
221                         //start the low timer
222                         this->actors[i]\&.actifTime=millis();              
223                     }           
224             
225                 }
226             }
227         }
228     
229     #if DEBUG == 1 
230 
231         Serial\&.println("new action is : ");
232         Serial\&.println(this->action);
233         Serial\&.println();
234     
235     #endif 
236 
237         this->write(this->action);
238 
239     } 
240 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 422 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
423 {
424 
425 #if DEBUG == 1 
426 
427     Serial\&.println("Enter Jetpack\&.printConf() ");
428     Serial\&.println();
429 
430 #endif 
431     Serial\&.println("Jetpack configuration ") ;
432 
433     Serial\&.print("actorsNumber : ");
434     Serial\&.println(this->actorsNumber);
435  
436         for(int i=0;i<this->actorsNumber;i++)
437     {   
438         Serial\&.print("actor N°");
439         Serial\&.print(i);
440         Serial\&.print(" actif :");
441         Serial\&.println(this->actors[0]\&.actif);
442 
443         Serial\&.print("actor N°");
444         Serial\&.print(i);
445         Serial\&.print(" low :");
446         Serial\&.println(this->actors[0]\&.low);
447 
448         Serial\&.print("actor N°");
449         Serial\&.print(i);
450         Serial\&.print(" high :");
451         Serial\&.println(this->actors[0]\&.high);
452 
453         Serial\&.print("actor N°");
454         Serial\&.print(i);
455         Serial\&.print(" type :");
456         Serial\&.println(this->actors[0]\&.type);
457         
458         Serial\&.print("actor N°");
459         Serial\&.print(i);
460         Serial\&.print(" temporal :");
461         Serial\&.println(this->actors[0]\&.temporal);
462  
463 
464     }
465     Serial\&.println();
466 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 57 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
58 {
59 
60 #if DEBUG == 1
61 
62     Serial\&.println("Entering Jetpack\&.write()");
63     Serial\&.println();
64 
65     Serial\&.println("writing this action : ");
66     Serial\&.println(action,HEX);
67     Serial\&.println();
68 
69 #endif 
70 
71     this->action=action;
72 
73     
74     digitalWrite(EnI2C, LOW);
75     
76     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
77 
78     digitalWrite(EnI2C, HIGH);
79 
80 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 87 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
88 {
89 
90 #if DEBUG == 1 
91 
92     Serial\&.println("Entering Jetpack\&.writeBit() ");
93 
94     Serial\&.print("Writing ");
95     Serial\&.print(state);
96 
97     Serial\&.print("to pin N°");
98     Serial\&.print(pin);
99 
100     Serial\&.println();
101 
102 #endif
103 
104     bitWrite(this->action, pin, state);
105     digitalWrite(EnI2C, LOW);
106     
107     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
108 
109     digitalWrite(EnI2C, HIGH);
110 
111 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 39 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber =0\fC [private]\fP"

.PP
Definition at line 41 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 61 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 63 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 65 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
