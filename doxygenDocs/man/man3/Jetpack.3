.TH "Jetpack" 3 "Mon Jul 10 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP =0"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 21 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 32 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
33 {
34 
35 #if DEBUG == 1 
36  
37     Serial\&.println( F("Entering Jetpack\&.begin() ") );
38     Serial\&.println();
39 
40 #endif
41 
42     pinMode(EnI2C,OUTPUT);
43     pinMode(dataPin,OUTPUT);
44     pinMode(clockPin,OUTPUT);
45     
46     
47 
48 }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 251 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::low, Jetpack::state::temporal, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
252 {
253 
254 #if DEBUG == 1 
255 
256     Serial\&.println( F("Entering Jetpack\&.config() ") );
257     Serial\&.println();
258 
259 #endif
260 
261     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
262 
263     if (!jetPackConfig) 
264     {
265 
266     #if DEBUG == 1 
267 
268         Serial\&.println( F("failed to read /jetPackConfig\&.json ") );
269         Serial\&.println();
270 
271     #endif
272 
273         return(false);
274     }
275     else
276     {
277         size_t size = jetPackConfig\&.size();
278         // Allocate a buffer to store contents of the file\&.
279         std::unique_ptr<char[]> buf(new char[size]);
280 
281         jetPackConfig\&.readBytes(buf\&.get(), size);
282         DynamicJsonBuffer jsonBuffer;
283         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
284         if (!json\&.success()) 
285         {
286         
287         #if DEBUG == 1 
288 
289             Serial\&.println( F("failed to parse jetpack config json from file ") );
290             Serial\&.println();
291 
292         #endif
293 
294             return(false);
295         } 
296         else
297         { 
298         
299         #if DEBUG == 1 
300 
301             Serial\&.println( F("read configuration file : ") );
302             json\&.printTo(Serial);
303             Serial\&.println();
304         
305         #endif
306   
307             if(json["ActorsNumber"]\&.success() )
308             {
309                 this->actorsNumber = json["ActorsNumber"]; 
310             
311                 for(int i=0;i<8;i++)
312                 {   if(json[String("Act")+String(i)]\&.success())
313                     {
314                         if(json[String("Act")+String(i)]["actif"]\&.success() )
315                         {
316                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
317                         }
318                         else
319                         {
320                             this->actors[i]\&.actif=this->actors[i]\&.actif;
321                         }
322                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
323 
324 
325                         if(json[String("Act")+String(i)]["low"]\&.success() )
326                         {                   
327                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
328                         }
329                         else
330                         {
331                             this->actors[i]\&.low=this->actors[i]\&.low;                  
332                         }
333                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
334     
335                     
336                         if(json[String("Act")+String(i)]["high"]\&.success() )
337                         {               
338                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
339                         }
340                         else
341                         {
342                             this->actors[i]\&.high=this->actors[i]\&.high;
343                         }
344                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
345 
346                     
347                         if(json[String("Act")+String(i)]["type"]\&.success() )
348                         {               
349                             this->actors[i]\&.type=json[String("Act")+String(i)]["type"]; 
350                         }
351                         else
352                         {
353                             this->actors[i]\&.type=this->actors[i]\&.type;
354                         }
355                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
356 
357                         if(json[String("Act")+String(i)]["temporal"]\&.success() )
358                         {
359                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];                                                  
360                         }
361                         else
362                         {
363                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"]; 
364                         }   
365                         json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
366                     }
367                     else
368                     {
369                         this->actors[i]=this->actors[i];
370                     }
371                     
372                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
373                     json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
374                     json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
375                     json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
376                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
377                 }
378             }
379             else
380             {
381                 this->actorsNumber=this->actorsNumber;
382             }
383             json["actorsNumber"]=this->actorsNumber;
384 
385             jetPackConfig\&.close();           
386             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
387             if(!jetPackConfig)
388             {
389             
390             #if DEBUG == 1 
391 
392                 Serial\&.println( F("failed to write to /jetPackConfig\&.json ") );
393                 Serial\&.println();
394             
395             #endif
396                 
397                 return(false);          
398             }  
399 
400             json\&.printTo(jetPackConfig);
401             jetPackConfig\&.close();
402 
403         #if DEBUG == 1 
404             
405             Serial\&.println(F("saved configuration : "));
406             json\&.printTo(Serial );
407             Serial\&.println();        
408         
409         #endif
410 
411             return(true); 
412         }
413     }   
414     
415 
416 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 134 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, Jetpack::state::actifTime, action, actors, Jetpack::state::inactifTime, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
135 {
136 
137 #if DEBUG == 1 
138 
139     Serial\&.println( F("Entering Jetpack\&.doAction()") );
140     Serial\&.println();
141 
142     Serial\&.println( F("input data is :") );
143     Serial\&.println(data);
144     Serial\&.println();
145 
146     Serial\&.println( F("input size is :") );  
147     Serial\&.println(JSON_SIZE);
148     Serial\&.println();
149 
150 #endif 
151 
152     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
153     JsonObject& root = jsonBuffer\&.parseObject(data);
154     
155     if (!root\&.success()) 
156     {
157     
158     #if DEBUG == 1 
159 
160         Serial\&.println( F("failed to parse json object ") );
161         Serial\&.println();
162     
163     #endif 
164 
165     }
166     else
167     {
168     
169     #if DEBUG == 1 
170 
171         Serial\&.println( F("created Json object :") );
172         root\&.printTo(Serial);
173         Serial\&.println();
174     
175     #endif 
176 
177         //invert the current action state for each actor
178         //if the value is outside the limits
179         for(int i=0;i<8;i++)
180         {
181             //check if the actor is actif 
182             if(this->actors[i]\&.actif==1)
183             {   
184                 //if the actor is not temporal
185                 if( this->actors[i]\&.temporal==0 ) 
186                 {
187                     if( ( ( root[this->actors[i]\&.type] ) > ( this->actors[i]\&.high ) ) || ( ( root[ this->actors[i]\&.type ] ) < ( this->actors[i]\&.low ) ) )   
188                     {   
189                         bitWrite( this->action , i , !( bitRead(this->action, i ) ) );  
190                     }
191                 }
192                 //if the actor is temporal
193                 else
194                 {   //if the actor was actif for highTime or more :
195                     if( ( millis()- this->actors[i]\&.actifTime  ) >= ( this->actors[i]\&.high  ) )
196                     {
197                         //stop the actor
198                         bitWrite( this->action , i , 0) ;
199 
200                         //make the actor inactif:
201                         this->actors[i]\&.actif=0;
202 
203                         //start the low timer
204                         this->actors[i]\&.inactifTime=millis();                
205                     }           
206                             
207                 }
208             }
209             //check if actor is inactif
210             else
211             {   //check if actor is temporal
212                 if(this->actors[i]\&.temporal==1)
213                 {
214                     //if the actor was inactif for lowTime or more :
215                     if( ( millis() - this->actors[i]\&.inactifTime ) >= ( this->actors[i]\&.low  ) )
216                     {
217                         //start the actor
218                         bitWrite( this->action , i , 1) ;
219 
220                         //make the actor actif:
221                         this->actors[i]\&.actif=1;
222 
223                         //start the low timer
224                         this->actors[i]\&.actifTime=millis();              
225                     }           
226             
227                 }
228             }
229         }
230     
231     #if DEBUG == 1 
232 
233         Serial\&.println( F("new action is : ") );
234         Serial\&.println(this->action);
235         Serial\&.println();
236     
237     #endif 
238 
239         this->write(this->action);
240 
241     } 
242 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 424 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
425 {
426 
427 #if DEBUG == 1 
428 
429     Serial\&.println( F("Enter Jetpack\&.printConf() ") );
430     Serial\&.println();
431 
432 #endif 
433     Serial\&.println( "Jetpack configuration " ) ;
434 
435     Serial\&.print( "actorsNumber : " );
436     Serial\&.println(this->actorsNumber);
437  
438         for(int i=0;i<this->actorsNumber;i++)
439     {   
440         Serial\&.print("actor N°");
441         Serial\&.print(i);
442         Serial\&.print(" actif :");
443         Serial\&.println(this->actors[0]\&.actif);
444 
445         Serial\&.print("actor N°");
446         Serial\&.print(i);
447         Serial\&.print(" low :");
448         Serial\&.println(this->actors[0]\&.low);
449 
450         Serial\&.print("actor N°");
451         Serial\&.print(i);
452         Serial\&.print(" high :");
453         Serial\&.println(this->actors[0]\&.high);
454 
455         Serial\&.print("actor N°");
456         Serial\&.print(i);
457         Serial\&.print(" type :");
458         Serial\&.println(this->actors[0]\&.type);
459         
460         Serial\&.print("actor N°");
461         Serial\&.print(i);
462         Serial\&.print(" temporal :");
463         Serial\&.println(this->actors[0]\&.temporal);
464  
465 
466     }
467     Serial\&.println();
468 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 59 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
60 {
61 
62 #if DEBUG == 1
63 
64     Serial\&.println( F("Entering Jetpack\&.write()") );
65     Serial\&.println();
66 
67     Serial\&.println( F("writing this action : ") );
68     Serial\&.println(action,HEX);
69     Serial\&.println();
70 
71 #endif 
72 
73     this->action=action;
74 
75     
76     digitalWrite(EnI2C, LOW);
77     
78     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
79 
80     digitalWrite(EnI2C, HIGH);
81 
82 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 89 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
90 {
91 
92 #if DEBUG == 1 
93 
94     Serial\&.println( F("Entering Jetpack\&.writeBit() ") );
95 
96     Serial\&.print( F("Writing ") );
97     Serial\&.print(state);
98 
99     Serial\&.print( F("to pin N°") );
100     Serial\&.print(pin);
101 
102     Serial\&.println();
103 
104 #endif
105 
106     bitWrite(this->action, pin, state);
107     digitalWrite(EnI2C, LOW);
108     
109     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
110 
111     digitalWrite(EnI2C, HIGH);
112 
113 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 39 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber =0\fC [private]\fP"

.PP
Definition at line 41 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 61 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 63 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 65 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
