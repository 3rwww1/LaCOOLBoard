.TH "Jetpack" 3 "Wed Jun 28 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 22 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 22 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
23  { 
24 
25     pinMode(EnI2C,OUTPUT);
26     pinMode(dataPin,OUTPUT);
27     pinMode(clockPin,OUTPUT);
28 
29 
30 
31  }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 116 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::low, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
117 {
118 
119     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
120 
121     if (!jetPackConfig) 
122     {
123         return(false);
124     }
125     else
126     {
127         size_t size = jetPackConfig\&.size();
128         // Allocate a buffer to store contents of the file\&.
129         std::unique_ptr<char[]> buf(new char[size]);
130 
131         jetPackConfig\&.readBytes(buf\&.get(), size);
132         DynamicJsonBuffer jsonBuffer;
133         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
134         if (!json\&.success()) 
135         {
136               return(false);
137         } 
138         else
139         {     
140             if(json["ActorsNumber"]\&.success() )
141             {
142                 this->actorsNumber = json["ActorsNumber"]; 
143             
144                 for(int i=0;i<this->actorsNumber;i++)
145                 {   if(json[String("Act")+String(i)]\&.success())
146                     {
147                         if(json[String("Act")+String(i)]["actif"]\&.success() )
148                         {
149                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
150                         }
151                         else
152                         {
153                             this->actors[i]\&.actif=this->actors[i]\&.actif;
154                         }
155                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
156 
157 
158                         if(json[String("Act")+String(i)]["low"]\&.success() )
159                         {                   
160                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
161                         }
162                         else
163                         {
164                             this->actors[i]\&.low=this->actors[i]\&.low;                  
165                         }
166                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
167     
168                     
169                         if(json[String("Act")+String(i)]["high"]\&.success() )
170                         {               
171                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
172                         }
173                         else
174                         {
175                             this->actors[i]\&.high=this->actors[i]\&.high;
176                         }
177                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
178 
179                     
180                         if(json[String("Act")+String(i)]["type"]\&.success() )
181                         {               
182                             this->actors[i]\&.type=json[String("Act")+String(i)]["type"]; 
183                         }
184                         else
185                         {
186                             this->actors[i]\&.type=this->actors[i]\&.type;
187                         }
188                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;  
189 
190                     }
191                     else
192                     {
193                         this->actors[i]=this->actors[i];
194                     }
195                     
196                     //json[String("Act")+String(i)]=this->actors[i];
197                 }
198             }
199             else
200             {
201                 this->actorsNumber=this->actorsNumber;
202             }
203             json["actorsNumber"]=this->actorsNumber;
204             
205             return(true); 
206         }
207     }   
208     
209 
210 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 89 of file Jetpack\&.cpp\&.
.PP
References action, actors, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
90 {
91     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
92     JsonObject& root = jsonBuffer\&.parseObject(data);
93     
94     //invert the current action state for each actor
95     //if the value is outside the limits
96     for(int i=0;i<8;i++)
97     {
98         if(this->actors[i]\&.actif==1)
99         {
100             if( ((root[this->actors[i]\&.type])>(this->actors[i]\&.high)) || ((root[ this->actors[i]\&.type ])<(this->actors[i]\&.low)) )   
101             {   
102             bitWrite(this->action , i , !(bitRead(this->action, i ) ) );    
103             }
104         }
105     }
106     this->write(this->action);
107 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 218 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
219 {
220     Serial\&.println("Jetpack Config ");
221     Serial\&.println(this->actorsNumber); 
222         for(int i=0;i<this->actorsNumber;i++)
223     {
224     Serial\&.println(this->actors[0]\&.actif);
225     Serial\&.println(this->actors[0]\&.low);
226     Serial\&.println(this->actors[0]\&.high);
227     Serial\&.println(this->actors[0]\&.type); 
228     }
229 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 42 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
43 {
44     this->action=action;
45 
46     digitalWrite(EnI2C, LOW);
47     
48     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
49 
50     digitalWrite(EnI2C, HIGH);
51 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 58 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
59 {
60 
61     bitWrite(this->action, pin, state);
62     digitalWrite(EnI2C, LOW);
63     
64     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
65 
66     digitalWrite(EnI2C, HIGH);
67 
68 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 40 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber\fC [private]\fP"

.PP
Definition at line 41 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 51 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 52 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 53 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
