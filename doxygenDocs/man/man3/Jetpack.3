.TH "Jetpack" 3 "Thu Jul 13 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP =0"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 21 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 32 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
33 {
34 
35 #if DEBUG == 1 
36  
37     Serial\&.println( F("Entering Jetpack\&.begin() ") );
38     Serial\&.println();
39 
40 #endif
41 
42     pinMode(EnI2C,OUTPUT);
43     pinMode(dataPin,OUTPUT);
44     pinMode(clockPin,OUTPUT);
45     
46     
47 
48 }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 355 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::inverted, Jetpack::state::low, Jetpack::state::temporal, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
356 {
357 
358 #if DEBUG == 1 
359 
360     Serial\&.println( F("Entering Jetpack\&.config() ") );
361     Serial\&.println();
362 
363 #endif
364 
365     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
366 
367     if (!jetPackConfig) 
368     {
369 
370     #if DEBUG == 1 
371 
372         Serial\&.println( F("failed to read /jetPackConfig\&.json ") );
373         Serial\&.println();
374 
375     #endif
376 
377         return(false);
378     }
379     else
380     {
381         size_t size = jetPackConfig\&.size();
382         // Allocate a buffer to store contents of the file\&.
383         std::unique_ptr<char[]> buf(new char[size]);
384 
385         jetPackConfig\&.readBytes(buf\&.get(), size);
386         DynamicJsonBuffer jsonBuffer;
387         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
388         if (!json\&.success()) 
389         {
390         
391         #if DEBUG == 1 
392 
393             Serial\&.println( F("failed to parse jetpack config json from file ") );
394             Serial\&.println();
395 
396         #endif
397 
398             return(false);
399         } 
400         else
401         { 
402         
403         #if DEBUG == 1 
404 
405             Serial\&.println( F("read configuration file : ") );
406             json\&.printTo(Serial);
407             Serial\&.println();
408         
409         #endif
410   
411             if(json["ActorsNumber"]\&.success() )
412             {
413                 this->actorsNumber = json["ActorsNumber"]; 
414             
415                 for(int i=0;i<8;i++)
416                 {   if(json[String("Act")+String(i)]\&.success())
417                     {
418                         if(json[String("Act")+String(i)]["actif"]\&.success() )
419                         {
420                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
421                         }
422                         else
423                         {
424                             this->actors[i]\&.actif=this->actors[i]\&.actif;
425                         }
426                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
427 
428 
429                         if(json[String("Act")+String(i)]["low"]\&.success() )
430                         {                   
431                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
432                         }
433                         else
434                         {
435                             this->actors[i]\&.low=this->actors[i]\&.low;                  
436                         }
437                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
438     
439                     
440                         if(json[String("Act")+String(i)]["high"]\&.success() )
441                         {               
442                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
443                         }
444                         else
445                         {
446                             this->actors[i]\&.high=this->actors[i]\&.high;
447                         }
448                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
449 
450                     
451                         if(json[String("Act")+String(i)]["type"]\&.success() )
452                         {               
453                             this->actors[i]\&.type=String( json[String("Act")+String(i)]["type"]\&.as<const char*>() ); 
454                         }
455                         else
456                         {
457                             this->actors[i]\&.type=this->actors[i]\&.type;
458                         }
459                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type\&.c_str();
460 
461 
462                         if(json[String("Act")+String(i)]["temporal"]\&.success() )
463                         {
464                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];                                                  
465                         }
466                         else
467                         {
468                             this->actors[i]\&.temporal=this->actors[i]\&.temporal; 
469                         }   
470                         json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
471 
472                         
473                         if(json[String("Act")+String(i)]["inverted"]\&.success() )
474                         {
475                             this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"];                                                  
476                         }
477                         else
478                         {
479                             this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"]; 
480                         }   
481                         json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
482 
483                         
484                          
485                     }
486                     else
487                     {
488                         this->actors[i]=this->actors[i];
489                     }
490                     
491                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
492                     json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
493                     json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
494                     json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
495                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
496                     json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted; 
497                 }
498             }
499             else
500             {
501                 this->actorsNumber=this->actorsNumber;
502             }
503             json["actorsNumber"]=this->actorsNumber;
504 
505             jetPackConfig\&.close();           
506             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
507             if(!jetPackConfig)
508             {
509             
510             #if DEBUG == 1 
511 
512                 Serial\&.println( F("failed to write to /jetPackConfig\&.json ") );
513                 Serial\&.println();
514             
515             #endif
516                 
517                 return(false);          
518             }  
519 
520             json\&.printTo(jetPackConfig);
521             jetPackConfig\&.close();
522 
523         #if DEBUG == 1 
524             
525             Serial\&.println(F("saved configuration : "));
526             json\&.printTo(Serial );
527             Serial\&.println();        
528         
529         #endif
530 
531             return(true); 
532         }
533     }   
534     
535 
536 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 134 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, Jetpack::state::actifTime, action, actors, Jetpack::state::inactifTime, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
135 {
136 
137 #if DEBUG == 1 
138 
139     Serial\&.println( F("Entering Jetpack\&.doAction()") );
140     Serial\&.println();
141 
142     Serial\&.println( F("input data is :") );
143     Serial\&.println(data);
144     Serial\&.println();
145 
146     Serial\&.println( F("input size is :") );  
147     Serial\&.println(JSON_SIZE);
148     Serial\&.println();
149 
150 #endif 
151 
152     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
153     JsonObject& root = jsonBuffer\&.parseObject(data);
154     
155     if (!root\&.success()) 
156     {
157     
158     #if DEBUG == 1 
159 
160         Serial\&.println( F("failed to parse json object ") );
161         Serial\&.println();
162     
163     #endif 
164 
165     }
166     else
167     {
168     
169     #if DEBUG == 1 
170 
171         Serial\&.println( F("created Json object :") );
172         root\&.printTo(Serial);
173         Serial\&.println();
174     
175     #endif 
176 
177         //invert the current action state for each actor
178         //if the value is outside the limits
179         for(int i=0;i<8;i++)
180         {
181             //check if the actor is actif 
182             if(this->actors[i]\&.actif==1)
183             {   
184                 //if the actor is not temporal
185                 if( this->actors[i]\&.temporal==0 ) 
186                 {   
187                     //regular actor
188                     if( (this->actors[i]\&.inverted) == 0 )
189                     {
190                         //measure >= high limit : stop actor
191                         if( ( root[this->actors[i]\&.type] ) >= ( this->actors[i]\&.high ) )  
192                         {   
193                             bitWrite( this->action , i , 0 ) ;  
194                         }
195                         //measure <= low limit : start actor
196                         else if( ( root[ this->actors[i]\&.type ] ) <= ( this->actors[i]\&.low ) )
197                         {
198                             bitWrite( this->action , i , 1 ) ;                  
199                         }
200                     }
201                     //inverted actor
202                     else if( (this->actors[i]\&.inverted) == 1 )
203                     {
204                         //measure >= high limit : start actor
205                         if( ( root[this->actors[i]\&.type] ) >= ( this->actors[i]\&.high ) )  
206                         {   
207                             bitWrite( this->action , i , 1 ) ;  
208                         }
209                         //measure <= low limit : stop actor
210                         else if( ( root[ this->actors[i]\&.type ] ) <= ( this->actors[i]\&.low ) )
211                         {
212                             bitWrite( this->action , i , 0 ) ;                  
213                         }
214 
215                     
216                     }
217                 }
218 
219                 //if the actor is temporal
220                 else
221                 {
222                     //actor of type hour
223                     if( ( this->actors[i]\&.type ) == ( "hour" ) )     
224                     {
225                     
226                     #if DEBUG == 1
227                         
228                         Serial\&.println("hour actor ");
229                         Serial\&.println(i);
230                         Serial\&.println();
231                     #endif
232 
233                         //time >= high : stop actor
234                         if( ( root[this->actors[i]\&.type] ) >= ( this->actors[i]\&.low ) )   
235                         {
236                         
237                         #if DEBUG == 1 
238                             
239                             Serial\&.print("deactive ");
240                             Serial\&.println(i);
241                         
242                         #endif  
243                             bitWrite( this->action , i , 0 ) ;  
244                         }
245                         //time >= low : start actor
246                         else if( ( root[ this->actors[i]\&.type ] ) >= ( this->actors[i]\&.high ) )
247                         {
248                         
249                         #if DEBUG == 1 
250                         
251                             Serial\&.print("active ");
252                             Serial\&.println(i);
253                         
254                         #endif
255                             bitWrite( this->action , i , 1 ) ;                  
256                         }
257                         
258                     }
259                     //actor not of type hour
260                     else if( ( this->actors[i]\&.type ) != ( "hour" ) )     
261                     {
262                     
263                     #if DEBUG == 1 
264                         
265                         Serial\&.println("not hour temporal actor");
266                         Serial\&.println(this->actors[i]\&.type);
267                         Serial\&.println(i);
268                         Serial\&.println("actifTime : ");
269                         Serial\&.println(this->actors[i]\&.actifTime);
270                         Serial\&.println("millis : ");
271                         Serial\&.println(millis() );
272                         Serial\&.println(" high : ");
273                         Serial\&.println(this->actors[i]\&.high );
274                         Serial\&.println();
275                     
276                     #endif
277                         //if the actor was actif for highTime or more :
278                         if( ( millis()- this->actors[i]\&.actifTime  ) >= ( this->actors[i]\&.high  ) )
279                         {
280                             //stop the actor
281                             bitWrite( this->action , i , 0) ;
282 
283                             //make the actor inactif:
284                             this->actors[i]\&.actif=0;
285 
286                             //start the low timer
287                             this->actors[i]\&.inactifTime=millis();                
288                         }
289                     }           
290                             
291                 }
292             }
293             //check if actor is inactif
294             else if(this->actors[i]\&.actif==0)
295             {   //check if actor is temporal
296                 if(this->actors[i]\&.temporal==1)
297                 {
298                     //if the actor was inactif for lowTime or more :
299                     if( ( millis() - this->actors[i]\&.inactifTime ) >= ( this->actors[i]\&.low  ) )
300                     {
301                         //start the actor
302                         bitWrite( this->action , i , 1) ;
303 
304                         //make the actor actif:
305                         this->actors[i]\&.actif=1;
306 
307                         //start the low timer
308                         this->actors[i]\&.actifTime=millis();
309 
310                     #if DEBUG == 1 
311                         
312                         Serial\&.println("inactif temporal actor");
313                         Serial\&.println(this->actors[i]\&.type);
314                         Serial\&.print("temporal : ");
315                         Serial\&.println(this->actors[i]\&.temporal);
316                         Serial\&.println(i);
317                         Serial\&.println("inactifTime : ");
318                         Serial\&.println(this->actors[i]\&.inactifTime);
319                         Serial\&.println("millis : ");
320                         Serial\&.println(millis() );
321                         Serial\&.println(" low : ");
322                         Serial\&.println(this->actors[i]\&.low );
323                         Serial\&.println();
324 
325                         Serial\&.println();
326                     
327                     #endif
328                 
329                     }           
330             
331                 }
332             }
333         }
334     
335     #if DEBUG == 1 
336 
337         Serial\&.println( F("new action is : ") );
338         Serial\&.println(this->action,BIN);
339         Serial\&.println();
340     
341     #endif 
342 
343         this->write(this->action);
344 
345     } 
346 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 544 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
545 {
546 
547 #if DEBUG == 1 
548 
549     Serial\&.println( F("Enter Jetpack\&.printConf() ") );
550     Serial\&.println();
551 
552 #endif 
553     Serial\&.println( "Jetpack configuration " ) ;
554 
555     Serial\&.print( "actorsNumber : " );
556     Serial\&.println(this->actorsNumber);
557  
558         for(int i=0;i<this->actorsNumber;i++)
559     {   
560         Serial\&.print("actor N°");
561         Serial\&.print(i);
562         Serial\&.print(" actif :");
563         Serial\&.println(this->actors[i]\&.actif);
564 
565         Serial\&.print("actor N°");
566         Serial\&.print(i);
567         Serial\&.print(" low :");
568         Serial\&.println(this->actors[i]\&.low);
569 
570         Serial\&.print("actor N°");
571         Serial\&.print(i);
572         Serial\&.print(" high :");
573         Serial\&.println(this->actors[i]\&.high);
574 
575         Serial\&.print("actor N°");
576         Serial\&.print(i);
577         Serial\&.print(" type :");
578         Serial\&.println(this->actors[i]\&.type);
579         
580         Serial\&.print("actor N°");
581         Serial\&.print(i);
582         Serial\&.print(" temporal :");
583         Serial\&.println(this->actors[i]\&.temporal);
584 
585         Serial\&.print("actor N°");
586         Serial\&.print(i);
587         Serial\&.print(" inverted :");
588         Serial\&.println(this->actors[i]\&.inverted);
589 
590  
591 
592     }
593 
594     Serial\&.println();
595 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 59 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
60 {
61 
62 #if DEBUG == 1
63 
64     Serial\&.println( F("Entering Jetpack\&.write()") );
65     Serial\&.println();
66 
67     Serial\&.println( F("writing this action : ") );
68     Serial\&.println(action,BIN);
69     Serial\&.println();
70 
71 #endif 
72 
73     this->action=action;
74 
75     
76     digitalWrite(EnI2C, LOW);
77     
78     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
79 
80     digitalWrite(EnI2C, HIGH);
81 
82 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 89 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
90 {
91 
92 #if DEBUG == 1 
93 
94     Serial\&.println( F("Entering Jetpack\&.writeBit() ") );
95 
96     Serial\&.print( F("Writing ") );
97     Serial\&.print(state);
98 
99     Serial\&.print( F("to pin N°") );
100     Serial\&.print(pin);
101 
102     Serial\&.println();
103 
104 #endif
105 
106     bitWrite(this->action, pin, state);
107     digitalWrite(EnI2C, LOW);
108     
109     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
110 
111     digitalWrite(EnI2C, HIGH);
112 
113 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 39 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber =0\fC [private]\fP"

.PP
Definition at line 41 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 65 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 67 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 69 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
