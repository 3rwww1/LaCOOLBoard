.TH "Jetpack" 3 "Mon Jul 3 2017" "CoolAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data, int JSON_SIZE)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBsetBit\fP (byte pin)"
.br
.ti -1c
.RI "static void \fBresetBit\fP (byte pin)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "byte \fBactorsNumber\fP"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 21 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 24 of file Jetpack\&.cpp\&.
.PP
References clockPin, dataPin, and EnI2C\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
25  { 
26     pinMode(EnI2C,OUTPUT);
27     pinMode(dataPin,OUTPUT);
28     pinMode(clockPin,OUTPUT);
29     
30     
31 
32  }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 183 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, actors, actorsNumber, Jetpack::state::high, Jetpack::state::low, Jetpack::state::temporal, and Jetpack::state::type\&.
.PP
Referenced by CoolBoard::begin(), and CoolBoard::update()\&.
.PP
.nf
184 {
185 
186     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
187 
188     if (!jetPackConfig) 
189     {
190         return(false);
191     }
192     else
193     {
194         size_t size = jetPackConfig\&.size();
195         // Allocate a buffer to store contents of the file\&.
196         std::unique_ptr<char[]> buf(new char[size]);
197 
198         jetPackConfig\&.readBytes(buf\&.get(), size);
199         DynamicJsonBuffer jsonBuffer;
200         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
201         if (!json\&.success()) 
202         {
203               return(false);
204         } 
205         else
206         {     
207             if(json["ActorsNumber"]\&.success() )
208             {
209                 this->actorsNumber = json["ActorsNumber"]; 
210             
211                 for(int i=0;i<8;i++)
212                 {   if(json[String("Act")+String(i)]\&.success())
213                     {
214                         if(json[String("Act")+String(i)]["actif"]\&.success() )
215                         {
216                             this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
217                         }
218                         else
219                         {
220                             this->actors[i]\&.actif=this->actors[i]\&.actif;
221                         }
222                         json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
223 
224 
225                         if(json[String("Act")+String(i)]["low"]\&.success() )
226                         {                   
227                             this->actors[i]\&.low=json[String("Act")+String(i)]["low"];
228                         }
229                         else
230                         {
231                             this->actors[i]\&.low=this->actors[i]\&.low;                  
232                         }
233                         json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
234     
235                     
236                         if(json[String("Act")+String(i)]["high"]\&.success() )
237                         {               
238                             this->actors[i]\&.high=json[String("Act")+String(i)]["high"];
239                         }
240                         else
241                         {
242                             this->actors[i]\&.high=this->actors[i]\&.high;
243                         }
244                         json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
245 
246                     
247                         if(json[String("Act")+String(i)]["type"]\&.success() )
248                         {               
249                             this->actors[i]\&.type=json[String("Act")+String(i)]["type"]; 
250                         }
251                         else
252                         {
253                             this->actors[i]\&.type=this->actors[i]\&.type;
254                         }
255                         json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
256 
257                         if(json[String("Act")+String(i)]["temporal"]\&.success() )
258                         {
259                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];                                                  
260                         }
261                         else
262                         {
263                             this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"]; 
264                         }   
265                         json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
266                     }
267                     else
268                     {
269                         this->actors[i]=this->actors[i];
270                     }
271                     
272                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
273                     json[String("Act")+String(i)]["low"]=this->actors[i]\&.low;
274                     json[String("Act")+String(i)]["high"]=this->actors[i]\&.high;
275                     json[String("Act")+String(i)]["type"]=this->actors[i]\&.type;
276                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal; 
277                 }
278             }
279             else
280             {
281                 this->actorsNumber=this->actorsNumber;
282             }
283             json["actorsNumber"]=this->actorsNumber;
284 
285             jetPackConfig\&.close();           
286             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
287             if(!jetPackConfig)
288             {
289                 return(false);          
290             }  
291 
292             json\&.printTo(jetPackConfig);
293             jetPackConfig\&.close();       
294             
295             return(true); 
296         }
297     }   
298     
299 
300 }
.fi
.SS "void Jetpack::doAction (const char * data, int JSON_SIZE)"
Jetpack::doAction(sensor data, sensor data size): This method is provided to automate the \fBJetpack\fP\&. exemple: initial state: current Temperature = 23 °C actors[0]\&.actif=1 actors[0]\&.low=25 °C actors[0]\&.high=30 °C actors[0]\&.type='Temperature'
.PP
condition verified: root['Temperature']<actors[0]\&.low
.PP
action: invert the state of actors[0]: bitWrite( action,0,!( bitRead ( action,0 ) ) ) write(action) 
.PP
Definition at line 114 of file Jetpack\&.cpp\&.
.PP
References Jetpack::state::actif, Jetpack::state::actifTime, action, actors, Jetpack::state::inactifTime, and write()\&.
.PP
Referenced by CoolBoard::offLineMode(), and CoolBoard::onLineMode()\&.
.PP
.nf
115 {
116     DynamicJsonBuffer jsonBuffer(JSON_SIZE);
117     JsonObject& root = jsonBuffer\&.parseObject(data);
118     
119     //invert the current action state for each actor
120     //if the value is outside the limits
121     for(int i=0;i<8;i++)
122     {
123         //check if the actor is actif 
124         if(this->actors[i]\&.actif==1)
125         {   
126             //check if the actor is temporal or not
127             if( this->actors[i]\&.temporal==0 ) 
128             {
129                 if( ( ( root[this->actors[i]\&.type] ) > ( this->actors[i]\&.high ) ) || ( ( root[ this->actors[i]\&.type ] ) < ( this->actors[i]\&.low ) ) )   
130                 {   
131                     bitWrite( this->action , i , !( bitRead(this->action, i ) ) );  
132                 }
133             }
134 
135             else
136             {   //if the actor was actif for highTime or more :
137                 if( ( millis()- this->actors[i]\&.actifTime  ) >= ( this->actors[i]\&.high  ) )
138                 {
139                     //stop the actor
140                     bitWrite( this->action , i , 0) ;
141 
142                     //make the actor inactif:
143                     this->actors[i]\&.actif=0;
144 
145                     //start the low timer
146                     this->actors[i]\&.inactifTime=millis();                
147                 }           
148                             
149             }
150         }
151         //check if actor is inactif
152         else
153         {   //check if actor is temporal
154             if(this->actors[i]\&.temporal==1)
155             {
156                 //if the actor was inactif for lowTime or more :
157                 if( ( millis() - this->actors[i]\&.inactifTime ) >= ( this->actors[i]\&.low  ) )
158                 {
159                     //start the actor
160                     bitWrite( this->action , i , 1) ;
161 
162                     //make the actor actif:
163                     this->actors[i]\&.actif=1;
164 
165                     //start the low timer
166                     this->actors[i]\&.actifTime=millis();              
167                 }           
168             
169             }
170         }
171     }
172 
173     this->write(this->action);
174 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 308 of file Jetpack\&.cpp\&.
.PP
References actors, and actorsNumber\&.
.PP
Referenced by CoolBoard::begin()\&.
.PP
.nf
309 {
310     Serial\&.println("Jetpack Config ");
311     Serial\&.println(this->actorsNumber); 
312         for(int i=0;i<this->actorsNumber;i++)
313     {
314     Serial\&.println(this->actors[0]\&.actif);
315     Serial\&.println(this->actors[0]\&.low);
316     Serial\&.println(this->actors[0]\&.high);
317     Serial\&.println(this->actors[0]\&.type); 
318     }
319 }
.fi
.SS "void Jetpack::resetBit (byte pin)\fC [static]\fP"
Jetpack::setBit(pin): This method is provided to directly put to LOW the pin passed as argument 
.PP
Definition at line 89 of file Jetpack\&.cpp\&.
.PP
.nf
90 {
91     /*auto bound_member_fn=std::bind(&Jetpack::writeBit,std::placeholders::_2,std::placeholders::_2);
92     bound_member_fn(pin,0);*/
93 }
.fi
.SS "void Jetpack::setBit (byte pin)\fC [static]\fP"
Jetpack::setBit(pin): This method is provided to directly put to HIGH the pin passed as argument 
.PP
Definition at line 77 of file Jetpack\&.cpp\&.
.PP
.nf
78 {
79 //  
80 //  wB(pin,0);
81 }   
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 43 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
Referenced by doAction()\&.
.PP
.nf
44 {
45     this->action=action;
46 
47     digitalWrite(EnI2C, LOW);
48     
49     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
50 
51     digitalWrite(EnI2C, HIGH);
52 }   
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 59 of file Jetpack\&.cpp\&.
.PP
References action, clockPin, dataPin, and EnI2C\&.
.PP
.nf
60 {
61 
62     bitWrite(this->action, pin, state);
63     digitalWrite(EnI2C, LOW);
64     
65     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
66 
67     digitalWrite(EnI2C, HIGH);
68 
69 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 43 of file Jetpack\&.h\&.
.PP
Referenced by doAction(), write(), and writeBit()\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.PP
Referenced by config(), doAction(), and printConf()\&.
.SS "byte Jetpack::actorsNumber\fC [private]\fP"

.PP
Definition at line 45 of file Jetpack\&.h\&.
.PP
Referenced by config(), and printConf()\&.
.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 65 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 67 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 69 of file Jetpack\&.h\&.
.PP
Referenced by begin(), write(), and writeBit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolAPI from the source code\&.
