.TH "CoolPubSubClient" 3 "Mon Aug 14 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CoolPubSubClient
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CoolPubSubClient\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCoolPubSubClient\fP ()"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (IPAddress, uint16_t, Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (IPAddress, uint16_t, Client &client, Stream &)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (IPAddress, uint16_t, \fBMQTT_CALLBACK_SIGNATURE\fP, Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (IPAddress, uint16_t, \fBMQTT_CALLBACK_SIGNATURE\fP, Client &client, Stream &)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (uint8_t *, uint16_t, Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (uint8_t *, uint16_t, Client &client, Stream &)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (uint8_t *, uint16_t, \fBMQTT_CALLBACK_SIGNATURE\fP, Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (uint8_t *, uint16_t, \fBMQTT_CALLBACK_SIGNATURE\fP, Client &client, Stream &)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (const char *, uint16_t, Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (const char *, uint16_t, Client &client, Stream &)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (const char *, uint16_t, \fBMQTT_CALLBACK_SIGNATURE\fP, Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP (const char *, uint16_t, \fBMQTT_CALLBACK_SIGNATURE\fP, Client &client, Stream &)"
.br
.ti -1c
.RI "\fB~CoolPubSubClient\fP ()"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetServer\fP (IPAddress \fBip\fP, uint16_t \fBport\fP)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetServer\fP (uint8_t *\fBip\fP, uint16_t \fBport\fP)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetServer\fP (const char *\fBdomain\fP, uint16_t \fBport\fP)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetCallback\fP (\fBMQTT_CALLBACK_SIGNATURE\fP)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetClient\fP (Client &client)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetStream\fP (Stream &\fBstream\fP)"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP & \fBsetTimeout\fP (uint16_t \fBsocketTimeout\fP)"
.br
.ti -1c
.RI "boolean \fBconnect\fP (const char *id, uint16_t \fBkeepAlive\fP=\fBMQTT_KEEPALIVE\fP, uint16_t \fBsocketTimeout\fP=\fBMQTT_SOCKET_TIMEOUT\fP)"
.br
.ti -1c
.RI "boolean \fBconnect\fP (const char *id, const char *user, const char *pass, uint16_t \fBkeepAlive\fP=\fBMQTT_KEEPALIVE\fP, uint16_t \fBsocketTimeout\fP=\fBMQTT_SOCKET_TIMEOUT\fP)"
.br
.ti -1c
.RI "boolean \fBconnect\fP (const char *id, const char *willTopic, uint8_t willQos, boolean willRetain, const char *willMessage, uint16_t \fBkeepAlive\fP=\fBMQTT_KEEPALIVE\fP, uint16_t \fBsocketTimeout\fP=\fBMQTT_SOCKET_TIMEOUT\fP)"
.br
.ti -1c
.RI "boolean \fBconnect\fP (const char *id, const char *user, const char *pass, const char *willTopic, uint8_t willQos, boolean willRetain, const char *willMessage, uint16_t \fBkeepAlive\fP=\fBMQTT_KEEPALIVE\fP, uint16_t \fBsocketTimeout\fP=\fBMQTT_SOCKET_TIMEOUT\fP)"
.br
.ti -1c
.RI "void \fBdisconnect\fP ()"
.br
.ti -1c
.RI "boolean \fBpublish\fP (const char *topic, const char *payload)"
.br
.ti -1c
.RI "boolean \fBpublish\fP (const char *topic, const char *payload, boolean retained)"
.br
.ti -1c
.RI "boolean \fBpublish\fP (const char *topic, const uint8_t *payload, unsigned int plength)"
.br
.ti -1c
.RI "boolean \fBpublish\fP (const char *topic, const uint8_t *payload, unsigned int plength, boolean retained)"
.br
.ti -1c
.RI "boolean \fBpublish_P\fP (const char *topic, const uint8_t *payload, unsigned int plength, boolean retained)"
.br
.ti -1c
.RI "boolean \fBsubscribe\fP (const char *topic)"
.br
.ti -1c
.RI "boolean \fBsubscribe\fP (const char *topic, uint8_t qos)"
.br
.ti -1c
.RI "boolean \fBunsubscribe\fP (const char *topic)"
.br
.ti -1c
.RI "boolean \fBloop\fP ()"
.br
.ti -1c
.RI "boolean \fBconnected\fP ()"
.br
.ti -1c
.RI "int \fBstate\fP ()"
.br
.ti -1c
.RI "boolean \fBsetBufferSize\fP (uint16_t size)"
.br
.ti -1c
.RI "uint16_t \fBgetBufferSize\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "uint16_t \fBreadPacket\fP (uint8_t *)"
.br
.ti -1c
.RI "boolean \fBreadByte\fP (uint8_t *result)"
.br
.ti -1c
.RI "boolean \fBreadByte\fP (uint8_t *result, uint16_t *index)"
.br
.ti -1c
.RI "boolean \fBwrite\fP (uint8_t header, uint8_t *buf, uint16_t length)"
.br
.ti -1c
.RI "uint16_t \fBwriteString\fP (const char *string, uint8_t *buf, uint16_t pos)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Client * \fB_client\fP"
.br
.ti -1c
.RI "uint8_t * \fBbuffer\fP"
.br
.ti -1c
.RI "uint16_t \fBbuffer_size\fP"
.br
.ti -1c
.RI "uint16_t \fBnextMsgId\fP"
.br
.ti -1c
.RI "unsigned long \fBlastOutActivity\fP"
.br
.ti -1c
.RI "unsigned long \fBlastInActivity\fP"
.br
.ti -1c
.RI "bool \fBpingOutstanding\fP"
.br
.ti -1c
.RI "\fBMQTT_CALLBACK_SIGNATURE\fP"
.br
.ti -1c
.RI "IPAddress \fBip\fP"
.br
.ti -1c
.RI "const char * \fBdomain\fP"
.br
.ti -1c
.RI "uint16_t \fBport\fP"
.br
.ti -1c
.RI "Stream * \fBstream\fP"
.br
.ti -1c
.RI "int \fB_state\fP"
.br
.ti -1c
.RI "uint16_t \fBkeepAlive\fP"
.br
.ti -1c
.RI "uint16_t \fBsocketTimeout\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 88 of file CoolPubSubClient\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "CoolPubSubClient::CoolPubSubClient ()"

.PP
Definition at line 14 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
14                                    {
15     this->_state = MQTT_DISCONNECTED;
16     this->_client = NULL;
17     this->stream = NULL;
18     setCallback(NULL);
19     this->buffer_size = MQTT_MAX_PACKET_SIZE;
20     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
21 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (Client & client)"

.PP
Definition at line 23 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
23                                                  {
24     this->_state = MQTT_DISCONNECTED;
25     setClient(client);
26     this->stream = NULL;
27     this->buffer_size = MQTT_MAX_PACKET_SIZE;
28     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
29 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (IPAddress addr, uint16_t port, Client & client)"

.PP
Definition at line 31 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
31                                                                                 {
32     this->_state = MQTT_DISCONNECTED;
33     setServer(addr, port);
34     setClient(client);
35     this->stream = NULL;
36     this->buffer_size = MQTT_MAX_PACKET_SIZE;
37     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
38 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (IPAddress addr, uint16_t port, Client & client, Stream & stream)"

.PP
Definition at line 39 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
39                                                                                                 {
40     this->_state = MQTT_DISCONNECTED;
41     setServer(addr,port);
42     setClient(client);
43     setStream(stream);
44     this->buffer_size = MQTT_MAX_PACKET_SIZE;
45     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
46 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (IPAddress addr, uint16_t port, \fBMQTT_CALLBACK_SIGNATURE\fP, Client & client)"

.PP
Definition at line 47 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
47                                                                                                          {
48     this->_state = MQTT_DISCONNECTED;
49     setServer(addr, port);
50     setCallback(callback);
51     setClient(client);
52     this->stream = NULL;
53     this->buffer_size = MQTT_MAX_PACKET_SIZE;
54     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
55 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (IPAddress addr, uint16_t port, \fBMQTT_CALLBACK_SIGNATURE\fP, Client & client, Stream & stream)"

.PP
Definition at line 56 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
56                                                                                                                          {
57     this->_state = MQTT_DISCONNECTED;
58     setServer(addr,port);
59     setCallback(callback);
60     setClient(client);
61     setStream(stream);
62     this->buffer_size = MQTT_MAX_PACKET_SIZE;
63     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
64 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (uint8_t * ip, uint16_t port, Client & client)"

.PP
Definition at line 66 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
66                                                                              {
67     this->_state = MQTT_DISCONNECTED;
68     setServer(ip, port);
69     setClient(client);
70     this->stream = NULL;
71     this->buffer_size = MQTT_MAX_PACKET_SIZE;
72     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
73 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (uint8_t * ip, uint16_t port, Client & client, Stream & stream)"

.PP
Definition at line 74 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
74                                                                                              {
75     this->_state = MQTT_DISCONNECTED;
76     setServer(ip,port);
77     setClient(client);
78     setStream(stream);
79     this->buffer_size = MQTT_MAX_PACKET_SIZE;
80     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
81 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (uint8_t * ip, uint16_t port, \fBMQTT_CALLBACK_SIGNATURE\fP, Client & client)"

.PP
Definition at line 82 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
82                                                                                                       {
83     this->_state = MQTT_DISCONNECTED;
84     setServer(ip, port);
85     setCallback(callback);
86     setClient(client);
87     this->stream = NULL;
88     this->buffer_size = MQTT_MAX_PACKET_SIZE;
89     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
90 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (uint8_t * ip, uint16_t port, \fBMQTT_CALLBACK_SIGNATURE\fP, Client & client, Stream & stream)"

.PP
Definition at line 91 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
91                                                                                                                       {
92     this->_state = MQTT_DISCONNECTED;
93     setServer(ip,port);
94     setCallback(callback);
95     setClient(client);
96     setStream(stream);
97     this->buffer_size = MQTT_MAX_PACKET_SIZE;
98     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
99 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (const char * domain, uint16_t port, Client & client)"

.PP
Definition at line 101 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
101                                                                                     {
102     this->_state = MQTT_DISCONNECTED;
103     setServer(domain,port);
104     setClient(client);
105     this->stream = NULL;
106     this->buffer_size = MQTT_MAX_PACKET_SIZE;
107     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
108 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (const char * domain, uint16_t port, Client & client, Stream & stream)"

.PP
Definition at line 109 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
109                                                                                                     {
110     this->_state = MQTT_DISCONNECTED;
111     setServer(domain,port);
112     setClient(client);
113     setStream(stream);
114     this->buffer_size = MQTT_MAX_PACKET_SIZE;
115     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
116 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (const char * domain, uint16_t port, \fBMQTT_CALLBACK_SIGNATURE\fP, Client & client)"

.PP
Definition at line 117 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
117                                                                                                              {
118     this->_state = MQTT_DISCONNECTED;
119     setServer(domain,port);
120     setCallback(callback);
121     setClient(client);
122     this->stream = NULL;
123     this->buffer_size = MQTT_MAX_PACKET_SIZE;
124     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
125 }
.fi
.SS "CoolPubSubClient::CoolPubSubClient (const char * domain, uint16_t port, \fBMQTT_CALLBACK_SIGNATURE\fP, Client & client, Stream & stream)"

.PP
Definition at line 126 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
126                                                                                                                              {
127     this->_state = MQTT_DISCONNECTED;
128     setServer(domain,port);
129     setCallback(callback);
130     setClient(client);
131     setStream(stream);
132     this->buffer_size = MQTT_MAX_PACKET_SIZE;
133     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);
134 }
.fi
.SS "CoolPubSubClient::~CoolPubSubClient ()"

.PP
Definition at line 136 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
136                                     {
137   free(this->buffer);
138 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "boolean CoolPubSubClient::connect (const char * id, uint16_t keepAlive = \fC\fBMQTT_KEEPALIVE\fP\fP, uint16_t socketTimeout = \fC\fBMQTT_SOCKET_TIMEOUT\fP\fP)"

.PP
Definition at line 140 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
140                                                                                             {
141     return connect(id,NULL,NULL,0,0,0,0,keepAlive,socketTimeout);
142  }
.fi
.SS "boolean CoolPubSubClient::connect (const char * id, const char * user, const char * pass, uint16_t keepAlive = \fC\fBMQTT_KEEPALIVE\fP\fP, uint16_t socketTimeout = \fC\fBMQTT_SOCKET_TIMEOUT\fP\fP)"

.PP
Definition at line 144 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
144                                                                                                                                 {
145     return connect(id,user,pass,0,0,0,0,keepAlive,socketTimeout);
146  }
.fi
.SS "boolean CoolPubSubClient::connect (const char * id, const char * willTopic, uint8_t willQos, boolean willRetain, const char * willMessage, uint16_t keepAlive = \fC\fBMQTT_KEEPALIVE\fP\fP, uint16_t socketTimeout = \fC\fBMQTT_SOCKET_TIMEOUT\fP\fP)"

.PP
Definition at line 148 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
148                                                                                                                                                                                  {
149     return connect(id,NULL,NULL,willTopic,willQos,willRetain,willMessage,keepAlive,socketTimeout);
150  }
.fi
.SS "boolean CoolPubSubClient::connect (const char * id, const char * user, const char * pass, const char * willTopic, uint8_t willQos, boolean willRetain, const char * willMessage, uint16_t keepAlive = \fC\fBMQTT_KEEPALIVE\fP\fP, uint16_t socketTimeout = \fC\fBMQTT_SOCKET_TIMEOUT\fP\fP)"

.PP
Definition at line 152 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
152                                                                                                                                                                                                                      {  
153     if (!connected()) {
154         int result = 0;
155 
156         if (domain != NULL) {
157             result = _client->connect(this->domain, this->port);
158         } else {
159             result = _client->connect(this->ip, this->port);
160         }
161         if (result == 1) {
162             nextMsgId = 1;
163             // Leave room in the buffer for header and variable length field
164             uint16_t length = 5;
165             unsigned int j;
166 
167 #if MQTT_VERSION == MQTT_VERSION_3_1
168             uint8_t d[9] = {0x00,0x06,'M','Q','I','s','d','p', MQTT_VERSION};
169 #define MQTT_HEADER_VERSION_LENGTH 9
170 #elif MQTT_VERSION == MQTT_VERSION_3_1_1
171             uint8_t d[7] = {0x00,0x04,'M','Q','T','T',MQTT_VERSION};
172 #define MQTT_HEADER_VERSION_LENGTH 7
173 #endif
174             for (j = 0;j<MQTT_HEADER_VERSION_LENGTH;j++) {
175                 buffer[length++] = d[j];
176             }
177 
178             uint8_t v;
179             if (willTopic) {
180                 v = 0x06|(willQos<<3)|(willRetain<<5);
181             } else {
182                 v = 0x02;
183             }
184 
185             if(user != NULL) {
186                 v = v|0x80;
187 
188                 if(pass != NULL) {
189                     v = v|(0x80>>1);
190                 }
191             }
192 
193             buffer[length++] = v;
194 
195             if (keepAlive > 0) {
196                 this->keepAlive = keepAlive;
197             } else {
198                 this->keepAlive = MQTT_KEEPALIVE;
199             }
200 
201             buffer[length++] = ((this->keepAlive) >> 8);
202             buffer[length++] = ((this->keepAlive) & 0xFF);
203 
204             length = writeString(id,buffer,length);
205             if (willTopic) {
206                 length = writeString(willTopic,buffer,length);
207                 length = writeString(willMessage,buffer,length);
208             }
209 
210             if(user != NULL) {
211                 length = writeString(user,buffer,length);
212                 if(pass != NULL) {
213                     length = writeString(pass,buffer,length);
214                 }
215             }
216 
217             write(MQTTCONNECT,buffer,length-5);
218 
219             lastInActivity = lastOutActivity = millis();
220         
221         if (socketTimeout > 0) {
222                 this->socketTimeout = socketTimeout;
223             } else {
224                 this->socketTimeout = MQTT_SOCKET_TIMEOUT;
225             }
226 
227 
228             while (!_client->available()) {
229                 unsigned long t = millis();
230                 if (t-lastInActivity >= ((int32_t) this->socketTimeout*1000UL)) {
231                     _state = MQTT_CONNECTION_TIMEOUT;
232                     _client->stop();
233                     return false;
234                 }
235             }
236             uint8_t llen;
237             uint16_t len = readPacket(&llen);
238 
239             if (len == 4) {
240                 if (buffer[3] == 0) {
241                     lastInActivity = millis();
242                     pingOutstanding = false;
243                     _state = MQTT_CONNECTED;
244                     return true;
245                 } else {
246                     _state = buffer[3];
247                 }
248             }
249             _client->stop();
250         } else {
251             _state = MQTT_CONNECT_FAILED;
252         }
253         return false;
254     }
255     return true;
256 }
.fi
.SS "boolean CoolPubSubClient::connected ()"

.PP
Definition at line 588 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
588                                     {
589     boolean rc;
590     if (_client == NULL ) {
591         rc = false;
592     } else {
593         rc = (int)_client->connected();
594         if (!rc) {
595             if (this->_state == MQTT_CONNECTED) {
596                 this->_state = MQTT_CONNECTION_LOST;
597                 _client->flush();
598                 _client->stop();
599             }
600         }
601     }
602     return rc;
603 }
.fi
.SS "void CoolPubSubClient::disconnect ()"

.PP
Definition at line 565 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
565                                   {
566     buffer[0] = MQTTDISCONNECT;
567     buffer[1] = 0;
568     _client->write(buffer,2);
569     _state = MQTT_DISCONNECTED;
570     _client->stop();
571     lastInActivity = lastOutActivity = millis();
572 }
.fi
.SS "uint16_t CoolPubSubClient::getBufferSize ()"

.PP
Definition at line 648 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
648                                          {
649   return this->buffer_size;
650 }
.fi
.SS "boolean CoolPubSubClient::loop ()"

.PP
Definition at line 334 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
334                                {
335     if (connected()) {
336         unsigned long t = millis();
337         if ((t - lastInActivity > this->keepAlive*1000UL) || (t - lastOutActivity > this->keepAlive*1000UL)) { 
338             if (pingOutstanding) {
339                 this->_state = MQTT_CONNECTION_TIMEOUT;
340                 _client->stop();
341                 return false;
342             } else {
343                 buffer[0] = MQTTPINGREQ;
344                 buffer[1] = 0;
345                 _client->write(buffer,2);
346                 lastOutActivity = t;
347                 lastInActivity = t;
348                 pingOutstanding = true;
349             }
350         }
351         if (_client->available()) {
352             uint8_t llen;
353             uint16_t len = readPacket(&llen);
354             uint16_t msgId = 0;
355             uint8_t *payload;
356             if (len > 0) {
357                 lastInActivity = t;
358                 uint8_t type = buffer[0]&0xF0;
359                 if (type == MQTTPUBLISH) {
360                     if (callback) {
361                         uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; /* topic length in bytes */
362                         memmove(buffer+llen+2,buffer+llen+3,tl); /* move topic inside buffer 1 byte to front */
363                         buffer[llen+2+tl] = 0; /* end the topic as a 'C' string with \x00 */
364                         char *topic = (char*) buffer+llen+2;
365                         // msgId only present for QOS>0
366                         if ((buffer[0]&0x06) == MQTTQOS1) {
367                             msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];
368                             payload = buffer+llen+3+tl+2;
369                             callback(topic,payload,len-llen-3-tl-2);
370 
371                             buffer[0] = MQTTPUBACK;
372                             buffer[1] = 2;
373                             buffer[2] = (msgId >> 8);
374                             buffer[3] = (msgId & 0xFF);
375                             _client->write(buffer,4);
376                             lastOutActivity = t;
377 
378                         } else {
379                             payload = buffer+llen+3+tl;
380                             callback(topic,payload,len-llen-3-tl);
381                         }
382                     }
383                 } else if (type == MQTTPINGREQ) {
384                     buffer[0] = MQTTPINGRESP;
385                     buffer[1] = 0;
386                     _client->write(buffer,2);
387                 } else if (type == MQTTPINGRESP) {
388                     pingOutstanding = false;
389                 }
390             }
391         }
392         return true;
393     }
394     return false;
395 }
.fi
.SS "boolean CoolPubSubClient::publish (const char * topic, const char * payload)"

.PP
Definition at line 397 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
397                                                                         {
398     return publish(topic,(const uint8_t*)payload,strlen(payload),false);
399 }
.fi
.SS "boolean CoolPubSubClient::publish (const char * topic, const char * payload, boolean retained)"

.PP
Definition at line 401 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
401                                                                                           {
402     return publish(topic,(const uint8_t*)payload,strlen(payload),retained);
403 }
.fi
.SS "boolean CoolPubSubClient::publish (const char * topic, const uint8_t * payload, unsigned int plength)"

.PP
Definition at line 405 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
405                                                                                                  {
406     return publish(topic, payload, plength, false);
407 }
.fi
.SS "boolean CoolPubSubClient::publish (const char * topic, const uint8_t * payload, unsigned int plength, boolean retained)"

.PP
Definition at line 409 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
409                                                                                                                    {
410     if (connected()) {
411         if (this->buffer_size < 5 + 2+strlen(topic) + plength) {
412             // Too long
413             return false;
414         }
415         // Leave room in the buffer for header and variable length field
416         uint16_t length = 5;
417         length = writeString(topic,buffer,length);
418         uint16_t i;
419         for (i=0;i<plength;i++) {
420             buffer[length++] = payload[i];
421         }
422         uint8_t header = MQTTPUBLISH;
423         if (retained) {
424             header |= 1;
425         }
426         return write(header,buffer,length-5);
427     }
428     return false;
429 }
.fi
.SS "boolean CoolPubSubClient::publish_P (const char * topic, const uint8_t * payload, unsigned int plength, boolean retained)"

.PP
Definition at line 431 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
431                                                                                                                      {
432     uint8_t llen = 0;
433     uint8_t digit;
434     unsigned int rc = 0;
435     uint16_t tlen;
436     unsigned int pos = 0;
437     unsigned int i;
438     uint8_t header;
439     unsigned int len;
440 
441     if (!connected()) {
442         return false;
443     }
444 
445     tlen = strlen(topic);
446 
447     header = MQTTPUBLISH;
448     if (retained) {
449         header |= 1;
450     }
451     buffer[pos++] = header;
452     len = plength + 2 + tlen;
453     do {
454         digit = len % 128;
455         len = len / 128;
456         if (len > 0) {
457             digit |= 0x80;
458         }
459         buffer[pos++] = digit;
460         llen++;
461     } while(len>0);
462 
463     pos = writeString(topic,buffer,pos);
464 
465     rc += _client->write(buffer,pos);
466 
467     for (i=0;i<plength;i++) {
468         rc += _client->write((char)pgm_read_byte_near(payload + i));
469     }
470 
471     lastOutActivity = millis();
472 
473     return rc == tlen + 4 + plength;
474 }
.fi
.SS "boolean CoolPubSubClient::readByte (uint8_t * result)\fC [private]\fP"

.PP
Definition at line 259 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
259                                                    {
260    uint32_t previousMillis = millis();
261    while(!_client->available()) 
262    {
263      uint32_t currentMillis = millis();
264      if(currentMillis - previousMillis >= ((int32_t) this->socketTimeout * 1000))
265      { 
266        return false;
267      }
268    }
269    *result = _client->read();
270    return true;
271 }
.fi
.SS "boolean CoolPubSubClient::readByte (uint8_t * result, uint16_t * index)\fC [private]\fP"

.PP
Definition at line 274 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
274                                                                     {
275   uint16_t current_index = *index;
276   uint8_t * write_address = &(result[current_index]);
277   if(readByte(write_address)){
278     *index = current_index + 1;
279     return true;
280   }
281   return false;
282 }
.fi
.SS "uint16_t CoolPubSubClient::readPacket (uint8_t * lengthLength)\fC [private]\fP"

.PP
Definition at line 284 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
284                                                            {
285     uint16_t len = 0;
286     if(!readByte(buffer, &len)) return 0;
287     bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;
288     uint32_t multiplier = 1;
289     uint16_t length = 0;
290     uint8_t digit = 0;
291     uint16_t skip = 0;
292     uint8_t start = 0;
293 
294     do {
295         if(!readByte(&digit)) return 0;
296         buffer[len++] = digit;
297         length += (digit & 127) * multiplier;
298         multiplier *= 128;
299     } while ((digit & 128) != 0);
300     *lengthLength = len-1;
301 
302     if (isPublish) {
303         // Read in topic length to calculate bytes to skip over for Stream writing
304         if(!readByte(buffer, &len)) return 0;
305         if(!readByte(buffer, &len)) return 0;
306         skip = (buffer[*lengthLength+1]<<8)+buffer[*lengthLength+2];
307         start = 2;
308         if (buffer[0]&MQTTQOS1) {
309             // skip message id
310             skip += 2;
311         }
312     }
313 
314     for (uint16_t i = start;i<length;i++) {
315         if(!readByte(&digit)) return 0;
316         if (this->stream) {
317             if (isPublish && len-*lengthLength-2>skip) {
318                 this->stream->write(digit);
319             }
320         }
321         if (len < this->buffer_size) {
322             buffer[len] = digit;
323         }
324         len++;
325     }
326 
327     if (!this->stream && len > this->buffer_size) {
328         len = 0; // This will cause the packet to be ignored\&.
329     }
330 
331     return len;
332 }
.fi
.SS "boolean CoolPubSubClient::setBufferSize (uint16_t size)"

.PP
Definition at line 642 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
642                                                      {
643   this->buffer = (uint8_t*)realloc(this->buffer, size);
644   this->buffer_size = size;
645   return (this->buffer == NULL);
646 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setCallback (\fBMQTT_CALLBACK_SIGNATURE\fP)"

.PP
Definition at line 623 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
623                                                                        {
624     this->callback = callback;
625     return *this;
626 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setClient (Client & client)"

.PP
Definition at line 628 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
628                                                            {
629     this->_client = &client;
630     return *this;
631 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setServer (IPAddress ip, uint16_t port)"

.PP
Definition at line 610 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
610                                                                          {
611     this->ip = ip;
612     this->port = port;
613     this->domain = NULL;
614     return *this;
615 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setServer (uint8_t * ip, uint16_t port)"

.PP
Definition at line 605 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
605                                                                          {
606     IPAddress addr(ip[0],ip[1],ip[2],ip[3]);
607     return setServer(addr,port);
608 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setServer (const char * domain, uint16_t port)"

.PP
Definition at line 617 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
617                                                                                 {
618     this->domain = domain;
619     this->port = port;
620     return *this;
621 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setStream (Stream & stream)"

.PP
Definition at line 633 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
633                                                            {
634     this->stream = &stream;
635     return *this;
636 }
.fi
.SS "\fBCoolPubSubClient\fP & CoolPubSubClient::setTimeout (uint16_t socketTimeout)"

.PP
Definition at line 652 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
652                                                                     {
653     this->socketTimeout = socketTimeout;
654     return *this;
655 }
.fi
.SS "int CoolPubSubClient::state ()"

.PP
Definition at line 638 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
638                             {
639     return this->_state;
640 }
.fi
.SS "boolean CoolPubSubClient::subscribe (const char * topic)"

.PP
Definition at line 518 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
518                                                      {
519     return subscribe(topic, 0);
520 }
.fi
.SS "boolean CoolPubSubClient::subscribe (const char * topic, uint8_t qos)"

.PP
Definition at line 522 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
522                                                                   {
523     if (qos < 0 || qos > 1) {
524         return false;
525     }
526     if (this->buffer_size < 9 + strlen(topic)) {
527         // Too long
528         return false;
529     }
530     if (connected()) {
531         // Leave room in the buffer for header and variable length field
532         uint16_t length = 5;
533         nextMsgId++;
534         if (nextMsgId == 0) {
535             nextMsgId = 1;
536         }
537         buffer[length++] = (nextMsgId >> 8);
538         buffer[length++] = (nextMsgId & 0xFF);
539         length = writeString((char*)topic, buffer,length);
540         buffer[length++] = qos;
541         return write(MQTTSUBSCRIBE|MQTTQOS1,buffer,length-5);
542     }
543     return false;
544 }
.fi
.SS "boolean CoolPubSubClient::unsubscribe (const char * topic)"

.PP
Definition at line 546 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
546                                                        {
547     if (this->buffer_size < 9 + strlen(topic)) {
548         // Too long
549         return false;
550     }
551     if (connected()) {
552         uint16_t length = 5;
553         nextMsgId++;
554         if (nextMsgId == 0) {
555             nextMsgId = 1;
556         }
557         buffer[length++] = (nextMsgId >> 8);
558         buffer[length++] = (nextMsgId & 0xFF);
559         length = writeString(topic, buffer,length);
560         return write(MQTTUNSUBSCRIBE|MQTTQOS1,buffer,length-5);
561     }
562     return false;
563 }
.fi
.SS "boolean CoolPubSubClient::write (uint8_t header, uint8_t * buf, uint16_t length)\fC [private]\fP"

.PP
Definition at line 476 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
476                                                                              {
477     uint8_t lenBuf[4];
478     uint8_t llen = 0;
479     uint8_t digit;
480     uint8_t pos = 0;
481     uint16_t rc;
482     uint16_t len = length;
483     do {
484         digit = len % 128;
485         len = len / 128;
486         if (len > 0) {
487             digit |= 0x80;
488         }
489         lenBuf[pos++] = digit;
490         llen++;
491     } while(len>0);
492 
493     buf[4-llen] = header;
494     for (int i=0;i<llen;i++) {
495         buf[5-llen+i] = lenBuf[i];
496     }
497 
498 #ifdef MQTT_MAX_TRANSFER_SIZE
499     uint8_t* writeBuf = buf+(4-llen);
500     uint16_t bytesRemaining = length+1+llen;  //Match the length type
501     uint8_t bytesToWrite;
502     boolean result = true;
503     while((bytesRemaining > 0) && result) {
504         bytesToWrite = (bytesRemaining > MQTT_MAX_TRANSFER_SIZE)?MQTT_MAX_TRANSFER_SIZE:bytesRemaining;
505         rc = _client->write(writeBuf,bytesToWrite);
506         result = (rc == bytesToWrite);
507         bytesRemaining -= rc;
508         writeBuf += rc;
509     }
510     return result;
511 #else
512     rc = _client->write(buf+(4-llen),length+1+llen);
513     lastOutActivity = millis();
514     return (rc == 1+llen+length);
515 #endif
516 }
.fi
.SS "uint16_t CoolPubSubClient::writeString (const char * string, uint8_t * buf, uint16_t pos)\fC [private]\fP"

.PP
Definition at line 574 of file CoolPubSubClient\&.cpp\&.
.PP
.nf
574                                                                                      {
575     const char* idp = string;
576     uint16_t i = 0;
577     pos += 2;
578     while (*idp) {
579         buf[pos++] = *idp++;
580         i++;
581     }
582     buf[pos-i-2] = (i >> 8);
583     buf[pos-i-1] = (i & 0xFF);
584     return pos;
585 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "Client* CoolPubSubClient::_client\fC [private]\fP"

.PP
Definition at line 90 of file CoolPubSubClient\&.h\&.
.SS "int CoolPubSubClient::_state\fC [private]\fP"

.PP
Definition at line 107 of file CoolPubSubClient\&.h\&.
.SS "uint8_t* CoolPubSubClient::buffer\fC [private]\fP"

.PP
Definition at line 91 of file CoolPubSubClient\&.h\&.
.SS "uint16_t CoolPubSubClient::buffer_size\fC [private]\fP"

.PP
Definition at line 92 of file CoolPubSubClient\&.h\&.
.SS "const char* CoolPubSubClient::domain\fC [private]\fP"

.PP
Definition at line 104 of file CoolPubSubClient\&.h\&.
.SS "IPAddress CoolPubSubClient::ip\fC [private]\fP"

.PP
Definition at line 103 of file CoolPubSubClient\&.h\&.
.SS "uint16_t CoolPubSubClient::keepAlive\fC [private]\fP"

.PP
Definition at line 108 of file CoolPubSubClient\&.h\&.
.SS "unsigned long CoolPubSubClient::lastInActivity\fC [private]\fP"

.PP
Definition at line 95 of file CoolPubSubClient\&.h\&.
.SS "unsigned long CoolPubSubClient::lastOutActivity\fC [private]\fP"

.PP
Definition at line 94 of file CoolPubSubClient\&.h\&.
.SS "CoolPubSubClient::MQTT_CALLBACK_SIGNATURE\fC [private]\fP"

.PP
Definition at line 97 of file CoolPubSubClient\&.h\&.
.SS "uint16_t CoolPubSubClient::nextMsgId\fC [private]\fP"

.PP
Definition at line 93 of file CoolPubSubClient\&.h\&.
.SS "bool CoolPubSubClient::pingOutstanding\fC [private]\fP"

.PP
Definition at line 96 of file CoolPubSubClient\&.h\&.
.SS "uint16_t CoolPubSubClient::port\fC [private]\fP"

.PP
Definition at line 105 of file CoolPubSubClient\&.h\&.
.SS "uint16_t CoolPubSubClient::socketTimeout\fC [private]\fP"

.PP
Definition at line 109 of file CoolPubSubClient\&.h\&.
.SS "Stream* CoolPubSubClient::stream\fC [private]\fP"

.PP
Definition at line 106 of file CoolPubSubClient\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
