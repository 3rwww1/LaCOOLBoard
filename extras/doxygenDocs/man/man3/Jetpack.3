.TH "Jetpack" 3 "Thu Aug 24 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data)"
.br
.ti -1c
.RI "void \fBnormalAction\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBinvertedAction\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBtemporalActionOff\fP (int actorNumber)"
.br
.ti -1c
.RI "void \fBtemporalActionOn\fP (int actorNumber)"
.br
.ti -1c
.RI "void \fBmixedTemporalActionOff\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBmixedTemporalActionOn\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBhourAction\fP (int actorNumber, int hour)"
.br
.ti -1c
.RI "void \fBmixedHourAction\fP (int actorNumber, int hour, float measurment)"
.br
.ti -1c
.RI "void \fBminuteAction\fP (int actorNumber, int minute)"
.br
.ti -1c
.RI "void \fBmixedMinuteAction\fP (int actorNumber, int minute, float measurment)"
.br
.ti -1c
.RI "void \fBhourMinuteAction\fP (int actorNumber, int hour, int minute)"
.br
.ti -1c
.RI "void \fBmixedHourMinuteAction\fP (int actorNumber, int hour, int minute, float measurment)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 42 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 47 of file Jetpack\&.cpp\&.
.PP
.nf
48 {
49 
50 #if DEBUG == 1 
51  
52     Serial\&.println( F("Entering Jetpack\&.begin() ") );
53     Serial\&.println();
54 
55 #endif
56 
57     pinMode(EnI2C,OUTPUT);
58     pinMode(dataPin,OUTPUT);
59     pinMode(clockPin,OUTPUT);
60     
61     
62 
63 }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 304 of file Jetpack\&.cpp\&.
.PP
.nf
305 {
306 
307 #if DEBUG == 1 
308 
309     Serial\&.println( F("Entering Jetpack\&.config() ") );
310     Serial\&.println();
311 
312 #endif
313 
314     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
315 
316     if (!jetPackConfig) 
317     {
318 
319     #if DEBUG == 1 
320 
321         Serial\&.println( F("failed to read /jetPackConfig\&.json ") );
322         Serial\&.println();
323 
324     #endif
325 
326         return(false);
327     }
328     else
329     {
330         size_t size = jetPackConfig\&.size();
331         // Allocate a buffer to store contents of the file\&.
332         std::unique_ptr<char[]> buf(new char[size]);
333 
334         jetPackConfig\&.readBytes(buf\&.get(), size);
335         DynamicJsonBuffer jsonBuffer;
336         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
337         if (!json\&.success()) 
338         {
339         
340         #if DEBUG == 1 
341 
342             Serial\&.println( F("failed to parse jetpack config json from file ") );
343             Serial\&.println();
344 
345         #endif
346 
347             return(false);
348         } 
349         else
350         { 
351         
352         #if DEBUG == 1 
353 
354             Serial\&.println( F("read configuration file : ") );
355             json\&.printTo(Serial);
356             Serial\&.println();
357 
358             Serial\&.print(F("jsonBuffer size: "));
359             Serial\&.println(jsonBuffer\&.size());
360             Serial\&.println();
361 
362         
363         #endif
364   
365             for(int i=0;i<8;i++)
366             {   
367                 if(json[String("Act")+String(i)]\&.success())
368                 {
369                     //parsing actif key
370                     if(json[String("Act")+String(i)]["actif"]\&.success() )
371                     {
372                         this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
373                     }
374                     else
375                     {
376                         this->actors[i]\&.actif=this->actors[i]\&.actif;
377                     }
378                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
379                     
380                     //parsing temporal key
381                     if(json[String("Act")+String(i)]["temporal"]\&.success() )
382                     {
383                         this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];
384                     }
385                     else
386                     {
387                         this->actors[i]\&.temporal=this->actors[i]\&.temporal;
388                     }
389                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
390                     
391                     //parsing inverted key
392                     if(json[String("Act")+String(i)]["inverted"]\&.success() )
393                     {
394                         this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"];
395                     }
396                     else
397                     {
398                         this->actors[i]\&.inverted=this->actors[i]\&.inverted;
399                     }
400                     json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
401 
402                     //parsing inverted key
403                     if(json[String("Act")+String(i)]["inverted"]\&.success() )
404                     {
405                         this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"];
406                     }
407                     else
408                     {
409                         this->actors[i]\&.inverted=this->actors[i]\&.inverted;
410                     }
411                     json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
412                     
413                     //parsing low key
414                     if(json[String("Act")+String(i)]["low"]\&.success() )
415                     {
416                         this->actors[i]\&.rangeLow=json[String("Act")+String(i)]["low"][0];
417                         this->actors[i]\&.timeLow=json[String("Act")+String(i)]["low"][1];
418                         this->actors[i]\&.hourLow=json[String("Act")+String(i)]["low"][2];                     
419                         this->actors[i]\&.minuteLow=json[String("Act")+String(i)]["low"][3];                       
420                     }
421                     else
422                     {
423                         this->actors[i]\&.rangeLow=this->actors[i]\&.rangeLow;
424                         this->actors[i]\&.timeLow=this->actors[i]\&.timeLow;
425                         this->actors[i]\&.hourLow=this->actors[i]\&.hourLow;
426                         this->actors[i]\&.minuteLow=this->actors[i]\&.minuteLow;                      
427                     }
428                     json[String("Act")+String(i)]["low"][0]=this->actors[i]\&.rangeLow;
429                     json[String("Act")+String(i)]["low"][1]=this->actors[i]\&.timeLow;
430                     json[String("Act")+String(i)]["low"][2]=this->actors[i]\&.hourLow;
431                     json[String("Act")+String(i)]["low"][3]=this->actors[i]\&.minuteLow;
432 
433                     //parsing high key
434                     if(json[String("Act")+String(i)]["high"]\&.success() )
435                     {
436                         this->actors[i]\&.rangeHigh=json[String("Act")+String(i)]["high"][0];
437                         this->actors[i]\&.timeHigh=json[String("Act")+String(i)]["high"][1];
438                         this->actors[i]\&.hourHigh=json[String("Act")+String(i)]["high"][2];                       
439                         this->actors[i]\&.minuteHigh=json[String("Act")+String(i)]["high"][3];                     
440                     }
441                     else
442                     {
443                         this->actors[i]\&.rangeHigh=this->actors[i]\&.rangeHigh;
444                         this->actors[i]\&.timeHigh=this->actors[i]\&.timeHigh;
445                         this->actors[i]\&.hourHigh=this->actors[i]\&.hourHigh;
446                         this->actors[i]\&.minuteHigh=this->actors[i]\&.minuteHigh;
447                     }
448                     json[String("Act")+String(i)]["high"][0]=this->actors[i]\&.rangeHigh;
449                     json[String("Act")+String(i)]["high"][1]=this->actors[i]\&.timeHigh;
450                     json[String("Act")+String(i)]["high"][2]=this->actors[i]\&.hourHigh;
451                     json[String("Act")+String(i)]["high"][3]=this->actors[i]\&.minuteHigh;
452 
453                     //parsing type key
454                     if(json[String("Act")+String(i)]["type"]\&.success() )
455                     {
456                         this->actors[i]\&.primaryType=json[String("Act")+String(i)]["type"][0]\&.as<String>();
457                         this->actors[i]\&.secondaryType=json[String("Act")+String(i)]["type"][1]\&.as<String>();                      
458                         
459                     }
460                     else
461                     {
462                         this->actors[i]\&.primaryType=this->actors[i]\&.primaryType;
463                         this->actors[i]\&.secondaryType=this->actors[i]\&.secondaryType;
464                     }
465                     json[String("Act")+String(i)]["type"][0]=this->actors[i]\&.primaryType;
466                     json[String("Act")+String(i)]["type"][1]=this->actors[i]\&.secondaryType;
467                         
468 
469 
470                     
471                     
472                      
473                 }
474                 else
475                 {
476                     this->actors[i]=this->actors[i];
477                 }
478                 
479                 json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
480                 json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
481                 json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
482 
483                 json[String("Act")+String(i)]["low"][0]=this->actors[i]\&.rangeLow;
484                 json[String("Act")+String(i)]["low"][1]=this->actors[i]\&.timeLow;
485                 json[String("Act")+String(i)]["low"][2]=this->actors[i]\&.hourLow;
486                 json[String("Act")+String(i)]["low"][3]=this->actors[i]\&.minuteLow;
487 
488                 json[String("Act")+String(i)]["high"][0]=this->actors[i]\&.rangeHigh;
489                 json[String("Act")+String(i)]["high"][1]=this->actors[i]\&.timeHigh;
490                 json[String("Act")+String(i)]["high"][2]=this->actors[i]\&.hourHigh;
491                 json[String("Act")+String(i)]["high"][3]=this->actors[i]\&.minuteHigh;
492 
493                 json[String("Act")+String(i)]["type"][0]=this->actors[i]\&.primaryType;
494                 json[String("Act")+String(i)]["type"][1]=this->actors[i]\&.secondaryType;
495 
496 
497 
498             }
499             
500 
501             jetPackConfig\&.close();           
502             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
503             if(!jetPackConfig)
504             {
505             
506             #if DEBUG == 1 
507 
508                 Serial\&.println( F("failed to write to /jetPackConfig\&.json ") );
509                 Serial\&.println();
510             
511             #endif
512                 
513                 return(false);          
514             }  
515 
516             json\&.printTo(jetPackConfig);
517             jetPackConfig\&.close();
518 
519         #if DEBUG == 1 
520             
521             Serial\&.println(F("saved configuration : "));
522             json\&.printTo(Serial );
523             Serial\&.println();        
524         
525         #endif
526 
527             return(true); 
528         }
529     }   
530     
531 
532 }
.fi
.SS "void Jetpack::doAction (const char * data)"
Jetpack::doAction(sensor data ): This method is provided to automate the \fBJetpack\fP\&.
.PP
The result action is the result of checking the different flags of an actor (actif , temporal ,inverted, primaryType and secondaryType ) and the corresponding call to the appropriate helping method 
.PP
Definition at line 141 of file Jetpack\&.cpp\&.
.PP
.nf
142 {
143 
144 #if DEBUG == 1 
145 
146     Serial\&.println( F("Entering Jetpack\&.doAction()") );
147     Serial\&.println();
148 
149     Serial\&.println( F("input data is :") );
150     Serial\&.println(data);
151     Serial\&.println();
152 
153 #endif 
154 
155     DynamicJsonBuffer jsonBuffer;
156     JsonObject& root = jsonBuffer\&.parseObject(data);
157     
158     if (!root\&.success()) 
159     {
160     
161     #if DEBUG == 1 
162 
163         Serial\&.println( F("failed to parse json object ") );
164         Serial\&.println();
165     
166     #endif 
167 
168     }
169     else
170     {
171     
172     #if DEBUG == 1 
173 
174         Serial\&.println( F("created Json object :") );
175         root\&.printTo(Serial);
176         Serial\&.println();
177 
178         Serial\&.print(F("jsonBuffer size: "));
179         Serial\&.println(jsonBuffer\&.size());
180         Serial\&.println();
181 
182     
183     #endif 
184 
185         //invert the current action state for each actor
186         //if the value is outside the limits
187         for(int i=0;i<8;i++)
188         {
189             //check if actor is actif
190             if(this->actors[i]\&.actif==1)
191             {
192                 //normal actor
193                 if(this->actors[i]\&.temporal == 0)
194                 {
195                     //not inverted actor
196                     if(this->actors[i]\&.inverted==0)
197                     {
198                         this->normalAction(i,root[this->actors[i]\&.primaryType]\&.as<float>());
199             
200                     }
201                     //inverted actor
202                     else if(this->actors[i]\&.inverted==1)
203                     {
204                         this->invertedAction(i,root[this->actors[i]\&.primaryType]\&.as<float>());            
205                     }
206                 }
207                 //temporal actor
208                 else if(this->actors[i]\&.temporal == 1 )
209                 {
210                     //hour actor
211                     if(this->actors[i]\&.secondaryType=="hour")
212                     {
213                         //mixed hour actor
214                         if(root[this->actors[i]\&.primaryType]\&.success() )
215                         {
216                             this->mixedHourAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>(),root[this->actors[i]\&.primaryType]\&.as<float>());
217                         }
218                         //normal hour actor
219                         else
220                         {
221                             this->hourAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>());
222                         }
223                     
224                     }
225                     //minute actor
226                     else if(this->actors[i]\&.secondaryType=="minute")
227                     {
228                         //mixed minute actor
229                         if(root[this->actors[i]\&.primaryType]\&.success() )
230                         {
231                             this->mixedMinuteAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>(),root[this->actors[i]\&.primaryType]\&.as<float>());
232                         }
233                         //normal minute actor
234                         else
235                         {
236                             this->minuteAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>());
237                         }
238                     }
239                     //hourMinute actor
240                     else if(this->actors[i]\&.secondaryType=="hourMinute")
241                     {
242                         //mixed hourMinute actor
243                         if(root[this->actors[i]\&.primaryType]\&.success() )
244                         {
245                             this->mixedHourMinuteAction(i,root["hour"]\&.as<int>(),root["minute"]\&.as<int>(),root[this->actors[i]\&.primaryType]\&.as<float>());
246                         }
247                         //normal hourMinute actor
248                         else
249                         {
250                             this->hourMinuteAction(i,root["hour"]\&.as<int>(),root["minute"]\&.as<int>());
251                         }
252                     }
253                     //normal temporal actor
254                     else if(this->actors[i]\&.secondaryType=="")
255                     {
256                         //mixed temporal actor
257                         if(root[this->actors[i]\&.primaryType]\&.success() )
258                         {
259                             this->mixedTemporalActionOn(i,root[this->actors[i]\&.primaryType]\&.as<float>());
260                         }
261                         //normal temporal actor
262                         else
263                         {
264                             this->temporalActionOn(i);
265                         }
266                                             
267                     }
268 
269                 }
270             }
271             //inactif actor
272             else if(this->actors[i]\&.actif == 0 )
273             {
274                 //temporal actor
275                 if(this->actors[i]\&.temporal==1)
276                 {
277                     //mixed temporal actor
278                     if(root[this->actors[i]\&.primaryType]\&.success() )
279                     {
280                         this->mixedTemporalActionOff(i,root[this->actors[i]\&.primaryType]\&.as<float>());
281                     }
282                     //normal temporal actor
283                     else
284                     {
285                         this->temporalActionOff(i);
286                     }
287                 }           
288             }
289 
290         }
291 
292         this->write(this->action);
293 
294     } 
295 }
.fi
.SS "void Jetpack::hourAction (int actorNumber, int hour)"
Jetpack::hourAction(actorNumber, current hour ): This method is provided to handle hour actors\&. it changes the action according to:
.PP
hour >= hourLow : deactivate the actor hour >= hourHigh : activate the actor 
.PP
Definition at line 1024 of file Jetpack\&.cpp\&.
.PP
.nf
1025 {
1026 
1027 #if DEBUG == 1
1028     
1029     Serial\&.print(F("hour Actor N° : "));
1030     Serial\&.println(actorNumber);
1031 
1032     Serial\&.print(F(" hour : "));
1033     Serial\&.println(hour);
1034 
1035     Serial\&.print(F("high hour : "));
1036     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1037 
1038     Serial\&.print(F("low hour : "));
1039     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1040 
1041 #endif
1042 
1043     //stop the actor    
1044     if(hour >= this->actors[actorNumber]\&.hourLow)
1045     {
1046         bitWrite( this->action , actorNumber , 0) ;
1047 
1048     #if DEBUG == 1 
1049 
1050         Serial\&.println(F("actor OFF "));
1051 
1052     #endif  
1053 
1054     }
1055     //starting the actor
1056     else if(hour >= this->actors[actorNumber]\&.hourHigh)
1057     {
1058         bitWrite( this->action , actorNumber , 1) ;
1059 
1060     #if DEBUG == 1 
1061 
1062         Serial\&.println(F("actor ON "));
1063 
1064     #endif  
1065     
1066     }
1067 
1068 }
.fi
.SS "void Jetpack::hourMinuteAction (int actorNumber, int hour, int minute)"
Jetpack::minteAction(actorNumber, current hour,current minute ): This method is provided to handle hour minute actors\&. it changes the action according to:
.PP
hour == hourLow : minute >= minuteLow : deactivate the actor
.PP
hour > hourLow : deactivate the actor
.PP
hour == hourHigh : minute >= minteHigh : activate the actor
.PP
hour > hourHigh : activate the actor 
.PP
Definition at line 1368 of file Jetpack\&.cpp\&.
.PP
.nf
1369 {
1370 
1371 #if DEBUG == 1
1372 
1373     Serial\&.print(F("hourMinute Actor N° : "));
1374     Serial\&.println(actorNumber);
1375 
1376     Serial\&.print(F(" hour : "));
1377     Serial\&.println(hour);
1378     Serial\&.print(F(" minute : "));
1379     Serial\&.println(minute);
1380 
1381     Serial\&.print(F("high hour : "));
1382     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1383 
1384     Serial\&.print(F("high minute : "));
1385     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1386 
1387     Serial\&.print(F("low hour : "));
1388     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1389 
1390     Serial\&.print(F("low minute : "));
1391     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1392 
1393 #endif
1394     //stop the actor
1395     if(hour==this->actors[actorNumber]\&.hourLow)
1396     {
1397         if(minute>= this->actors[actorNumber]\&.minuteLow)
1398         {
1399             bitWrite( this->action , actorNumber , 0) ;
1400         #if DEBUG == 1 
1401 
1402             Serial\&.println(F("actor OFF "));
1403 
1404         #endif  
1405         }
1406     }
1407     else if(hour > this->actors[actorNumber]\&.hourLow)
1408     {
1409 
1410         bitWrite( this->action , actorNumber , 0) ;
1411     #if DEBUG == 1 
1412 
1413         Serial\&.println(F("actor OFF "));
1414 
1415     #endif  
1416     
1417     }
1418     //start the actor
1419     else if(hour==this->actors[actorNumber]\&.hourHigh)
1420     {
1421         if(minute>= this->actors[actorNumber]\&.minuteHigh)
1422         {
1423             bitWrite( this->action , actorNumber , 1) ;
1424 
1425         #if DEBUG == 1 
1426 
1427             Serial\&.println(F("actor ON "));
1428 
1429         #endif  
1430         }
1431     }
1432     else if(hour > this->actors[actorNumber]\&.hourHigh)
1433     {
1434 
1435         bitWrite( this->action , actorNumber , 1) ;
1436 
1437     #if DEBUG == 1 
1438 
1439         Serial\&.println(F("actor ON "));
1440 
1441     #endif      
1442 
1443     }
1444 
1445     
1446 }
.fi
.SS "void Jetpack::invertedAction (int actorNumber, float measurment)"
Jetpack::invertedAction(actorNumber , measured value): This method is provided to handle inverted actors\&. it changes the action according to wether the measured value is: 
.PP
.RS 4
rangeHigh (activate actor) 
.RE
.PP
< rangeLow ( deactivate actor ) 
.PP
Definition at line 691 of file Jetpack\&.cpp\&.
.PP
.nf
692 {
693 #if DEBUG == 1
694     
695     Serial\&.print("inverted Actor N° : ");
696     Serial\&.println(actorNumber);
697 
698     Serial\&.print("measured value : ");
699     Serial\&.println(measurment);
700 
701     Serial\&.print("high range : ");
702     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
703 
704     Serial\&.print("low range : ");
705     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
706 
707 #endif
708 
709     //measured value lower than minimum range : deactivate actor
710     if(measurment < this->actors[actorNumber]\&.rangeLow)
711     {
712         bitWrite( this->action , actorNumber , 0) ;
713 
714     #if DEBUG == 1 
715 
716         Serial\&.println(F("actor OFF "));
717     
718     #endif
719 
720     }
721     //measured value higher than maximum range : activate actor
722     else if(measurment > this->actors[actorNumber]\&.rangeHigh)
723     {
724         bitWrite( this->action , actorNumber , 1) ;
725 
726     #if DEBUG == 1 
727 
728         Serial\&.println(F("actor ON "));
729     
730     #endif
731 
732     }
733 
734 
735 }
.fi
.SS "void Jetpack::minuteAction (int actorNumber, int minute)"
Jetpack::minteAction(actorNumber, current minute ): This method is provided to handle minute actors\&. it changes the action according to:
.PP
minute >= minuteLow : deactivate the actor minute >= minuteHigh : activate the actor 
.PP
Definition at line 1192 of file Jetpack\&.cpp\&.
.PP
.nf
1193 {
1194 
1195 #if DEBUG == 1
1196     
1197     Serial\&.print(F("minute Actor N° : "));
1198     Serial\&.println(actorNumber);
1199 
1200     Serial\&.print(F(" minute : "));
1201     Serial\&.println(minute);
1202 
1203     Serial\&.print(F("high minute : "));
1204     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1205 
1206     Serial\&.print(F("low minute : "));
1207     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1208 
1209 #endif
1210 
1211     //stop the actor    
1212     if(minute >= this->actors[actorNumber]\&.minuteLow)
1213     {
1214         bitWrite( this->action , actorNumber , 0) ;
1215 
1216     #if DEBUG == 1 
1217 
1218         Serial\&.println(F("actor OFF "));
1219 
1220     #endif  
1221 
1222     }   
1223     //starting the actor
1224     else if(minute >= this->actors[actorNumber]\&.minuteHigh)
1225     {
1226         bitWrite( this->action , actorNumber , 1) ;
1227 
1228     #if DEBUG == 1 
1229 
1230         Serial\&.println(F("actor ON "));
1231 
1232     #endif  
1233 
1234     }
1235 
1236 } 
.fi
.SS "void Jetpack::mixedHourAction (int actorNumber, int hour, float measurment)"
Jetpack::mixedHourAction(actorNumber, current hour, measured value ): This method is provided to handle mixed hour actors\&. it changes the action according to :
.PP
hour >= hourLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor
.PP
hour >= hourHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor 
.PP
Definition at line 1085 of file Jetpack\&.cpp\&.
.PP
.nf
1086 {
1087 
1088 #if DEBUG == 1
1089     
1090     Serial\&.print("mixed hour Actor N° : ");
1091     Serial\&.println(actorNumber);
1092 
1093     Serial\&.print(" hour : ");
1094     Serial\&.println(hour);
1095 
1096     Serial\&.print("high hour : ");
1097     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1098 
1099     Serial\&.print("low hour : ");
1100     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1101 
1102     Serial\&.print("measured value : ");
1103     Serial\&.println(measurment);
1104 
1105     Serial\&.print("high range : ");
1106     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1107 
1108     Serial\&.print("low range : ");
1109     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1110 
1111 #endif
1112     //stop the actor    
1113     if(hour >= this->actors[actorNumber]\&.hourLow)
1114     {
1115             if( measurment >= this->actors[actorNumber]\&.rangeHigh )
1116             {
1117                 bitWrite( this->action , actorNumber , 0) ;
1118 
1119             #if DEBUG == 1 
1120 
1121                 Serial\&.print(measurment);
1122                 Serial\&.print(F(" > " ));
1123                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1124 
1125                 Serial\&.println(F("actor OFF "));
1126 
1127             #endif  
1128 
1129             }
1130             else 
1131             {
1132                 bitWrite( this->action , actorNumber , 1) ;
1133 
1134             #if DEBUG == 1 
1135 
1136                 Serial\&.print(measurment);
1137                 Serial\&.print(F(" < " ));
1138                 Serial\&.print(this->actors[actorNumber]\&.rangeHigh);
1139 
1140                 Serial\&.println(F("actor ON "));
1141 
1142             #endif  
1143                 
1144             }
1145     }
1146     //starting the actor
1147     else if(hour >= this->actors[actorNumber]\&.hourHigh)
1148     {
1149             if( measurment < this->actors[actorNumber]\&.rangeLow )
1150             {
1151                 bitWrite( this->action , actorNumber , 1) ;
1152 
1153             #if DEBUG == 1 
1154 
1155                 Serial\&.print(measurment);
1156                 Serial\&.print(F(" < " ));
1157                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1158 
1159                 Serial\&.println(F("actor ON "));
1160 
1161             #endif  
1162             }
1163             else 
1164             {
1165                 bitWrite( this->action , actorNumber , 0) ;
1166 
1167             #if DEBUG == 1 
1168 
1169                 Serial\&.print(measurment);
1170                 Serial\&.print(F(" > " ));
1171                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1172 
1173                 Serial\&.println(F("actor OFF "));
1174 
1175             #endif                  
1176             }
1177 
1178     }
1179 
1180 }
.fi
.SS "void Jetpack::mixedHourMinuteAction (int actorNumber, int hour, int minute, float measurment)"
Jetpack::minteAction(actorNumber, current hour,current minute , measured Value ): This method is provided to handle hour minute actors\&. it changes the action according to:
.PP
hour == hourLow : minute >= minuteLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor
.PP
hour > hourLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor
.PP
hour == hourHigh : minute >= minteHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor
.PP
hour > hourHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor 
.PP
Definition at line 1473 of file Jetpack\&.cpp\&.
.PP
.nf
1474 {
1475 
1476 #if DEBUG == 1
1477     
1478     Serial\&.print("hourMinute Actor N° : ");
1479     Serial\&.println(actorNumber);
1480 
1481     Serial\&.print(" hour : ");
1482     Serial\&.println(hour);
1483     Serial\&.print(" minute : ");
1484     Serial\&.println(minute);
1485 
1486     Serial\&.print("high hour : ");
1487     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1488 
1489     Serial\&.print("high minute : ");
1490     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1491 
1492     Serial\&.print("low hour : ");
1493     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1494 
1495     Serial\&.print("low minute : ");
1496     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1497 
1498     Serial\&.print("measured value : ");
1499     Serial\&.println(measurment);
1500 
1501     Serial\&.print("high range : ");
1502     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1503 
1504     Serial\&.print("low range : ");
1505     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1506 
1507 #endif
1508     //stop the actor
1509     if(hour==this->actors[actorNumber]\&.hourLow)
1510     {
1511         if(minute>= this->actors[actorNumber]\&.minuteLow)
1512         {
1513             if( measurment >= this->actors[actorNumber]\&.rangeHigh )
1514             {
1515                 bitWrite( this->action , actorNumber , 0) ;
1516 
1517             #if DEBUG == 1 
1518 
1519                 Serial\&.print(measurment);
1520                 Serial\&.print(F(" >= " ));
1521                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1522 
1523                 Serial\&.println(F("actor OFF "));
1524 
1525             #endif  
1526 
1527             }
1528             else 
1529             {
1530                 bitWrite( this->action , actorNumber , 1) ;
1531 
1532             #if DEBUG == 1 
1533 
1534                 Serial\&.print(measurment);
1535                 Serial\&.print(F(" < " ));
1536                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1537 
1538                 Serial\&.println(F("actor ON "));
1539 
1540             #endif  
1541                 
1542             }
1543         }
1544     }
1545     else if(hour > this->actors[actorNumber]\&.hourLow)
1546     {
1547 
1548         if( measurment >= this->actors[actorNumber]\&.rangeHigh )
1549         {
1550             bitWrite( this->action , actorNumber , 0) ;
1551 
1552         #if DEBUG == 1 
1553 
1554             Serial\&.print(measurment);
1555             Serial\&.print(F(" >= " ));
1556             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1557 
1558             Serial\&.println(F("actor OFF "));
1559 
1560         #endif  
1561 
1562         }
1563         else 
1564         {
1565             bitWrite( this->action , actorNumber , 1) ;
1566 
1567         #if DEBUG == 1 
1568 
1569             Serial\&.print(measurment);
1570             Serial\&.print(F(" < " ));
1571             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1572 
1573             Serial\&.println(F("actor ON "));
1574 
1575         #endif  
1576             
1577         }
1578 
1579 
1580     }
1581     //start the actor
1582     else if(hour==this->actors[actorNumber]\&.hourHigh)
1583     {
1584         if(minute>= this->actors[actorNumber]\&.minuteHigh)
1585         {
1586             if( measurment < this->actors[actorNumber]\&.rangeLow )
1587             {
1588                 bitWrite( this->action , actorNumber , 1) ;
1589 
1590             #if DEBUG == 1 
1591 
1592                 Serial\&.print(measurment);
1593                 Serial\&.print(F(" < " ));
1594                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1595 
1596                 Serial\&.println(F("actor ON "));
1597 
1598             #endif  
1599 
1600             }
1601             else 
1602             {
1603                 bitWrite( this->action , actorNumber , 0) ;
1604 
1605             #if DEBUG == 1 
1606 
1607                 Serial\&.print(measurment);
1608                 Serial\&.println(F(" > " ));
1609                 Serial\&.print(this->actors[actorNumber]\&.rangeLow);
1610 
1611                 Serial\&.println(F("actor OFF "));
1612 
1613             #endif  
1614                 
1615             }
1616         }
1617     }
1618     else if(hour > this->actors[actorNumber]\&.hourHigh)
1619     {
1620 
1621         if( measurment < this->actors[actorNumber]\&.rangeLow )
1622         {
1623             bitWrite( this->action , actorNumber , 1) ;
1624 
1625         #if DEBUG == 1 
1626 
1627             Serial\&.print(measurment);
1628             Serial\&.print(F(" < " ));
1629             Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1630 
1631             Serial\&.println(F("actor ON "));
1632 
1633         #endif  
1634 
1635         }
1636         else 
1637         {
1638             bitWrite( this->action , actorNumber , 0) ;
1639 
1640         #if DEBUG == 1 
1641 
1642             Serial\&.print(measurment);
1643             Serial\&.println(F(" > " ));
1644             Serial\&.print(this->actors[actorNumber]\&.rangeLow);
1645 
1646             Serial\&.println(F("actor OFF "));
1647 
1648         #endif  
1649             
1650         }
1651     
1652     }
1653 
1654 }
.fi
.SS "void Jetpack::mixedMinuteAction (int actorNumber, int minute, float measurment)"
Jetpack::mixedMinuteAction(actorNumber, current minute, measured value ): This method is provided to handle mixed minute actors\&. it changes the action according to :
.PP
minute >= minuteLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor
.PP
minute >= minuteHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor 
.PP
Definition at line 1252 of file Jetpack\&.cpp\&.
.PP
.nf
1253 {
1254 
1255 #if DEBUG == 1
1256     
1257     Serial\&.print("mixed minute Actor N° : ");
1258     Serial\&.println(actorNumber);
1259 
1260     Serial\&.print(" minute : ");
1261     Serial\&.println(minute);
1262 
1263     Serial\&.print("high minute : ");
1264     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1265 
1266     Serial\&.print("low minute : ");
1267     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1268 
1269     Serial\&.print("measured value : ");
1270     Serial\&.println(measurment);
1271 
1272     Serial\&.print("high range : ");
1273     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1274 
1275     Serial\&.print("low range : ");
1276     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1277 
1278 #endif
1279     //stop the actor    
1280     if(minute >= this->actors[actorNumber]\&.minuteLow)
1281     {
1282             if( measurment > this->actors[actorNumber]\&.rangeHigh )
1283             {
1284                 bitWrite( this->action , actorNumber , 0) ;
1285 
1286             #if DEBUG == 1 
1287 
1288                 Serial\&.print(measurment);
1289                 Serial\&.print(F(" > " ));
1290                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1291 
1292                 Serial\&.println(F("actor OFF "));
1293 
1294             #endif
1295     
1296             }
1297             else 
1298             {
1299                 bitWrite( this->action , actorNumber , 1) ;
1300 
1301             #if DEBUG == 1 
1302 
1303                 Serial\&.print(measurment);
1304                 Serial\&.print(F(" < " ));
1305                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1306 
1307                 Serial\&.println(F("actor ON "));
1308 
1309             #endif  
1310                 
1311             }
1312     }   
1313     //starting the actor
1314     else if(minute >= this->actors[actorNumber]\&.minuteHigh)
1315     {
1316             if( measurment < this->actors[actorNumber]\&.rangeLow )
1317             {
1318                 bitWrite( this->action , actorNumber , 1) ;
1319 
1320             #if DEBUG == 1 
1321 
1322                 Serial\&.print(measurment);
1323                 Serial\&.print(F(" < " ));
1324                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1325 
1326                 Serial\&.println(F("actor ON "));
1327 
1328             #endif  
1329 
1330             }
1331             else 
1332             {
1333                 bitWrite( this->action , actorNumber , 0) ;
1334             
1335             #if DEBUG == 1 
1336 
1337                 Serial\&.print(measurment);
1338                 Serial\&.print(F(" > " ));
1339                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1340 
1341                 Serial\&.println(F("actor OFF "));
1342 
1343             #endif  
1344                 
1345             }
1346 
1347     }
1348 
1349 }
.fi
.SS "void Jetpack::mixedTemporalActionOff (int actorNumber, float measurment)"
Jetpack::mixedTemporalActionOff(actorNumber, measured value ): This method is provided to handle mixed temporal actors\&. it changes the action according to:
.PP
currentTime - startTime >= timeHigh : measured value >= rangeHigh : deactivate actor measured value < rangeHigh : activate actor 
.PP
Definition at line 797 of file Jetpack\&.cpp\&.
.PP
.nf
798 {
799 
800 #if DEBUG == 1
801     
802     Serial\&.print("mixed Temporal Actor N° : ");
803     Serial\&.println(actorNumber);
804 
805     Serial\&.print("measured value : ");
806     Serial\&.println(measurment);
807 
808     Serial\&.print("high range : ");
809     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
810 
811     Serial\&.print("time high : ");
812     Serial\&.println(this->actors[actorNumber]\&.timeHigh);
813 
814     Serial\&.print("actif Time : ");
815     Serial\&.println(this->actors[actorNumber]\&.actifTime);
816 
817     Serial\&.print(F("millis : "));
818     Serial\&.println(millis());
819 
820 #endif
821     if( ( millis()- this->actors[actorNumber]\&.actifTime  ) >= (  this->actors[actorNumber]\&.timeHigh  ) )
822     {   
823         if( measurment >= this->actors[actorNumber]\&.rangeHigh )
824         {
825             //stop the actor
826             bitWrite( this->action , actorNumber , 0) ;
827 
828             //make the actor inactif:
829             this->actors[actorNumber]\&.actif=0;
830 
831             //start the low timer
832             this->actors[actorNumber]\&.inactifTime=millis();
833 
834         #if DEBUG == 1 
835 
836             Serial\&.print(F("actor was on for at least "));
837             Serial\&.print(this->actors[actorNumber]\&.timeHigh);
838             Serial\&.println(F(" ms "));
839 
840             Serial\&.print(measurment);
841             Serial\&.print(F(" > " ));
842             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
843 
844             
845             Serial\&.println(F("actor OFF "));
846 
847         #endif
848 
849         }
850         else 
851         {
852             bitWrite( this->action , actorNumber , 1) ;
853 
854         #if DEBUG == 1 
855             
856             Serial\&.print(F("actor was on for at least "));
857             Serial\&.print(this->actors[actorNumber]\&.timeHigh);
858             Serial\&.println(F(" ms "));
859 
860             Serial\&.print(measurment);
861             Serial\&.print(F(" < " ));
862             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
863 
864             Serial\&.println(F("actor ON "));
865 
866         #endif              
867 
868         }           
869     }
870 
871 }
.fi
.SS "void Jetpack::mixedTemporalActionOn (int actorNumber, float measurment)"
Jetpack::mixedTemporalActionOn(actorNumber, measured value ): This method is provided to handle mixed temporal actors\&. it changes the action according to :
.PP
currentTime - stopTime > timeLow : measured value >= rangeLow : deactivate actor measured value < rangeLow : activate actor 
.PP
Definition at line 935 of file Jetpack\&.cpp\&.
.PP
.nf
936 {
937 
938 #if DEBUG == 1
939     
940     Serial\&.print("mixed Temporal Actor N° : ");
941     Serial\&.println(actorNumber);
942 
943     Serial\&.print("measured value : ");
944     Serial\&.println(measurment);
945 
946     Serial\&.print("low range : ");
947     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
948 
949     Serial\&.print("time low : ");
950     Serial\&.println(this->actors[actorNumber]\&.timeLow);
951 
952     Serial\&.print("inactif Time : ");
953     Serial\&.println(this->actors[actorNumber]\&.inactifTime);
954 
955     Serial\&.print(F("millis : "));
956     Serial\&.println(millis());
957 
958 #endif
959 
960     if( ( millis() - this->actors[actorNumber]\&.inactifTime ) >= (  this->actors[actorNumber]\&.timeLow  ) )
961     {
962         if( measurment < this->actors[actorNumber]\&.rangeLow )
963         {
964             //start the actor
965             bitWrite( this->action , actorNumber , 1) ;
966 
967             //make the actor actif:
968             this->actors[actorNumber]\&.actif=1;
969 
970             //start the low timer
971             this->actors[actorNumber]\&.actifTime=millis();
972 
973         #if DEBUG == 1 
974 
975             Serial\&.print(F("actor was off for at least "));
976             Serial\&.print(this->actors[actorNumber]\&.timeLow);
977             Serial\&.println(F(" ms "));
978 
979             Serial\&.print(measurment);
980             Serial\&.print(F(" < " ));
981             Serial\&.println(this->actors[actorNumber]\&.rangeLow);
982     
983             Serial\&.println(F("actor ON "));
984     
985         #endif  
986 
987         }
988         else 
989         {
990             bitWrite( this->action , actorNumber , 0) ; 
991 
992         #if DEBUG == 1 
993 
994             Serial\&.print(F("actor was off for at least "));
995             Serial\&.print(this->actors[actorNumber]\&.timeLow);
996             Serial\&.println(F(" ms "));
997 
998             Serial\&.print(measurment);
999             Serial\&.print(F(" > " ));
1000             Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1001 
1002             Serial\&.println(F("actor OFF "));
1003     
1004         #endif              
1005 
1006         }
1007 
1008     }
1009 
1010     
1011 }
.fi
.SS "void Jetpack::normalAction (int actorNumber, float measurment)"
Jetpack::normalAction(actorNumber , measured value): This method is provided to handle normal actors\&. it changes the action according to wether the measured value is: > rangeHigh ( deactivate actor) or < rangeLow (activate actor ) 
.PP
Definition at line 634 of file Jetpack\&.cpp\&.
.PP
.nf
635 {
636 
637 #if DEBUG == 1
638     
639     Serial\&.print(F("none inverted Actor N° : "));
640     Serial\&.println(actorNumber);
641 
642     Serial\&.print(F("measured value : "));
643     Serial\&.println(measurment);
644 
645     Serial\&.print(F("high range : "));
646     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
647 
648     Serial\&.print(F("low range : "));
649     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
650 
651 #endif
652 
653     //measured value lower than minimum range : activate actor
654     if(measurment < this->actors[actorNumber]\&.rangeLow)
655     {
656         bitWrite( this->action , actorNumber , 1) ;
657 
658     #if DEBUG == 1 
659 
660         Serial\&.println(F("actor ON "));
661     
662     #endif
663                 
664     }
665     //measured value higher than maximum range : deactivate actor
666     else if(measurment > this->actors[actorNumber]\&.rangeHigh)
667     {
668         bitWrite( this->action , actorNumber , 0) ;
669 
670     #if DEBUG == 1 
671 
672         Serial\&.println(F("actor OFF "));
673     
674     #endif
675     
676     }
677 
678 
679 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 540 of file Jetpack\&.cpp\&.
.PP
.nf
541 {
542 
543 #if DEBUG == 1 
544 
545     Serial\&.println( F("Enter Jetpack\&.printConf() ") );
546     Serial\&.println();
547 
548 #endif 
549     Serial\&.println(F( "Jetpack configuration " ) ) ;
550  
551         for(int i=0;i<8;i++)
552     {   
553         Serial\&.print(F("actor N°"));
554         Serial\&.print(i);
555         Serial\&.print(F(" actif :"));
556         Serial\&.println(this->actors[i]\&.actif);
557         
558         Serial\&.print(F("actor N°"));
559         Serial\&.print(i);
560         Serial\&.print(F(" temporal :"));
561         Serial\&.println(this->actors[i]\&.temporal);
562 
563         Serial\&.print(F("actor N°"));
564         Serial\&.print(i);
565         Serial\&.print(F(" inverted :"));
566         Serial\&.println(this->actors[i]\&.inverted);
567 
568 
569         Serial\&.print(F("actor N°"));
570         Serial\&.print(i);
571         Serial\&.print(F(" primary Type :"));
572         Serial\&.println(this->actors[i]\&.primaryType);
573 
574         Serial\&.print(F("actor N°"));
575         Serial\&.print(i);
576         Serial\&.print(F(" secondary Type :"));        
577         Serial\&.println(this->actors[i]\&.secondaryType);
578 
579         Serial\&.print(F("actor N°"));
580         Serial\&.print(i);
581         Serial\&.print(F(" range Low :"));
582         Serial\&.println(this->actors[i]\&.rangeLow);
583 
584         Serial\&.print(F("actor N°"));
585         Serial\&.print(i);
586         Serial\&.print(F(" time Low :"));
587         Serial\&.println(this->actors[i]\&.timeLow);
588 
589         Serial\&.print(F("actor N°"));
590         Serial\&.print(i);
591         Serial\&.print(F(" hour low:"));
592         Serial\&.println(this->actors[i]\&.hourLow);
593 
594         Serial\&.print(F("actor N°"));
595         Serial\&.print(i);
596         Serial\&.print(F(" minute low:"));
597         Serial\&.println(this->actors[i]\&.minuteLow);
598 
599         Serial\&.print(F("actor N°"));
600         Serial\&.print(i);
601         Serial\&.print(F(" range High:"));
602         Serial\&.println(this->actors[i]\&.rangeHigh);
603 
604         Serial\&.print(F("actor N°"));
605         Serial\&.print(i);
606         Serial\&.print(F(" time High:"));
607         Serial\&.println(this->actors[i]\&.timeHigh);
608 
609         Serial\&.print(F("actor N°"));
610         Serial\&.print(i);
611         Serial\&.print(F(" hour high:"));
612         Serial\&.println(this->actors[i]\&.hourHigh);
613 
614         Serial\&.print(F("actor N°"));
615         Serial\&.print(i);
616         Serial\&.print(F(" minute high:"));
617         Serial\&.println(this->actors[i]\&.minuteHigh);
618 
619         Serial\&.println(); 
620 
621     }
622 
623     Serial\&.println();
624 }
.fi
.SS "void Jetpack::temporalActionOff (int actorNumber)"
Jetpack::temporalActionOff(actorNumber ): This method is provided to handle temporal actors\&. it changes the action according to:
.PP
currentTime - startTime > timeHigh : deactivate actor 
.PP
Definition at line 746 of file Jetpack\&.cpp\&.
.PP
.nf
747 {
748 
749 #if DEBUG == 1
750     
751     Serial\&.print(F("temporal Actor N° : "));
752     Serial\&.println(actorNumber);
753 
754     Serial\&.print(F("millis : "));
755     Serial\&.println(millis());
756 
757     Serial\&.print(F("actif Time : "));
758     Serial\&.println(this->actors[actorNumber]\&.actifTime);
759 
760     Serial\&.print(F("high time : "));
761     Serial\&.println(this->actors[actorNumber]\&.timeHigh);
762 
763 
764 #endif
765     
766     if( ( millis()- this->actors[actorNumber]\&.actifTime  ) >= (  this->actors[actorNumber]\&.timeHigh  ) )
767     {
768         //stop the actor
769         bitWrite( this->action , actorNumber , 0) ;
770 
771         //make the actor inactif:
772         this->actors[actorNumber]\&.actif=0;
773 
774         //start the low timer
775         this->actors[actorNumber]\&.inactifTime=millis();
776 
777     #if DEBUG == 1 
778 
779         Serial\&.println(F("actor OFF "));
780     
781     #endif
782                 
783     }   
784 }
.fi
.SS "void Jetpack::temporalActionOn (int actorNumber)"
Jetpack::temporalActionOn(actorNumber ): This method is provided to handle temporal actors\&. it changes the action according to :
.PP
currentTime - stopTime > timeLow : activate actor 
.PP
Definition at line 883 of file Jetpack\&.cpp\&.
.PP
.nf
884 {
885 
886 #if DEBUG == 1
887     
888     Serial\&.print(F("temporal Actor N° : "));
889     Serial\&.println(actorNumber);
890 
891     Serial\&.print(F("millis : "));
892     Serial\&.println(millis());
893 
894     Serial\&.print(F("inactif Time : "));
895     Serial\&.println(this->actors[actorNumber]\&.inactifTime);
896 
897     Serial\&.print(F("low time : "));
898     Serial\&.println(this->actors[actorNumber]\&.timeLow);
899 
900 
901 #endif
902     
903      if( ( millis() - this->actors[actorNumber]\&.inactifTime ) >= (  this->actors[actorNumber]\&.timeLow  ) )
904     {
905         //start the actor
906         bitWrite( this->action , actorNumber , 1) ;
907 
908         //make the actor actif:
909         this->actors[actorNumber]\&.actif=1;
910 
911         //start the low timer
912         this->actors[actorNumber]\&.actifTime=millis();
913 
914     #if DEBUG == 1 
915 
916         Serial\&.println(F("actor ON "));
917 
918     #endif              
919 
920     }
921 
922 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 74 of file Jetpack\&.cpp\&.
.PP
.nf
75 {
76 
77 #if DEBUG == 1
78 
79     Serial\&.println( F("Entering Jetpack\&.write()") );
80     Serial\&.println();
81 
82     Serial\&.println( F("writing this action : ") );
83     Serial\&.println(action,BIN);
84     Serial\&.println();
85 
86 #endif 
87 
88     this->action=action;
89 
90     
91     digitalWrite(EnI2C, LOW);
92     
93     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
94 
95     digitalWrite(EnI2C, HIGH);
96 
97 
98 }
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 105 of file Jetpack\&.cpp\&.
.PP
.nf
106 {
107 
108 #if DEBUG == 1 
109 
110     Serial\&.println( F("Entering Jetpack\&.writeBit() ") );
111 
112     Serial\&.print( F("Writing ") );
113     Serial\&.print(state);
114 
115     Serial\&.print( F("to pin N°") );
116     Serial\&.print(pin);
117 
118     Serial\&.println();
119 
120 #endif
121 
122     bitWrite(this->action, pin, state);
123     digitalWrite(EnI2C, LOW);
124     
125     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
126 
127     digitalWrite(EnI2C, HIGH);
128 
129 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"

.PP
Definition at line 84 of file Jetpack\&.h\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.SS "const int Jetpack::clockPin = 4\fC [private]\fP"

.PP
Definition at line 124 of file Jetpack\&.h\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"

.PP
Definition at line 126 of file Jetpack\&.h\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"

.PP
Definition at line 128 of file Jetpack\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
