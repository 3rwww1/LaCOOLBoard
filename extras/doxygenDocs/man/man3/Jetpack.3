.TH "Jetpack" 3 "Wed Aug 30 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Jetpack \- This class manages the \fBJetpack\fP shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Jetpack\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBwrite\fP (byte \fBaction\fP)"
.br
.ti -1c
.RI "void \fBwriteBit\fP (byte pin, bool \fBstate\fP)"
.br
.ti -1c
.RI "void \fBdoAction\fP (const char *data)"
.br
.ti -1c
.RI "void \fBnormalAction\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBinvertedAction\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBtemporalActionOff\fP (int actorNumber)"
.br
.ti -1c
.RI "void \fBtemporalActionOn\fP (int actorNumber)"
.br
.ti -1c
.RI "void \fBmixedTemporalActionOff\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBmixedTemporalActionOn\fP (int actorNumber, float measurment)"
.br
.ti -1c
.RI "void \fBhourAction\fP (int actorNumber, int hour)"
.br
.ti -1c
.RI "void \fBmixedHourAction\fP (int actorNumber, int hour, float measurment)"
.br
.ti -1c
.RI "void \fBminuteAction\fP (int actorNumber, int minute)"
.br
.ti -1c
.RI "void \fBmixedMinuteAction\fP (int actorNumber, int minute, float measurment)"
.br
.ti -1c
.RI "void \fBhourMinuteAction\fP (int actorNumber, int hour, int minute)"
.br
.ti -1c
.RI "void \fBmixedHourMinuteAction\fP (int actorNumber, int hour, int minute, float measurment)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "byte \fBaction\fP = B00000000"
.br
.ti -1c
.RI "struct \fBJetpack::state\fP \fBactors\fP [8]"
.br
.ti -1c
.RI "const int \fBclockPin\fP = 4"
.br
.ti -1c
.RI "const int \fBdataPin\fP = 15"
.br
.ti -1c
.RI "const int \fBEnI2C\fP =5"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class manages the \fBJetpack\fP shield\&. 
.PP
Definition at line 44 of file Jetpack\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Jetpack::begin (void)"
\fBJetpack::begin()\fP: This method is provided to initialise the pin that control the \fBJetpack\fP shield 
.PP
Definition at line 49 of file Jetpack\&.cpp\&.
.PP
.nf
50 {
51 
52 #if DEBUG == 1 
53  
54     Serial\&.println( F("Entering Jetpack\&.begin() ") );
55     Serial\&.println();
56 
57 #endif
58 
59     pinMode(EnI2C,OUTPUT);
60     pinMode(dataPin,OUTPUT);
61     pinMode(clockPin,OUTPUT);
62     
63     
64 
65 }
.fi
.SS "bool Jetpack::config ()"
\fBJetpack::config()\fP: This method is provided to configure the \fBJetpack\fP with a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 306 of file Jetpack\&.cpp\&.
.PP
.nf
307 {
308 
309 #if DEBUG == 1 
310 
311     Serial\&.println( F("Entering Jetpack\&.config() ") );
312     Serial\&.println();
313 
314 #endif
315 
316     File jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "r");
317 
318     if (!jetPackConfig) 
319     {
320 
321     #if DEBUG == 1 
322 
323         Serial\&.println( F("failed to read /jetPackConfig\&.json ") );
324         Serial\&.println();
325 
326     #endif
327 
328         return(false);
329     }
330     else
331     {
332         size_t size = jetPackConfig\&.size();
333         // Allocate a buffer to store contents of the file\&.
334         std::unique_ptr<char[]> buf(new char[size]);
335 
336         jetPackConfig\&.readBytes(buf\&.get(), size);
337         DynamicJsonBuffer jsonBuffer;
338         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
339         if (!json\&.success()) 
340         {
341         
342         #if DEBUG == 1 
343 
344             Serial\&.println( F("failed to parse jetpack config json from file ") );
345             Serial\&.println();
346 
347         #endif
348 
349             return(false);
350         } 
351         else
352         { 
353         
354         #if DEBUG == 1 
355 
356             Serial\&.println( F("read configuration file : ") );
357             json\&.printTo(Serial);
358             Serial\&.println();
359 
360             Serial\&.print(F("jsonBuffer size: "));
361             Serial\&.println(jsonBuffer\&.size());
362             Serial\&.println();
363 
364         
365         #endif
366   
367             for(int i=0;i<8;i++)
368             {   
369                 if(json[String("Act")+String(i)]\&.success())
370                 {
371                     //parsing actif key
372                     if(json[String("Act")+String(i)]["actif"]\&.success() )
373                     {
374                         this->actors[i]\&.actif=json[String("Act")+String(i)]["actif"];
375                     }
376                     else
377                     {
378                         this->actors[i]\&.actif=this->actors[i]\&.actif;
379                     }
380                     json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
381                     
382                     //parsing temporal key
383                     if(json[String("Act")+String(i)]["temporal"]\&.success() )
384                     {
385                         this->actors[i]\&.temporal=json[String("Act")+String(i)]["temporal"];
386                     }
387                     else
388                     {
389                         this->actors[i]\&.temporal=this->actors[i]\&.temporal;
390                     }
391                     json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
392                     
393                     //parsing inverted key
394                     if(json[String("Act")+String(i)]["inverted"]\&.success() )
395                     {
396                         this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"];
397                     }
398                     else
399                     {
400                         this->actors[i]\&.inverted=this->actors[i]\&.inverted;
401                     }
402                     json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
403 
404                     //parsing inverted key
405                     if(json[String("Act")+String(i)]["inverted"]\&.success() )
406                     {
407                         this->actors[i]\&.inverted=json[String("Act")+String(i)]["inverted"];
408                     }
409                     else
410                     {
411                         this->actors[i]\&.inverted=this->actors[i]\&.inverted;
412                     }
413                     json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
414                     
415                     //parsing low key
416                     if(json[String("Act")+String(i)]["low"]\&.success() )
417                     {
418                         this->actors[i]\&.rangeLow=json[String("Act")+String(i)]["low"][0];
419                         this->actors[i]\&.timeLow=json[String("Act")+String(i)]["low"][1];
420                         this->actors[i]\&.hourLow=json[String("Act")+String(i)]["low"][2];                     
421                         this->actors[i]\&.minuteLow=json[String("Act")+String(i)]["low"][3];                       
422                     }
423                     else
424                     {
425                         this->actors[i]\&.rangeLow=this->actors[i]\&.rangeLow;
426                         this->actors[i]\&.timeLow=this->actors[i]\&.timeLow;
427                         this->actors[i]\&.hourLow=this->actors[i]\&.hourLow;
428                         this->actors[i]\&.minuteLow=this->actors[i]\&.minuteLow;                      
429                     }
430                     json[String("Act")+String(i)]["low"][0]=this->actors[i]\&.rangeLow;
431                     json[String("Act")+String(i)]["low"][1]=this->actors[i]\&.timeLow;
432                     json[String("Act")+String(i)]["low"][2]=this->actors[i]\&.hourLow;
433                     json[String("Act")+String(i)]["low"][3]=this->actors[i]\&.minuteLow;
434 
435                     //parsing high key
436                     if(json[String("Act")+String(i)]["high"]\&.success() )
437                     {
438                         this->actors[i]\&.rangeHigh=json[String("Act")+String(i)]["high"][0];
439                         this->actors[i]\&.timeHigh=json[String("Act")+String(i)]["high"][1];
440                         this->actors[i]\&.hourHigh=json[String("Act")+String(i)]["high"][2];                       
441                         this->actors[i]\&.minuteHigh=json[String("Act")+String(i)]["high"][3];                     
442                     }
443                     else
444                     {
445                         this->actors[i]\&.rangeHigh=this->actors[i]\&.rangeHigh;
446                         this->actors[i]\&.timeHigh=this->actors[i]\&.timeHigh;
447                         this->actors[i]\&.hourHigh=this->actors[i]\&.hourHigh;
448                         this->actors[i]\&.minuteHigh=this->actors[i]\&.minuteHigh;
449                     }
450                     json[String("Act")+String(i)]["high"][0]=this->actors[i]\&.rangeHigh;
451                     json[String("Act")+String(i)]["high"][1]=this->actors[i]\&.timeHigh;
452                     json[String("Act")+String(i)]["high"][2]=this->actors[i]\&.hourHigh;
453                     json[String("Act")+String(i)]["high"][3]=this->actors[i]\&.minuteHigh;
454 
455                     //parsing type key
456                     if(json[String("Act")+String(i)]["type"]\&.success() )
457                     {
458                         this->actors[i]\&.primaryType=json[String("Act")+String(i)]["type"][0]\&.as<String>();
459                         this->actors[i]\&.secondaryType=json[String("Act")+String(i)]["type"][1]\&.as<String>();                      
460                         
461                     }
462                     else
463                     {
464                         this->actors[i]\&.primaryType=this->actors[i]\&.primaryType;
465                         this->actors[i]\&.secondaryType=this->actors[i]\&.secondaryType;
466                     }
467                     json[String("Act")+String(i)]["type"][0]=this->actors[i]\&.primaryType;
468                     json[String("Act")+String(i)]["type"][1]=this->actors[i]\&.secondaryType;
469                         
470 
471 
472                     
473                     
474                      
475                 }
476                 else
477                 {
478                     this->actors[i]=this->actors[i];
479                 }
480                 
481                 json[String("Act")+String(i)]["actif"]=this->actors[i]\&.actif;
482                 json[String("Act")+String(i)]["temporal"]=this->actors[i]\&.temporal;
483                 json[String("Act")+String(i)]["inverted"]=this->actors[i]\&.inverted;
484 
485                 json[String("Act")+String(i)]["low"][0]=this->actors[i]\&.rangeLow;
486                 json[String("Act")+String(i)]["low"][1]=this->actors[i]\&.timeLow;
487                 json[String("Act")+String(i)]["low"][2]=this->actors[i]\&.hourLow;
488                 json[String("Act")+String(i)]["low"][3]=this->actors[i]\&.minuteLow;
489 
490                 json[String("Act")+String(i)]["high"][0]=this->actors[i]\&.rangeHigh;
491                 json[String("Act")+String(i)]["high"][1]=this->actors[i]\&.timeHigh;
492                 json[String("Act")+String(i)]["high"][2]=this->actors[i]\&.hourHigh;
493                 json[String("Act")+String(i)]["high"][3]=this->actors[i]\&.minuteHigh;
494 
495                 json[String("Act")+String(i)]["type"][0]=this->actors[i]\&.primaryType;
496                 json[String("Act")+String(i)]["type"][1]=this->actors[i]\&.secondaryType;
497 
498 
499 
500             }
501             
502 
503             jetPackConfig\&.close();           
504             jetPackConfig = SPIFFS\&.open("/jetPackConfig\&.json", "w");          
505             if(!jetPackConfig)
506             {
507             
508             #if DEBUG == 1 
509 
510                 Serial\&.println( F("failed to write to /jetPackConfig\&.json ") );
511                 Serial\&.println();
512             
513             #endif
514                 
515                 return(false);          
516             }  
517 
518             json\&.printTo(jetPackConfig);
519             jetPackConfig\&.close();
520 
521         #if DEBUG == 1 
522             
523             Serial\&.println(F("saved configuration : "));
524             json\&.printTo(Serial );
525             Serial\&.println();        
526         
527         #endif
528 
529             return(true); 
530         }
531     }   
532     
533 
534 }
.fi
.SS "void Jetpack::doAction (const char * data)"
Jetpack::doAction(sensor data ): This method is provided to automate the \fBJetpack\fP\&.
.PP
The result action is the result of checking the different flags of an actor (actif , temporal ,inverted, primaryType and secondaryType ) and the corresponding call to the appropriate helping method 
.PP
Definition at line 143 of file Jetpack\&.cpp\&.
.PP
.nf
144 {
145 
146 #if DEBUG == 1 
147 
148     Serial\&.println( F("Entering Jetpack\&.doAction()") );
149     Serial\&.println();
150 
151     Serial\&.println( F("input data is :") );
152     Serial\&.println(data);
153     Serial\&.println();
154 
155 #endif 
156 
157     DynamicJsonBuffer jsonBuffer;
158     JsonObject& root = jsonBuffer\&.parseObject(data);
159     
160     if (!root\&.success()) 
161     {
162     
163     #if DEBUG == 1 
164 
165         Serial\&.println( F("failed to parse json object ") );
166         Serial\&.println();
167     
168     #endif 
169 
170     }
171     else
172     {
173     
174     #if DEBUG == 1 
175 
176         Serial\&.println( F("created Json object :") );
177         root\&.printTo(Serial);
178         Serial\&.println();
179 
180         Serial\&.print(F("jsonBuffer size: "));
181         Serial\&.println(jsonBuffer\&.size());
182         Serial\&.println();
183 
184     
185     #endif 
186 
187         //invert the current action state for each actor
188         //if the value is outside the limits
189         for(int i=0;i<8;i++)
190         {
191             //check if actor is actif
192             if(this->actors[i]\&.actif==1)
193             {
194                 //normal actor
195                 if(this->actors[i]\&.temporal == 0)
196                 {
197                     //not inverted actor
198                     if(this->actors[i]\&.inverted==0)
199                     {
200                         this->normalAction(i,root[this->actors[i]\&.primaryType]\&.as<float>());
201             
202                     }
203                     //inverted actor
204                     else if(this->actors[i]\&.inverted==1)
205                     {
206                         this->invertedAction(i,root[this->actors[i]\&.primaryType]\&.as<float>());            
207                     }
208                 }
209                 //temporal actor
210                 else if(this->actors[i]\&.temporal == 1 )
211                 {
212                     //hour actor
213                     if(this->actors[i]\&.secondaryType=="hour")
214                     {
215                         //mixed hour actor
216                         if(root[this->actors[i]\&.primaryType]\&.success() )
217                         {
218                             this->mixedHourAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>(),root[this->actors[i]\&.primaryType]\&.as<float>());
219                         }
220                         //normal hour actor
221                         else
222                         {
223                             this->hourAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>());
224                         }
225                     
226                     }
227                     //minute actor
228                     else if(this->actors[i]\&.secondaryType=="minute")
229                     {
230                         //mixed minute actor
231                         if(root[this->actors[i]\&.primaryType]\&.success() )
232                         {
233                             this->mixedMinuteAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>(),root[this->actors[i]\&.primaryType]\&.as<float>());
234                         }
235                         //normal minute actor
236                         else
237                         {
238                             this->minuteAction(i,root[this->actors[i]\&.secondaryType]\&.as<int>());
239                         }
240                     }
241                     //hourMinute actor
242                     else if(this->actors[i]\&.secondaryType=="hourMinute")
243                     {
244                         //mixed hourMinute actor
245                         if(root[this->actors[i]\&.primaryType]\&.success() )
246                         {
247                             this->mixedHourMinuteAction(i,root["hour"]\&.as<int>(),root["minute"]\&.as<int>(),root[this->actors[i]\&.primaryType]\&.as<float>());
248                         }
249                         //normal hourMinute actor
250                         else
251                         {
252                             this->hourMinuteAction(i,root["hour"]\&.as<int>(),root["minute"]\&.as<int>());
253                         }
254                     }
255                     //normal temporal actor
256                     else if(this->actors[i]\&.secondaryType=="")
257                     {
258                         //mixed temporal actor
259                         if(root[this->actors[i]\&.primaryType]\&.success() )
260                         {
261                             this->mixedTemporalActionOn(i,root[this->actors[i]\&.primaryType]\&.as<float>());
262                         }
263                         //normal temporal actor
264                         else
265                         {
266                             this->temporalActionOn(i);
267                         }
268                                             
269                     }
270 
271                 }
272             }
273             //inactif actor
274             else if(this->actors[i]\&.actif == 0 )
275             {
276                 //temporal actor
277                 if(this->actors[i]\&.temporal==1)
278                 {
279                     //mixed temporal actor
280                     if(root[this->actors[i]\&.primaryType]\&.success() )
281                     {
282                         this->mixedTemporalActionOff(i,root[this->actors[i]\&.primaryType]\&.as<float>());
283                     }
284                     //normal temporal actor
285                     else
286                     {
287                         this->temporalActionOff(i);
288                     }
289                 }           
290             }
291 
292         }
293 
294         this->write(this->action);
295 
296     } 
297 }
.fi
.SS "void Jetpack::hourAction (int actorNumber, int hour)"
Jetpack::hourAction(actorNumber, current hour ): This method is provided to handle hour actors\&. it changes the action according to:
.PP
hour >= hourLow : deactivate the actor hour >= hourHigh : activate the actor 
.PP
Definition at line 1026 of file Jetpack\&.cpp\&.
.PP
.nf
1027 {
1028 
1029 #if DEBUG == 1
1030     
1031     Serial\&.print(F("hour Actor N° : "));
1032     Serial\&.println(actorNumber);
1033 
1034     Serial\&.print(F(" hour : "));
1035     Serial\&.println(hour);
1036 
1037     Serial\&.print(F("high hour : "));
1038     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1039 
1040     Serial\&.print(F("low hour : "));
1041     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1042 
1043 #endif
1044 
1045     //stop the actor    
1046     if(hour >= this->actors[actorNumber]\&.hourLow)
1047     {
1048         bitWrite( this->action , actorNumber , 0) ;
1049 
1050     #if DEBUG == 1 
1051 
1052         Serial\&.println(F("actor OFF "));
1053 
1054     #endif  
1055 
1056     }
1057     //starting the actor
1058     else if(hour >= this->actors[actorNumber]\&.hourHigh)
1059     {
1060         bitWrite( this->action , actorNumber , 1) ;
1061 
1062     #if DEBUG == 1 
1063 
1064         Serial\&.println(F("actor ON "));
1065 
1066     #endif  
1067     
1068     }
1069 
1070 }
.fi
.SS "void Jetpack::hourMinuteAction (int actorNumber, int hour, int minute)"
Jetpack::minteAction(actorNumber, current hour,current minute ): This method is provided to handle hour minute actors\&. it changes the action according to:
.PP
hour == hourLow : minute >= minuteLow : deactivate the actor
.PP
hour > hourLow : deactivate the actor
.PP
hour == hourHigh : minute >= minteHigh : activate the actor
.PP
hour > hourHigh : activate the actor 
.PP
Definition at line 1370 of file Jetpack\&.cpp\&.
.PP
.nf
1371 {
1372 
1373 #if DEBUG == 1
1374 
1375     Serial\&.print(F("hourMinute Actor N° : "));
1376     Serial\&.println(actorNumber);
1377 
1378     Serial\&.print(F(" hour : "));
1379     Serial\&.println(hour);
1380     Serial\&.print(F(" minute : "));
1381     Serial\&.println(minute);
1382 
1383     Serial\&.print(F("high hour : "));
1384     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1385 
1386     Serial\&.print(F("high minute : "));
1387     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1388 
1389     Serial\&.print(F("low hour : "));
1390     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1391 
1392     Serial\&.print(F("low minute : "));
1393     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1394 
1395 #endif
1396     //stop the actor
1397     if(hour==this->actors[actorNumber]\&.hourLow)
1398     {
1399         if(minute>= this->actors[actorNumber]\&.minuteLow)
1400         {
1401             bitWrite( this->action , actorNumber , 0) ;
1402         #if DEBUG == 1 
1403 
1404             Serial\&.println(F("actor OFF "));
1405 
1406         #endif  
1407         }
1408     }
1409     else if(hour > this->actors[actorNumber]\&.hourLow)
1410     {
1411 
1412         bitWrite( this->action , actorNumber , 0) ;
1413     #if DEBUG == 1 
1414 
1415         Serial\&.println(F("actor OFF "));
1416 
1417     #endif  
1418     
1419     }
1420     //start the actor
1421     else if(hour==this->actors[actorNumber]\&.hourHigh)
1422     {
1423         if(minute>= this->actors[actorNumber]\&.minuteHigh)
1424         {
1425             bitWrite( this->action , actorNumber , 1) ;
1426 
1427         #if DEBUG == 1 
1428 
1429             Serial\&.println(F("actor ON "));
1430 
1431         #endif  
1432         }
1433     }
1434     else if(hour > this->actors[actorNumber]\&.hourHigh)
1435     {
1436 
1437         bitWrite( this->action , actorNumber , 1) ;
1438 
1439     #if DEBUG == 1 
1440 
1441         Serial\&.println(F("actor ON "));
1442 
1443     #endif      
1444 
1445     }
1446 
1447     
1448 }
.fi
.SS "void Jetpack::invertedAction (int actorNumber, float measurment)"
Jetpack::invertedAction(actorNumber , measured value): This method is provided to handle inverted actors\&. it changes the action according to wether the measured value is: 
.PP
.RS 4
rangeHigh (activate actor) 
.RE
.PP
< rangeLow ( deactivate actor ) 
.PP
Definition at line 693 of file Jetpack\&.cpp\&.
.PP
.nf
694 {
695 #if DEBUG == 1
696     
697     Serial\&.print("inverted Actor N° : ");
698     Serial\&.println(actorNumber);
699 
700     Serial\&.print("measured value : ");
701     Serial\&.println(measurment);
702 
703     Serial\&.print("high range : ");
704     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
705 
706     Serial\&.print("low range : ");
707     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
708 
709 #endif
710 
711     //measured value lower than minimum range : deactivate actor
712     if(measurment < this->actors[actorNumber]\&.rangeLow)
713     {
714         bitWrite( this->action , actorNumber , 0) ;
715 
716     #if DEBUG == 1 
717 
718         Serial\&.println(F("actor OFF "));
719     
720     #endif
721 
722     }
723     //measured value higher than maximum range : activate actor
724     else if(measurment > this->actors[actorNumber]\&.rangeHigh)
725     {
726         bitWrite( this->action , actorNumber , 1) ;
727 
728     #if DEBUG == 1 
729 
730         Serial\&.println(F("actor ON "));
731     
732     #endif
733 
734     }
735 
736 
737 }
.fi
.SS "void Jetpack::minuteAction (int actorNumber, int minute)"
Jetpack::minteAction(actorNumber, current minute ): This method is provided to handle minute actors\&. it changes the action according to:
.PP
minute >= minuteLow : deactivate the actor minute >= minuteHigh : activate the actor 
.PP
Definition at line 1194 of file Jetpack\&.cpp\&.
.PP
.nf
1195 {
1196 
1197 #if DEBUG == 1
1198     
1199     Serial\&.print(F("minute Actor N° : "));
1200     Serial\&.println(actorNumber);
1201 
1202     Serial\&.print(F(" minute : "));
1203     Serial\&.println(minute);
1204 
1205     Serial\&.print(F("high minute : "));
1206     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1207 
1208     Serial\&.print(F("low minute : "));
1209     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1210 
1211 #endif
1212 
1213     //stop the actor    
1214     if(minute >= this->actors[actorNumber]\&.minuteLow)
1215     {
1216         bitWrite( this->action , actorNumber , 0) ;
1217 
1218     #if DEBUG == 1 
1219 
1220         Serial\&.println(F("actor OFF "));
1221 
1222     #endif  
1223 
1224     }   
1225     //starting the actor
1226     else if(minute >= this->actors[actorNumber]\&.minuteHigh)
1227     {
1228         bitWrite( this->action , actorNumber , 1) ;
1229 
1230     #if DEBUG == 1 
1231 
1232         Serial\&.println(F("actor ON "));
1233 
1234     #endif  
1235 
1236     }
1237 
1238 } 
.fi
.SS "void Jetpack::mixedHourAction (int actorNumber, int hour, float measurment)"
Jetpack::mixedHourAction(actorNumber, current hour, measured value ): This method is provided to handle mixed hour actors\&. it changes the action according to :
.PP
hour >= hourLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor
.PP
hour >= hourHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor 
.PP
Definition at line 1087 of file Jetpack\&.cpp\&.
.PP
.nf
1088 {
1089 
1090 #if DEBUG == 1
1091     
1092     Serial\&.print("mixed hour Actor N° : ");
1093     Serial\&.println(actorNumber);
1094 
1095     Serial\&.print(" hour : ");
1096     Serial\&.println(hour);
1097 
1098     Serial\&.print("high hour : ");
1099     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1100 
1101     Serial\&.print("low hour : ");
1102     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1103 
1104     Serial\&.print("measured value : ");
1105     Serial\&.println(measurment);
1106 
1107     Serial\&.print("high range : ");
1108     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1109 
1110     Serial\&.print("low range : ");
1111     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1112 
1113 #endif
1114     //stop the actor    
1115     if(hour >= this->actors[actorNumber]\&.hourLow)
1116     {
1117             if( measurment >= this->actors[actorNumber]\&.rangeHigh )
1118             {
1119                 bitWrite( this->action , actorNumber , 0) ;
1120 
1121             #if DEBUG == 1 
1122 
1123                 Serial\&.print(measurment);
1124                 Serial\&.print(F(" > " ));
1125                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1126 
1127                 Serial\&.println(F("actor OFF "));
1128 
1129             #endif  
1130 
1131             }
1132             else 
1133             {
1134                 bitWrite( this->action , actorNumber , 1) ;
1135 
1136             #if DEBUG == 1 
1137 
1138                 Serial\&.print(measurment);
1139                 Serial\&.print(F(" < " ));
1140                 Serial\&.print(this->actors[actorNumber]\&.rangeHigh);
1141 
1142                 Serial\&.println(F("actor ON "));
1143 
1144             #endif  
1145                 
1146             }
1147     }
1148     //starting the actor
1149     else if(hour >= this->actors[actorNumber]\&.hourHigh)
1150     {
1151             if( measurment < this->actors[actorNumber]\&.rangeLow )
1152             {
1153                 bitWrite( this->action , actorNumber , 1) ;
1154 
1155             #if DEBUG == 1 
1156 
1157                 Serial\&.print(measurment);
1158                 Serial\&.print(F(" < " ));
1159                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1160 
1161                 Serial\&.println(F("actor ON "));
1162 
1163             #endif  
1164             }
1165             else 
1166             {
1167                 bitWrite( this->action , actorNumber , 0) ;
1168 
1169             #if DEBUG == 1 
1170 
1171                 Serial\&.print(measurment);
1172                 Serial\&.print(F(" > " ));
1173                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1174 
1175                 Serial\&.println(F("actor OFF "));
1176 
1177             #endif                  
1178             }
1179 
1180     }
1181 
1182 }
.fi
.SS "void Jetpack::mixedHourMinuteAction (int actorNumber, int hour, int minute, float measurment)"
Jetpack::minteAction(actorNumber, current hour,current minute , measured Value ): This method is provided to handle hour minute actors\&. it changes the action according to:
.PP
hour == hourLow : minute >= minuteLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor
.PP
hour > hourLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor
.PP
hour == hourHigh : minute >= minteHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor
.PP
hour > hourHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor 
.PP
Definition at line 1475 of file Jetpack\&.cpp\&.
.PP
.nf
1476 {
1477 
1478 #if DEBUG == 1
1479     
1480     Serial\&.print("hourMinute Actor N° : ");
1481     Serial\&.println(actorNumber);
1482 
1483     Serial\&.print(" hour : ");
1484     Serial\&.println(hour);
1485     Serial\&.print(" minute : ");
1486     Serial\&.println(minute);
1487 
1488     Serial\&.print("high hour : ");
1489     Serial\&.println(this->actors[actorNumber]\&.hourHigh);
1490 
1491     Serial\&.print("high minute : ");
1492     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1493 
1494     Serial\&.print("low hour : ");
1495     Serial\&.println(this->actors[actorNumber]\&.hourLow);
1496 
1497     Serial\&.print("low minute : ");
1498     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1499 
1500     Serial\&.print("measured value : ");
1501     Serial\&.println(measurment);
1502 
1503     Serial\&.print("high range : ");
1504     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1505 
1506     Serial\&.print("low range : ");
1507     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1508 
1509 #endif
1510     //stop the actor
1511     if(hour==this->actors[actorNumber]\&.hourLow)
1512     {
1513         if(minute>= this->actors[actorNumber]\&.minuteLow)
1514         {
1515             if( measurment >= this->actors[actorNumber]\&.rangeHigh )
1516             {
1517                 bitWrite( this->action , actorNumber , 0) ;
1518 
1519             #if DEBUG == 1 
1520 
1521                 Serial\&.print(measurment);
1522                 Serial\&.print(F(" >= " ));
1523                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1524 
1525                 Serial\&.println(F("actor OFF "));
1526 
1527             #endif  
1528 
1529             }
1530             else 
1531             {
1532                 bitWrite( this->action , actorNumber , 1) ;
1533 
1534             #if DEBUG == 1 
1535 
1536                 Serial\&.print(measurment);
1537                 Serial\&.print(F(" < " ));
1538                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1539 
1540                 Serial\&.println(F("actor ON "));
1541 
1542             #endif  
1543                 
1544             }
1545         }
1546     }
1547     else if(hour > this->actors[actorNumber]\&.hourLow)
1548     {
1549 
1550         if( measurment >= this->actors[actorNumber]\&.rangeHigh )
1551         {
1552             bitWrite( this->action , actorNumber , 0) ;
1553 
1554         #if DEBUG == 1 
1555 
1556             Serial\&.print(measurment);
1557             Serial\&.print(F(" >= " ));
1558             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1559 
1560             Serial\&.println(F("actor OFF "));
1561 
1562         #endif  
1563 
1564         }
1565         else 
1566         {
1567             bitWrite( this->action , actorNumber , 1) ;
1568 
1569         #if DEBUG == 1 
1570 
1571             Serial\&.print(measurment);
1572             Serial\&.print(F(" < " ));
1573             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1574 
1575             Serial\&.println(F("actor ON "));
1576 
1577         #endif  
1578             
1579         }
1580 
1581 
1582     }
1583     //start the actor
1584     else if(hour==this->actors[actorNumber]\&.hourHigh)
1585     {
1586         if(minute>= this->actors[actorNumber]\&.minuteHigh)
1587         {
1588             if( measurment < this->actors[actorNumber]\&.rangeLow )
1589             {
1590                 bitWrite( this->action , actorNumber , 1) ;
1591 
1592             #if DEBUG == 1 
1593 
1594                 Serial\&.print(measurment);
1595                 Serial\&.print(F(" < " ));
1596                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1597 
1598                 Serial\&.println(F("actor ON "));
1599 
1600             #endif  
1601 
1602             }
1603             else 
1604             {
1605                 bitWrite( this->action , actorNumber , 0) ;
1606 
1607             #if DEBUG == 1 
1608 
1609                 Serial\&.print(measurment);
1610                 Serial\&.println(F(" > " ));
1611                 Serial\&.print(this->actors[actorNumber]\&.rangeLow);
1612 
1613                 Serial\&.println(F("actor OFF "));
1614 
1615             #endif  
1616                 
1617             }
1618         }
1619     }
1620     else if(hour > this->actors[actorNumber]\&.hourHigh)
1621     {
1622 
1623         if( measurment < this->actors[actorNumber]\&.rangeLow )
1624         {
1625             bitWrite( this->action , actorNumber , 1) ;
1626 
1627         #if DEBUG == 1 
1628 
1629             Serial\&.print(measurment);
1630             Serial\&.print(F(" < " ));
1631             Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1632 
1633             Serial\&.println(F("actor ON "));
1634 
1635         #endif  
1636 
1637         }
1638         else 
1639         {
1640             bitWrite( this->action , actorNumber , 0) ;
1641 
1642         #if DEBUG == 1 
1643 
1644             Serial\&.print(measurment);
1645             Serial\&.println(F(" > " ));
1646             Serial\&.print(this->actors[actorNumber]\&.rangeLow);
1647 
1648             Serial\&.println(F("actor OFF "));
1649 
1650         #endif  
1651             
1652         }
1653     
1654     }
1655 
1656 }
.fi
.SS "void Jetpack::mixedMinuteAction (int actorNumber, int minute, float measurment)"
Jetpack::mixedMinuteAction(actorNumber, current minute, measured value ): This method is provided to handle mixed minute actors\&. it changes the action according to :
.PP
minute >= minuteLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor
.PP
minute >= minuteHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor 
.PP
Definition at line 1254 of file Jetpack\&.cpp\&.
.PP
.nf
1255 {
1256 
1257 #if DEBUG == 1
1258     
1259     Serial\&.print("mixed minute Actor N° : ");
1260     Serial\&.println(actorNumber);
1261 
1262     Serial\&.print(" minute : ");
1263     Serial\&.println(minute);
1264 
1265     Serial\&.print("high minute : ");
1266     Serial\&.println(this->actors[actorNumber]\&.minuteHigh);
1267 
1268     Serial\&.print("low minute : ");
1269     Serial\&.println(this->actors[actorNumber]\&.minuteLow);
1270 
1271     Serial\&.print("measured value : ");
1272     Serial\&.println(measurment);
1273 
1274     Serial\&.print("high range : ");
1275     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1276 
1277     Serial\&.print("low range : ");
1278     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1279 
1280 #endif
1281     //stop the actor    
1282     if(minute >= this->actors[actorNumber]\&.minuteLow)
1283     {
1284             if( measurment > this->actors[actorNumber]\&.rangeHigh )
1285             {
1286                 bitWrite( this->action , actorNumber , 0) ;
1287 
1288             #if DEBUG == 1 
1289 
1290                 Serial\&.print(measurment);
1291                 Serial\&.print(F(" > " ));
1292                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1293 
1294                 Serial\&.println(F("actor OFF "));
1295 
1296             #endif
1297     
1298             }
1299             else 
1300             {
1301                 bitWrite( this->action , actorNumber , 1) ;
1302 
1303             #if DEBUG == 1 
1304 
1305                 Serial\&.print(measurment);
1306                 Serial\&.print(F(" < " ));
1307                 Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
1308 
1309                 Serial\&.println(F("actor ON "));
1310 
1311             #endif  
1312                 
1313             }
1314     }   
1315     //starting the actor
1316     else if(minute >= this->actors[actorNumber]\&.minuteHigh)
1317     {
1318             if( measurment < this->actors[actorNumber]\&.rangeLow )
1319             {
1320                 bitWrite( this->action , actorNumber , 1) ;
1321 
1322             #if DEBUG == 1 
1323 
1324                 Serial\&.print(measurment);
1325                 Serial\&.print(F(" < " ));
1326                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1327 
1328                 Serial\&.println(F("actor ON "));
1329 
1330             #endif  
1331 
1332             }
1333             else 
1334             {
1335                 bitWrite( this->action , actorNumber , 0) ;
1336             
1337             #if DEBUG == 1 
1338 
1339                 Serial\&.print(measurment);
1340                 Serial\&.print(F(" > " ));
1341                 Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1342 
1343                 Serial\&.println(F("actor OFF "));
1344 
1345             #endif  
1346                 
1347             }
1348 
1349     }
1350 
1351 }
.fi
.SS "void Jetpack::mixedTemporalActionOff (int actorNumber, float measurment)"
Jetpack::mixedTemporalActionOff(actorNumber, measured value ): This method is provided to handle mixed temporal actors\&. it changes the action according to:
.PP
currentTime - startTime >= timeHigh : measured value >= rangeHigh : deactivate actor measured value < rangeHigh : activate actor 
.PP
Definition at line 799 of file Jetpack\&.cpp\&.
.PP
.nf
800 {
801 
802 #if DEBUG == 1
803     
804     Serial\&.print("mixed Temporal Actor N° : ");
805     Serial\&.println(actorNumber);
806 
807     Serial\&.print("measured value : ");
808     Serial\&.println(measurment);
809 
810     Serial\&.print("high range : ");
811     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
812 
813     Serial\&.print("time high : ");
814     Serial\&.println(this->actors[actorNumber]\&.timeHigh);
815 
816     Serial\&.print("actif Time : ");
817     Serial\&.println(this->actors[actorNumber]\&.actifTime);
818 
819     Serial\&.print(F("millis : "));
820     Serial\&.println(millis());
821 
822 #endif
823     if( ( millis()- this->actors[actorNumber]\&.actifTime  ) >= (  this->actors[actorNumber]\&.timeHigh  ) )
824     {   
825         if( measurment >= this->actors[actorNumber]\&.rangeHigh )
826         {
827             //stop the actor
828             bitWrite( this->action , actorNumber , 0) ;
829 
830             //make the actor inactif:
831             this->actors[actorNumber]\&.actif=0;
832 
833             //start the low timer
834             this->actors[actorNumber]\&.inactifTime=millis();
835 
836         #if DEBUG == 1 
837 
838             Serial\&.print(F("actor was on for at least "));
839             Serial\&.print(this->actors[actorNumber]\&.timeHigh);
840             Serial\&.println(F(" ms "));
841 
842             Serial\&.print(measurment);
843             Serial\&.print(F(" > " ));
844             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
845 
846             
847             Serial\&.println(F("actor OFF "));
848 
849         #endif
850 
851         }
852         else 
853         {
854             bitWrite( this->action , actorNumber , 1) ;
855 
856         #if DEBUG == 1 
857             
858             Serial\&.print(F("actor was on for at least "));
859             Serial\&.print(this->actors[actorNumber]\&.timeHigh);
860             Serial\&.println(F(" ms "));
861 
862             Serial\&.print(measurment);
863             Serial\&.print(F(" < " ));
864             Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
865 
866             Serial\&.println(F("actor ON "));
867 
868         #endif              
869 
870         }           
871     }
872 
873 }
.fi
.SS "void Jetpack::mixedTemporalActionOn (int actorNumber, float measurment)"
Jetpack::mixedTemporalActionOn(actorNumber, measured value ): This method is provided to handle mixed temporal actors\&. it changes the action according to :
.PP
currentTime - stopTime > timeLow : measured value >= rangeLow : deactivate actor measured value < rangeLow : activate actor 
.PP
Definition at line 937 of file Jetpack\&.cpp\&.
.PP
.nf
938 {
939 
940 #if DEBUG == 1
941     
942     Serial\&.print("mixed Temporal Actor N° : ");
943     Serial\&.println(actorNumber);
944 
945     Serial\&.print("measured value : ");
946     Serial\&.println(measurment);
947 
948     Serial\&.print("low range : ");
949     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
950 
951     Serial\&.print("time low : ");
952     Serial\&.println(this->actors[actorNumber]\&.timeLow);
953 
954     Serial\&.print("inactif Time : ");
955     Serial\&.println(this->actors[actorNumber]\&.inactifTime);
956 
957     Serial\&.print(F("millis : "));
958     Serial\&.println(millis());
959 
960 #endif
961 
962     if( ( millis() - this->actors[actorNumber]\&.inactifTime ) >= (  this->actors[actorNumber]\&.timeLow  ) )
963     {
964         if( measurment < this->actors[actorNumber]\&.rangeLow )
965         {
966             //start the actor
967             bitWrite( this->action , actorNumber , 1) ;
968 
969             //make the actor actif:
970             this->actors[actorNumber]\&.actif=1;
971 
972             //start the low timer
973             this->actors[actorNumber]\&.actifTime=millis();
974 
975         #if DEBUG == 1 
976 
977             Serial\&.print(F("actor was off for at least "));
978             Serial\&.print(this->actors[actorNumber]\&.timeLow);
979             Serial\&.println(F(" ms "));
980 
981             Serial\&.print(measurment);
982             Serial\&.print(F(" < " ));
983             Serial\&.println(this->actors[actorNumber]\&.rangeLow);
984     
985             Serial\&.println(F("actor ON "));
986     
987         #endif  
988 
989         }
990         else 
991         {
992             bitWrite( this->action , actorNumber , 0) ; 
993 
994         #if DEBUG == 1 
995 
996             Serial\&.print(F("actor was off for at least "));
997             Serial\&.print(this->actors[actorNumber]\&.timeLow);
998             Serial\&.println(F(" ms "));
999 
1000             Serial\&.print(measurment);
1001             Serial\&.print(F(" > " ));
1002             Serial\&.println(this->actors[actorNumber]\&.rangeLow);
1003 
1004             Serial\&.println(F("actor OFF "));
1005     
1006         #endif              
1007 
1008         }
1009 
1010     }
1011 
1012     
1013 }
.fi
.SS "void Jetpack::normalAction (int actorNumber, float measurment)"
Jetpack::normalAction(actorNumber , measured value): This method is provided to handle normal actors\&. it changes the action according to wether the measured value is: > rangeHigh ( deactivate actor) or < rangeLow (activate actor ) 
.PP
Definition at line 636 of file Jetpack\&.cpp\&.
.PP
.nf
637 {
638 
639 #if DEBUG == 1
640     
641     Serial\&.print(F("none inverted Actor N° : "));
642     Serial\&.println(actorNumber);
643 
644     Serial\&.print(F("measured value : "));
645     Serial\&.println(measurment);
646 
647     Serial\&.print(F("high range : "));
648     Serial\&.println(this->actors[actorNumber]\&.rangeHigh);
649 
650     Serial\&.print(F("low range : "));
651     Serial\&.println(this->actors[actorNumber]\&.rangeLow);
652 
653 #endif
654 
655     //measured value lower than minimum range : activate actor
656     if(measurment < this->actors[actorNumber]\&.rangeLow)
657     {
658         bitWrite( this->action , actorNumber , 1) ;
659 
660     #if DEBUG == 1 
661 
662         Serial\&.println(F("actor ON "));
663     
664     #endif
665                 
666     }
667     //measured value higher than maximum range : deactivate actor
668     else if(measurment > this->actors[actorNumber]\&.rangeHigh)
669     {
670         bitWrite( this->action , actorNumber , 0) ;
671 
672     #if DEBUG == 1 
673 
674         Serial\&.println(F("actor OFF "));
675     
676     #endif
677     
678     }
679 
680 
681 }
.fi
.SS "void Jetpack::printConf ()"
\fBJetpack::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 542 of file Jetpack\&.cpp\&.
.PP
.nf
543 {
544 
545 #if DEBUG == 1 
546 
547     Serial\&.println( F("Enter Jetpack\&.printConf() ") );
548     Serial\&.println();
549 
550 #endif 
551     Serial\&.println(F( "Jetpack configuration " ) ) ;
552  
553         for(int i=0;i<8;i++)
554     {   
555         Serial\&.print(F("actor N°"));
556         Serial\&.print(i);
557         Serial\&.print(F(" actif :"));
558         Serial\&.println(this->actors[i]\&.actif);
559         
560         Serial\&.print(F("actor N°"));
561         Serial\&.print(i);
562         Serial\&.print(F(" temporal :"));
563         Serial\&.println(this->actors[i]\&.temporal);
564 
565         Serial\&.print(F("actor N°"));
566         Serial\&.print(i);
567         Serial\&.print(F(" inverted :"));
568         Serial\&.println(this->actors[i]\&.inverted);
569 
570 
571         Serial\&.print(F("actor N°"));
572         Serial\&.print(i);
573         Serial\&.print(F(" primary Type :"));
574         Serial\&.println(this->actors[i]\&.primaryType);
575 
576         Serial\&.print(F("actor N°"));
577         Serial\&.print(i);
578         Serial\&.print(F(" secondary Type :"));        
579         Serial\&.println(this->actors[i]\&.secondaryType);
580 
581         Serial\&.print(F("actor N°"));
582         Serial\&.print(i);
583         Serial\&.print(F(" range Low :"));
584         Serial\&.println(this->actors[i]\&.rangeLow);
585 
586         Serial\&.print(F("actor N°"));
587         Serial\&.print(i);
588         Serial\&.print(F(" time Low :"));
589         Serial\&.println(this->actors[i]\&.timeLow);
590 
591         Serial\&.print(F("actor N°"));
592         Serial\&.print(i);
593         Serial\&.print(F(" hour low:"));
594         Serial\&.println(this->actors[i]\&.hourLow);
595 
596         Serial\&.print(F("actor N°"));
597         Serial\&.print(i);
598         Serial\&.print(F(" minute low:"));
599         Serial\&.println(this->actors[i]\&.minuteLow);
600 
601         Serial\&.print(F("actor N°"));
602         Serial\&.print(i);
603         Serial\&.print(F(" range High:"));
604         Serial\&.println(this->actors[i]\&.rangeHigh);
605 
606         Serial\&.print(F("actor N°"));
607         Serial\&.print(i);
608         Serial\&.print(F(" time High:"));
609         Serial\&.println(this->actors[i]\&.timeHigh);
610 
611         Serial\&.print(F("actor N°"));
612         Serial\&.print(i);
613         Serial\&.print(F(" hour high:"));
614         Serial\&.println(this->actors[i]\&.hourHigh);
615 
616         Serial\&.print(F("actor N°"));
617         Serial\&.print(i);
618         Serial\&.print(F(" minute high:"));
619         Serial\&.println(this->actors[i]\&.minuteHigh);
620 
621         Serial\&.println(); 
622 
623     }
624 
625     Serial\&.println();
626 }
.fi
.SS "void Jetpack::temporalActionOff (int actorNumber)"
Jetpack::temporalActionOff(actorNumber ): This method is provided to handle temporal actors\&. it changes the action according to:
.PP
currentTime - startTime > timeHigh : deactivate actor 
.PP
Definition at line 748 of file Jetpack\&.cpp\&.
.PP
.nf
749 {
750 
751 #if DEBUG == 1
752     
753     Serial\&.print(F("temporal Actor N° : "));
754     Serial\&.println(actorNumber);
755 
756     Serial\&.print(F("millis : "));
757     Serial\&.println(millis());
758 
759     Serial\&.print(F("actif Time : "));
760     Serial\&.println(this->actors[actorNumber]\&.actifTime);
761 
762     Serial\&.print(F("high time : "));
763     Serial\&.println(this->actors[actorNumber]\&.timeHigh);
764 
765 
766 #endif
767     
768     if( ( millis()- this->actors[actorNumber]\&.actifTime  ) >= (  this->actors[actorNumber]\&.timeHigh  ) )
769     {
770         //stop the actor
771         bitWrite( this->action , actorNumber , 0) ;
772 
773         //make the actor inactif:
774         this->actors[actorNumber]\&.actif=0;
775 
776         //start the low timer
777         this->actors[actorNumber]\&.inactifTime=millis();
778 
779     #if DEBUG == 1 
780 
781         Serial\&.println(F("actor OFF "));
782     
783     #endif
784                 
785     }   
786 }
.fi
.SS "void Jetpack::temporalActionOn (int actorNumber)"
Jetpack::temporalActionOn(actorNumber ): This method is provided to handle temporal actors\&. it changes the action according to :
.PP
currentTime - stopTime > timeLow : activate actor 
.PP
Definition at line 885 of file Jetpack\&.cpp\&.
.PP
.nf
886 {
887 
888 #if DEBUG == 1
889     
890     Serial\&.print(F("temporal Actor N° : "));
891     Serial\&.println(actorNumber);
892 
893     Serial\&.print(F("millis : "));
894     Serial\&.println(millis());
895 
896     Serial\&.print(F("inactif Time : "));
897     Serial\&.println(this->actors[actorNumber]\&.inactifTime);
898 
899     Serial\&.print(F("low time : "));
900     Serial\&.println(this->actors[actorNumber]\&.timeLow);
901 
902 
903 #endif
904     
905      if( ( millis() - this->actors[actorNumber]\&.inactifTime ) >= (  this->actors[actorNumber]\&.timeLow  ) )
906     {
907         //start the actor
908         bitWrite( this->action , actorNumber , 1) ;
909 
910         //make the actor actif:
911         this->actors[actorNumber]\&.actif=1;
912 
913         //start the low timer
914         this->actors[actorNumber]\&.actifTime=millis();
915 
916     #if DEBUG == 1 
917 
918         Serial\&.println(F("actor ON "));
919 
920     #endif              
921 
922     }
923 
924 }
.fi
.SS "void Jetpack::write (byte action)"
Jetpack::write(action): This method is provided to write the given action to the entire \fBJetpack\fP action is a Byte (8 bits ), each bit goes to an output\&. MSBFirst 
.PP
Definition at line 76 of file Jetpack\&.cpp\&.
.PP
.nf
77 {
78 
79 #if DEBUG == 1
80 
81     Serial\&.println( F("Entering Jetpack\&.write()") );
82     Serial\&.println();
83 
84     Serial\&.println( F("writing this action : ") );
85     Serial\&.println(action,BIN);
86     Serial\&.println();
87 
88 #endif 
89 
90     this->action=action;
91 
92     
93     digitalWrite(EnI2C, LOW);
94     
95     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
96 
97     digitalWrite(EnI2C, HIGH);
98 
99 
100 }
.fi
.SS "void Jetpack::writeBit (byte pin, bool state)"
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin 
.PP
Definition at line 107 of file Jetpack\&.cpp\&.
.PP
.nf
108 {
109 
110 #if DEBUG == 1 
111 
112     Serial\&.println( F("Entering Jetpack\&.writeBit() ") );
113 
114     Serial\&.print( F("Writing ") );
115     Serial\&.print(state);
116 
117     Serial\&.print( F("to pin N°") );
118     Serial\&.print(pin);
119 
120     Serial\&.println();
121 
122 #endif
123 
124     bitWrite(this->action, pin, state);
125     digitalWrite(EnI2C, LOW);
126     
127     shiftOut(dataPin, clockPin, MSBFIRST, this->action);
128 
129     digitalWrite(EnI2C, HIGH);
130 
131 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "byte Jetpack::action = B00000000\fC [private]\fP"
the \fBJetpack\fP's Action 
.PP
Definition at line 89 of file Jetpack\&.h\&.
.SS "struct \fBJetpack::state\fP Jetpack::actors[8]\fC [private]\fP"

.SS "const int Jetpack::clockPin = 4\fC [private]\fP"
clock pin for the shift register 
.PP
Definition at line 183 of file Jetpack\&.h\&.
.SS "const int Jetpack::dataPin = 15\fC [private]\fP"
data pin for the shift register 
.PP
Definition at line 188 of file Jetpack\&.h\&.
.SS "const int Jetpack::EnI2C =5\fC [private]\fP"
I2C Enable pin 
.PP
Definition at line 193 of file Jetpack\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
