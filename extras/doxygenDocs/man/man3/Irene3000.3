.TH "Irene3000" 3 "Wed Aug 30 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Irene3000 \- This class is provided to manage the \fBIrene3000\fP Ph/Temperature Shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Irene3000\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBparameters_T\fP"
.br
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "int \fBreadButton\fP ()"
.br
.ti -1c
.RI "void \fBsetGain\fP (\fBadsGain_t\fP gain)"
.br
.ti -1c
.RI "int \fBreadADSChannel2\fP (\fBadsGain_t\fP gain)"
.br
.ti -1c
.RI "float \fBreadPh\fP (double t)"
.br
.ti -1c
.RI "double \fBreadTemp\fP ()"
.br
.ti -1c
.RI "void \fBresetParams\fP ()"
.br
.ti -1c
.RI "void \fBcalibratepH7\fP ()"
.br
.ti -1c
.RI "void \fBcalibratepH4\fP ()"
.br
.ti -1c
.RI "void \fBcalcpHSlope\fP ()"
.br
.ti -1c
.RI "\fBadsGain_t\fP \fBgainConvert\fP (uint16_t tempGain)"
.br
.ti -1c
.RI "bool \fBsaveParams\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBAdafruit_ADS1115\fP \fBads\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::parameters_T\fP \fBparams\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::state\fP \fBwaterTemp\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::state\fP \fBphProbe\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::state\fP \fBadc2\fP"
.br
.ti -1c
.RI "const float \fBvRef\fP = 1\&.024"
.br
.ti -1c
.RI "const float \fBopampGain\fP = 5\&.25"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class is provided to manage the \fBIrene3000\fP Ph/Temperature Shield\&. 
.PP
Definition at line 59 of file Irene3000\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Irene3000::begin (void)"
\fBIrene3000::begin()\fP: This method is provided to start the \fBIrene3000\fP 
.PP
Definition at line 52 of file Irene3000\&.cpp\&.
.PP
.nf
53 {
54     this->ads\&.begin();
55 
56     delay(2000);
57 
58 #if DEBUG == 1 
59 
60 
61     Serial\&.println( F("Entering Irene3000\&.begin()") );
62     Serial\&.println();
63     
64     
65     
66 
67 #endif
68     Serial\&.println(F("Press the button to calibrate the Ph probe "));
69 
70     delay(2000);
71 
72     int bValue=this->readButton();
73     
74     while(bValue<500)
75     {
76         bValue=this->readButton();
77         delay(10);  
78     }
79 
80     if(  bValue > 20000 )
81     {
82     
83 
84         
85         Serial\&.println(F("calibrating the Ph probe " ) );
86         
87         Serial\&.println(F("ph7 calibration for 25 seconds"));
88         
89         delay(10000);
90         
91         this->calibratepH7();
92 
93         delay(15000);       
94     
95         this->calibratepH7();
96 
97         delay(1000);
98         Serial\&.println(F("ph 7 calibration ok"));
99         Serial\&.println();
100     
101 
102         Serial\&.println(F("ph 4 calibration for 25 seconds"));
103     
104         delay(10000);       
105 
106         this->calibratepH4();
107 
108         delay(15000);
109         
110         this->calibratepH4();
111     
112         delay(1000);        
113 
114         Serial\&.println(F("ph 4 calibration ok"));
115         Serial\&.println();
116     
117 
118 
119         this->saveParams();
120     
121     }
122 
123 }
.fi
.SS "void Irene3000::calcpHSlope ()"
Irene3000::calcpHSlop(): This method is provided to calculate th PH slope 
.PP
Definition at line 685 of file Irene3000\&.cpp\&.
.PP
.nf
686 {
687 
688 #if DEBUG == 1 
689 
690     Serial\&.println( F("Entering Irene3000\&.calcpHSlope()") );
691     Serial\&.println();
692 
693 #endif 
694 
695     params\&.pHStep = ((((vRef * (float)(params\&.pH7Cal - params\&.pH4Cal)) / 32767) * 1000) / opampGain) / 3;
696 
697  
698 }
.fi
.SS "void Irene3000::calibratepH4 ()"
\fBIrene3000::calibratepH4()\fP: This method is provided to calibrate the PH probe to 4 
.PP
Definition at line 659 of file Irene3000\&.cpp\&.
.PP
.nf
660 {
661 
662 #if DEBUG == 1 
663 
664     Serial\&.println( F("Entering Irene3000\&.calibraph4()") );
665     Serial\&.println();
666 
667 #endif 
668     delay(1000);
669 
670     this->setGain(GAIN_FOUR);
671 
672     this->params\&.pH4Cal =  ads\&.readADC_SingleEnded(ph);
673 
674     this->calcpHSlope();
675 
676 
677 
678 }
.fi
.SS "void Irene3000::calibratepH7 ()"
\fBIrene3000::calibratepH7()\fP: This method is provided to calibrate the PH probe to 7 
.PP
Definition at line 632 of file Irene3000\&.cpp\&.
.PP
.nf
633 {
634 
635 #if DEBUG == 1 
636 
637     Serial\&.println( F("Entering Irene3000\&.calibratepH7() ") );
638     Serial\&.println();
639     
640     
641 
642 #endif 
643     delay(1000);
644 
645     this->setGain(GAIN_FOUR);
646         
647     this->params\&.pH7Cal = ads\&.readADC_SingleEnded(ph);
648  
649     this->calcpHSlope();
650 
651 
652 }
.fi
.SS "bool Irene3000::config ()"
\fBIrene3000::config()\fP: This method is provided to configure the \fBIrene3000\fP shield through a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 203 of file Irene3000\&.cpp\&.
.PP
.nf
204 {
205 
206 #if DEBUG == 1 
207 
208     Serial\&.println( F("Entering Irene3000\&.config()") );
209     Serial\&.println();
210 
211 #endif
212 
213     File irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "r");
214 
215     if (!irene3000Config) 
216     {
217     
218     #if DEBUG == 1 
219 
220         Serial\&.println( F("failed to read /irene3000Config\&.json") );
221         Serial\&.println();
222     
223     #endif
224 
225         return(false);
226     }
227     else
228     {
229         size_t size = irene3000Config\&.size();
230         // Allocate a buffer to store contents of the file\&.
231         std::unique_ptr<char[]> buf(new char[size]);
232             uint16_t tempGain;
233         irene3000Config\&.readBytes(buf\&.get(), size);
234         DynamicJsonBuffer jsonBuffer;
235         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
236         if (!json\&.success()) 
237         {
238         
239         #if DEBUG == 1 
240 
241             Serial\&.println( F("failed to parse json ") );
242             Serial\&.println();
243         
244         #endif
245             
246             return(false);
247         } 
248         else
249         {
250         
251         #if DEBUG == 1 
252     
253             Serial\&.println( F("read configuration file ") );
254             json\&.printTo(Serial);
255             Serial\&.println();
256 
257             Serial\&.print(F("jsonBuffer size: "));
258             Serial\&.println(jsonBuffer\&.size());
259             Serial\&.println();
260 
261         
262 
263         #endif          
264             if(json["waterTemp"]["active"]\&.success() )
265             {           
266                 this->waterTemp\&.active = json["waterTemp"]["active"]; 
267             }
268             else
269             {
270                 this->waterTemp\&.active=this->waterTemp\&.active;
271             }
272             json["waterTemp"]["active"]=this->waterTemp\&.active;
273 
274             
275             if(json["phProbe"]["active"]\&.success())
276             {
277                 this->phProbe\&.active=json["phProbe"]["active"];
278             }
279             else
280             {
281                 this->phProbe\&.active=this->phProbe\&.active;
282             }
283             json["phProbe"]["active"]=this->phProbe\&.active;
284 
285             
286             if(json["adc2"]["active"]\&.success() )
287             {
288                 this->adc2\&.active=json["adc2"]["active"];
289             }
290             else
291             {
292                 this->adc2\&.active=this->adc2\&.active;
293             }
294             json["adc2"]["active"]=this->adc2\&.active;
295 
296             
297             if(json["adc2"]["gain"]\&.success() )
298             {           
299                 tempGain=json["adc2"]["gain"];
300                 this->adc2\&.gain=this->gainConvert(tempGain);
301             }
302             else
303             {
304                 this->adc2\&.gain=this->adc2\&.gain;
305             }
306             json["adc2"]["gain"]=this->adc2\&.gain;
307 
308             
309             if(json["adc2"]["type"]\&.success() )
310             {
311                 this->adc2\&.type=json["adc2"]["type"]\&.as<String>(); 
312             }
313             else
314             {
315                 this->adc2\&.type=this->adc2\&.type;
316             }
317             json["adc2"]["type"]=this->adc2\&.type;
318 
319 
320             if(json["pH7Cal"]\&.success())
321             {
322                 this->params\&.pH7Cal=json["pH7Cal"];          
323             }
324             else
325             {
326                 this->params\&.pH7Cal=this->params\&.pH7Cal;
327             }
328             json["pH7Cal"]=this->params\&.pH7Cal;
329 
330             
331             if(json["pH4Cal"]\&.success())
332             {
333                 this->params\&.pH4Cal=json["pH4Cal"];          
334             }
335             else
336             {
337                 this->params\&.pH4Cal=this->params\&.pH4Cal;
338             }
339             json["pH4Cal"]=this->params\&.pH4Cal;
340 
341 
342             if(json["pHStep"]\&.success())
343             {
344                 this->params\&.pHStep=json["pHStep"];          
345             }
346             else
347             {
348                 this->params\&.pHStep=this->params\&.pHStep;
349             }
350             json["pHStep"]=this->params\&.pHStep;
351 
352 
353             irene3000Config\&.close();
354             irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "w");
355 
356             if(!irene3000Config)
357             {
358             
359             #if DEBUG == 1
360 
361                 Serial\&.println( F("failed to write to /irene3000Config\&.json") );
362                 Serial\&.println();
363             
364             #endif 
365 
366                 return(false);
367             }
368 
369             json\&.printTo(irene3000Config);
370             irene3000Config\&.close();
371             
372         #if DEBUG == 1 
373 
374             Serial\&.println( F("saved configuration file :")  );
375             json\&.printTo(Serial);
376             Serial\&.println();
377         
378         #endif
379 
380             return(true); 
381         }
382     }   
383 
384 }
.fi
.SS "\fBadsGain_t\fP Irene3000::gainConvert (uint16_t tempGain)"
\fBIrene3000::gainConvert\fP( gain : { 0\&.67 ,1,2,4,8,16 } ) This method is provided to convert the gain to Internal Constants
.PP
\fBReturns:\fP
.RS 4
internal representation of the ADS gain 
.RE
.PP

.PP
Definition at line 732 of file Irene3000\&.cpp\&.
.PP
.nf
733 {
734 
735 #if DEBUG == 1 
736 
737     Serial\&.println( F("Entering Irene3000\&.gainConvert()") );
738     Serial\&.println();
739 
740 #endif 
741     
742     switch(tempGain)
743     {
744         case(1): return (GAIN_ONE);
745         case(2) : return(GAIN_TWO);
746         case(4): return(GAIN_FOUR) ;   
747         case(8):return(GAIN_EIGHT)  ;  
748         case(16):return(GAIN_SIXTEEN);
749         default: return(GAIN_TWOTHIRDS);    
750     }
751 
752     return(GAIN_ONE);
753 
754 }
.fi
.SS "void Irene3000::printConf ()"
\fBIrene3000::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 391 of file Irene3000\&.cpp\&.
.PP
.nf
392 {
393 
394 #if DEBUG == 1 
395 
396     Serial\&.println( F("Entering Irene3000\&.printConf()") );
397     Serial\&.println();
398 
399 #endif 
400 
401     Serial\&.println("Irene Configuration ");
402 
403     Serial\&.print("waterTemp\&.active : ");
404     Serial\&.println(waterTemp\&.active);
405 
406     Serial\&.print("waterTemp\&.gain : ");
407     Serial\&.println(waterTemp\&.gain,HEX);   
408 
409     Serial\&.print("phProbe\&.active : ");
410     Serial\&.println(phProbe\&.active);
411 
412     Serial\&.print("phProbe\&.gain : ");
413     Serial\&.println(phProbe\&.gain,HEX);
414     
415     Serial\&.print("adc2\&.active : ");
416     Serial\&.println(adc2\&.active);
417 
418     Serial\&.print("adc2\&.gain : ");
419     Serial\&.println(adc2\&.gain,HEX);
420 
421     Serial\&.print("adc2\&.type : ");
422     Serial\&.println(adc2\&.type);
423 
424     Serial\&.println();
425 }
.fi
.SS "String Irene3000::read (void)"
\fBIrene3000\fP:\fBread()\fP: This method is provided to read the \fBIrene3000\fP sensors data
.PP
\fBReturns:\fP
.RS 4
json string of the sensors data 
.RE
.PP

.PP
Definition at line 133 of file Irene3000\&.cpp\&.
.PP
.nf
134 {
135 
136 #if DEBUG == 1 
137     
138     Serial\&.println( F("Entering Irene3000\&.read()") );
139     Serial\&.println();
140 
141 #endif 
142 
143     String data;
144     DynamicJsonBuffer jsonBuffer;
145     JsonObject& root = jsonBuffer\&.createObject();
146     if( !( root\&.success()) )
147     {
148     
149     #if DEBUG == 1 
150 
151         Serial\&.println( F("failed to create json") );
152     
153     #endif 
154 
155         return("");
156     }
157 
158         
159     if(waterTemp\&.active)
160     {
161         root["waterTemp"] = this->readTemp();
162 
163         if(phProbe\&.active)
164         {
165             root["ph"] =this->readPh( root["waterTemp"]\&.as<double>() ) ;
166         }
167 
168     }
169 
170     if(adc2\&.active)
171     {
172         root[adc2\&.type] =this->readADSChannel2(adc2\&.gain);
173     }
174     
175     root\&.printTo(data);
176     
177 #if DEBUG == 1 
178 
179     Serial\&.println( F("Irene data : ") );
180     Serial\&.println(data);
181     Serial\&.println();
182 
183     Serial\&.print(F("jsonBuffer size: "));
184     Serial\&.println(jsonBuffer\&.size());
185     Serial\&.println();
186 
187 
188 #endif
189     
190     return(data);
191     
192     
193 
194 }
.fi
.SS "int Irene3000::readADSChannel2 (\fBadsGain_t\fP gain)"
Irene3000::readADSChannel2(gain): This method is provided to read from the ADS channel 2 \&. ADS Channel 2 is free and the user can connect another analog sensor to it\&.
.PP
\fBReturns:\fP
.RS 4
the ADS Channel 2 value 
.RE
.PP

.PP
Definition at line 484 of file Irene3000\&.cpp\&.
.PP
.nf
485 { 
486 
487 #if DEBUG == 1 
488     
489     Serial\&.println( F("Entering Irene3000\&.readADSChannel2()") );
490     Serial\&.println();
491 
492 #endif
493 
494     this->setGain(gain);
495     int result = this->ads\&.readADC_SingleEnded(freeAdc);
496 #if DEBUG == 1 
497     
498     Serial\&.println( F("adc2 value : ") );
499     Serial\&.println( );
500     Serial\&.println();
501 
502 #endif
503 
504     return( result ) ;
505 }
.fi
.SS "int Irene3000::readButton ()"
\fBIrene3000::readButton()\fP: This method is provided to read the \fBIrene3000\fP button
.PP
\fBReturns:\fP
.RS 4
the button value 
.RE
.PP

.PP
Definition at line 434 of file Irene3000\&.cpp\&.
.PP
.nf
435 {
436 
437 #if DEBUG == 1 
438 
439     Serial\&.println( F("Entering Irene3000\&.readButton()" ) );
440     Serial\&.println();
441 
442 #endif 
443 
444     this->setGain(GAIN_TWOTHIRDS);
445     int result =this->ads\&.readADC_SingleEnded(button);
446 #if DEBUG == 1
447     
448     Serial\&.println( F("button value : ") );
449     Serial\&.println( result );
450 
451 #endif 
452 
453     return( result );
454     
455 }
.fi
.SS "float Irene3000::readPh (double t)"
\fBIrene3000::readPh(double t)\fP: This method is provided to read the PH probe note that for the best results, PH must be correlated to Temperature\&.
.PP
\fBReturns:\fP
.RS 4
the PH probe value 
.RE
.PP

.PP
Definition at line 515 of file Irene3000\&.cpp\&.
.PP
.nf
516 {
517 
518 #if DEBUG == 1 
519 
520     Serial\&.println( F("Entering Irene3000\&.readPh()") );
521     Serial\&.println();
522 
523 #endif 
524 
525     this->setGain(GAIN_FOUR);
526     int adcR=ads\&.readADC_SingleEnded(ph);
527     double Voltage =  REFERENCE_VOLTAGE_GAIN_4 * ( adcR ) / ADC_MAXIMUM_VALUE;
528 
529     float miliVolts = Voltage * 1000;
530     float temporary = ((((vRef * (float)params\&.pH7Cal) / 32767) * 1000) - miliVolts) / opampGain;
531     
532     float phT=7 - (temporary / params\&.pHStep);
533 
534     float ph25= ( phT / ( 1 + 0\&.009*( t - 25 ) ) );
535 
536 #if DEBUG == 1 
537 
538     Serial\&.println( F("ph is : ") );
539     Serial\&.println( phT ) ;
540     
541     Serial\&.println(F("corrected ph to 25°C is : "));
542     Serial\&.println(ph25);
543 
544 #endif 
545     if(isnan(ph25) )
546     {
547         return(-42);    
548     }
549 
550     return(ph25);
551 
552 }
.fi
.SS "double Irene3000::readTemp ()"
Irene3000::readTemp(gain): This method is provided to read the Temeperature probe
.PP
\fBReturns:\fP
.RS 4
the Temperature probe value 
.RE
.PP

.PP
Definition at line 561 of file Irene3000\&.cpp\&.
.PP
.nf
562 {
563 
564 #if DEBUG == 1 
565 
566     Serial\&.println( F("Entering Irene3000\&.readTemp()") );
567     Serial\&.println();
568 
569 #endif
570 
571     const double A = 3\&.9083E-3;
572     const double B = -5\&.775E-7;
573     double T;
574 
575     this->setGain(GAIN_EIGHT);
576 
577     double adc0 = ads\&.readADC_SingleEnded(temp);
578 
579 
580     double R = ( ( adc0 * V_GAIN_8 ) / 0\&.095 ) / 1000 ;
581 
582     T = 0\&.0 - A;
583     T += sqrt((A * A) - 4\&.0 * B * (1\&.0 - R));
584     T /= (2\&.0 * B);
585 
586     if (T > 0 && T < 200) 
587     {
588 
589     #if DEBUG == 1 
590 
591         Serial\&.print( F(" temperature : ") );
592         Serial\&.println(T);
593         Serial\&.println();
594     
595     #endif 
596         if(isnan(T))
597         {
598             return(-300);           
599         }
600 
601         return T;
602     }
603     else 
604     {
605         T = 0\&.0 - A;
606         T -= sqrt((A * A) - 4\&.0 * B * (1\&.0 - R));
607         T /= (2\&.0 * B);
608     
609     #if DEBUG == 1 
610     
611         Serial\&.println( F("temperature : ") );
612         Serial\&.println(T);
613         Serial\&.println();
614     
615     #endif
616         if(isnan(T))
617         {
618             return(-400);           
619         }
620 
621         return T;
622     }
623 
624 }
.fi
.SS "void Irene3000::resetParams (void)"
\fBIrene3000::resetParams()\fP: This method is provided to reset the PH configuration, assuming Ideal configuration 
.PP
Definition at line 706 of file Irene3000\&.cpp\&.
.PP
.nf
707 {
708 
709 #if DEBUG == 1 
710 
711     Serial\&.println( F("Entering Irene3000\&.resetParams()") );
712     Serial\&.println();
713 
714 #endif 
715 
716     //Restore to default set of parameters!
717     params\&.WriteCheck = Write_Check;
718     params\&.pH7Cal = 16384; //assume ideal probe and amp conditions 1/2 of 4096
719     params\&.pH4Cal = 8192; //using ideal probe slope we end up this many 12bit units away on the 4 scale
720     params\&.pHStep = 59\&.16;//ideal probe slope
721 
722 
723 }
.fi
.SS "bool Irene3000::saveParams ()"

.PP
Definition at line 757 of file Irene3000\&.cpp\&.
.PP
.nf
758 {
759 
760 #if DEBUG == 1
761         
762     Serial\&.println(F("Entering Irene3000\&.saveParams()"));
763     Serial\&.println();
764     
765     Serial\&.println(F("saving new params"));
766 #endif
767     
768     //open file
769     File irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "r");
770 
771     if (!irene3000Config) 
772     {
773     
774     #if DEBUG == 1 
775 
776         Serial\&.println( F("failed to read /irene3000Config\&.json") );
777         Serial\&.println();
778     
779     #endif
780 
781         return(false);
782     }
783     else
784     {
785         //read file into json
786         size_t size = irene3000Config\&.size();
787         // Allocate a buffer to store contents of the file\&.
788         std::unique_ptr<char[]> buf(new char[size]);
789             irene3000Config\&.readBytes(buf\&.get(), size);
790         DynamicJsonBuffer jsonBuffer;
791         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
792         if (!json\&.success()) 
793         {
794         
795         #if DEBUG == 1 
796 
797             Serial\&.println( F("failed to parse json ") );
798             Serial\&.println();
799         
800         #endif
801             
802             return(false);
803         } 
804         else
805         {
806         
807         #if DEBUG == 1 
808     
809             Serial\&.println( F("read configuration file ") );
810             json\&.printTo(Serial);
811             Serial\&.println();
812 
813             Serial\&.print(F("jsonBuffer size: "));
814             Serial\&.println(jsonBuffer\&.size());
815             Serial\&.println();
816 
817         
818 
819         #endif          
820     
821             //add params to json
822             json["pH7Cal"]=this->params\&.pH7Cal;
823             json["pH4Cal"]=this->params\&.pH4Cal;
824             json["pHStep"]=this->params\&.pHStep;          
825             
826             irene3000Config\&.close();
827             
828             
829             //save json to file
830             irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "w");
831 
832             if(!irene3000Config)
833             {
834             
835             #if DEBUG == 1
836 
837                 Serial\&.println( F("failed to write to /irene3000Config\&.json") );
838                 Serial\&.println();
839             
840             #endif 
841 
842                 return(false);
843             }
844 
845             json\&.printTo(irene3000Config);
846             irene3000Config\&.close();
847             
848         #if DEBUG == 1 
849 
850             Serial\&.println( F("saved configuration file :")  );
851             json\&.printTo(Serial);
852             Serial\&.println();
853         
854         #endif
855 
856             return(true); 
857         }
858     }   
859 
860 }
.fi
.SS "void Irene3000::setGain (\fBadsGain_t\fP gain)"
Irene3000::setGain(gain): This method is provided to set the ADS chip gain 
.PP
Definition at line 462 of file Irene3000\&.cpp\&.
.PP
.nf
463 {
464 
465 #if DEBUG == 1  
466 
467     Serial\&.println( F("Entering Irene3000\&.setGain()") );
468     Serial\&.println();
469 
470 #endif
471 
472     this->ads\&.setGain(gain);
473 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "struct \fBIrene3000::state\fP Irene3000::adc2\fC [private]\fP"

.SS "\fBAdafruit_ADS1115\fP Irene3000::ads\fC [private]\fP"
ADS1115 instance 
.PP
Definition at line 99 of file Irene3000\&.h\&.
.SS "const float Irene3000::opampGain = 5\&.25\fC [private]\fP"
opAmpGain constant used for ADC conversion 
.PP
Definition at line 144 of file Irene3000\&.h\&.
.SS "struct \fBIrene3000::parameters_T\fP Irene3000::params\fC [private]\fP"

.SS "struct \fBIrene3000::state\fP  Irene3000::phProbe\fC [private]\fP"

.SS "const float Irene3000::vRef = 1\&.024\fC [private]\fP"
vRef constant used for ADC conversion 
.PP
Definition at line 139 of file Irene3000\&.h\&.
.SS "struct \fBIrene3000::state\fP  Irene3000::waterTemp\fC [private]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
