.TH "Irene3000" 3 "Wed Aug 30 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Irene3000 \- This class is provided to manage the \fBIrene3000\fP Ph/Temperature Shield\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Irene3000\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBparameters_T\fP"
.br
.ti -1c
.RI "struct \fBstate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "int \fBreadButton\fP ()"
.br
.ti -1c
.RI "void \fBsetGain\fP (\fBadsGain_t\fP gain)"
.br
.ti -1c
.RI "int \fBreadADSChannel2\fP (\fBadsGain_t\fP gain)"
.br
.ti -1c
.RI "float \fBreadPh\fP (double t)"
.br
.ti -1c
.RI "double \fBreadTemp\fP ()"
.br
.ti -1c
.RI "void \fBresetParams\fP ()"
.br
.ti -1c
.RI "void \fBcalibratepH7\fP ()"
.br
.ti -1c
.RI "void \fBcalibratepH4\fP ()"
.br
.ti -1c
.RI "void \fBcalcpHSlope\fP ()"
.br
.ti -1c
.RI "\fBadsGain_t\fP \fBgainConvert\fP (uint16_t tempGain)"
.br
.ti -1c
.RI "bool \fBsaveParams\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBAdafruit_ADS1115\fP \fBads\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::parameters_T\fP \fBparams\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::state\fP \fBwaterTemp\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::state\fP \fBphProbe\fP"
.br
.ti -1c
.RI "struct \fBIrene3000::state\fP \fBadc2\fP"
.br
.ti -1c
.RI "const float \fBvRef\fP = 1\&.024"
.br
.ti -1c
.RI "const float \fBopampGain\fP = 5\&.25"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class is provided to manage the \fBIrene3000\fP Ph/Temperature Shield\&. 
.PP
Definition at line 58 of file Irene3000\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void Irene3000::begin (void)"
\fBIrene3000::begin()\fP: This method is provided to start the \fBIrene3000\fP 
.PP
Definition at line 51 of file irene3000\&.cpp\&.
.PP
.nf
52 {
53     this->ads\&.begin();
54 
55     delay(2000);
56 
57 #if DEBUG == 1 
58 
59 
60     Serial\&.println( F("Entering Irene3000\&.begin()") );
61     Serial\&.println();
62     
63     
64     
65 
66 #endif
67     Serial\&.println(F("Press the button to calibrate the Ph probe "));
68 
69     delay(2000);
70 
71     int bValue=this->readButton();
72     
73     while(bValue<500)
74     {
75         bValue=this->readButton();
76         delay(10);  
77     }
78 
79     if(  bValue > 20000 )
80     {
81     
82 
83         
84         Serial\&.println(F("calibrating the Ph probe " ) );
85         
86         Serial\&.println(F("ph7 calibration for 25 seconds"));
87         
88         delay(10000);
89         
90         this->calibratepH7();
91 
92         delay(15000);       
93     
94         this->calibratepH7();
95 
96         delay(1000);
97         Serial\&.println(F("ph 7 calibration ok"));
98         Serial\&.println();
99     
100 
101         Serial\&.println(F("ph 4 calibration for 25 seconds"));
102     
103         delay(10000);       
104 
105         this->calibratepH4();
106 
107         delay(15000);
108         
109         this->calibratepH4();
110     
111         delay(1000);        
112 
113         Serial\&.println(F("ph 4 calibration ok"));
114         Serial\&.println();
115     
116 
117 
118         this->saveParams();
119     
120     }
121 
122 }
.fi
.SS "void Irene3000::calcpHSlope ()"
Irene3000::calcpHSlop(): This method is provided to calculate th PH slope 
.PP
Definition at line 684 of file irene3000\&.cpp\&.
.PP
.nf
685 {
686 
687 #if DEBUG == 1 
688 
689     Serial\&.println( F("Entering Irene3000\&.calcpHSlope()") );
690     Serial\&.println();
691 
692 #endif 
693 
694     params\&.pHStep = ((((vRef * (float)(params\&.pH7Cal - params\&.pH4Cal)) / 32767) * 1000) / opampGain) / 3;
695 
696  
697 }
.fi
.SS "void Irene3000::calibratepH4 ()"
\fBIrene3000::calibratepH4()\fP: This method is provided to calibrate the PH probe to 4 
.PP
Definition at line 658 of file irene3000\&.cpp\&.
.PP
.nf
659 {
660 
661 #if DEBUG == 1 
662 
663     Serial\&.println( F("Entering Irene3000\&.calibraph4()") );
664     Serial\&.println();
665 
666 #endif 
667     delay(1000);
668 
669     this->setGain(GAIN_FOUR);
670 
671     this->params\&.pH4Cal =  ads\&.readADC_SingleEnded(ph);
672 
673     this->calcpHSlope();
674 
675 
676 
677 }
.fi
.SS "void Irene3000::calibratepH7 ()"
\fBIrene3000::calibratepH7()\fP: This method is provided to calibrate the PH probe to 7 
.PP
Definition at line 631 of file irene3000\&.cpp\&.
.PP
.nf
632 {
633 
634 #if DEBUG == 1 
635 
636     Serial\&.println( F("Entering Irene3000\&.calibratepH7() ") );
637     Serial\&.println();
638     
639     
640 
641 #endif 
642     delay(1000);
643 
644     this->setGain(GAIN_FOUR);
645         
646     this->params\&.pH7Cal = ads\&.readADC_SingleEnded(ph);
647  
648     this->calcpHSlope();
649 
650 
651 }
.fi
.SS "bool Irene3000::config ()"
\fBIrene3000::config()\fP: This method is provided to configure the \fBIrene3000\fP shield through a configuration file
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 202 of file irene3000\&.cpp\&.
.PP
.nf
203 {
204 
205 #if DEBUG == 1 
206 
207     Serial\&.println( F("Entering Irene3000\&.config()") );
208     Serial\&.println();
209 
210 #endif
211 
212     File irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "r");
213 
214     if (!irene3000Config) 
215     {
216     
217     #if DEBUG == 1 
218 
219         Serial\&.println( F("failed to read /irene3000Config\&.json") );
220         Serial\&.println();
221     
222     #endif
223 
224         return(false);
225     }
226     else
227     {
228         size_t size = irene3000Config\&.size();
229         // Allocate a buffer to store contents of the file\&.
230         std::unique_ptr<char[]> buf(new char[size]);
231             uint16_t tempGain;
232         irene3000Config\&.readBytes(buf\&.get(), size);
233         DynamicJsonBuffer jsonBuffer;
234         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
235         if (!json\&.success()) 
236         {
237         
238         #if DEBUG == 1 
239 
240             Serial\&.println( F("failed to parse json ") );
241             Serial\&.println();
242         
243         #endif
244             
245             return(false);
246         } 
247         else
248         {
249         
250         #if DEBUG == 1 
251     
252             Serial\&.println( F("read configuration file ") );
253             json\&.printTo(Serial);
254             Serial\&.println();
255 
256             Serial\&.print(F("jsonBuffer size: "));
257             Serial\&.println(jsonBuffer\&.size());
258             Serial\&.println();
259 
260         
261 
262         #endif          
263             if(json["waterTemp"]["active"]\&.success() )
264             {           
265                 this->waterTemp\&.active = json["waterTemp"]["active"]; 
266             }
267             else
268             {
269                 this->waterTemp\&.active=this->waterTemp\&.active;
270             }
271             json["waterTemp"]["active"]=this->waterTemp\&.active;
272 
273             
274             if(json["phProbe"]["active"]\&.success())
275             {
276                 this->phProbe\&.active=json["phProbe"]["active"];
277             }
278             else
279             {
280                 this->phProbe\&.active=this->phProbe\&.active;
281             }
282             json["phProbe"]["active"]=this->phProbe\&.active;
283 
284             
285             if(json["adc2"]["active"]\&.success() )
286             {
287                 this->adc2\&.active=json["adc2"]["active"];
288             }
289             else
290             {
291                 this->adc2\&.active=this->adc2\&.active;
292             }
293             json["adc2"]["active"]=this->adc2\&.active;
294 
295             
296             if(json["adc2"]["gain"]\&.success() )
297             {           
298                 tempGain=json["adc2"]["gain"];
299                 this->adc2\&.gain=this->gainConvert(tempGain);
300             }
301             else
302             {
303                 this->adc2\&.gain=this->adc2\&.gain;
304             }
305             json["adc2"]["gain"]=this->adc2\&.gain;
306 
307             
308             if(json["adc2"]["type"]\&.success() )
309             {
310                 this->adc2\&.type=json["adc2"]["type"]\&.as<String>(); 
311             }
312             else
313             {
314                 this->adc2\&.type=this->adc2\&.type;
315             }
316             json["adc2"]["type"]=this->adc2\&.type;
317 
318 
319             if(json["pH7Cal"]\&.success())
320             {
321                 this->params\&.pH7Cal=json["pH7Cal"];          
322             }
323             else
324             {
325                 this->params\&.pH7Cal=this->params\&.pH7Cal;
326             }
327             json["pH7Cal"]=this->params\&.pH7Cal;
328 
329             
330             if(json["pH4Cal"]\&.success())
331             {
332                 this->params\&.pH4Cal=json["pH4Cal"];          
333             }
334             else
335             {
336                 this->params\&.pH4Cal=this->params\&.pH4Cal;
337             }
338             json["pH4Cal"]=this->params\&.pH4Cal;
339 
340 
341             if(json["pHStep"]\&.success())
342             {
343                 this->params\&.pHStep=json["pHStep"];          
344             }
345             else
346             {
347                 this->params\&.pHStep=this->params\&.pHStep;
348             }
349             json["pHStep"]=this->params\&.pHStep;
350 
351 
352             irene3000Config\&.close();
353             irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "w");
354 
355             if(!irene3000Config)
356             {
357             
358             #if DEBUG == 1
359 
360                 Serial\&.println( F("failed to write to /irene3000Config\&.json") );
361                 Serial\&.println();
362             
363             #endif 
364 
365                 return(false);
366             }
367 
368             json\&.printTo(irene3000Config);
369             irene3000Config\&.close();
370             
371         #if DEBUG == 1 
372 
373             Serial\&.println( F("saved configuration file :")  );
374             json\&.printTo(Serial);
375             Serial\&.println();
376         
377         #endif
378 
379             return(true); 
380         }
381     }   
382 
383 }
.fi
.SS "\fBadsGain_t\fP Irene3000::gainConvert (uint16_t tempGain)"
\fBIrene3000::gainConvert\fP( gain : { 0\&.67 ,1,2,4,8,16 } ) This method is provided to convert the gain to Internal Constants
.PP
\fBReturns:\fP
.RS 4
internal representation of the ADS gain 
.RE
.PP

.PP
Definition at line 731 of file irene3000\&.cpp\&.
.PP
.nf
732 {
733 
734 #if DEBUG == 1 
735 
736     Serial\&.println( F("Entering Irene3000\&.gainConvert()") );
737     Serial\&.println();
738 
739 #endif 
740     
741     switch(tempGain)
742     {
743         case(1): return (GAIN_ONE);
744         case(2) : return(GAIN_TWO);
745         case(4): return(GAIN_FOUR) ;   
746         case(8):return(GAIN_EIGHT)  ;  
747         case(16):return(GAIN_SIXTEEN);
748         default: return(GAIN_TWOTHIRDS);    
749     }
750 
751     return(GAIN_ONE);
752 
753 }
.fi
.SS "void Irene3000::printConf ()"
\fBIrene3000::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 390 of file irene3000\&.cpp\&.
.PP
.nf
391 {
392 
393 #if DEBUG == 1 
394 
395     Serial\&.println( F("Entering Irene3000\&.printConf()") );
396     Serial\&.println();
397 
398 #endif 
399 
400     Serial\&.println("Irene Configuration ");
401 
402     Serial\&.print("waterTemp\&.active : ");
403     Serial\&.println(waterTemp\&.active);
404 
405     Serial\&.print("waterTemp\&.gain : ");
406     Serial\&.println(waterTemp\&.gain,HEX);   
407 
408     Serial\&.print("phProbe\&.active : ");
409     Serial\&.println(phProbe\&.active);
410 
411     Serial\&.print("phProbe\&.gain : ");
412     Serial\&.println(phProbe\&.gain,HEX);
413     
414     Serial\&.print("adc2\&.active : ");
415     Serial\&.println(adc2\&.active);
416 
417     Serial\&.print("adc2\&.gain : ");
418     Serial\&.println(adc2\&.gain,HEX);
419 
420     Serial\&.print("adc2\&.type : ");
421     Serial\&.println(adc2\&.type);
422 
423     Serial\&.println();
424 }
.fi
.SS "String Irene3000::read (void)"
\fBIrene3000\fP:\fBread()\fP: This method is provided to read the \fBIrene3000\fP sensors data
.PP
\fBReturns:\fP
.RS 4
json string of the sensors data 
.RE
.PP

.PP
Definition at line 132 of file irene3000\&.cpp\&.
.PP
.nf
133 {
134 
135 #if DEBUG == 1 
136     
137     Serial\&.println( F("Entering Irene3000\&.read()") );
138     Serial\&.println();
139 
140 #endif 
141 
142     String data;
143     DynamicJsonBuffer jsonBuffer;
144     JsonObject& root = jsonBuffer\&.createObject();
145     if( !( root\&.success()) )
146     {
147     
148     #if DEBUG == 1 
149 
150         Serial\&.println( F("failed to create json") );
151     
152     #endif 
153 
154         return("");
155     }
156 
157         
158     if(waterTemp\&.active)
159     {
160         root["waterTemp"] = this->readTemp();
161 
162         if(phProbe\&.active)
163         {
164             root["ph"] =this->readPh( root["waterTemp"]\&.as<double>() ) ;
165         }
166 
167     }
168 
169     if(adc2\&.active)
170     {
171         root[adc2\&.type] =this->readADSChannel2(adc2\&.gain);
172     }
173     
174     root\&.printTo(data);
175     
176 #if DEBUG == 1 
177 
178     Serial\&.println( F("Irene data : ") );
179     Serial\&.println(data);
180     Serial\&.println();
181 
182     Serial\&.print(F("jsonBuffer size: "));
183     Serial\&.println(jsonBuffer\&.size());
184     Serial\&.println();
185 
186 
187 #endif
188     
189     return(data);
190     
191     
192 
193 }
.fi
.SS "int Irene3000::readADSChannel2 (\fBadsGain_t\fP gain)"
Irene3000::readADSChannel2(gain): This method is provided to read from the ADS channel 2 \&. ADS Channel 2 is free and the user can connect another analog sensor to it\&.
.PP
\fBReturns:\fP
.RS 4
the ADS Channel 2 value 
.RE
.PP

.PP
Definition at line 483 of file irene3000\&.cpp\&.
.PP
.nf
484 { 
485 
486 #if DEBUG == 1 
487     
488     Serial\&.println( F("Entering Irene3000\&.readADSChannel2()") );
489     Serial\&.println();
490 
491 #endif
492 
493     this->setGain(gain);
494     int result = this->ads\&.readADC_SingleEnded(freeAdc);
495 #if DEBUG == 1 
496     
497     Serial\&.println( F("adc2 value : ") );
498     Serial\&.println( );
499     Serial\&.println();
500 
501 #endif
502 
503     return( result ) ;
504 }
.fi
.SS "int Irene3000::readButton ()"
\fBIrene3000::readButton()\fP: This method is provided to read the \fBIrene3000\fP button
.PP
\fBReturns:\fP
.RS 4
the button value 
.RE
.PP

.PP
Definition at line 433 of file irene3000\&.cpp\&.
.PP
.nf
434 {
435 
436 #if DEBUG == 1 
437 
438     Serial\&.println( F("Entering Irene3000\&.readButton()" ) );
439     Serial\&.println();
440 
441 #endif 
442 
443     this->setGain(GAIN_TWOTHIRDS);
444     int result =this->ads\&.readADC_SingleEnded(button);
445 #if DEBUG == 1
446     
447     Serial\&.println( F("button value : ") );
448     Serial\&.println( result );
449 
450 #endif 
451 
452     return( result );
453     
454 }
.fi
.SS "float Irene3000::readPh (double t)"
\fBIrene3000::readPh(double t)\fP: This method is provided to read the PH probe note that for the best results, PH must be correlated to Temperature\&.
.PP
\fBReturns:\fP
.RS 4
the PH probe value 
.RE
.PP

.PP
Definition at line 514 of file irene3000\&.cpp\&.
.PP
.nf
515 {
516 
517 #if DEBUG == 1 
518 
519     Serial\&.println( F("Entering Irene3000\&.readPh()") );
520     Serial\&.println();
521 
522 #endif 
523 
524     this->setGain(GAIN_FOUR);
525     int adcR=ads\&.readADC_SingleEnded(ph);
526     double Voltage =  REFERENCE_VOLTAGE_GAIN_4 * ( adcR ) / ADC_MAXIMUM_VALUE;
527 
528     float miliVolts = Voltage * 1000;
529     float temporary = ((((vRef * (float)params\&.pH7Cal) / 32767) * 1000) - miliVolts) / opampGain;
530     
531     float phT=7 - (temporary / params\&.pHStep);
532 
533     float ph25= ( phT / ( 1 + 0\&.009*( t - 25 ) ) );
534 
535 #if DEBUG == 1 
536 
537     Serial\&.println( F("ph is : ") );
538     Serial\&.println( phT ) ;
539     
540     Serial\&.println(F("corrected ph to 25°C is : "));
541     Serial\&.println(ph25);
542 
543 #endif 
544     if(isnan(ph25) )
545     {
546         return(-42);    
547     }
548 
549     return(ph25);
550 
551 }
.fi
.SS "double Irene3000::readTemp ()"
Irene3000::readTemp(gain): This method is provided to read the Temeperature probe
.PP
\fBReturns:\fP
.RS 4
the Temperature probe value 
.RE
.PP

.PP
Definition at line 560 of file irene3000\&.cpp\&.
.PP
.nf
561 {
562 
563 #if DEBUG == 1 
564 
565     Serial\&.println( F("Entering Irene3000\&.readTemp()") );
566     Serial\&.println();
567 
568 #endif
569 
570     const double A = 3\&.9083E-3;
571     const double B = -5\&.775E-7;
572     double T;
573 
574     this->setGain(GAIN_EIGHT);
575 
576     double adc0 = ads\&.readADC_SingleEnded(temp);
577 
578 
579     double R = ( ( adc0 * V_GAIN_8 ) / 0\&.095 ) / 1000 ;
580 
581     T = 0\&.0 - A;
582     T += sqrt((A * A) - 4\&.0 * B * (1\&.0 - R));
583     T /= (2\&.0 * B);
584 
585     if (T > 0 && T < 200) 
586     {
587 
588     #if DEBUG == 1 
589 
590         Serial\&.print( F(" temperature : ") );
591         Serial\&.println(T);
592         Serial\&.println();
593     
594     #endif 
595         if(isnan(T))
596         {
597             return(-300);           
598         }
599 
600         return T;
601     }
602     else 
603     {
604         T = 0\&.0 - A;
605         T -= sqrt((A * A) - 4\&.0 * B * (1\&.0 - R));
606         T /= (2\&.0 * B);
607     
608     #if DEBUG == 1 
609     
610         Serial\&.println( F("temperature : ") );
611         Serial\&.println(T);
612         Serial\&.println();
613     
614     #endif
615         if(isnan(T))
616         {
617             return(-400);           
618         }
619 
620         return T;
621     }
622 
623 }
.fi
.SS "void Irene3000::resetParams (void)"
\fBIrene3000::resetParams()\fP: This method is provided to reset the PH configuration, assuming Ideal configuration 
.PP
Definition at line 705 of file irene3000\&.cpp\&.
.PP
.nf
706 {
707 
708 #if DEBUG == 1 
709 
710     Serial\&.println( F("Entering Irene3000\&.resetParams()") );
711     Serial\&.println();
712 
713 #endif 
714 
715     //Restore to default set of parameters!
716     params\&.WriteCheck = Write_Check;
717     params\&.pH7Cal = 16384; //assume ideal probe and amp conditions 1/2 of 4096
718     params\&.pH4Cal = 8192; //using ideal probe slope we end up this many 12bit units away on the 4 scale
719     params\&.pHStep = 59\&.16;//ideal probe slope
720 
721 
722 }
.fi
.SS "bool Irene3000::saveParams ()"

.PP
Definition at line 756 of file irene3000\&.cpp\&.
.PP
.nf
757 {
758 
759 #if DEBUG == 1
760         
761     Serial\&.println(F("Entering Irene3000\&.saveParams()"));
762     Serial\&.println();
763     
764     Serial\&.println(F("saving new params"));
765 #endif
766     
767     //open file
768     File irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "r");
769 
770     if (!irene3000Config) 
771     {
772     
773     #if DEBUG == 1 
774 
775         Serial\&.println( F("failed to read /irene3000Config\&.json") );
776         Serial\&.println();
777     
778     #endif
779 
780         return(false);
781     }
782     else
783     {
784         //read file into json
785         size_t size = irene3000Config\&.size();
786         // Allocate a buffer to store contents of the file\&.
787         std::unique_ptr<char[]> buf(new char[size]);
788             irene3000Config\&.readBytes(buf\&.get(), size);
789         DynamicJsonBuffer jsonBuffer;
790         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
791         if (!json\&.success()) 
792         {
793         
794         #if DEBUG == 1 
795 
796             Serial\&.println( F("failed to parse json ") );
797             Serial\&.println();
798         
799         #endif
800             
801             return(false);
802         } 
803         else
804         {
805         
806         #if DEBUG == 1 
807     
808             Serial\&.println( F("read configuration file ") );
809             json\&.printTo(Serial);
810             Serial\&.println();
811 
812             Serial\&.print(F("jsonBuffer size: "));
813             Serial\&.println(jsonBuffer\&.size());
814             Serial\&.println();
815 
816         
817 
818         #endif          
819     
820             //add params to json
821             json["pH7Cal"]=this->params\&.pH7Cal;
822             json["pH4Cal"]=this->params\&.pH4Cal;
823             json["pHStep"]=this->params\&.pHStep;          
824             
825             irene3000Config\&.close();
826             
827             
828             //save json to file
829             irene3000Config = SPIFFS\&.open("/irene3000Config\&.json", "w");
830 
831             if(!irene3000Config)
832             {
833             
834             #if DEBUG == 1
835 
836                 Serial\&.println( F("failed to write to /irene3000Config\&.json") );
837                 Serial\&.println();
838             
839             #endif 
840 
841                 return(false);
842             }
843 
844             json\&.printTo(irene3000Config);
845             irene3000Config\&.close();
846             
847         #if DEBUG == 1 
848 
849             Serial\&.println( F("saved configuration file :")  );
850             json\&.printTo(Serial);
851             Serial\&.println();
852         
853         #endif
854 
855             return(true); 
856         }
857     }   
858 
859 }
.fi
.SS "void Irene3000::setGain (\fBadsGain_t\fP gain)"
Irene3000::setGain(gain): This method is provided to set the ADS chip gain 
.PP
Definition at line 461 of file irene3000\&.cpp\&.
.PP
.nf
462 {
463 
464 #if DEBUG == 1  
465 
466     Serial\&.println( F("Entering Irene3000\&.setGain()") );
467     Serial\&.println();
468 
469 #endif
470 
471     this->ads\&.setGain(gain);
472 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "struct \fBIrene3000::state\fP Irene3000::adc2\fC [private]\fP"

.SS "\fBAdafruit_ADS1115\fP Irene3000::ads\fC [private]\fP"
ADS1115 instance 
.PP
Definition at line 98 of file Irene3000\&.h\&.
.SS "const float Irene3000::opampGain = 5\&.25\fC [private]\fP"
opAmpGain constant used for ADC conversion 
.PP
Definition at line 143 of file Irene3000\&.h\&.
.SS "struct \fBIrene3000::parameters_T\fP Irene3000::params\fC [private]\fP"

.SS "struct \fBIrene3000::state\fP  Irene3000::phProbe\fC [private]\fP"

.SS "const float Irene3000::vRef = 1\&.024\fC [private]\fP"
vRef constant used for ADC conversion 
.PP
Definition at line 138 of file Irene3000\&.h\&.
.SS "struct \fBIrene3000::state\fP  Irene3000::waterTemp\fC [private]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
