.TH "CoolMQTT" 3 "Wed Aug 30 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CoolMQTT \- This class handles the mqtt client\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CoolMQTT\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "int \fBconnect\fP (unsigned long keepAlive)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data, unsigned long logInterval)"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "void \fBconfig\fP (const char \fBmqttServer\fP[], const char \fBinTopic\fP[], const char \fBoutTopic\fP[], const char \fBuser\fP[], int \fBbufferSize\fP)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBcallback\fP (char *topic, byte *payload, unsigned int length)"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "int \fBstate\fP ()"
.br
.ti -1c
.RI "bool \fBmqttLoop\fP ()"
.br
.ti -1c
.RI "String \fBgetUser\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char \fBmqttServer\fP [50] ={'0'}"
.br
.ti -1c
.RI "String \fBmsg\fP =''"
.br
.ti -1c
.RI "char \fBinTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBoutTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBuser\fP [50] ={'0'}"
.br
.ti -1c
.RI "int \fBbufferSize\fP =3000"
.br
.ti -1c
.RI "WiFiClient \fBespClient\fP"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP \fBclient\fP"
.br
.ti -1c
.RI "bool \fBnewMsg\fP =0"
.br
.ti -1c
.RI "unsigned long \fBpreviousLogTime\fP =0"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class handles the mqtt client\&. 
.PP
Definition at line 45 of file CoolMQTT\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void CoolMQTT::begin ()"
\fBCoolMQTT::begin()\fP: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size 
.PP
Definition at line 54 of file CoolMQTT\&.cpp\&.
.PP
.nf
55 { 
56 
57 #if DEBUG == 1 
58 
59     Serial\&.println( F("Entering CoolMQTT\&.begin()") );
60     Serial\&.println();
61 
62 #endif
63 
64     client\&.setClient(espClient);
65     client\&.setServer(mqttServer, 1883);  
66     client\&.setCallback([this] (char* topic, byte* payload, unsigned int length) { this->callback(topic, payload, length); });
67     client\&.setBufferSize((unsigned short)bufferSize);
68 
69 }
.fi
.SS "void CoolMQTT::callback (char * topic, byte * payload, unsigned int length)"
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic\&.
.PP
Arguments are automatically assigned in client\&.setCallback() 
.PP
Definition at line 310 of file CoolMQTT\&.cpp\&.
.PP
.nf
311 {
312 
313 #if DEBUG == 1
314 
315     Serial\&.println( F("Entering CoolMQTT\&.callback() ") );
316     Serial\&.println();
317 
318 #endif 
319 
320     if(this->newMsg==false)
321     {
322         char temp[length+1];
323 
324     #if DEBUG == 1
325 
326         Serial\&.println( F("received temp msg : ") );
327         
328     #endif
329         
330         for (unsigned int i = 0; i < length; i++) 
331         {
332             temp[i]=(char)payload[i];
333         
334         #if DEBUG == 1 
335 
336             Serial\&.print( (char)payload[i] );
337         
338         #endif
339 
340         }
341     
342     #if DEBUG == 1 
343 
344         Serial\&.println();
345         Serial\&.println( F("storing new message : ") );
346 
347         Serial\&.print(F("length : "));
348         Serial\&.println(length);
349         
350         Serial\&.print(F("size : "));
351         Serial\&.print(sizeof(payload));
352         Serial\&.println();
353     
354     #endif
355 
356         this->newMsg=true;
357 
358         temp[length+1]='\0';
359 
360         this->msg=String(temp);
361         this->msg\&.remove(length,1);
362     
363     #if DEBUG == 1 
364 
365         Serial\&.println( F("stored message : ") );
366         Serial\&.println(this->msg);
367     
368     #endif
369 
370     }
371     else
372     {
373     
374     #if DEBUG == 1
375 
376         Serial\&.println( F("did not read last message") );
377     
378     #endif 
379         
380     }
381 
382 }
.fi
.SS "void CoolMQTT::config (const char mqttServer[], const char inTopic[], const char outTopic[], const char user[], int bufferSize)"
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client 
.PP
Definition at line 627 of file CoolMQTT\&.cpp\&.
.PP
.nf
628 {
629 
630 #if DEBUG == 1
631 
632     Serial\&.println( F("Entering CoolMQTT\&.config() , no SPIFFS variant") );
633     Serial\&.println();
634 
635 #endif
636 
637     for(int i =0;i< 50 ;i++)
638     {
639         this->mqttServer[i]=mqttServer[i];
640         this->inTopic[i]=inTopic[i];
641         this->outTopic[i]=outTopic[i];
642         this->user[i]=user[i];
643     }
644     this->bufferSize=bufferSize;
645     
646 
647 }
.fi
.SS "bool CoolMQTT::config ()"
\fBCoolMQTT::config()\fP: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 430 of file CoolMQTT\&.cpp\&.
.PP
.nf
431 {
432 
433 #if DEBUG == 1 
434 
435     Serial\&.println( F("Entering CoolMQTT\&.config()") );
436     Serial\&.println();
437 
438 #endif
439 
440     //read config file
441     //update data
442     File configFile = SPIFFS\&.open("/mqttConfig\&.json", "r");
443 
444     if (!configFile) 
445     {
446     
447     #if DEBUG == 1 
448 
449         Serial\&.println( F("failed to read /mqttConfig\&.json") );
450         Serial\&.println();
451 
452     #endif
453 
454         return(false);
455     }
456     else
457     {
458         size_t size = configFile\&.size();
459         // Allocate a buffer to store contents of the file\&.
460         std::unique_ptr<char[]> buf(new char[size]);
461 
462         configFile\&.readBytes(buf\&.get(), size);
463         DynamicJsonBuffer jsonBuffer;
464         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
465         if (!json\&.success()) 
466         {
467         
468         #if DEBUG == 1 
469 
470             Serial\&.println( F("failed to parse json ") );
471             Serial\&.println();
472         
473         #endif
474             
475             return(false);
476         } 
477         else
478         {
479         
480         #if DEBUG == 1 
481         
482             Serial\&.println( F("configuration json is ") );
483             json\&.printTo(Serial);
484             Serial\&.println();
485 
486             Serial\&.print(F("jsonBuffer size: "));
487             Serial\&.println(jsonBuffer\&.size());
488             Serial\&.println();
489 
490 
491         #endif
492 
493             if(json["mqttServer"]\&.success() )
494             {           
495                 const char* tempmqttServer = json["mqttServer"]; 
496                 for(int i =0;i< 50 ;i++)
497                 {
498                     mqttServer[i]=tempmqttServer[i];
499                 }
500             }
501             else
502             {
503                 for(int i =0;i< 50 ;i++)
504                 {
505                     this->mqttServer[i]=this->mqttServer[i];
506                 }
507 
508             }
509             json["mqttServer"]=this->mqttServer;
510 
511             
512             if(json["inTopic"]\&.success() )
513             {
514                 const char* tempInTopic = json["inTopic"]; 
515                 for(int i =0;i< 50;i++)
516                 {
517                     inTopic[i]=tempInTopic[i];
518                 }
519             }
520             else
521             {
522                 String tempMAC = WiFi\&.macAddress();
523                 tempMAC\&.replace(":","");
524                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC\&.c_str());    
525             
526             #if DEBUG == 1              
527                 
528                 Serial\&.print( F("Set Incomming MQTT Channel to : ") );
529                 Serial\&.println(inTopic);
530             
531             #endif  
532 
533             }
534             json["inTopic"]=this->inTopic;
535             
536             
537             if(json["outTopic"]\&.success() )
538             {
539                 const char* tempOutTopic = json["outTopic"]; 
540                 for(int i =0;i<50;i++)
541                 {
542                     outTopic[i]=tempOutTopic[i];
543                 }
544             }
545             else
546             {
547                 String tempMAC = WiFi\&.macAddress();
548                 tempMAC\&.replace(":","");
549                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC\&.c_str());
550             
551             #if DEBUG == 1 
552 
553                 Serial\&.print( F("Set Outgoing MQTT Channel to : ") );
554                 Serial\&.println(outTopic);
555             
556             #endif
557 
558             }
559             json["outTopic"]=this->outTopic;
560         
561             
562             if(json["user"]\&.success() )
563             {               
564                 const char* tempUser = json["user"]; 
565                 for(int i =0;i<50;i++)
566                 {
567                     user[i]=tempUser[i];
568                 }
569             }
570             else
571             {
572                 for(int i=0;i<50;i++)
573                 {
574                     this->user[i]=this->user[i];
575                 }               
576             }
577             json["user"]=this->user;
578             
579             if(json["bufferSize"]\&.success() )
580             {
581                 int tempBufferSize = json["bufferSize"]; 
582                 bufferSize=tempBufferSize;
583             }
584             else
585             {
586                 this->bufferSize=this->bufferSize;
587             }
588             json["bufferSize"]=this->bufferSize;
589 
590             configFile\&.close();
591             configFile = SPIFFS\&.open("/mqttConfig\&.json", "w");
592             if(!configFile)
593             {
594             
595             #if DEBUG == 1 
596 
597                 Serial\&.println( F("failed to write to /mqttConfig\&.json") );
598             
599             #endif
600 
601                 return(false);              
602             }
603             
604             json\&.printTo(configFile);
605             configFile\&.close();
606 
607         #if DEBUG == 1 
608 
609             Serial\&.println( F("saved configuration is :") );
610             json\&.printTo(Serial);
611             Serial\&.println();
612         
613         #endif
614 
615             return(true); 
616         }
617     }   
618     
619 
620 }
.fi
.SS "int CoolMQTT::connect (unsigned long keepAlive)"
CoolMQTT::connect( time to keep the connection alive in seconds ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time\&.
.PP
\fBReturns:\fP
.RS 4
mqtt client state 
.RE
.PP

.PP
Definition at line 110 of file CoolMQTT\&.cpp\&.
.PP
.nf
111 {       
112 
113     int i=0;
114 
115 #if DEBUG == 1 
116 
117     Serial\&.println( F("Entering CoolMQTT\&.connect()") );
118 
119 #endif
120     Serial\&.println( F("MQTT connecting\&.\&.\&.") );
121     
122     while( ( !this->client\&.connected() ) && ( i<100 ) ) 
123     {
124         // Attempt to connect
125         if( this->client\&.connect( this-> user,keepAlive*10  ) )
126         {
127             client\&.subscribe( this->inTopic );
128 
129         #if DEBUG == 1 
130 
131             Serial\&.println( F(" subscribed , leavin ") ) ;
132         
133         #endif
134 
135             return( this->state() );
136         }
137 
138         else
139         {
140         
141         #if DEBUG == 1 
142 
143             Serial\&.println( F("not connected , retrying") );
144         
145         #endif
146 
147             
148         }
149 
150     delay(5);
151     i++;
152     }
153     if (state() == 0)
154     {
155         Serial\&.println( F("MQTT connected : OK") );
156         Serial\&.println();
157     }
158     else Serial\&.println( F("MQTT not jet connected\&.\&.\&."));
159     return( this->state() );
160 
161 }
.fi
.SS "String CoolMQTT::getUser ()"
\fBCoolMQTT::getUser()\fP: This method is provided to get the user name 
.PP
Definition at line 690 of file CoolMQTT\&.cpp\&.
.PP
.nf
691 {
692 
693 #if DEBUG == 1 
694     Serial\&.println( F("Entering CoolMQTT\&.getUser()") );
695     Serial\&.println();
696     
697     Serial\&.print( F("user : ") );
698     Serial\&.println(this->user);
699 
700 #endif
701 
702     return String(this->user);
703 }
.fi
.SS "bool CoolMQTT::mqttLoop ()"
\fBCoolMQTT::mqttLoop()\fP: This method is provided to allow the client to process the data
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 274 of file CoolMQTT\&.cpp\&.
.PP
.nf
275 {
276 
277     unsigned long lastTime=millis();
278 
279 #if DEBUG == 1
280 
281     Serial\&.println( F("Entering CoolMQTT\&.mqttLoop()") );
282     Serial\&.println();
283 
284 #endif  
285 
286     while( ( millis() - lastTime ) < 1000)
287     {
288         this->client\&.loop();
289         yield();
290     }
291 
292 #if DEBUG == 1 
293     
294     Serial\&.print( F("loop result : ") );
295     Serial\&.println( this->client\&.loop() );
296     Serial\&.println();
297 
298 #endif
299 
300     return( this->client\&.loop() );
301 }
.fi
.SS "void CoolMQTT::printConf ()"
\fBCoolMQTT::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 654 of file CoolMQTT\&.cpp\&.
.PP
.nf
655 {
656 
657 #if DEBUG == 1 
658 
659     Serial\&.println( F("Entering CoolMQTT\&.printConf()") );
660     Serial\&.println();    
661 
662 #endif
663     
664     Serial\&.println("MQTT configuration ");
665 
666     Serial\&.print("mqttServer : ");
667     Serial\&.println(this->mqttServer);
668 
669     Serial\&.print("inTopic : ");
670     Serial\&.println(this->inTopic);
671 
672     Serial\&.print("outTopic : ");
673     Serial\&.println(this->outTopic);
674 
675     Serial\&.print("user : ");
676     Serial\&.println(this->user);
677 
678     Serial\&.print("bufferSize : ");
679     Serial\&.println(this->bufferSize);
680 
681     Serial\&.println();
682 
683 
684 }
.fi
.SS "bool CoolMQTT::publish (const char * data)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 171 of file CoolMQTT\&.cpp\&.
.PP
.nf
172 {
173 
174 #if DEBUG == 1 
175 
176     Serial\&.println( F("Entering CoolMQTT\&.publish()") );
177     Serial\&.println();
178     //data is in JSON, publish it directly
179 
180     Serial\&.println( F("data to publish : ") );
181     Serial\&.println(data);
182     Serial\&.print( F("data size : ") );
183     Serial\&.println(strlen(data));
184 
185     Serial\&.println();
186 
187 #endif
188 #if DEBUG == 0
189     Serial\&.println( F("Publishing Message : "));
190     Serial\&.println(data);
191     Serial\&.println();
192 #endif
193 
194     bool pub=client\&.publish( this->outTopic,(byte*) data,strlen(data),false  );
195 
196 #if DEBUG == 1 
197 
198     Serial\&.print( F("success : ") );
199     Serial\&.println(pub); 
200 
201 #endif
202 #if DEBUG == 0
203     if (pub == 1)
204     {
205         Serial\&.println( F("Publish : OK"));
206     }
207     else Serial\&.println( F("Publish : FAIL!!!"));
208 #endif
209 
210     return(pub);
211 
212 }
.fi
.SS "bool CoolMQTT::publish (const char * data, unsigned long logInterval)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval in seconds
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 222 of file CoolMQTT\&.cpp\&.
.PP
.nf
223 {
224 
225 #if DEBUG == 1 
226 
227     Serial\&.println( F("Entering CoolMQTT\&.publish() every logInterval ") );
228     Serial\&.println();
229 
230 #endif 
231     //log interval is passed in seconds, logInterval*1000 = logInterval in ms
232     if( ( millis() - ( this->previousLogTime)  ) >= ( logInterval*1000 ) )
233     {
234     
235     #if DEBUG == 1
236 
237         Serial\&.println( F("log Interval has passed ") );
238         Serial\&.println();
239     
240     #endif
241 
242         this->publish(data);
243 
244         this->previousLogTime=millis();
245     
246     #if DEBUG == 1 
247 
248         Serial\&.print( F("last log time : ") );
249         Serial\&.println(this->previousLogTime);
250 
251     #endif
252 
253         return(true);
254     }
255 
256 #if DEBUG == 1 
257 
258     Serial\&.println( F("log Interval still didn't pass ") );  
259     Serial\&.println();
260 
261 #endif
262 
263     return(false);
264 }
.fi
.SS "String CoolMQTT::read ()"
\fBCoolMQTT::read()\fP: This method is provided to return the last read message\&. 
.PP
Definition at line 389 of file CoolMQTT\&.cpp\&.
.PP
.nf
390 { 
391 
392 #if DEBUG == 1 
393 
394     Serial\&.println( F("Entering CoolMQTT\&.read()") );
395     Serial\&.println();
396 
397 #endif 
398 
399     if(this->newMsg==true)
400     {
401         
402         this->newMsg=false;
403 
404 #if DEBUG == 1 
405         Serial\&.println( F("received new message") );
406         Serial\&.println( F("message : ") );
407         Serial\&.println(this->msg);
408         Serial\&.println();
409 
410 #endif
411 
412         return(this->msg);
413         
414     }
415     return("");
416 
417 }
.fi
.SS "int CoolMQTT::state ()"
\fBCoolMQTT::state()\fP: This method is provided to return the mqtt client's state\&. 
.PP
\fBReturns:\fP
.RS 4
mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect 
.RE
.PP

.PP
Definition at line 87 of file CoolMQTT\&.cpp\&.
.PP
.nf
88 {
89 
90 #if DEBUG == 1 
91 
92     Serial\&.println( F("Entering CoolMQTT\&.state()") );
93     Serial\&.println();    
94     Serial\&.print( F("state : ") );
95     Serial\&.println( this->client\&.state() );
96 
97 #endif
98     
99     return( this->client\&.state() );
100 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int CoolMQTT::bufferSize =3000\fC [private]\fP"
MQTT inner bufferSize 
.PP
Definition at line 104 of file CoolMQTT\&.h\&.
.SS "\fBCoolPubSubClient\fP CoolMQTT::client\fC [private]\fP"
MQTT Client instance 
.PP
Definition at line 114 of file CoolMQTT\&.h\&.
.SS "WiFiClient CoolMQTT::espClient\fC [private]\fP"
WifiClient instance 
.PP
Definition at line 109 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::inTopic[50] ={'0'}\fC [private]\fP"
MQTT Topic to subscribe/listen to 
.PP
Definition at line 89 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::mqttServer[50] ={'0'}\fC [private]\fP"
MQTT Server name/ip 
.PP
Definition at line 79 of file CoolMQTT\&.h\&.
.SS "String CoolMQTT::msg =''\fC [private]\fP"
String to store incoming messages 
.PP
Definition at line 84 of file CoolMQTT\&.h\&.
.SS "bool CoolMQTT::newMsg =0\fC [private]\fP"
new message flag 
.PP
Definition at line 119 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::outTopic[50] ={'0'}\fC [private]\fP"
MQTT topic to publish/write to 
.PP
Definition at line 94 of file CoolMQTT\&.h\&.
.SS "unsigned long CoolMQTT::previousLogTime =0\fC [private]\fP"
last time the Client sent a Message over MQTT in ms 
.PP
Definition at line 125 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::user[50] ={'0'}\fC [private]\fP"
MQTT user name 
.PP
Definition at line 99 of file CoolMQTT\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
