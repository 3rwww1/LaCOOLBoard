.TH "CoolMQTT" 3 "Wed Aug 30 2017" "CoolBoardAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CoolMQTT \- This class handles the mqtt client\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CoolMQTT\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "int \fBconnect\fP (unsigned long keepAlive)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data)"
.br
.ti -1c
.RI "bool \fBpublish\fP (const char *data, unsigned long logInterval)"
.br
.ti -1c
.RI "String \fBread\fP ()"
.br
.ti -1c
.RI "void \fBconfig\fP (const char \fBmqttServer\fP[], const char \fBinTopic\fP[], const char \fBoutTopic\fP[], const char \fBuser\fP[], int \fBbufferSize\fP)"
.br
.ti -1c
.RI "bool \fBconfig\fP ()"
.br
.ti -1c
.RI "void \fBcallback\fP (char *topic, byte *payload, unsigned int length)"
.br
.ti -1c
.RI "void \fBprintConf\fP ()"
.br
.ti -1c
.RI "int \fBstate\fP ()"
.br
.ti -1c
.RI "bool \fBmqttLoop\fP ()"
.br
.ti -1c
.RI "String \fBgetUser\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char \fBmqttServer\fP [50] ={'0'}"
.br
.ti -1c
.RI "String \fBmsg\fP =''"
.br
.ti -1c
.RI "char \fBinTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBoutTopic\fP [50] ={'0'}"
.br
.ti -1c
.RI "char \fBuser\fP [50] ={'0'}"
.br
.ti -1c
.RI "int \fBbufferSize\fP =3000"
.br
.ti -1c
.RI "WiFiClient \fBespClient\fP"
.br
.ti -1c
.RI "\fBCoolPubSubClient\fP \fBclient\fP"
.br
.ti -1c
.RI "bool \fBnewMsg\fP =0"
.br
.ti -1c
.RI "unsigned long \fBpreviousLogTime\fP =0"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class handles the mqtt client\&. 
.PP
Definition at line 44 of file CoolMQTT\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void CoolMQTT::begin ()"
\fBCoolMQTT::begin()\fP: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size 
.PP
Definition at line 53 of file CoolMQTT\&.cpp\&.
.PP
.nf
54 { 
55 
56 #if DEBUG == 1 
57 
58     Serial\&.println( F("Entering CoolMQTT\&.begin()") );
59     Serial\&.println();
60 
61 #endif
62 
63     client\&.setClient(espClient);
64     client\&.setServer(mqttServer, 1883);  
65     client\&.setCallback([this] (char* topic, byte* payload, unsigned int length) { this->callback(topic, payload, length); });
66     client\&.setBufferSize((unsigned short)bufferSize);
67 
68 }
.fi
.SS "void CoolMQTT::callback (char * topic, byte * payload, unsigned int length)"
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic\&.
.PP
Arguments are automatically assigned in client\&.setCallback() 
.PP
Definition at line 309 of file CoolMQTT\&.cpp\&.
.PP
.nf
310 {
311 
312 #if DEBUG == 1
313 
314     Serial\&.println( F("Entering CoolMQTT\&.callback() ") );
315     Serial\&.println();
316 
317 #endif 
318 
319     if(this->newMsg==false)
320     {
321         char temp[length+1];
322 
323     #if DEBUG == 1
324 
325         Serial\&.println( F("received temp msg : ") );
326         
327     #endif
328         
329         for (unsigned int i = 0; i < length; i++) 
330         {
331             temp[i]=(char)payload[i];
332         
333         #if DEBUG == 1 
334 
335             Serial\&.print( (char)payload[i] );
336         
337         #endif
338 
339         }
340     
341     #if DEBUG == 1 
342 
343         Serial\&.println();
344         Serial\&.println( F("storing new message : ") );
345 
346         Serial\&.print(F("length : "));
347         Serial\&.println(length);
348         
349         Serial\&.print(F("size : "));
350         Serial\&.print(sizeof(payload));
351         Serial\&.println();
352     
353     #endif
354 
355         this->newMsg=true;
356 
357         temp[length+1]='\0';
358 
359         this->msg=String(temp);
360         this->msg\&.remove(length,1);
361     
362     #if DEBUG == 1 
363 
364         Serial\&.println( F("stored message : ") );
365         Serial\&.println(this->msg);
366     
367     #endif
368 
369     }
370     else
371     {
372     
373     #if DEBUG == 1
374 
375         Serial\&.println( F("did not read last message") );
376     
377     #endif 
378         
379     }
380 
381 }
.fi
.SS "void CoolMQTT::config (const char mqttServer[], const char inTopic[], const char outTopic[], const char user[], int bufferSize)"
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client 
.PP
Definition at line 626 of file CoolMQTT\&.cpp\&.
.PP
.nf
627 {
628 
629 #if DEBUG == 1
630 
631     Serial\&.println( F("Entering CoolMQTT\&.config() , no SPIFFS variant") );
632     Serial\&.println();
633 
634 #endif
635 
636     for(int i =0;i< 50 ;i++)
637     {
638         this->mqttServer[i]=mqttServer[i];
639         this->inTopic[i]=inTopic[i];
640         this->outTopic[i]=outTopic[i];
641         this->user[i]=user[i];
642     }
643     this->bufferSize=bufferSize;
644     
645 
646 }
.fi
.SS "bool CoolMQTT::config ()"
\fBCoolMQTT::config()\fP: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 429 of file CoolMQTT\&.cpp\&.
.PP
.nf
430 {
431 
432 #if DEBUG == 1 
433 
434     Serial\&.println( F("Entering CoolMQTT\&.config()") );
435     Serial\&.println();
436 
437 #endif
438 
439     //read config file
440     //update data
441     File configFile = SPIFFS\&.open("/mqttConfig\&.json", "r");
442 
443     if (!configFile) 
444     {
445     
446     #if DEBUG == 1 
447 
448         Serial\&.println( F("failed to read /mqttConfig\&.json") );
449         Serial\&.println();
450 
451     #endif
452 
453         return(false);
454     }
455     else
456     {
457         size_t size = configFile\&.size();
458         // Allocate a buffer to store contents of the file\&.
459         std::unique_ptr<char[]> buf(new char[size]);
460 
461         configFile\&.readBytes(buf\&.get(), size);
462         DynamicJsonBuffer jsonBuffer;
463         JsonObject& json = jsonBuffer\&.parseObject(buf\&.get());
464         if (!json\&.success()) 
465         {
466         
467         #if DEBUG == 1 
468 
469             Serial\&.println( F("failed to parse json ") );
470             Serial\&.println();
471         
472         #endif
473             
474             return(false);
475         } 
476         else
477         {
478         
479         #if DEBUG == 1 
480         
481             Serial\&.println( F("configuration json is ") );
482             json\&.printTo(Serial);
483             Serial\&.println();
484 
485             Serial\&.print(F("jsonBuffer size: "));
486             Serial\&.println(jsonBuffer\&.size());
487             Serial\&.println();
488 
489 
490         #endif
491 
492             if(json["mqttServer"]\&.success() )
493             {           
494                 const char* tempmqttServer = json["mqttServer"]; 
495                 for(int i =0;i< 50 ;i++)
496                 {
497                     mqttServer[i]=tempmqttServer[i];
498                 }
499             }
500             else
501             {
502                 for(int i =0;i< 50 ;i++)
503                 {
504                     this->mqttServer[i]=this->mqttServer[i];
505                 }
506 
507             }
508             json["mqttServer"]=this->mqttServer;
509 
510             
511             if(json["inTopic"]\&.success() )
512             {
513                 const char* tempInTopic = json["inTopic"]; 
514                 for(int i =0;i< 50;i++)
515                 {
516                     inTopic[i]=tempInTopic[i];
517                 }
518             }
519             else
520             {
521                 String tempMAC = WiFi\&.macAddress();
522                 tempMAC\&.replace(":","");
523                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC\&.c_str());    
524             
525             #if DEBUG == 1              
526                 
527                 Serial\&.print( F("Set Incomming MQTT Channel to : ") );
528                 Serial\&.println(inTopic);
529             
530             #endif  
531 
532             }
533             json["inTopic"]=this->inTopic;
534             
535             
536             if(json["outTopic"]\&.success() )
537             {
538                 const char* tempOutTopic = json["outTopic"]; 
539                 for(int i =0;i<50;i++)
540                 {
541                     outTopic[i]=tempOutTopic[i];
542                 }
543             }
544             else
545             {
546                 String tempMAC = WiFi\&.macAddress();
547                 tempMAC\&.replace(":","");
548                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC\&.c_str());
549             
550             #if DEBUG == 1 
551 
552                 Serial\&.print( F("Set Outgoing MQTT Channel to : ") );
553                 Serial\&.println(outTopic);
554             
555             #endif
556 
557             }
558             json["outTopic"]=this->outTopic;
559         
560             
561             if(json["user"]\&.success() )
562             {               
563                 const char* tempUser = json["user"]; 
564                 for(int i =0;i<50;i++)
565                 {
566                     user[i]=tempUser[i];
567                 }
568             }
569             else
570             {
571                 for(int i=0;i<50;i++)
572                 {
573                     this->user[i]=this->user[i];
574                 }               
575             }
576             json["user"]=this->user;
577             
578             if(json["bufferSize"]\&.success() )
579             {
580                 int tempBufferSize = json["bufferSize"]; 
581                 bufferSize=tempBufferSize;
582             }
583             else
584             {
585                 this->bufferSize=this->bufferSize;
586             }
587             json["bufferSize"]=this->bufferSize;
588 
589             configFile\&.close();
590             configFile = SPIFFS\&.open("/mqttConfig\&.json", "w");
591             if(!configFile)
592             {
593             
594             #if DEBUG == 1 
595 
596                 Serial\&.println( F("failed to write to /mqttConfig\&.json") );
597             
598             #endif
599 
600                 return(false);              
601             }
602             
603             json\&.printTo(configFile);
604             configFile\&.close();
605 
606         #if DEBUG == 1 
607 
608             Serial\&.println( F("saved configuration is :") );
609             json\&.printTo(Serial);
610             Serial\&.println();
611         
612         #endif
613 
614             return(true); 
615         }
616     }   
617     
618 
619 }
.fi
.SS "int CoolMQTT::connect (unsigned long keepAlive)"
CoolMQTT::connect( time to keep the connection alive in seconds ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time\&.
.PP
\fBReturns:\fP
.RS 4
mqtt client state 
.RE
.PP

.PP
Definition at line 109 of file CoolMQTT\&.cpp\&.
.PP
.nf
110 {       
111 
112     int i=0;
113 
114 #if DEBUG == 1 
115 
116     Serial\&.println( F("Entering CoolMQTT\&.connect()") );
117 
118 #endif
119     Serial\&.println( F("MQTT connecting\&.\&.\&.") );
120     
121     while( ( !this->client\&.connected() ) && ( i<100 ) ) 
122     {
123         // Attempt to connect
124         if( this->client\&.connect( this-> user,keepAlive*10  ) )
125         {
126             client\&.subscribe( this->inTopic );
127 
128         #if DEBUG == 1 
129 
130             Serial\&.println( F(" subscribed , leavin ") ) ;
131         
132         #endif
133 
134             return( this->state() );
135         }
136 
137         else
138         {
139         
140         #if DEBUG == 1 
141 
142             Serial\&.println( F("not connected , retrying") );
143         
144         #endif
145 
146             
147         }
148 
149     delay(5);
150     i++;
151     }
152     if (state() == 0)
153     {
154         Serial\&.println( F("MQTT connected : OK") );
155         Serial\&.println();
156     }
157     else Serial\&.println( F("MQTT not jet connected\&.\&.\&."));
158     return( this->state() );
159 
160 }
.fi
.SS "String CoolMQTT::getUser ()"
\fBCoolMQTT::getUser()\fP: This method is provided to get the user name 
.PP
Definition at line 689 of file CoolMQTT\&.cpp\&.
.PP
.nf
690 {
691 
692 #if DEBUG == 1 
693     Serial\&.println( F("Entering CoolMQTT\&.getUser()") );
694     Serial\&.println();
695     
696     Serial\&.print( F("user : ") );
697     Serial\&.println(this->user);
698 
699 #endif
700 
701     return String(this->user);
702 }
.fi
.SS "bool CoolMQTT::mqttLoop ()"
\fBCoolMQTT::mqttLoop()\fP: This method is provided to allow the client to process the data
.PP
\fBReturns:\fP
.RS 4
true if successful,false otherwise 
.RE
.PP

.PP
Definition at line 273 of file CoolMQTT\&.cpp\&.
.PP
.nf
274 {
275 
276     unsigned long lastTime=millis();
277 
278 #if DEBUG == 1
279 
280     Serial\&.println( F("Entering CoolMQTT\&.mqttLoop()") );
281     Serial\&.println();
282 
283 #endif  
284 
285     while( ( millis() - lastTime ) < 1000)
286     {
287         this->client\&.loop();
288         yield();
289     }
290 
291 #if DEBUG == 1 
292     
293     Serial\&.print( F("loop result : ") );
294     Serial\&.println( this->client\&.loop() );
295     Serial\&.println();
296 
297 #endif
298 
299     return( this->client\&.loop() );
300 }
.fi
.SS "void CoolMQTT::printConf ()"
\fBCoolMQTT::printConf()\fP: This method is provided to print the configuration to the Serial Monitor 
.PP
Definition at line 653 of file CoolMQTT\&.cpp\&.
.PP
.nf
654 {
655 
656 #if DEBUG == 1 
657 
658     Serial\&.println( F("Entering CoolMQTT\&.printConf()") );
659     Serial\&.println();    
660 
661 #endif
662     
663     Serial\&.println("MQTT configuration ");
664 
665     Serial\&.print("mqttServer : ");
666     Serial\&.println(this->mqttServer);
667 
668     Serial\&.print("inTopic : ");
669     Serial\&.println(this->inTopic);
670 
671     Serial\&.print("outTopic : ");
672     Serial\&.println(this->outTopic);
673 
674     Serial\&.print("user : ");
675     Serial\&.println(this->user);
676 
677     Serial\&.print("bufferSize : ");
678     Serial\&.println(this->bufferSize);
679 
680     Serial\&.println();
681 
682 
683 }
.fi
.SS "bool CoolMQTT::publish (const char * data)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 170 of file CoolMQTT\&.cpp\&.
.PP
.nf
171 {
172 
173 #if DEBUG == 1 
174 
175     Serial\&.println( F("Entering CoolMQTT\&.publish()") );
176     Serial\&.println();
177     //data is in JSON, publish it directly
178 
179     Serial\&.println( F("data to publish : ") );
180     Serial\&.println(data);
181     Serial\&.print( F("data size : ") );
182     Serial\&.println(strlen(data));
183 
184     Serial\&.println();
185 
186 #endif
187 #if DEBUG == 0
188     Serial\&.println( F("Publishing Message : "));
189     Serial\&.println(data);
190     Serial\&.println();
191 #endif
192 
193     bool pub=client\&.publish( this->outTopic,(byte*) data,strlen(data),false  );
194 
195 #if DEBUG == 1 
196 
197     Serial\&.print( F("success : ") );
198     Serial\&.println(pub); 
199 
200 #endif
201 #if DEBUG == 0
202     if (pub == 1)
203     {
204         Serial\&.println( F("Publish : OK"));
205     }
206     else Serial\&.println( F("Publish : FAIL!!!"));
207 #endif
208 
209     return(pub);
210 
211 }
.fi
.SS "bool CoolMQTT::publish (const char * data, unsigned long logInterval)"
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval in seconds
.PP
\fBReturns:\fP
.RS 4
true if publish successful, false otherwise 
.RE
.PP

.PP
Definition at line 221 of file CoolMQTT\&.cpp\&.
.PP
.nf
222 {
223 
224 #if DEBUG == 1 
225 
226     Serial\&.println( F("Entering CoolMQTT\&.publish() every logInterval ") );
227     Serial\&.println();
228 
229 #endif 
230     //log interval is passed in seconds, logInterval*1000 = logInterval in ms
231     if( ( millis() - ( this->previousLogTime)  ) >= ( logInterval*1000 ) )
232     {
233     
234     #if DEBUG == 1
235 
236         Serial\&.println( F("log Interval has passed ") );
237         Serial\&.println();
238     
239     #endif
240 
241         this->publish(data);
242 
243         this->previousLogTime=millis();
244     
245     #if DEBUG == 1 
246 
247         Serial\&.print( F("last log time : ") );
248         Serial\&.println(this->previousLogTime);
249 
250     #endif
251 
252         return(true);
253     }
254 
255 #if DEBUG == 1 
256 
257     Serial\&.println( F("log Interval still didn't pass ") );  
258     Serial\&.println();
259 
260 #endif
261 
262     return(false);
263 }
.fi
.SS "String CoolMQTT::read ()"
\fBCoolMQTT::read()\fP: This method is provided to return the last read message\&. 
.PP
Definition at line 388 of file CoolMQTT\&.cpp\&.
.PP
.nf
389 { 
390 
391 #if DEBUG == 1 
392 
393     Serial\&.println( F("Entering CoolMQTT\&.read()") );
394     Serial\&.println();
395 
396 #endif 
397 
398     if(this->newMsg==true)
399     {
400         
401         this->newMsg=false;
402 
403 #if DEBUG == 1 
404         Serial\&.println( F("received new message") );
405         Serial\&.println( F("message : ") );
406         Serial\&.println(this->msg);
407         Serial\&.println();
408 
409 #endif
410 
411         return(this->msg);
412         
413     }
414     return("");
415 
416 }
.fi
.SS "int CoolMQTT::state ()"
\fBCoolMQTT::state()\fP: This method is provided to return the mqtt client's state\&. 
.PP
\fBReturns:\fP
.RS 4
mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect 
.RE
.PP

.PP
Definition at line 86 of file CoolMQTT\&.cpp\&.
.PP
.nf
87 {
88 
89 #if DEBUG == 1 
90 
91     Serial\&.println( F("Entering CoolMQTT\&.state()") );
92     Serial\&.println();    
93     Serial\&.print( F("state : ") );
94     Serial\&.println( this->client\&.state() );
95 
96 #endif
97     
98     return( this->client\&.state() );
99 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int CoolMQTT::bufferSize =3000\fC [private]\fP"
MQTT inner bufferSize 
.PP
Definition at line 103 of file CoolMQTT\&.h\&.
.SS "\fBCoolPubSubClient\fP CoolMQTT::client\fC [private]\fP"
MQTT Client instance 
.PP
Definition at line 113 of file CoolMQTT\&.h\&.
.SS "WiFiClient CoolMQTT::espClient\fC [private]\fP"
WifiClient instance 
.PP
Definition at line 108 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::inTopic[50] ={'0'}\fC [private]\fP"
MQTT Topic to subscribe/listen to 
.PP
Definition at line 88 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::mqttServer[50] ={'0'}\fC [private]\fP"
MQTT Server name/ip 
.PP
Definition at line 78 of file CoolMQTT\&.h\&.
.SS "String CoolMQTT::msg =''\fC [private]\fP"
String to store incoming messages 
.PP
Definition at line 83 of file CoolMQTT\&.h\&.
.SS "bool CoolMQTT::newMsg =0\fC [private]\fP"
new message flag 
.PP
Definition at line 118 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::outTopic[50] ={'0'}\fC [private]\fP"
MQTT topic to publish/write to 
.PP
Definition at line 93 of file CoolMQTT\&.h\&.
.SS "unsigned long CoolMQTT::previousLogTime =0\fC [private]\fP"
last time the Client sent a Message over MQTT in ms 
.PP
Definition at line 124 of file CoolMQTT\&.h\&.
.SS "char CoolMQTT::user[50] ={'0'}\fC [private]\fP"
MQTT user name 
.PP
Definition at line 98 of file CoolMQTT\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CoolBoardAPI from the source code\&.
