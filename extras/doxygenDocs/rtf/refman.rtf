{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment CoolBoardAPI }CoolBoardAPI}
{\comment Generated byDoxgyen. }
{\creatim \yr2017\mo8\dy30\hr9\min59\sec38}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt CoolBoardAPI}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Wed Aug 30 2017 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
README{\tc \v README}\par \pard\plain 
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 What is this repository for?} \par}
Quick summary :\par
{\b CoolBoard} API is a set of libraries and wrappers to simplify the access and usage of all the capabilites of the {\b CoolBoard}.\par
Version : 1.0\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 How do I get set up?} \par}
Configuration :\par
1/Download and Install the Arduino IDE ({\f2 https://www.arduino.cc/en/Main/Software} )\par
2/Download and Add the ESP8266 Hardware extension to Arduino ({\f2 https://github.com/esp8266/Arduino} )\par
3/Download and Add the {\b CoolBoard} Library set to the Arduino IDE :\par
a)First Method :\par
-Open the Arduino IDE\par
-Go to the "Sketch" Menu\par
-Include Library > Manage Libraries.\par
-Search for {\b CoolBoard}\par
-Install\par
-Restart Arduino IDE\par
b)Second Method (if you have a CoolBoard.zip file ):\par
-Open the Arduino IDE\par
-Go to the "Sketch" Menu\par
-Include Library > "Add .ZIP Library".\par
-Search for CoolBoard.zip\par
-Click Open\par
-Restart Arduino IDE\par
c)Third Method (if you have the bitbucket/github link):\par
-Open Arduino IDE > File > Preferences\par
-Check the "SketchBook Location" path\par
-Go to the Arduino/libraries folder (if it doesn't exist, create one )\par
-Clone the repo there ( git clone "bitbucket/github link" )\par
-Restart Arduino IDE\par
4/Download ESP8266FS Tool ({\f2 https://arduino-esp8266.readthedocs.io/en/latest/filesystem.html#uploading-files-to-file-system})\par
5/Optional but Heavily Recommended : Download the ESP8266 Exception Decoder ( download link :{\f2 https://github.com/me-no-dev/EspExceptionDecoder/releases/tag/1.0.6}) Install guide : {\f2 https://github.com/me-no-dev/EspExceptionDecoder}\par
Dependencies :\par
You need the following libraries to be able to use the {\b CoolBoard} API:\par
-ArduinoJson({\f2 https://github.com/bblanchon/ArduinoJson})\par
-NeoPixelBus({\f2 https://github.com/Makuna/NeoPixelBus})\par
-TimeLib({\f2 https://github.com/PaulStoffregen/Time})\par
-DS1337RTC({\f2 https://github.com/etrombly/DS1337RTC})\par
-DallasTemperature({\f2 https://github.com/milesburton/Arduino-Temperature-Control-Library})\par
Configuration Files :\par
-The {\b CoolBoard} API heavily uses the SPIFFS for storing and retreiving configuration and data files\par
This is a description of the configuration files and what are they used for :\par
1/coolBoardConfig.json :\par
logInterval: The time Interval to wait,in seconds, between two logs\par
ireneActive: Put this flag to 1(true) if you are using the {\b Irene3000} module\par
jetpackActive:Put this flag to 1(true) if you are using the {\b Jetpack} modue\par
externalSensorsActive: Put this flag to 1(true) if you are using a supported external Sensor\par
sleepActive: Put this flag to 1(true) if you want your {\b CoolBoard} to enable Sleep mode In Sleep Mode : your {\b CoolBoard} will do the following : -readSensors -activate Actors(if any) -log the data -check for updates -go to sleep for logInterval period of time\par
userActive:Put this flag to 1(true) if you want your {\b CoolBoard} to collect userData : userName {\b CoolBoard} MAC Address TimeStamp\par
manual /!\\ : Put this flag to 1(true) to control to turn on/off your actors and bypass your initial actors configuration {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid          Be Careful with this mode!!.\par
\par
         When this mode is actif , the CoolBoard will not restart automatically to apply any new configuration sent via\par
         the update method.\par
\par
         Restarting the coolBoard when in manual mode will deactivate all the actors!\par
\par
         Never forget to reset this to 0(false) to go back to normal mode!\par
}
\par
2/coolBoardLedConfig.json:\par
ledActive: Put this flag to 1(true) if you want to have Light Effects from the on Board LED\par
3/coolBoardSensorsConfig.json:\par
temperature : Put this flag to 1(true) if you want to collect the Temperature using the {\b BME280} Sensor\par
humidity : Put this flag to 1(true) if you want to collect the humidity using the {\b BME280} Sensor\par
pressure : Put this flag to 1(true) if you want to collect the pressure using the {\b BME280} Sensor\par
visible : Put this flag to 1(true) if you want to collect the visible light index using the SI114X Sensor\par
ir : Put this flag to 1(true) if you want to collect the infrared light index using the SI114X Sensor\par
uv : Put this flag to 1(true) if you want to collect the ultraviolet light index using the SI114X Sensor\par
vbat : Put this flag to 1(true) if you want to collect the battery voltage\par
soilMoisture : Put this flag to 1(true) if you want to collect the soil Moisture\par
4/externalSensorsConfig.json:\par
sensorsNumber: the number of supported external sensors you connect to the coolBoard\par
reference: the reference of a supported external sensor(e.g {\b NDIR_I2C} , DallasTemperature )\par
type: the type of the measurments you are making (e.g : co2, temperature,voltage ... )\par
address : the sensor's address , if it has one (e.g : {\b NDIR_I2C} CO2 sensor's address is 77 )\par
5/irene3000Config.json:\par
waterTemp.active: Put this flag to 1(true) in order to use the temperature sensor connected to the {\b Irene3000}\par
phProbe.active: Put this flag to 1(true) in order to use the ph sensor connected to the {\b Irene3000}\par
adc2.active: Put this flag to 1(true) in order to use the extra ADC input of the {\b Irene3000}\par
adc2.gain: this is the value of the gain applied to the extra ADC input of the {\b Irene3000}\par
adc2.type: the type of the measurments you are making (e.g : co2, temperature,voltage ... )\par
6/jetPackConfig.json and coolBoardActorConfig.json:\par
Act[i].actif: Put this flag to 1(true) in order to use the jetpack output N\'EF\'BF\'BDi (0..7)\par
Act[i].inverted:Put this flag to 1(true) if the actor is inverted (e.g : a cooler is activated when Temp>TempMax) Put this flag to 0(false) if the actor is notInverted(e.g : a heater is activated when Temp<TempMin)\par
Act[i].temporal:Put this flag to 1(true) if you want the actor to be actif of a period of time , then inactif for another period of time.\par
Act[i].type:["primaryType","secondaryType"] : this array contains the priamryType and the secondaryType of the actor -The primaryType is the type associated to the sensors. (e.g : primaryType : "Temperature" is associated to the sensor of type "Temperature"). -It can also be empty , in case of PURE temporal actors\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                              -The secondaryType is only used in temporal mode.\par
                                             it can be : -"" (empty):the actor will be on for a period of timeHigh ms\par
                                                                     the actor will be off for a period of timeLow ms\par
\par
                                                         -"hour" :the actor will be on when the Hour is equal or greater then hourHigh\par
                                                                  the actor will be off when the Hour is equal or greater then hourLow\par
\par
                                                         -"minute":the actor will be on when the Minute is equal or greater then minuteHigh\par
                                                                  :the actor will be off when the Minute is equal or greater then minuteLow\par
\par
                                                         -"hourMinute":the actor will be on when : Hour == hourHigh AND Minute >= minuteHigh\par
                                                                                                   Hour > hourHigh\par
                                                                       the actor will be off when : Hour == hourLow AND Minute >= minuteLow\par
                                                                                                    Hour>hourLow\par
\par
                                              /!\\ NOTE  that if both primaryType and secondaryType are valid : the actor will be in\par
                                                 mixed mode : it will need to valid both Time and measurment conditions to go on or off\par
\par
Act[i].low:[rangeLow,timeLow,hourLow,minuteLow] : this array contains the values previously described:\par
                                                  -rangeLow is the minimum of the range at which \par
                                                  to activate(deactivate in inverted mode) the actor\par
\par
                                                  -timeLow is the time spent off in temporal mode\par
\par
                                                  -hourLow is the hour to turn off the actor when secondaryType is hour or hourMinute\par
\par
                                                  -minuteLow is the minute to turn off the actor when secondaryType is minute or hourMinute\par
\par
\par
Act[i].high:[rangeHigh,timeHigh,hourHigh,minuteHigh]: this array contains the values previously described:\par
                                                  -rangeHigh is the maximum of the range at which \par
                                                  to deactivate(activate in inverted mode) the actor\par
\par
                                                  -timeHigh is the time spent on in temporal mode\par
\par
                                                  -hourHigh is the hour to turn on the actor when secondaryType is hour or hourMinute\par
\par
                                                  -minuteHigh is the minute to turn on the actor when secondaryType is minute or hourMinute\par
\par
\par
   Note that the coolBoardActorConfig.json contains only one Actor.\par
}
\par
7/mqttConfig.json:\par
mqttServer: This is the mqttServer (ip/url) address\par
user: This is the userId\par
bufferSize: This is the memory allocated to the mqtt buffer in bytes\par
inTopic : this is the topic that the coolBoard subscribes to (receives updates from )\par
outTopic : this is the topic that the coolBoard will publish to.\par
8/rtcConfig.json:\par
timeServer: NTP server ip address\par
localPort: port used to make the NTP request to update the time\par
9/wifiConfig.json:\par
wifiCount: the number of wifis saved in this configuration file\par
timeOut:access point timeout in seconds.\par
nomad: put this flag to 1(true) to activate nomad mode. in nomad mode : the coolBoard will only try to connect to known WiFis. if it fails it will NOT lunch the access point.\par
How to run the exemples : {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid -Open Arduino IDE \par
\par
-File > Exemples > CoolBoard\par
\par
-Select the Exemple you want\par
\par
-Flash it\par
\par
-Flash the SPIFFS ( this is only required for the CoolBoardExemple, CoolBoardFarmExemple and CoolBoardStationExemple)\par
\par
-Open The Serial Monitor\par
\par
-Sit back and Enjoy!\par
}
\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Contribution guidelines} \par}
For minor fixes of code and documentation, please go ahead and submit a pull request.\par
Larger changes (rewriting parts of existing code from scratch, adding new functions to the core, adding new libraries) should generally be discussed by opening an issue first.\par
Feature branches with lots of small commits (especially titled "oops", "fix typo", "forgot to add file", etc.) should be squashed before opening a pull request. At the same time, please refrain from putting multiple unrelated changes into a single pull request.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 License and credits} \par}
All files under src/internal are modified versions of existing libraries. All Credit of the original work goes to their respective authors.\par
All Other files are provided as is under the MIT license :\par
Copyright (c) 2017 La Cool Co SAS\par
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\par
We can only gurantee that we did our best to have everything working on our side.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Who do I talk to?} \par}
If you encounter a problem , have a good idea or just want to talk\par
Please open an issue, a pull request or send us an email :\par
La Cool Co {\f2 team@lacool.co} \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Adafruit_ADS1015\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Adafruit_ADS1115\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
CoolBoardSensors::airActive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
BaseExternalSensor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ExternalSensor< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensor< DallasTemperature >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensor< NDIR_I2C >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
BME280\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoard\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardActor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardLed\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardSensors\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolFileSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolMQTT\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolPubSubClient\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolSI114X\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolTime\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolWifi\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensors\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Irene3000\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Jetpack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardSensors::lightActive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NDIR_I2C\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Irene3000::parameters_T\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensors::sensor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SensorCalibration\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SensorSettings\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Irene3000::state\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Jetpack::state\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardActor::state\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
WiFiManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
WiFiManagerParameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Adafruit_ADS1015} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Adafruit_ADS1115} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardSensors::airActive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BaseExternalSensor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BME280} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoard} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardActor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardLed} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardSensors} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolFileSystem} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolMQTT} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolPubSubClient} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolSI114X} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolTime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolWifi} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensor< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensor< DallasTemperature >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensor< NDIR_I2C >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensors} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Irene3000} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Jetpack} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardSensors::lightActive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NDIR_I2C} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Irene3000::parameters_T} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensors::sensor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SensorCalibration} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SensorSettings} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Irene3000::state} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Jetpack::state} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardActor::state} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b WiFiManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b WiFiManagerParameter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/{\b parse.js} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/{\b template.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Adafruit_ADS1015 Class Reference\par \pard\plain 
{\tc\tcl2 \v Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\par
{
{\f2 #include <CoolAdafruit_ADS1015.h>}}\par
Inheritance diagram for Adafruit_ADS1015:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d7a/class_adafruit___a_d_s1015__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Adafruit_ADS1015:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d64/class_adafruit___a_d_s1015__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_ADS1015} (uint8_t i2cAddress={\b ADS1015_ADDRESS})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1015 class w/appropriate properties. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the HW (reads coefficients values, etc.) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b readADC_SingleEnded} (uint8_t channel)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a single-ended ADC reading from the specified channel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b readADC_Differential_0_1} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN0) and N (AIN1) input. Generates a signed value since the difference can be either positive or negative. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b readADC_Differential_2_3} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN2) and N (AIN3) input. Generates a signed value since the difference can be either positive or negative. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startComparator_SingleEnded} (uint8_t channel, int16_t threshold)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the comparator to operate in basic mode, causing the ALERT/RDY pin to assert (go from high to low) when the ADC value exceeds the specified threshold. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b getLastConversionResults} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In order to clear the comparator, we need to read the conversion results. This function reads the last conversion results without changing the config value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGain} ({\b adsGain_t} gain)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gain and input voltage range. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b getGain} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a gain and input voltage range. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b m_i2cAddress}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b m_conversionDelay}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b m_bitShift}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b m_gain}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 119 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Adafruit_ADS1015\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:Adafruit_ADS1015}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Adafruit_ADS1015::Adafruit_ADS1015 (uint8_t  {\i i2cAddress} = {\f2 {\b ADS1015_ADDRESS}})}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1015 class w/appropriate properties. }}\par
{
Definition at line 88 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    89 \{\par
   90    m_i2cAddress = i2cAddress;\par
   91    m_conversionDelay = ADS1015_CONVERSIONDELAY;\par
   92    m_bitShift = 4;\par
   93    m_gain = GAIN_TWOTHIRDS; /* +/- 6.144V range (limited to VDD +0.3V max!) */\par
   94 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_ADS1015::begin (void )}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the HW (reads coefficients values, etc.) }}\par
{
Definition at line 114 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114                              \{\par
  115   Wire.begin(2,14);\par
  116 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a6eba7c3cd854927f60883bb371e5faa6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getGain\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:getGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Adafruit_ADS1015::getGain (void )}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a gain and input voltage range. }}\par
{
Definition at line 133 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134 \{\par
  135   return m_gain;\par
  136 \}\par
}
}
{\xe \v getLastConversionResults\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:getLastConversionResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Adafruit_ADS1015::getLastConversionResults ()}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In order to clear the comparator, we need to read the conversion results. This function reads the last conversion results without changing the config value. }}\par
{
Definition at line 348 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   349 \{\par
  350   // Wait for the conversion to complete\par
  351   delay(m_conversionDelay);\par
  352 \par
  353   // Read the conversion results\par
  354   uint16_t res = readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;\par
  355   if (m_bitShift == 0)\par
  356   \{\par
  357     return (int16_t)res;\par
  358   \}\par
  359   else\par
  360   \{\par
  361     // Shift 12-bit results right 4 bits for the ADS1015,\par
  362     // making sure we keep the sign bit intact\par
  363     if (res > 0x07FF)\par
  364     \{\par
  365       // negative number - extend the sign to 16th bit\par
  366       res |= 0xF000;\par
  367     \}\par
  368     return (int16_t)res;\par
  369   \}\par
  370 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_ad8f36d80847020778425107f6451a8c2_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADC_Differential_0_1\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:readADC_Differential_0_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Adafruit_ADS1015::readADC_Differential_0_1 (void )}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN0) and N (AIN1) input. Generates a signed value since the difference can be either positive or negative. }}\par
{
Definition at line 199 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   199                                                    \{\par
  200   // Start with default values\par
  201   uint16_t config = ADS1015_REG_CONFIG_CQUE_NONE    | // Disable the comparator (default val)\par
  202                     ADS1015_REG_CONFIG_CLAT_NONLAT  | // Non-latching (default val)\par
  203                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  204                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  205                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  206                     ADS1015_REG_CONFIG_MODE_SINGLE;   // Single-shot mode (default)\par
  207 \par
  208   // Set PGA/voltage range\par
  209   config |= m_gain;\par
  210                     \par
  211   // Set channels\par
  212   config |= ADS1015_REG_CONFIG_MUX_DIFF_0_1;          // AIN0 = P, AIN1 = N\par
  213 \par
  214   // Set 'start single-conversion' bit\par
  215   config |= ADS1015_REG_CONFIG_OS_SINGLE;\par
  216 \par
  217   // Write config register to the ADC\par
  218   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  219 \par
  220   // Wait for the conversion to complete\par
  221   delay(m_conversionDelay);\par
  222 \par
  223   // Read the conversion results\par
  224   uint16_t res = readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;\par
  225   if (m_bitShift == 0)\par
  226   \{\par
  227     return (int16_t)res;\par
  228   \}\par
  229   else\par
  230   \{\par
  231     // Shift 12-bit results right 4 bits for the ADS1015,\par
  232     // making sure we keep the sign bit intact\par
  233     if (res > 0x07FF)\par
  234     \{\par
  235       // negative number - extend the sign to 16th bit\par
  236       res |= 0xF000;\par
  237     \}\par
  238     return (int16_t)res;\par
  239   \}\par
  240 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a56582333958e66efaccd3d4a8a47e3ff_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADC_Differential_2_3\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:readADC_Differential_2_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Adafruit_ADS1015::readADC_Differential_2_3 (void )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN2) and N (AIN3) input. Generates a signed value since the difference can be either positive or negative. }}\par
{
Definition at line 250 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   250                                                    \{\par
  251   // Start with default values\par
  252   uint16_t config = ADS1015_REG_CONFIG_CQUE_NONE    | // Disable the comparator (default val)\par
  253                     ADS1015_REG_CONFIG_CLAT_NONLAT  | // Non-latching (default val)\par
  254                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  255                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  256                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  257                     ADS1015_REG_CONFIG_MODE_SINGLE;   // Single-shot mode (default)\par
  258 \par
  259   // Set PGA/voltage range\par
  260   config |= m_gain;\par
  261 \par
  262   // Set channels\par
  263   config |= ADS1015_REG_CONFIG_MUX_DIFF_2_3;          // AIN2 = P, AIN3 = N\par
  264 \par
  265   // Set 'start single-conversion' bit\par
  266   config |= ADS1015_REG_CONFIG_OS_SINGLE;\par
  267 \par
  268   // Write config register to the ADC\par
  269   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  270 \par
  271   // Wait for the conversion to complete\par
  272   delay(m_conversionDelay);\par
  273 \par
  274   // Read the conversion results\par
  275   uint16_t res = readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;\par
  276   if (m_bitShift == 0)\par
  277   \{\par
  278     return (int16_t)res;\par
  279   \}\par
  280   else\par
  281   \{\par
  282     // Shift 12-bit results right 4 bits for the ADS1015,\par
  283     // making sure we keep the sign bit intact\par
  284     if (res > 0x07FF)\par
  285     \{\par
  286       // negative number - extend the sign to 16th bit\par
  287       res |= 0xF000;\par
  288     \}\par
  289     return (int16_t)res;\par
  290   \}\par
  291 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a38311881bcab46f7496c4bb6e4cad576_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADC_SingleEnded\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:readADC_SingleEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Adafruit_ADS1015::readADC_SingleEnded (uint8_t  {\i channel})}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a single-ended ADC reading from the specified channel. }}\par
{
Definition at line 143 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   143                                                               \{\par
  144   if (channel > 3)\par
  145   \{\par
  146     return 0;\par
  147   \}\par
  148   \par
  149   // Start with default values\par
  150   uint16_t config = ADS1015_REG_CONFIG_CQUE_NONE    | // Disable the comparator (default val)\par
  151                     ADS1015_REG_CONFIG_CLAT_NONLAT  | // Non-latching (default val)\par
  152                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  153                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  154                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  155                     ADS1015_REG_CONFIG_MODE_SINGLE;   // Single-shot mode (default)\par
  156 \par
  157   // Set PGA/voltage range\par
  158   config |= m_gain;\par
  159 \par
  160   // Set single-ended input channel\par
  161   switch (channel)\par
  162   \{\par
  163     case (0):\par
  164       config |= ADS1015_REG_CONFIG_MUX_SINGLE_0;\par
  165       break;\par
  166     case (1):\par
  167       config |= ADS1015_REG_CONFIG_MUX_SINGLE_1;\par
  168       break;\par
  169     case (2):\par
  170       config |= ADS1015_REG_CONFIG_MUX_SINGLE_2;\par
  171       break;\par
  172     case (3):\par
  173       config |= ADS1015_REG_CONFIG_MUX_SINGLE_3;\par
  174       break;\par
  175   \}\par
  176 \par
  177   // Set 'start single-conversion' bit\par
  178   config |= ADS1015_REG_CONFIG_OS_SINGLE;\par
  179 \par
  180   // Write config register to the ADC\par
  181   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  182 \par
  183   // Wait for the conversion to complete\par
  184   delay(m_conversionDelay);\par
  185 \par
  186   // Read the conversion results\par
  187   // Shift 12-bit results right 4 bits for the ADS1015\par
  188   return readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;  \par
  189 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a40f38b9e1f3ec397c0670dd632510235_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a40f38b9e1f3ec397c0670dd632510235_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setGain\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:setGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_ADS1015::setGain ({\b adsGain_t}  {\i gain})}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gain and input voltage range. }}\par
{
Definition at line 123 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   124 \{\par
  125   m_gain = gain;\par
  126 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a399441eace686975ff22937cbe45cc50_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startComparator_SingleEnded\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:startComparator_SingleEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_ADS1015::startComparator_SingleEnded (uint8_t  {\i channel}, int16_t  {\i threshold})}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the comparator to operate in basic mode, causing the ALERT/RDY pin to assert (go from high to low) when the ADC value exceeds the specified threshold. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will also set the ADC in continuous conversion mode. \par
}{
Definition at line 302 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   303 \{\par
  304   // Start with default values\par
  305   uint16_t config = ADS1015_REG_CONFIG_CQUE_1CONV   | // Comparator enabled and asserts on 1 match\par
  306                     ADS1015_REG_CONFIG_CLAT_LATCH   | // Latching mode\par
  307                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  308                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  309                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  310                     ADS1015_REG_CONFIG_MODE_CONTIN  | // Continuous conversion mode\par
  311                     ADS1015_REG_CONFIG_MODE_CONTIN;   // Continuous conversion mode\par
  312 \par
  313   // Set PGA/voltage range\par
  314   config |= m_gain;\par
  315                     \par
  316   // Set single-ended input channel\par
  317   switch (channel)\par
  318   \{\par
  319     case (0):\par
  320       config |= ADS1015_REG_CONFIG_MUX_SINGLE_0;\par
  321       break;\par
  322     case (1):\par
  323       config |= ADS1015_REG_CONFIG_MUX_SINGLE_1;\par
  324       break;\par
  325     case (2):\par
  326       config |= ADS1015_REG_CONFIG_MUX_SINGLE_2;\par
  327       break;\par
  328     case (3):\par
  329       config |= ADS1015_REG_CONFIG_MUX_SINGLE_3;\par
  330       break;\par
  331   \}\par
  332 \par
  333   // Set the high threshold register\par
  334   // Shift 12-bit results left 4 bits for the ADS1015\par
  335   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_HITHRESH, threshold << m_bitShift);\par
  336 \par
  337   // Write config register to the ADC\par
  338   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  339 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_aecd30775d943ea9d9cff0e3485926596_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_bitShift\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_bitShift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Adafruit_ADS1015::m_bitShift{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v m_conversionDelay\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_conversionDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Adafruit_ADS1015::m_conversionDelay{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v m_gain\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_gain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Adafruit_ADS1015::m_gain{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v m_i2cAddress\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_i2cAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Adafruit_ADS1015::m_i2cAddress{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Adafruit_ADS1115 Class Reference\par \pard\plain 
{\tc\tcl2 \v Adafruit_ADS1115}
{\xe \v Adafruit_ADS1115}
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
{
{\f2 #include <CoolAdafruit_ADS1015.h>}}\par
Inheritance diagram for Adafruit_ADS1115:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/de8/class_adafruit___a_d_s1115__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Adafruit_ADS1115:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/ddc/class_adafruit___a_d_s1115__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_ADS1115} (uint8_t i2cAddress={\b ADS1015_ADDRESS})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1115 class w/appropriate properties. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 143 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Adafruit_ADS1115\:Adafruit_ADS1115}
{\xe \v Adafruit_ADS1115\:Adafruit_ADS1115}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Adafruit_ADS1115::Adafruit_ADS1115 (uint8_t  {\i i2cAddress} = {\f2 {\b ADS1015_ADDRESS}})}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1115 class w/appropriate properties. }}\par
{
Definition at line 101 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   102 \{\par
  103    m_i2cAddress = i2cAddress;\par
  104    m_conversionDelay = ADS1115_CONVERSIONDELAY;\par
  105    m_bitShift = 0;\par
  106    m_gain = GAIN_TWOTHIRDS; /* +/- 6.144V range (limited to VDD +0.3V max!) */\par
  107 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardSensors::airActive Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive}
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
Collaboration diagram for CoolBoardSensors::airActive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d30/struct_cool_board_sensors_1_1air_active__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b temperature} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b humidity} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pressure} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b airActive} structure\par
set temperature to 1 to have temperature Readings\par
set humidity to 1 to have humidity Readings\par
set pressure to 1 to have pressure Readings \par
}{
Definition at line 123 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v humidity\:CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive\:humidity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::airActive::humidity =0}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolBoardSensors.h.}\par
}
{\xe \v pressure\:CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive\:pressure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::airActive::pressure =0}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file CoolBoardSensors.h.}\par
}
{\xe \v temperature\:CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive\:temperature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::airActive::temperature =0}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BaseExternalSensor Class Reference\par \pard\plain 
{\tc\tcl2 \v BaseExternalSensor}
{\xe \v BaseExternalSensor}
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for BaseExternalSensor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d26/class_base_external_sensor__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for BaseExternalSensor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc4/class_base_external_sensor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BaseExternalSensor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism. \par
}{
Definition at line 50 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BaseExternalSensor\:BaseExternalSensor}
{\xe \v BaseExternalSensor\:BaseExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BaseExternalSensor::BaseExternalSensor (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b BaseExternalSensor()}: Base class generic Constructor \par
}{
Definition at line 58 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59     \{\par
   60 \par
   61     #if DEBUGExternal == 1 \par
   62 \par
   63         Serial.println( "BaseExternalSensor Constructor" );\par
   64         Serial.println();\par
   65     \par
   66     #endif\par
   67 \par
   68     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:BaseExternalSensor}
{\xe \v BaseExternalSensor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t BaseExternalSensor::begin (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b begin()}: Base class virtual generic begin method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid generic value as it's not supposed to be used \par
}}{
Reimplemented in {\b ExternalSensor< DallasTemperature >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b ExternalSensor< NDIR_I2C >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b ExternalSensor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 78 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    79     \{\par
   80     \par
   81     #if DEBUGExternal == 1 \par
   82     \par
   83         Serial.println( "BaseExternalSensor.begin()" );\par
   84         Serial.println();\par
   85     \par
   86     #endif\par
   87 \par
   88         return(-2);\par
   89     \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d68/class_base_external_sensor_a87d132803d4f4fdd4e66332809f0c9a0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:BaseExternalSensor}
{\xe \v BaseExternalSensor\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float BaseExternalSensor::read (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b read()}: Base class virtual generic read method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid generic value as it is not supposed to be used \par
}}{
Reimplemented in {\b ExternalSensor< DallasTemperature >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b ExternalSensor< NDIR_I2C >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b ExternalSensor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 100 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101     \{\par
  102     \par
  103     #if DEBUGExternal == 1 \par
  104 \par
  105         Serial.println( "BaseExternalSensor.read()" );\par
  106         Serial.println();\par
  107     \par
  108     #endif      \par
  109         \par
  110         return(-2);\par
  111     \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d68/class_base_external_sensor_a1564f16deacf57b51b9948ac29db4291_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BME280 Class Reference\par \pard\plain 
{\tc\tcl2 \v BME280}
{\xe \v BME280}
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
\par
{
{\f2 #include <CoolSparkFunBME280.h>}}\par
Collaboration diagram for BME280:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d82/class_b_m_e280__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BME280} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b begin} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatPressure} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatAltitudeMeters} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatAltitudeFeet} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatHumidity} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readTempC} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readTempF} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readRegisterRegion} (uint8_t *, uint8_t, uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b readRegister} (uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b readRegisterInt16} (uint8_t offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeRegister} (uint8_t, uint8_t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SensorSettings} {\b settings}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SensorCalibration} {\b calibration}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b t_fine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 143 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BME280\:BME280}
{\xe \v BME280\:BME280}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BME280::BME280 (void )}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     //Construct with these default settings if nothing is specified\par
   46 \par
   47     //Select interface mode\par
   48     settings.commInterface = I2C_MODE; //Can be I2C_MODE, SPI_MODE\par
   49     //Select address for I2C.  Does nothing for SPI\par
   50     settings.I2CAddress = 0x77; //Ignored for SPI_MODE\par
   51     //Select CS pin for SPI.  Does nothing for I2C\par
   52     settings.chipSelectPin = 10;\par
   53     settings.runMode = 0;\par
   54     settings.tempOverSample = 0;\par
   55     settings.pressOverSample = 0;\par
   56     settings.humidOverSample = 0;\par
   57 \par
   58 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:BME280}
{\xe \v BME280\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BME280::begin (void )}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     //Check the settings structure values to determine how to setup the device\par
   73     uint8_t dataToWrite = 0;  //Temporary variable\par
   74 \par
   75     switch (settings.commInterface)\par
   76     \{\par
   77 \par
   78     case I2C_MODE:\par
   79         Wire.begin(2,14);\par
   80         break;\par
   81 \par
   82     case SPI_MODE:\par
   83         // start the SPI library:\par
   84         SPI.begin();\par
   85         // Maximum SPI frequency is 10MHz, could divide by 2 here:\par
   86         SPI.setClockDivider(SPI_CLOCK_DIV32);\par
   87         // Data is read and written MSb first.\par
   88         SPI.setBitOrder(MSBFIRST);\par
   89         // Data is captured on rising edge of clock (CPHA = 0)\par
   90         // Base value of the clock is HIGH (CPOL = 1)\par
   91         // This was SPI_MODE3 for RedBoard, but I had to change to\par
   92         // MODE0 for Teensy 3.1 operation\par
   93         SPI.setDataMode(SPI_MODE3);\par
   94         // initalize the  data ready and chip select pins:\par
   95         pinMode(settings.chipSelectPin, OUTPUT);\par
   96         digitalWrite(settings.chipSelectPin, HIGH);\par
   97         break;\par
   98 \par
   99     default:\par
  100         break;\par
  101     \}\par
  102 \par
  103     //Reading all compensation data, range 0x88:A1, 0xE1:E7\par
  104     \par
  105     calibration.dig_T1 = ((uint16_t)((readRegister(BME280_DIG_T1_MSB_REG) << 8) + readRegister(BME280_DIG_T1_LSB_REG)));\par
  106     calibration.dig_T2 = ((int16_t)((readRegister(BME280_DIG_T2_MSB_REG) << 8) + readRegister(BME280_DIG_T2_LSB_REG)));\par
  107     calibration.dig_T3 = ((int16_t)((readRegister(BME280_DIG_T3_MSB_REG) << 8) + readRegister(BME280_DIG_T3_LSB_REG)));\par
  108 \par
  109     calibration.dig_P1 = ((uint16_t)((readRegister(BME280_DIG_P1_MSB_REG) << 8) + readRegister(BME280_DIG_P1_LSB_REG)));\par
  110     calibration.dig_P2 = ((int16_t)((readRegister(BME280_DIG_P2_MSB_REG) << 8) + readRegister(BME280_DIG_P2_LSB_REG)));\par
  111     calibration.dig_P3 = ((int16_t)((readRegister(BME280_DIG_P3_MSB_REG) << 8) + readRegister(BME280_DIG_P3_LSB_REG)));\par
  112     calibration.dig_P4 = ((int16_t)((readRegister(BME280_DIG_P4_MSB_REG) << 8) + readRegister(BME280_DIG_P4_LSB_REG)));\par
  113     calibration.dig_P5 = ((int16_t)((readRegister(BME280_DIG_P5_MSB_REG) << 8) + readRegister(BME280_DIG_P5_LSB_REG)));\par
  114     calibration.dig_P6 = ((int16_t)((readRegister(BME280_DIG_P6_MSB_REG) << 8) + readRegister(BME280_DIG_P6_LSB_REG)));\par
  115     calibration.dig_P7 = ((int16_t)((readRegister(BME280_DIG_P7_MSB_REG) << 8) + readRegister(BME280_DIG_P7_LSB_REG)));\par
  116     calibration.dig_P8 = ((int16_t)((readRegister(BME280_DIG_P8_MSB_REG) << 8) + readRegister(BME280_DIG_P8_LSB_REG)));\par
  117     calibration.dig_P9 = ((int16_t)((readRegister(BME280_DIG_P9_MSB_REG) << 8) + readRegister(BME280_DIG_P9_LSB_REG)));\par
  118 \par
  119     calibration.dig_H1 = ((uint8_t)(readRegister(BME280_DIG_H1_REG)));\par
  120     calibration.dig_H2 = ((int16_t)((readRegister(BME280_DIG_H2_MSB_REG) << 8) + readRegister(BME280_DIG_H2_LSB_REG)));\par
  121     calibration.dig_H3 = ((uint8_t)(readRegister(BME280_DIG_H3_REG)));\par
  122     calibration.dig_H4 = ((int16_t)((readRegister(BME280_DIG_H4_MSB_REG) << 4) + (readRegister(BME280_DIG_H4_LSB_REG) & 0x0F)));\par
  123     calibration.dig_H5 = ((int16_t)((readRegister(BME280_DIG_H5_MSB_REG) << 4) + ((readRegister(BME280_DIG_H4_LSB_REG) >> 4) & 0x0F)));\par
  124     calibration.dig_H6 = ((uint8_t)readRegister(BME280_DIG_H6_REG));\par
  125 \par
  126     //Set the oversampling control words.\par
  127     //config will only be writeable in sleep mode, so first insure that.\par
  128     writeRegister(BME280_CTRL_MEAS_REG, 0x00);\par
  129     \par
  130     //Set the config word\par
  131     dataToWrite = (settings.tStandby << 0x5) & 0xE0;\par
  132     dataToWrite |= (settings.filter << 0x02) & 0x1C;\par
  133     writeRegister(BME280_CONFIG_REG, dataToWrite);\par
  134     \par
  135     //Set ctrl_hum first, then ctrl_meas to activate ctrl_hum\par
  136     dataToWrite = settings.humidOverSample & 0x07; //all other bits can be ignored\par
  137     writeRegister(BME280_CTRL_HUMIDITY_REG, dataToWrite);\par
  138     \par
  139     //set ctrl_meas\par
  140     //First, set temp oversampling\par
  141     dataToWrite = (settings.tempOverSample << 0x5) & 0xE0;\par
  142     //Next, pressure oversampling\par
  143     dataToWrite |= (settings.pressOverSample << 0x02) & 0x1C;\par
  144     //Last, set mode\par
  145     dataToWrite |= (settings.runMode) & 0x03;\par
  146     //Load the byte\par
  147     writeRegister(BME280_CTRL_MEAS_REG, dataToWrite);\par
  148     \par
  149     return readRegister(0xD0);\par
  150 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a994c102f010547f9c740a338ef9905c7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a994c102f010547f9c740a338ef9905c7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatAltitudeFeet\:BME280}
{\xe \v BME280\:readFloatAltitudeFeet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatAltitudeFeet (void )}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 201 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   202 \{\par
  203     float heightOutput = 0;\par
  204     \par
  205     heightOutput = readFloatAltitudeMeters() * 3.28084;\par
  206     return heightOutput;\par
  207     \par
  208 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a6525c8a26f887b52596c86bed99343cb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatAltitudeMeters\:BME280}
{\xe \v BME280\:readFloatAltitudeMeters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatAltitudeMeters (void )}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194     float heightOutput = 0;\par
  195     \par
  196     heightOutput = ((float)-45846.2)*(pow(((float)readFloatPressure()/(float)101325), 0.190263) - (float)1);\par
  197     return heightOutput;\par
  198     \par
  199 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_af67b56ba50760ee1d116acc6c5010221_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_af67b56ba50760ee1d116acc6c5010221_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatHumidity\:BME280}
{\xe \v BME280\:readFloatHumidity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatHumidity (void )}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 215 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   216 \{\par
  217     \par
  218     // Returns humidity in %RH as unsigned 32 bit integer in Q22. 10 format (22 integer and 10 fractional bits).\par
  219     // Output value of \'9347445\'94 represents 47445/1024 = 46. 333 %RH\par
  220     int32_t adc_H = ((uint32_t)readRegister(BME280_HUMIDITY_MSB_REG) << 8) | ((uint32_t)readRegister(BME280_HUMIDITY_LSB_REG));\par
  221     \par
  222     int32_t var1;\par
  223     var1 = (t_fine - ((int32_t)76800));\par
  224     var1 = (((((adc_H << 14) - (((int32_t)calibration.dig_H4) << 20) - (((int32_t)calibration.dig_H5) * var1)) +\par
  225     ((int32_t)16384)) >> 15) * (((((((var1 * ((int32_t)calibration.dig_H6)) >> 10) * (((var1 * ((int32_t)calibration.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) + ((int32_t)2097152)) *\par
  226     ((int32_t)calibration.dig_H2) + 8192) >> 14));\par
  227     var1 = (var1 - (((((var1 >> 15) * (var1 >> 15)) >> 7) * ((int32_t)calibration.dig_H1)) >> 4));\par
  228     var1 = (var1 < 0 ? 0 : var1);\par
  229     var1 = (var1 > 419430400 ? 419430400 : var1);\par
  230 \par
  231     return (float)(var1>>12) / 1024.0;\par
  232 \par
  233 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a42ea7232039eebf5aadb391ef6132c35_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a42ea7232039eebf5aadb391ef6132c35_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatPressure\:BME280}
{\xe \v BME280\:readFloatPressure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatPressure (void )}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 164 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166 \par
  167     // Returns pressure in Pa as unsigned 32 bit integer in Q24.8 format (24 integer bits and 8 fractional bits).\par
  168     // Output value of \'9324674867\'94 represents 24674867/256 = 96386.2 Pa = 963.862 hPa\par
  169     int32_t adc_P = ((uint32_t)readRegister(BME280_PRESSURE_MSB_REG) << 12) | ((uint32_t)readRegister(BME280_PRESSURE_LSB_REG) << 4) | ((readRegister(BME280_PRESSURE_XLSB_REG) >> 4) & 0x0F);\par
  170     \par
  171     int64_t var1, var2, p_acc;\par
  172     var1 = ((int64_t)t_fine) - 128000;\par
  173     var2 = var1 * var1 * (int64_t)calibration.dig_P6;\par
  174     var2 = var2 + ((var1 * (int64_t)calibration.dig_P5)<<17);\par
  175     var2 = var2 + (((int64_t)calibration.dig_P4)<<35);\par
  176     var1 = ((var1 * var1 * (int64_t)calibration.dig_P3)>>8) + ((var1 * (int64_t)calibration.dig_P2)<<12);\par
  177     var1 = (((((int64_t)1)<<47)+var1))*((int64_t)calibration.dig_P1)>>33;\par
  178     if (var1 == 0)\par
  179     \{\par
  180         return 0; // avoid exception caused by division by zero\par
  181     \}\par
  182     p_acc = 1048576 - adc_P;\par
  183     p_acc = (((p_acc<<31) - var2)*3125)/var1;\par
  184     var1 = (((int64_t)calibration.dig_P9) * (p_acc>>13) * (p_acc>>13)) >> 25;\par
  185     var2 = (((int64_t)calibration.dig_P8) * p_acc) >> 19;\par
  186     p_acc = ((p_acc + var1 + var2) >> 8) + (((int64_t)calibration.dig_P7)<<4);\par
  187     \par
  188     return (float)p_acc / 256.0;\par
  189     \par
  190 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_ada6e799917afb4f228e6253bc56ffe75_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_ada6e799917afb4f228e6253bc56ffe75_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegister\:BME280}
{\xe \v BME280\:readRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BME280::readRegister (uint8_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 325 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   326 \{\par
  327     //Return value\par
  328     uint8_t result;\par
  329     uint8_t numBytes = 1;\par
  330     switch (settings.commInterface) \{\par
  331 \par
  332     case I2C_MODE:\par
  333         Wire.beginTransmission(settings.I2CAddress);\par
  334         Wire.write(offset);\par
  335         Wire.endTransmission();\par
  336 \par
  337         Wire.requestFrom(settings.I2CAddress, numBytes);\par
  338         while ( Wire.available() ) // slave may send less than requested\par
  339         \{\par
  340             result = Wire.read(); // receive a byte as a proper uint8_t\par
  341         \}\par
  342         break;\par
  343 \par
  344     case SPI_MODE:\par
  345         // take the chip select low to select the device:\par
  346         digitalWrite(settings.chipSelectPin, LOW);\par
  347         // send the device the register you want to read:\par
  348         SPI.transfer(offset | 0x80);  //Ored with "read request" bit\par
  349         // send a value of 0 to read the first byte returned:\par
  350         result = SPI.transfer(0x00);\par
  351         // take the chip select high to de-select:\par
  352         digitalWrite(settings.chipSelectPin, HIGH);\par
  353         break;\par
  354 \par
  355     default:\par
  356         break;\par
  357     \}\par
  358     return result;\par
  359 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a1bbd14c8591966df531e40085342ff71_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegisterInt16\:BME280}
{\xe \v BME280\:readRegisterInt16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t BME280::readRegisterInt16 (uint8_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 361 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   362 \{\par
  363     uint8_t myBuffer[2];\par
  364     readRegisterRegion(myBuffer, offset, 2);  //Does memory transfer\par
  365     int16_t output = (int16_t)myBuffer[0] | int16_t(myBuffer[1] << 8);\par
  366     \par
  367     return output;\par
  368 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_ac43c30f9b321d301694094d6b4bebe7e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegisterRegion\:BME280}
{\xe \v BME280\:readRegisterRegion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BME280::readRegisterRegion (uint8_t *  {\i outputPointer}, uint8_t  {\i offset}, uint8_t  {\i length})}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 278 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279 \{\par
  280     //define pointer that will point to the external space\par
  281     uint8_t i = 0;\par
  282     char c = 0;\par
  283 \par
  284     switch (settings.commInterface)\par
  285     \{\par
  286 \par
  287     case I2C_MODE:\par
  288         Wire.beginTransmission(settings.I2CAddress);\par
  289         Wire.write(offset);\par
  290         Wire.endTransmission();\par
  291 \par
  292         // request bytes from slave device\par
  293         Wire.requestFrom(settings.I2CAddress, length);\par
  294         while ( (Wire.available()) && (i < length))  // slave may send less than requested\par
  295         \{\par
  296             c = Wire.read(); // receive a byte as character\par
  297             *outputPointer = c;\par
  298             outputPointer++;\par
  299             i++;\par
  300         \}\par
  301         break;\par
  302 \par
  303     case SPI_MODE:\par
  304         // take the chip select low to select the device:\par
  305         digitalWrite(settings.chipSelectPin, LOW);\par
  306         // send the device the register you want to read:\par
  307         SPI.transfer(offset | 0x80);  //Ored with "read request" bit\par
  308         while ( i < length ) // slave may send less than requested\par
  309         \{\par
  310             c = SPI.transfer(0x00); // receive a byte as character\par
  311             *outputPointer = c;\par
  312             outputPointer++;\par
  313             i++;\par
  314         \}\par
  315         // take the chip select high to de-select:\par
  316         digitalWrite(settings.chipSelectPin, HIGH);\par
  317         break;\par
  318 \par
  319     default:\par
  320         break;\par
  321     \}\par
  322 \par
  323 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_aecca87c2c40a7f2bcabcea921bdc6124_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTempC\:BME280}
{\xe \v BME280\:readTempC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readTempC (void )}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 243 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   244 \{\par
  245     // Returns temperature in DegC, resolution is 0.01 DegC. Output value of \'935123\'94 equals 51.23 DegC.\par
  246     // t_fine carries fine temperature as global value\par
  247 \par
  248     //get the reading (adc_T);\par
  249     int32_t adc_T = ((uint32_t)readRegister(BME280_TEMPERATURE_MSB_REG) << 12) | ((uint32_t)readRegister(BME280_TEMPERATURE_LSB_REG) << 4) | ((readRegister(BME280_TEMPERATURE_XLSB_REG) >> 4) & 0x0F);\par
  250 \par
  251     //By datasheet, calibrate\par
  252     int64_t var1, var2;\par
  253 \par
  254     var1 = ((((adc_T>>3) - ((int32_t)calibration.dig_T1<<1))) * ((int32_t)calibration.dig_T2)) >> 11;\par
  255     var2 = (((((adc_T>>4) - ((int32_t)calibration.dig_T1)) * ((adc_T>>4) - ((int32_t)calibration.dig_T1))) >> 12) *\par
  256     ((int32_t)calibration.dig_T3)) >> 14;\par
  257     t_fine = var1 + var2;\par
  258     float output = (t_fine * 5 + 128) >> 8;\par
  259 \par
  260     output = output / 100;\par
  261     \par
  262     return output;\par
  263 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_afffdd1d7ded9e1f92200e70669019d97_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_afffdd1d7ded9e1f92200e70669019d97_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTempF\:BME280}
{\xe \v BME280\:readTempF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readTempF (void )}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   266 \{\par
  267     float output = readTempC();\par
  268     output = (output * 9) / 5 + 32;\par
  269 \par
  270     return output;\par
  271 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a9648b496f6b4700550782a715a98b3c7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reset\:BME280}
{\xe \v BME280\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BME280::reset (void )}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   154 \{\par
  155     writeRegister(BME280_RST_REG, 0xB6);\par
  156     \par
  157 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_aeec5deb6daace6ae390108b4210e9df7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeRegister\:BME280}
{\xe \v BME280\:writeRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BME280::writeRegister (uint8_t  {\i offset}, uint8_t  {\i dataToWrite})}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 370 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   371 \{\par
  372     switch (settings.commInterface)\par
  373     \{\par
  374     case I2C_MODE:\par
  375         //Write the byte\par
  376         Wire.beginTransmission(settings.I2CAddress);\par
  377         Wire.write(offset);\par
  378         Wire.write(dataToWrite);\par
  379         Wire.endTransmission();\par
  380         break;\par
  381 \par
  382     case SPI_MODE:\par
  383         // take the chip select low to select the device:\par
  384         digitalWrite(settings.chipSelectPin, LOW);\par
  385         // send the device the register you want to read:\par
  386         SPI.transfer(offset & 0x7F);\par
  387         // send a value of 0 to read the first byte returned:\par
  388         SPI.transfer(dataToWrite);\par
  389         // decrement the number of bytes left to read:\par
  390         // take the chip select high to de-select:\par
  391         digitalWrite(settings.chipSelectPin, HIGH);\par
  392         break;\par
  393 \par
  394     default:\par
  395         break;\par
  396     \}\par
  397 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_afcff21c342725246bf415d7f0e4d04f0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v calibration\:BME280}
{\xe \v BME280\:calibration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SensorCalibration} BME280::calibration}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file CoolSparkFunBME280.h.}\par
}
{\xe \v settings\:BME280}
{\xe \v BME280\:settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SensorSettings} BME280::settings}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file CoolSparkFunBME280.h.}\par
}
{\xe \v t_fine\:BME280}
{\xe \v BME280\:t_fine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t BME280::t_fine}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoard Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoard}
{\xe \v CoolBoard}
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions. }}\par
{
{\f2 #include <CoolBoard.h>}}\par
Collaboration diagram for CoolBoard:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d3a/class_cool_board__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoard} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (const char *{\b answer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b offLineMode} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b onLineMode} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b connect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isConnected} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getLogInterval} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sleep} (unsigned long interval)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b readSensors} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initReadI2C} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b userData} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolFileSystem} {\b fileSystem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardSensors} {\b coolBoardSensors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardLed} {\b coolBoardLed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolTime} {\b rtc}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolWifi} {\b wifiManager}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolMQTT} {\b mqtt}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Jetpack} {\b jetPack}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Irene3000} {\b irene3000}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensors} {\b externalSensors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardActor} {\b onBoardActor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b userActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ireneActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b jetpackActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b externalSensorsActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sleepActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b manual} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b logInterval} =1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b data} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b answer} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b EnI2C} = 5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions. \par
}{
Definition at line 56 of file CoolBoard.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoolBoard\:CoolBoard}
{\xe \v CoolBoard\:CoolBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolBoard::CoolBoard ()}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::CoolBoard()}: This Constructor is provided to start the I2C interface and Init the different used pins \par
}{
Definition at line 50 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52 \par
   53 #if DEBUG == 1\par
   54 \par
   55     Serial.println( F("Entering CoolBoard Constructor") );\par
   56     Serial.println();\par
   57 \par
   58 #endif\par
   59     \par
   60     Wire.begin(2, 14);                       //I2C init \par
   61 \par
   62     pinMode(EnI2C, OUTPUT);        //Declare I2C Enable pin \par
   63 \par
   64 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolBoard}
{\xe \v CoolBoard\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::begin ()}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::begin()}: This method is provided to configure and start the used CoolKit Parts. It also starts the first connection try If Serial is enabled,it prints the configuration of the used parts. \par
}{
Definition at line 75 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    76 \{\par
   77 \par
   78 #if DEBUG == 1\par
   79 \par
   80     Serial.println( F("Starting the CoolBoard  ")  );\par
   81     Serial.println( F("Entering CoolBoard.begin() ")  );\par
   82     Serial.println();\par
   83 #endif  \par
   84 \par
   85 #if DEBUG == 0\par
   86     Serial.println( F("Starting Coolboard..."));\par
   87 #endif\par
   88 \par
   89 \par
   90     delay(100);\par
   91     \par
   92     coolBoardLed.write(255,128,0);//orange\par
   93 \par
   94     this->initReadI2C();\par
   95     delay(50);\par
   96 \par
   97     coolBoardSensors.config();\par
   98     coolBoardSensors.begin();\par
   99     delay(100);\par
  100     \par
  101     onBoardActor.config();\par
  102     onBoardActor.begin();\par
  103     delay(100);\par
  104     \par
  105     wifiManager.config();\par
  106     wifiManager.begin();\par
  107     delay(100);\par
  108 \par
  109     mqtt.config();\par
  110     mqtt.begin();\par
  111     delay(100);\par
  112 \par
  113 #if DEBUG == 1\par
  114 \par
  115     coolBoardLed.printConf();\par
  116 \par
  117     coolBoardSensors.printConf();\par
  118 \par
  119     onBoardActor.printConf();\par
  120 \par
  121     wifiManager.printConf();\par
  122 \par
  123     mqtt.printConf();\par
  124     \par
  125 \par
  126 #endif\par
  127 \par
  128 \par
  129     if (jetpackActive)\par
  130     \{\par
  131         jetPack.config();\par
  132         jetPack.begin();\par
  133 \par
  134     #if DEBUG == 1\par
  135         \par
  136         jetPack.printConf();\par
  137 \par
  138     #endif\par
  139         delay(100);\par
  140     \}\par
  141 \par
  142     if (ireneActive)\par
  143     \{\par
  144         irene3000.config();\par
  145         irene3000.begin();\par
  146 \par
  147     #if DEBUG == 1\par
  148 \par
  149         irene3000.printConf();\par
  150 \par
  151     #endif\par
  152         delay(100);\par
  153     \}\par
  154 \par
  155     if (externalSensorsActive)\par
  156     \{\par
  157         externalSensors.config();\par
  158         externalSensors.begin();\par
  159 \par
  160     #if DEBUG == 1\par
  161 \par
  162         externalSensors.printConf();\par
  163 \par
  164     #endif\par
  165         delay(100);\par
  166     \}\par
  167     \par
  168     coolBoardLed.fadeOut(255,128,0,0.5);//orange\par
  169 \par
  170     this->connect();\par
  171     delay(100);\par
  172 \par
  173     rtc.config();\par
  174     rtc.begin();\par
  175 \par
  176 #if DEBUG == 1\par
  177 \par
  178     rtc.printConf();\par
  179 \par
  180 #endif\par
  181     delay(100);\par
  182     \par
  183     coolBoardLed.blink(0,255,0,0.5);//green\par
  184 \par
  185 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_acba7c5aef7268b2c0044bdb54d3b9d76_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoard}
{\xe \v CoolBoard\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::config ()}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::config()}: This method is provided to configure the {\b CoolBoard} : -log interval -irene3000 activated/deactivated -jetpack activated/deactivated -external Sensors activated/deactivated -mqtt server timeout\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if configuration is done, false otherwise \par
}}{
Definition at line 727 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   728 \{\par
  729     yield();\par
  730 \par
  731 #if DEBUG == 1\par
  732 \par
  733     Serial.println( F("Entering CoolBoard.config() ") );\par
  734     Serial.println();\par
  735 \par
  736 #endif\par
  737 #if DEBUG == 0\par
  738     Serial.println();\par
  739     Serial.println( F("Loading configuration for this CoolBoard..."));\par
  740 #endif \par
  741 \par
  742     //open file system\par
  743     fileSystem.begin();\par
  744     \par
  745     //start the led\par
  746     coolBoardLed.config();\par
  747     coolBoardLed.begin();\par
  748     coolBoardLed.fadeIn(243,171,46,0.5);//shade of orange       \par
  749 \par
  750     \par
  751     //open configuration file\par
  752     File configFile = SPIFFS.open("/coolBoardConfig.json", "r");\par
  753     \par
  754     if (!configFile)\par
  755 \par
  756     \{\par
  757     \par
  758         Serial.println( F("failed to read /coolBoardConfig.json  ") );\par
  759 \par
  760         coolBoardLed.blink(255,0,0,0.5);//shade of red      \par
  761         return(false);\par
  762     \}\par
  763 \par
  764     else\par
  765     \{\par
  766         size_t size = configFile.size();\par
  767 \par
  768         // Allocate a buffer to store contents of the file.\par
  769         std::unique_ptr < char[] > buf(new char[size]);\par
  770 \par
  771         configFile.readBytes(buf.get(), size);\par
  772 \par
  773         DynamicJsonBuffer jsonBuffer;\par
  774 \par
  775         JsonObject & json = jsonBuffer.parseObject(buf.get());\par
  776 \par
  777         if (!json.success())\par
  778         \{\par
  779         \par
  780             Serial.println( F("failed to parse CoolBoard Config json object ") );\par
  781     \par
  782             coolBoardLed.blink(255,0,0,0.5);//shade of red      \par
  783             return(false);\par
  784         \}\par
  785 \par
  786         else\par
  787         \{   \par
  788         \par
  789         #if DEBUG == 1\par
  790             \par
  791             Serial.println( F("configuration json : ") );\par
  792             json.printTo(Serial);\par
  793             Serial.println();\par
  794             \par
  795             Serial.print(F("jsonBuffer size : "));\par
  796             Serial.print(jsonBuffer.size());\par
  797             Serial.println();\par
  798 \par
  799         #endif\par
  800             \par
  801             //parsing userActive Key\par
  802             if (json["userActive"].success())\par
  803             \{\par
  804                 this -> userActive = json["userActive"];\par
  805             \}\par
  806 \par
  807             else\par
  808             \{\par
  809                 this -> userActive = this -> userActive;\par
  810             \}\par
  811             json["userActive"] = this -> userActive;\par
  812 \par
  813             //parsing logInterval key\par
  814             if (json["logInterval"].success())\par
  815             \{\par
  816                 this -> logInterval = json["logInterval"];\par
  817             \}\par
  818             else\par
  819             \{\par
  820                 this -> logInterval = this -> logInterval;\par
  821             \}\par
  822             json["logInterval"] = this -> logInterval;\par
  823             \par
  824             //parsing ireneActive key           \par
  825             if (json["ireneActive"].success())\par
  826             \{\par
  827                 this -> ireneActive = json["ireneActive"];\par
  828             \}\par
  829             else\par
  830             \{\par
  831                 this -> ireneActive = this -> ireneActive;\par
  832             \}\par
  833             json["ireneActive"] = this -> ireneActive;\par
  834             \par
  835             //parsing jetpackActive key\par
  836             if (json["jetpackActive"].success())\par
  837             \{\par
  838                 this -> jetpackActive = json["jetpackActive"];\par
  839             \}\par
  840             else\par
  841             \{\par
  842                 this -> jetpackActive = this -> jetpackActive;\par
  843             \}\par
  844             json["jetpackActive"] = this -> jetpackActive;\par
  845 \par
  846             //parsing externalSensorsActive key\par
  847             if (json["externalSensorsActive"].success())\par
  848             \{\par
  849                 this -> externalSensorsActive = json["externalSensorsActive"];\par
  850             \}\par
  851             else\par
  852             \{\par
  853                 this -> externalSensorsActive = this -> externalSensorsActive;\par
  854             \}\par
  855             json["externalSensorsActive"] = this -> externalSensorsActive;\par
  856 \par
  857             \par
  858             //parsing sleepActive key\par
  859             if (json["sleepActive"].success())\par
  860             \{\par
  861                 this -> sleepActive = json["sleepActive"];\par
  862             \}\par
  863             else\par
  864             \{\par
  865                 this -> sleepActive = this -> sleepActive;\par
  866             \}\par
  867             json["sleepActive"] = this -> sleepActive;\par
  868 \par
  869 \par
  870             //parsing manual key\par
  871             if (json["manual"].success())\par
  872             \{\par
  873                 this -> manual = json["manual"];\par
  874             \}\par
  875             else\par
  876             \{\par
  877                 this -> manual = this -> manual;\par
  878             \}\par
  879             json["manual"] = this -> manual;\par
  880 \par
  881 \par
  882 \par
  883             //saving the current/correct configuration\par
  884             configFile.close();\par
  885             configFile = SPIFFS.open("/coolBoardConfig.json", "w");\par
  886             if (!configFile)\par
  887             \{\par
  888             \par
  889                 Serial.println( F("failed to write to /coolBoardConfig.json") );\par
  890                 Serial.println();\par
  891 \par
  892                 coolBoardLed.blink(255,0,0,0.5);//shade of red      \par
  893                 return(false);\par
  894             \}\par
  895 \par
  896             json.printTo(configFile);\par
  897             configFile.close();\par
  898             #if DEBUG == 0\par
  899 \par
  900                 Serial.println( F("Configuration loaded : OK"));\par
  901                 Serial.println();\par
  902 \par
  903             #endif\par
  904 \par
  905             return(true);\par
  906         \}\par
  907     \}\par
  908 \par
  909     coolBoardLed.strobe(243,171,46,0.5);//shade of orange\par
  910     \par
  911     coolBoardLed.fadeOut(243,171,46,0.5);//shade of orange              \par
  912 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a583a874c09c07e70a6eb9229fc4beddb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolBoard}
{\xe \v CoolBoard\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoard::connect ()}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::connect()}: This method is provided to manage the network connection and the mqtt connection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid mqtt client state \par
}}{
Definition at line 246 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   247 \{\par
  248 \par
  249 #if DEBUG == 1  \par
  250 \par
  251     Serial.println( F("Entering CoolBoard.connect ") );\par
  252     Serial.println();\par
  253     Serial.println( F("Connecting the CoolBoard  ") );\par
  254     delay(100);\par
  255 \par
  256 #endif\par
  257     coolBoardLed.write(0,0,255);//blue\par
  258 \par
  259     \par
  260             \par
  261     \par
  262 #if DEBUG == 1      \par
  263 \par
  264     Serial.println( F("Launching CoolWifi") );\par
  265     Serial.println();\par
  266 \par
  267 #endif\par
  268     wifiManager.connect();\par
  269     delay(100);\par
  270 \par
  271 \par
  272     //only attempt MQTT connection when Wifi is Connected\par
  273     if (wifiManager.state() == WL_CONNECTED)\par
  274     \{\par
  275 \par
  276     #if DEBUG == 1  \par
  277     \par
  278         Serial.println( F("Launching mqtt.connect()") );\par
  279         Serial.println();\par
  280     \par
  281     #endif  \par
  282         //logInterval in seconds\par
  283         mqtt.connect(this -> getLogInterval()*2);\par
  284         delay(100);\par
  285     \}\par
  286     \par
  287         \par
  288     \par
  289     \par
  290 #if DEBUG == 1\par
  291 \par
  292     Serial.println( F("mqtt state is :") );\par
  293     Serial.println(mqtt.state());\par
  294     Serial.println();\par
  295     delay(100);\par
  296 \par
  297 #endif\par
  298 \par
  299     coolBoardLed.blink(0,0,255,0.5);//blue\par
  300 \par
  301     return(mqtt.state());\par
  302 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a519de78b807f8ec6463ff484eb925918_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a519de78b807f8ec6463ff484eb925918_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getLogInterval\:CoolBoard}
{\xe \v CoolBoard\:getLogInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoard::getLogInterval ()}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::getLogInterval()}: This method is provided to get the log interval\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid interval value in s \par
}}{
Definition at line 1151 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1152 \{\par
 1153 \par
 1154 #if DEBUG == 1\par
 1155 \par
 1156     Serial.println( F("Entering CoolBoard.getLogInterval() ") );\par
 1157     Serial.println();\par
 1158     Serial.println( F("log Interval is :") );\par
 1159     Serial.println(logInterval);\par
 1160     Serial.println();\par
 1161 \par
 1162 #endif\par
 1163 \par
 1164     return(this -> logInterval);\par
 1165 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a7508e029f2ee17bb747ffab599285e0d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initReadI2C\:CoolBoard}
{\xe \v CoolBoard\:initReadI2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::initReadI2C ()}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::initReadI2C()}: This method is provided to enable the I2C Interface. \par
}{
Definition at line 1246 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1247 \{\par
 1248 \par
 1249 #if DEBUG == 1\par
 1250 \par
 1251     Serial.println( F("Entering CoolBoard.initReadI2C()") );\par
 1252     Serial.println();\par
 1253 \par
 1254 #endif\par
 1255  \par
 1256     digitalWrite(EnI2C,HIGH);//HIGH= I2C Enable\par
 1257 \par
 1258 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a397b46fadab8f530a8cf4d914c561366_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isConnected\:CoolBoard}
{\xe \v CoolBoard\:isConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoard::isConnected ()}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::isConnected()}\par
This method is provided to check if the card is connected to Wifi and MQTT\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 : connected -1: Wifi Not Connected -2: MQTT Not Connected \par
}}{
Definition at line 198 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   199 \{\par
  200 \par
  201 #if DEBUG == 1  \par
  202 \par
  203     Serial.println( F("Entering CoolBoard.isConnected ") );\par
  204     Serial.println();\par
  205 \par
  206 #endif\par
  207     if (wifiManager.state() != WL_CONNECTED)\par
  208     \{\par
  209     \par
  210         Serial.println(F("Wifi Not Connected"));\par
  211 \par
  212     #if DEBUG == 1\par
  213 \par
  214         Serial.println(F("Wifi State is "));\par
  215         Serial.println(wifiManager.state());\par
  216         \par
  217     #endif\par
  218         return(-1);\par
  219     \}\par
  220     \par
  221     if(mqtt.state() != 0)\par
  222     \{\par
  223         \par
  224         Serial.println( F("MQTT not Connected"));\par
  225 \par
  226     #if DEBUG==1\par
  227         Serial.println( F("mqtt state is :") );\par
  228         Serial.println(mqtt.state());   \par
  229     \par
  230     #endif\par
  231 \par
  232     \}\par
  233     \par
  234     return(0);\par
  235 \par
  236 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ad7442cf4b62c7b0d5bd62a0f75ffc065_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v offLineMode\:CoolBoard}
{\xe \v CoolBoard\:offLineMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::offLineMode ()}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoard::offlineMode(): This method is provided to manage the offLine mode: -read sensors -do actions -save data in the file system -if there is WiFi but no Internet : make data available over AP -if there is no connection : retry to connect \par
}{
Definition at line 573 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   574 \{\par
  575     coolBoardLed.fade(51,100,50,0.5);//dark shade of green  \par
  576 #if DEBUG == 1  \par
  577     \par
  578     Serial.println( F("Entering off line mode ") ); \par
  579     \par
  580 #endif\par
  581 \par
  582 #if DEBUG == 0\par
  583 \par
  584     Serial.println( F("CoolBoard is in Offline Mode"));\par
  585 \par
  586 #endif\par
  587 \par
  588     //read user data if user is active\par
  589     if(userActive)\par
  590     \{\par
  591 \par
  592         coolBoardLed.fadeIn(245,237,27,0.5);//shade of yellow\par
  593 \par
  594     #if DEBUG == 1\par
  595         \par
  596         Serial.println( F("User is Active") );\par
  597         Serial.println( F("Collecting User's data ( mac,username,timeStamp )") );\par
  598         Serial.println();\par
  599 \par
  600     #endif\par
  601 \par
  602         coolBoardLed.blink(245,237,27,0.5);//shade of yellow    \par
  603 \par
  604         //reading user data\par
  605         data=this->userData();//\{"":"","":"","",""\}\par
  606 \par
  607         //formatting json \par
  608         data.setCharAt( data.lastIndexOf('\}') , ',');//\{"":"","":"","","",\par
  609         \par
  610                 \par
  611         //read sensors data\par
  612 \par
  613         Serial.println( F("Collecting sensors data ") );\par
  614         Serial.println();\par
  615 \par
  616         data+=this->readSensors();//\{"":"","":"","","",\{.......\}\par
  617 \par
  618         \par
  619 \par
  620         //formatting json correctly\par
  621         data.remove(data.lastIndexOf('\{'), 1);//\{"":"","":"","","",.......\}\par
  622 \par
  623         coolBoardLed.fadeOut(245,237,27,0.5);//shade of yellow\par
  624                 \par
  625     \}   \par
  626     else\par
  627     \{\par
  628         //read sensors data\par
  629     #if DEBUG == 1\par
  630 \par
  631         Serial.println( F("Collecting sensors data ") );\par
  632         Serial.println();\par
  633 \par
  634     #endif\par
  635 \par
  636         coolBoardLed.fade(190,100,150,0.5);//shade of violet        \par
  637 \par
  638         data=this->readSensors();//\{..,..,..\}\par
  639     \}\par
  640 \par
  641     coolBoardLed.fade(51,100,50,0.5);//dark shade of green  \par
  642 \par
  643     //do action\par
  644 \par
  645     if (jetpackActive)\par
  646     \{\par
  647     \par
  648 \par
  649 \par
  650     #if DEBUG == 1\par
  651 \par
  652         Serial.println( F("jetpack is Active ") );\par
  653         Serial.println( F("jetpack doing action ") );\par
  654         Serial.println();\par
  655     \par
  656     #endif\par
  657         coolBoardLed.fade(100,100,150,0.5);//dark shade of blue \par
  658     \par
  659         jetPack.doAction( data.c_str() );\par
  660     \}\par
  661     \par
  662     delay(100);\par
  663 \par
  664     onBoardActor.doAction( data.c_str() );  \par
  665 \par
  666 \par
  667     coolBoardLed.fade(51,100,50,0.5);//dark shade of green  \par
  668     \par
  669     //saving data in the file system\par
  670     \par
  671     fileSystem.saveSensorData( data.c_str() );\par
  672 \par
  673     #if DEBUG == 0\par
  674 \par
  675         Serial.println( F("saving Data in Memory : OK"));\par
  676 \par
  677     #endif\par
  678 \par
  679     coolBoardLed.fadeOut(51,100,50,0.5);//dark shade of green\par
  680 \par
  681     //case we have wifi but no internet\par
  682     if( (wifiManager.state() == WL_CONNECTED) && ( mqtt.state()!=0 ) )\par
  683     \{\par
  684         \par
  685         Serial.println(F("there is Wifi but no Internet"));\par
  686         Serial.println(F("lunching AP to check saved files"));\par
  687         Serial.println(F("and Add new WiFi if needed"));\par
  688         \par
  689         wifiManager.connectAP();\par
  690         \par
  691     \}\par
  692     \par
  693     //case we have no connection at all\par
  694     if( wifiManager.state() != WL_CONNECTED )\par
  695     \{\par
  696     \par
  697     #if DEBUG == 1\par
  698         \par
  699         Serial.println(F("there is No Wifi "));\par
  700         Serial.println(F("retrying to connect"));\par
  701     \par
  702     #endif\par
  703 \par
  704     #if DEBUG == 0\par
  705         Serial.println( F("there is no WiFi..."));\par
  706     #endif\par
  707         \par
  708         this->connect();//nomad case : just run wifiMulti\par
  709                 //normal case : run wifiMulti+AP\par
  710         \par
  711     \}   \par
  712 \par
  713 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ae6b5e1274d760462290192acea4adca8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v onLineMode\:CoolBoard}
{\xe \v CoolBoard\:onLineMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::onLineMode ()}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::onLineMode()}: This method is provided to manage the online mode: -update clock -read sensor -do actions -publish data -read answer -update config \par
}{
Definition at line 314 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315 \{\par
  316 \par
  317     coolBoardLed.fadeIn(128,255,50,0.5);//shade of green\par
  318 \par
  319 #if DEBUG == 1\par
  320 \par
  321     Serial.println( F("Entering CoolBoard.onLineMode() ") );\par
  322     Serial.println();\par
  323 \par
  324 #endif\par
  325 #if DEBUG == 0\par
  326 \par
  327     Serial.println( F("CoolBoard is in Online Mode"));\par
  328 \par
  329 #endif\par
  330 \par
  331     data="";\par
  332     answer="";\par
  333 \par
  334     //send saved data if any\par
  335     if(fileSystem.isDataSaved())\par
  336     \{\par
  337 \par
  338         coolBoardLed.fadeIn(128,128,255,0.5);//shade of blue\par
  339 \par
  340         Serial.println( F("There is data saved on the File System") );\par
  341         Serial.println( F("Sending saved data over MQTT ") );\par
  342         Serial.println();\par
  343         coolBoardLed.strobe(128,128,255,0.5);//shade of blue \par
  344 \par
  345         mqtt.publish("sending saved data");\par
  346         mqtt.mqttLoop();\par
  347 \par
  348 \par
  349         \par
  350         int size=0;\par
  351         std::unique_ptr<String[]> savedData(std::move(fileSystem.getSensorSavedData(size)));//\{..,..,..\}\par
  352 \par
  353         int i=0;\par
  354         //loop through the array\par
  355         while(i<size)\par
  356         \{\par
  357             //formatting data:\par
  358         \par
  359             String jsonData = "\{\\"state\\":\{\\"reported\\":";\par
  360             jsonData += savedData[i]; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}\par
  361             jsonData += " \} \}"; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}  \} \}\par
  362 \par
  363         #if DEBUG == 1 \par
  364             Serial.println(F("Size is : "));\par
  365             Serial.println(size);\par
  366             Serial.print(F("sending line N\'B0"));\par
  367             Serial.println(i);\par
  368             Serial.println(jsonData);\par
  369             Serial.println();\par
  370 \par
  371         #endif\par
  372 \par
  373             coolBoardLed.strobe(128,128,255,0.5);//shade of blue\par
  374         \par
  375             mqtt.publish( jsonData.c_str() );\par
  376             mqtt.mqttLoop();\par
  377         \par
  378             coolBoardLed.fadeOut(128,128,255,0.5);//shade of blue\par
  379             \par
  380             i++;\par
  381             yield();\par
  382         \}       \par
  383 \par
  384 \par
  385     #if DEBUG == 1\par
  386 \par
  387         Serial.println( F("Saved data sent ") );\par
  388         Serial.println();\par
  389     \par
  390     #endif\par
  391 \par
  392     \}\par
  393 \par
  394     coolBoardLed.blink(128,255,50,0.5);//shade of green\par
  395 \par
  396     //clock update\par
  397     Serial.println( F("Re-checking RTC..."));\par
  398     rtc.update();\par
  399 \par
  400     //read user data if user is active\par
  401     if(userActive)\par
  402     \{\par
  403         coolBoardLed.fadeIn(245,237,27,0.5);//shade of yellow\par
  404     \par
  405     #if DEBUG == 1\par
  406 \par
  407         Serial.println( F("User is Active") );\par
  408         Serial.println( F("Collecting User's data ( mac,username,timeStamp )") );\par
  409         Serial.println();\par
  410     \par
  411     #endif  \par
  412         coolBoardLed.blink(245,237,27,0.5);//shade of yellow    \par
  413 \par
  414         //reading user data\par
  415         data=this->userData();//\{"":"","":"","",""\}\par
  416 \par
  417         //formatting json \par
  418         data.setCharAt( data.lastIndexOf('\}') , ',');//\{"":"","":"","","",\par
  419                 \par
  420         //read sensors data\par
  421     #if DEBUG == 1\par
  422 \par
  423         Serial.println( F("Collecting sensors data ") );\par
  424         Serial.println();\par
  425     \par
  426     #endif\par
  427 \par
  428         data+=this->readSensors();//\{"":"","":"","","",\{.......\}        \par
  429 \par
  430         //formatting json correctly\par
  431         data.remove(data.lastIndexOf('\{'), 1);//\{"":"","":"","","",.......\}\par
  432         \par
  433         coolBoardLed.fadeOut(245,237,27,0.5);//shade of yellow\par
  434                 \par
  435     \}   \par
  436     else\par
  437     \{\par
  438         //read sensors data\par
  439     #if DEBUG == 1\par
  440 \par
  441         Serial.println( F("Collecting sensors data ") );\par
  442         Serial.println();\par
  443     \par
  444     #endif\par
  445         coolBoardLed.fade(190,100,150,0.5);//shade of violet        \par
  446         data=this->readSensors();//\{..,..,..\}\par
  447     \}\par
  448     \par
  449 \par
  450 \par
  451 \par
  452     //do action\par
  453 \par
  454     if (jetpackActive)\par
  455     \{\par
  456 \par
  457 \par
  458     #if DEBUG ==1\par
  459 \par
  460         Serial.println( F("jetpack is Active ") );\par
  461         Serial.println();\par
  462 \par
  463     #endif\par
  464     \par
  465         if(this->manual == 0 )\par
  466         \{\par
  467 \par
  468             Serial.println( F("jetpack doing action ") );\par
  469 \par
  470             coolBoardLed.fade(100,100,150,0.5);//dark shade of blue     \par
  471 \par
  472             jetPack.doAction(data.c_str());\par
  473             \par
  474 \par
  475         \par
  476         \}\par
  477         \par
  478         else if(this->manual == 1 )\par
  479         \{\par
  480         \par
  481             Serial.println(F("we are in manual mode"));\par
  482             mqtt.mqttLoop();\par
  483             answer = mqtt.read();\par
  484             this -> update(answer.c_str());\par
  485         \}\par
  486     \}\par
  487 \par
  488     delay(100);\par
  489 \par
  490     onBoardActor.doAction( data.c_str() );  \par
  491 \par
  492 \par
  493 \par
  494     \par
  495     coolBoardLed.fadeIn(128,255,50,0.5);//shade of green\par
  496 \par
  497     //formatting data:\par
  498     String jsonData = "\{\\"state\\":\{\\"reported\\":";\par
  499     jsonData += data; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}\par
  500     jsonData += " \} \}"; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}  \} \}\par
  501     \par
  502     //mqtt client loop to allow data handling\par
  503     mqtt.mqttLoop();\par
  504 \par
  505     coolBoardLed.blink(128,255,50,0.5);//shade of green \par
  506 \par
  507     //read mqtt answer\par
  508     answer = mqtt.read();\par
  509 \par
  510 #if DEBUG == 1 \par
  511 \par
  512     Serial.println( F("checking if there's an MQTT message ")  );\par
  513     Serial.println( F("answer is : ") );    \par
  514     Serial.println(answer); \par
  515     Serial.println();\par
  516 \par
  517 #endif  \par
  518 \par
  519     coolBoardLed.fadeOut(128,255,50,0.5);//shade of green   \par
  520 \par
  521     //check if the configuration needs update \par
  522     //and update it if needed \par
  523     this -> update(answer.c_str());\par
  524     \par
  525     coolBoardLed.fadeIn(128,255,50,0.5);//shade of green    \par
  526 \par
  527     //publishing data   \par
  528     if( this->sleepActive==0 )  \par
  529     \{   \par
  530         coolBoardLed.strobe(255,0,230,0.5);//shade of pink\par
  531         \par
  532         //logInterval in seconds\par
  533         mqtt.publish( jsonData.c_str(), this->getLogInterval() );\par
  534         mqtt.mqttLoop();\par
  535     \par
  536     \}\par
  537     else\par
  538     \{\par
  539         coolBoardLed.strobe(230,255,0,0.5);//shade of yellow    \par
  540 \par
  541         mqtt.publish(jsonData.c_str());     \par
  542         mqtt.mqttLoop();\par
  543         answer = mqtt.read();\par
  544         this ->update(answer.c_str());\par
  545 \par
  546         //logInterval in seconds\par
  547         this->sleep( this->getLogInterval() ) ;\par
  548     \}\par
  549 \par
  550     coolBoardLed.fadeOut(128,255,50,0.5);//shade of green       \par
  551 \par
  552     mqtt.mqttLoop();\par
  553 \par
  554     //read mqtt answer\par
  555     answer = mqtt.read();\par
  556     this -> update(answer.c_str()); \par
  557 \par
  558     coolBoardLed.blink(128,255,50,0.5);//shade of green \par
  559 \par
  560 \par
  561 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_aa0bbc4bc605e35618d18e68795c61363_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoard}
{\xe \v CoolBoard\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::printConf ()}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::printConf()}: This method is provided to print the configuration to the Serial Monitor. \par
}{
Definition at line 921 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   922 \{\par
  923 \par
  924 #if DEBUG == 1\par
  925     \par
  926     Serial.println( F("Entering CoolBoard.printConf() ") );\par
  927     Serial.println();\par
  928 \par
  929 #endif\par
  930 \par
  931     Serial.println( F("Printing Cool Board Configuration "));\par
  932     Serial.print( F("log interval       : "));\par
  933     Serial.println(this->logInterval);\par
  934 \par
  935     Serial.print( F("irene active       : "));\par
  936     Serial.println(this->ireneActive);\par
  937 \par
  938     Serial.print( F("jetpack active     : "));\par
  939     Serial.println(this->jetpackActive);\par
  940 \par
  941     Serial.print( F("external sensors active    : "));\par
  942     Serial.println(this->externalSensorsActive);\par
  943 \par
  944     Serial.print( F("sleep active       : "));\par
  945     Serial.println(this->sleepActive);\par
  946 \par
  947     Serial.print( F("user active        : "));\par
  948     Serial.println(this->userActive);\par
  949 \par
  950     Serial.print( F("manual active      : "));\par
  951     Serial.println(this->manual);\par
  952 \par
  953     Serial.println();\par
  954 \par
  955 \par
  956 \par
  957 \par
  958 \}\par
}
}
{\xe \v readSensors\:CoolBoard}
{\xe \v CoolBoard\:readSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::readSensors ()}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::readSensors()}: This method is provided to read and format all the sensors data in a single json.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string of all the sensors read. \par
}}{
Definition at line 1175 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1176 \{\par
 1177 \par
 1178     coolBoardLed.fadeIn(128,255,0,0.5);//light shade of green\par
 1179                 \par
 1180 #if DEBUG == 1\par
 1181 \par
 1182     Serial.println( F("Entering CoolBoard.readSensors()") );\par
 1183     Serial.println();\par
 1184 \par
 1185 #endif\par
 1186     coolBoardLed.strobe(128,255,0,0.5);//light shade of green\par
 1187 \par
 1188     String sensorsData;\par
 1189     \par
 1190     this->initReadI2C();\par
 1191 \par
 1192     sensorsData = coolBoardSensors.read(); // \{..,..,..\}\par
 1193     \par
 1194     if (externalSensorsActive)\par
 1195     \{\par
 1196         sensorsData += externalSensors.read(); // \{..,..,..\}\{..,..\}\par
 1197 \par
 1198         sensorsData.setCharAt(sensorsData.lastIndexOf('\}'), ','); // \{..,..,..\}\{..,..,\par
 1199         sensorsData.setCharAt(sensorsData.lastIndexOf('\{'), ','); // \{..,..,..\},..,..,\par
 1200         sensorsData.remove(sensorsData.lastIndexOf('\}'), 1); // \{..,..,..,..,..,\par
 1201         sensorsData.setCharAt(sensorsData.lastIndexOf(','), '\}'); // \{..,..,..,..,..\}\par
 1202 \par
 1203     \}\par
 1204     if (ireneActive)\par
 1205     \{\par
 1206         sensorsData += irene3000.read(); // \{..,..,..,..,..\}\{..,..,..\}\par
 1207 \par
 1208         sensorsData.setCharAt(sensorsData.lastIndexOf('\}'), ','); // \{..,..,..,..,..\}\{..,..,..,\par
 1209         sensorsData.setCharAt(sensorsData.lastIndexOf('\{'), ','); // \{..,..,..,..,..\},..,..,..,\par
 1210         sensorsData.remove(sensorsData.lastIndexOf('\}'), 1); // \{..,..,..,..,..,..,..,..,\par
 1211         sensorsData.setCharAt(sensorsData.lastIndexOf(','), '\}'); // \{..,..,..,..,..,..,..,..\}      \par
 1212         \par
 1213         \par
 1214     \}\par
 1215 \par
 1216     //getting Hour:\par
 1217     tmElements_t tm;\par
 1218     tm=rtc.getTimeDate();\par
 1219     \par
 1220     //adding Hour\par
 1221     sensorsData.remove(sensorsData.lastIndexOf('\}'), 1); // \{..,..,..,..,..,..,..,..,   \par
 1222     sensorsData+=",\\"hour\\":";  \par
 1223     sensorsData+=tm.Hour;\par
 1224     sensorsData+=",\\"minute\\":";\par
 1225     sensorsData+=tm.Minute;\par
 1226     sensorsData+="\}";\par
 1227     \par
 1228 #if DEBUG == 1\par
 1229     Serial.println();\par
 1230     Serial.println( F("sensors data is ") );\par
 1231     Serial.println(sensorsData);\par
 1232     Serial.println();\par
 1233 \par
 1234 #endif\par
 1235     coolBoardLed.fadeOut(128,255,0,0.5);//light shade of green\par
 1236 \par
 1237     return(sensorsData);\par
 1238 \par
 1239 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ad03abdce2e65f520bbf2cff0f2d083cf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ad03abdce2e65f520bbf2cff0f2d083cf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sleep\:CoolBoard}
{\xe \v CoolBoard\:sleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::sleep (unsigned long  {\i interval})}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoard::sleep(int interval): This method is provided to allow the board to enter deepSleep mode for a period of time equal to interval in s \par
}{
Definition at line 1315 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1316 \{\par
 1317 \par
 1318     Serial.println( F("Entering CoolBoard.sleep() ") );\par
 1319     Serial.print( F("going to sleep for ") );\par
 1320     Serial.print(interval);\par
 1321     Serial.println(F("s") );\par
 1322     Serial.println();\par
 1323     \par
 1324     //interval is in seconds , interval*1000*1000 in \'B5S\par
 1325     ESP.deepSleep ( ( interval * 1000 * 1000 ), WAKE_RF_DEFAULT) ;\par
 1326 \par
 1327 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a069952cdcb2e7f68518aa429eceadb6e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v update\:CoolBoard}
{\xe \v CoolBoard\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::update (const char *  {\i answer})}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoard::update(mqtt answer): This method is provided to handle the configuration update of the different parts \par
}{
Definition at line 965 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   966 \{\par
  967     coolBoardLed.fadeIn(153,76,0,0.5);//shade of brown      \par
  968 \par
  969 #if DEBUG == 1\par
  970 \par
  971     Serial.println( F("Entering CoolBoard.update() ") );\par
  972     Serial.println();\par
  973     Serial.println( F("message is : ") );\par
  974     Serial.println(answer);\par
  975     Serial.println();\par
  976 \par
  977 #endif\par
  978 \par
  979     DynamicJsonBuffer jsonBuffer;\par
  980     JsonObject & root = jsonBuffer.parseObject(answer);\par
  981     JsonObject & stateDesired = root["state"];\par
  982 \par
  983 #if DEBUG == 1\par
  984 \par
  985     Serial.println( F("root json : ") );\par
  986     root.printTo(Serial);\par
  987     Serial.println();\par
  988 \par
  989     Serial.println( F("stateDesired json : "));\par
  990     stateDesired.printTo(Serial);\par
  991     Serial.println();\par
  992     \par
  993     Serial.print( F("jsonBuffer size : "));\par
  994     Serial.println(jsonBuffer.size());\par
  995 \par
  996 #endif\par
  997 \par
  998     if (stateDesired.success())\par
  999     \{\par
 1000     \par
 1001     #if DEBUG == 1\par
 1002 \par
 1003         Serial.println( F("update message parsing : success") );\par
 1004         Serial.println();\par
 1005     \par
 1006     #endif\par
 1007 \par
 1008             String answerDesired;\par
 1009         \par
 1010             stateDesired.printTo(answerDesired);\par
 1011             \par
 1012         #if DEBUG == 1      \par
 1013         \par
 1014             Serial.println( F("update is ok ") );\par
 1015             Serial.println( F("desired update is : ") );            \par
 1016             Serial.println(answerDesired);\par
 1017             Serial.println("json size is : ");\par
 1018             Serial.println(jsonBuffer.size() ) ;                \par
 1019             Serial.println();\par
 1020 \par
 1021         \par
 1022         #endif\par
 1023             //manual mode check\par
 1024             if(this->manual == 1 )\par
 1025             \{ \par
 1026                 JsonObject & manualMode=stateDesired["manual"];\par
 1027                 //json parse\par
 1028                 for(auto kv : manualMode)\par
 1029                 \{\par
 1030                 #if DEBUG == 1\par
 1031 \par
 1032                     Serial.print(F("writing to "));\par
 1033                     Serial.println(kv.key);\par
 1034                     Serial.print(F("state : "));\par
 1035                     Serial.println(kv.value.as<bool>());        \par
 1036                     \par
 1037                 #endif              \par
 1038 \par
 1039                     if( strcmp(kv.key,"Act0") == 0 )\par
 1040                     \{\par
 1041                     \par
 1042                         jetPack.writeBit(0,kv.value.as<bool>() ); \par
 1043                         \par
 1044                     \}\par
 1045                     else if(strcmp(kv.key,"Act1") == 0)\par
 1046                     \{\par
 1047                         jetPack.writeBit(1,kv.value.as<bool>() ); \par
 1048 \par
 1049                     \}\par
 1050                     else if(strcmp(kv.key,"Act2") == 0)\par
 1051                     \{\par
 1052                         jetPack.writeBit(2,kv.value.as<bool>() ); \par
 1053 \par
 1054                     \}\par
 1055                     else if(strcmp(kv.key,"Act3") == 0)\par
 1056                     \{\par
 1057                         jetPack.writeBit(3,kv.value.as<bool>() ); \par
 1058 \par
 1059                     \}\par
 1060                     else if(strcmp(kv.key,"Act4") == 0)\par
 1061                     \{\par
 1062                         jetPack.writeBit(4,kv.value.as<bool>() ); \par
 1063 \par
 1064                     \}\par
 1065                     else if(strcmp(kv.key,"Act5") == 0)\par
 1066                     \{\par
 1067                         jetPack.writeBit(5,kv.value.as<bool>() ); \par
 1068 \par
 1069                     \}\par
 1070                     else if(strcmp(kv.key,"Act6") == 0)\par
 1071                     \{\par
 1072                         jetPack.writeBit(6,kv.value.as<bool>() ); \par
 1073 \par
 1074                     \}\par
 1075                     else if (strcmp(kv.key,"Act7") == 0)\par
 1076                     \{\par
 1077                         jetPack.writeBit(7,kv.value.as<bool>() ); \par
 1078 \par
 1079                     \}\par
 1080                     else if (strcmp(kv.key,"ActB") == 0)\par
 1081                     \{\par
 1082                         onBoardActor.write(kv.value.as<bool>() ); \par
 1083 \par
 1084                     \}\par
 1085                                 \par
 1086                 \par
 1087                 \}\par
 1088 \par
 1089                 \par
 1090             \}\par
 1091 \par
 1092             //saving the new configuration\par
 1093             fileSystem.updateConfigFiles(answerDesired);\par
 1094 \par
 1095                 //answering the update msg:\par
 1096             //reported = received configuration\par
 1097             //desired=null\par
 1098         \par
 1099             String updateAnswer;\par
 1100             String tempString;\par
 1101             \par
 1102             stateDesired.printTo(tempString);\par
 1103             updateAnswer="\{\\"state\\":\{\\"reported\\":";\par
 1104             updateAnswer+=tempString;\par
 1105             updateAnswer+=",\\"desired\\":null\}\}";\par
 1106 \par
 1107         #if DEBUG == 1\par
 1108 \par
 1109             Serial.println( F("preparing answer message ") );\par
 1110             Serial.println();\par
 1111             Serial.println( F("updateAnswer : ") );\par
 1112             Serial.println(updateAnswer);\par
 1113         \par
 1114         #endif  \par
 1115 \par
 1116             mqtt.publish(updateAnswer.c_str());\par
 1117             \par
 1118             mqtt.mqttLoop();\par
 1119 \par
 1120             delay(10);\par
 1121         \par
 1122             if(manual == 0 )\par
 1123             \{\par
 1124                 //restart the esp to apply the config\par
 1125                 ESP.restart();\par
 1126             \}\par
 1127     \}\par
 1128     else\par
 1129     \{\par
 1130     \par
 1131     #if DEBUG == 1\par
 1132 \par
 1133         Serial.println( F("Failed to parse update message( OR no message received )") );\par
 1134         Serial.println();\par
 1135     \par
 1136     #endif\par
 1137     \par
 1138     \}\par
 1139 \par
 1140     coolBoardLed.strobe(153,76,0,0.5);//shade of brown\par
 1141     coolBoardLed.fadeOut(153,76,0,0.5);//shade of brown                             \par
 1142 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a8612756d3f73198cdde857a66f0fe690_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a8612756d3f73198cdde857a66f0fe690_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v userData\:CoolBoard}
{\xe \v CoolBoard\:userData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::userData ()}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::userData()}: This method is provided to return the user's data.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string of the user's data \par
}}{
Definition at line 1268 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1269 \{\par
 1270 \par
 1271 #if DEBUG == 1\par
 1272 \par
 1273     Serial.println( F("Entering CoolBoard.userData() ") );\par
 1274     Serial.println();\par
 1275 \par
 1276 #endif\par
 1277 \par
 1278     String tempMAC = WiFi.macAddress();\par
 1279 \par
 1280     tempMAC.replace(":", "");\par
 1281 \par
 1282     String userJson = "\{\\"user\\":\\"";\par
 1283 \par
 1284     userJson += mqtt.getUser();\par
 1285 \par
 1286     userJson += "\\",\\"timestamp\\":\\"";\par
 1287 \par
 1288     userJson += rtc.getESDate(); // "timestamp":"20yy-mm-ddThh:mm:ssZ"\par
 1289 \par
 1290     userJson += "\\",\\"mac\\":\\"";\par
 1291 \par
 1292     userJson += tempMAC;\par
 1293 \par
 1294     userJson += "\\"\}";\par
 1295 \par
 1296 #if DEBUG == 1\par
 1297 \par
 1298     Serial.println( F("userData is : ") );\par
 1299     Serial.println(userJson);\par
 1300     Serial.println();\par
 1301 \par
 1302 #endif  \par
 1303     \par
 1304     return(userJson);\par
 1305     \par
 1306 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ae7358fb6e623cfc81b775f5f1734909b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ae7358fb6e623cfc81b775f5f1734909b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v answer\:CoolBoard}
{\xe \v CoolBoard\:answer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::answer =""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
answer string, string that contains received MQTT messages \par
}{
Definition at line 203 of file CoolBoard.h.}\par
}
{\xe \v coolBoardLed\:CoolBoard}
{\xe \v CoolBoard\:coolBoardLed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolBoardLed} CoolBoard::coolBoardLed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Led handler instance \par
}{
Definition at line 105 of file CoolBoard.h.}\par
}
{\xe \v coolBoardSensors\:CoolBoard}
{\xe \v CoolBoard\:coolBoardSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolBoardSensors} CoolBoard::coolBoardSensors{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Board handler instance \par
}{
Definition at line 100 of file CoolBoard.h.}\par
}
{\xe \v data\:CoolBoard}
{\xe \v CoolBoard\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::data =""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data string, string that contains sensors data \par
}{
Definition at line 197 of file CoolBoard.h.}\par
}
{\xe \v EnI2C\:CoolBoard}
{\xe \v CoolBoard\:EnI2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoard::EnI2C = 5{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable I2C pin, double usage for I2C and shift register latch , HIGH=I2C , LOW=shift register latch All I2C is over pins (2,14) \par
}{
Definition at line 210 of file CoolBoard.h.}\par
}
{\xe \v externalSensors\:CoolBoard}
{\xe \v CoolBoard\:externalSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExternalSensors} CoolBoard::externalSensors{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
External Sensors handler instance \par
}{
Definition at line 135 of file CoolBoard.h.}\par
}
{\xe \v externalSensorsActive\:CoolBoard}
{\xe \v CoolBoard\:externalSensorsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::externalSensorsActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
externalSensors flag, set to 1 when using 1/many external Sensor(s) \par
}{
Definition at line 164 of file CoolBoard.h.}\par
}
{\xe \v fileSystem\:CoolBoard}
{\xe \v CoolBoard\:fileSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolFileSystem} CoolBoard::fileSystem{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
fileSystem handler instance \par
}{
Definition at line 95 of file CoolBoard.h.}\par
}
{\xe \v irene3000\:CoolBoard}
{\xe \v CoolBoard\:irene3000}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Irene3000} CoolBoard::irene3000{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} handler instance \par
}{
Definition at line 130 of file CoolBoard.h.}\par
}
{\xe \v ireneActive\:CoolBoard}
{\xe \v CoolBoard\:ireneActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::ireneActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ireneActive flag, set to 1 when using an Irene module \par
}{
Definition at line 152 of file CoolBoard.h.}\par
}
{\xe \v jetPack\:CoolBoard}
{\xe \v CoolBoard\:jetPack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Jetpack} CoolBoard::jetPack{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} handler instance \par
}{
Definition at line 125 of file CoolBoard.h.}\par
}
{\xe \v jetpackActive\:CoolBoard}
{\xe \v CoolBoard\:jetpackActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::jetpackActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
jetpackActive flag, set to 1 when using a {\b Jetpack} module \par
}{
Definition at line 158 of file CoolBoard.h.}\par
}
{\xe \v logInterval\:CoolBoard}
{\xe \v CoolBoard\:logInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoard::logInterval =1{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
log Interval value, the period of time between logs{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
in Seconds \par}
}{
Definition at line 191 of file CoolBoard.h.}\par
}
{\xe \v manual\:CoolBoard}
{\xe \v CoolBoard\:manual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::manual =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
manual flag, set to 1 when using manual mode in manual Mode , user can activate/deactivate actors through a specific MQTT command\par
/!\\ in manual Mode, receving an update will not reset the {\b CoolBoard} /!\\ resetting the {\b CoolBoard} in manual mode will deactivate all actors \par
}{
Definition at line 184 of file CoolBoard.h.}\par
}
{\xe \v mqtt\:CoolBoard}
{\xe \v CoolBoard\:mqtt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolMQTT} CoolBoard::mqtt{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT handler instance \par
}{
Definition at line 120 of file CoolBoard.h.}\par
}
{\xe \v onBoardActor\:CoolBoard}
{\xe \v CoolBoard\:onBoardActor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolBoardActor} CoolBoard::onBoardActor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On Board Actor handler instance \par
}{
Definition at line 140 of file CoolBoard.h.}\par
}
{\xe \v rtc\:CoolBoard}
{\xe \v CoolBoard\:rtc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolTime} CoolBoard::rtc{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
RTC handler instance \par
}{
Definition at line 110 of file CoolBoard.h.}\par
}
{\xe \v sleepActive\:CoolBoard}
{\xe \v CoolBoard\:sleepActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::sleepActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sleepActive flag, set to 1 when using sleep Mode in Sleep mode : the {\b CoolBoard} will do a cycle (init, read sensors, do action,log) and go to sleep for a LogInterval period of time \par
}{
Definition at line 173 of file CoolBoard.h.}\par
}
{\xe \v userActive\:CoolBoard}
{\xe \v CoolBoard\:userActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::userActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
userActive flag, set to 1 to collect userData(MAC,userName,TimeStamp) \par
}{
Definition at line 146 of file CoolBoard.h.}\par
}
{\xe \v wifiManager\:CoolBoard}
{\xe \v CoolBoard\:wifiManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolWifi} CoolBoard::wifiManager{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wifi handler instance \par
}{
Definition at line 115 of file CoolBoard.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardActor Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardActor}
{\xe \v CoolBoardActor}
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor}. }}\par
{
{\f2 #include <CoolBoardActor.h>}}\par
Collaboration diagram for CoolBoardActor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d3e/class_cool_board_actor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (bool action)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doAction} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalAction} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invertedAction} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOff} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOn} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOff} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOn} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourAction} (int hour)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourAction} (int hour, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b minuteAction} (int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedMinuteAction} (int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourMinuteAction} (int hour, int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourMinuteAction} (int hour, int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardActor::state} {\b actor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b pin} = 15\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor}. \par
}{
Definition at line 44 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolBoardActor}
{\xe \v CoolBoardActor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::begin ()}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::begin()}: This method is provided to initialise the {\b CoolBoardActor} pin \par
}{
Definition at line 48 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49 \{\par
   50 \par
   51 #if DEBUG == 1 \par
   52  \par
   53     Serial.println( F("Entering CoolBoardActor.begin() ") );\par
   54     Serial.println();\par
   55 \par
   56 #endif\par
   57 \par
   58     pinMode(this->pin,OUTPUT);\par
   59     \par
   60     \par
   61 \par
   62 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a7f4422fd85a5510bc2cdfd68e109be5e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoardActor}
{\xe \v CoolBoardActor\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::config ()}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::config()}: This method is provided to configure the {\b CoolBoardActor} with a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 258 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   259 \{\par
  260 \par
  261 #if DEBUG == 1 \par
  262 \par
  263     Serial.println( F("Entering CoolBoardActor.config() ") );\par
  264     Serial.println();\par
  265 \par
  266 #endif\par
  267 \par
  268     File coolBoardActorConfig = SPIFFS.open("/coolBoardActorConfig.json", "r");\par
  269 \par
  270     if (!coolBoardActorConfig) \par
  271     \{\par
  272 \par
  273     #if DEBUG == 1 \par
  274 \par
  275         Serial.println( F("failed to read /coolBoardActorConfig.json ") );\par
  276         Serial.println();\par
  277 \par
  278     #endif\par
  279 \par
  280         return(false);\par
  281     \}\par
  282     else\par
  283     \{\par
  284         size_t size = coolBoardActorConfig.size();\par
  285         // Allocate a buffer to store contents of the file.\par
  286         std::unique_ptr<char[]> buf(new char[size]);\par
  287 \par
  288         coolBoardActorConfig.readBytes(buf.get(), size);\par
  289         DynamicJsonBuffer jsonBuffer;\par
  290         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  291         if (!json.success()) \par
  292         \{\par
  293         \par
  294         #if DEBUG == 1 \par
  295 \par
  296             Serial.println( F("failed to parse coolBoardActor Config  json from file ") );\par
  297             Serial.println();\par
  298 \par
  299         #endif\par
  300 \par
  301             return(false);\par
  302         \} \par
  303         else\par
  304         \{ \par
  305         \par
  306         #if DEBUG == 1 \par
  307 \par
  308             Serial.println( F("read configuration file : ") );\par
  309             json.printTo(Serial);\par
  310             Serial.println();\par
  311 \par
  312             Serial.print(F("jsonBuffer size: "));\par
  313             Serial.println(jsonBuffer.size());\par
  314             Serial.println();\par
  315 \par
  316         \par
  317         #endif\par
  318   \par
  319             //parsing actif key\par
  320             if(json["actif"].success() )\par
  321             \{\par
  322                 this->actor.actif=json["actif"];\par
  323             \}\par
  324             else\par
  325             \{\par
  326                 this->actor.actif=this->actor.actif;\par
  327             \}\par
  328             json["actif"]=this->actor.actif;\par
  329             \par
  330             //parsing temporal key\par
  331             if(json["temporal"].success() )\par
  332             \{\par
  333                 this->actor.temporal=json["temporal"];\par
  334             \}\par
  335             else\par
  336             \{\par
  337                 this->actor.temporal=this->actor.temporal;\par
  338             \}\par
  339             json["temporal"]=this->actor.temporal;\par
  340             \par
  341             //parsing inverted key\par
  342             if(json["inverted"].success() )\par
  343             \{\par
  344                 this->actor.inverted=json["inverted"];\par
  345             \}\par
  346             else\par
  347             \{\par
  348                 this->actor.inverted=this->actor.inverted;\par
  349             \}\par
  350             json["inverted"]=this->actor.inverted;\par
  351 \par
  352             //parsing inverted key\par
  353             if(json["inverted"].success() )\par
  354             \{\par
  355                 this->actor.inverted=json["inverted"];\par
  356             \}\par
  357             else\par
  358             \{\par
  359                 this->actor.inverted=this->actor.inverted;\par
  360             \}\par
  361             json["inverted"]=this->actor.inverted;\par
  362             \par
  363             //parsing low key\par
  364             if(json["low"].success() )\par
  365             \{\par
  366                 this->actor.rangeLow=json["low"][0];\par
  367                 this->actor.timeLow=json["low"][1];\par
  368                 this->actor.hourLow=json["low"][2];                     \par
  369                 this->actor.minuteLow=json["low"][3];                       \par
  370             \}\par
  371             else\par
  372             \{\par
  373                 this->actor.rangeLow=this->actor.rangeLow;\par
  374                 this->actor.timeLow=this->actor.timeLow;\par
  375                 this->actor.hourLow=this->actor.hourLow;\par
  376                 this->actor.minuteLow=this->actor.minuteLow;                        \par
  377             \}\par
  378             json["low"][0]=this->actor.rangeLow;\par
  379             json["low"][1]=this->actor.timeLow;\par
  380             json["low"][2]=this->actor.hourLow;\par
  381             json["low"][3]=this->actor.minuteLow;\par
  382 \par
  383             //parsing high key\par
  384             if(json["high"].success() )\par
  385             \{\par
  386                 this->actor.rangeHigh=json["high"][0];\par
  387                 this->actor.timeHigh=json["high"][1];\par
  388                 this->actor.hourHigh=json["high"][2];                       \par
  389                 this->actor.minuteHigh=json["high"][3];                     \par
  390             \}\par
  391             else\par
  392             \{\par
  393                 this->actor.rangeHigh=this->actor.rangeHigh;\par
  394                 this->actor.timeHigh=this->actor.timeHigh;\par
  395                 this->actor.hourHigh=this->actor.hourHigh;\par
  396                 this->actor.minuteHigh=this->actor.minuteHigh;\par
  397             \}\par
  398             json["high"][0]=this->actor.rangeHigh;\par
  399             json["high"][1]=this->actor.timeHigh;\par
  400             json["high"][2]=this->actor.hourHigh;\par
  401             json["high"][3]=this->actor.minuteHigh;\par
  402 \par
  403             //parsing type key\par
  404             if(json["type"].success() )\par
  405             \{\par
  406                 this->actor.primaryType=json["type"][0].as<String>();\par
  407                 this->actor.secondaryType=json["type"][1].as<String>();                     \par
  408                 \par
  409             \}\par
  410             else\par
  411             \{\par
  412                 this->actor.primaryType=this->actor.primaryType;\par
  413                 this->actor.secondaryType=this->actor.secondaryType;\par
  414             \}\par
  415             json["type"][0]=this->actor.primaryType;\par
  416             json["type"][1]=this->actor.secondaryType;\par
  417             \par
  418 \par
  419             coolBoardActorConfig.close();           \par
  420             coolBoardActorConfig = SPIFFS.open("/coolBoardActorConfig.json", "w");          \par
  421             if(!coolBoardActorConfig)\par
  422             \{\par
  423             \par
  424             #if DEBUG == 1 \par
  425 \par
  426                 Serial.println( F("failed to write to /coolBoardActorConfig.json ") );\par
  427                 Serial.println();\par
  428             \par
  429             #endif\par
  430                 \par
  431                 return(false);          \par
  432             \}  \par
  433 \par
  434             json.printTo(coolBoardActorConfig);\par
  435             coolBoardActorConfig.close();\par
  436 \par
  437         #if DEBUG == 1 \par
  438             \par
  439             Serial.println(F("saved configuration : "));\par
  440             json.printTo(Serial );\par
  441             Serial.println();       \par
  442         \par
  443         #endif\par
  444 \par
  445             return(true); \par
  446         \}\par
  447     \}   \par
  448     \par
  449 \par
  450 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a5af5538fc7d169f63127e06d5219bcd4_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v doAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:doAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::doAction (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::doAction(sensor data ): This method is provided to automate the {\b CoolBoardActor}.\par
The result action is the result of checking the different flags of the actor (actif , temporal ,inverted, primaryType and secondaryType ) and the corresponding call to the appropriate helping method \par
}{
Definition at line 101 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   102 \{\par
  103 \par
  104 #if DEBUG == 1 \par
  105 \par
  106     Serial.println( F("Entering CoolBoardActor.doAction()") );\par
  107     Serial.println();\par
  108 \par
  109     Serial.println( F("input data is :") );\par
  110     Serial.println(data);\par
  111     Serial.println();\par
  112 \par
  113 #endif \par
  114 \par
  115     DynamicJsonBuffer jsonBuffer;\par
  116     JsonObject& root = jsonBuffer.parseObject(data);\par
  117     \par
  118     if (!root.success()) \par
  119     \{\par
  120     \par
  121     #if DEBUG == 1 \par
  122 \par
  123         Serial.println( F("failed to parse json object ") );\par
  124         Serial.println();\par
  125     \par
  126     #endif \par
  127 \par
  128     \}\par
  129     else\par
  130     \{\par
  131     \par
  132     #if DEBUG == 1 \par
  133 \par
  134         Serial.println( F("created Json object :") );\par
  135         root.printTo(Serial);\par
  136         Serial.println();\par
  137 \par
  138         Serial.print(F("jsonBuffer size: "));\par
  139         Serial.println(jsonBuffer.size());\par
  140         Serial.println();\par
  141 \par
  142     \par
  143     #endif \par
  144 \par
  145         //invert the current action state for the actor\par
  146         //if the value is outside the limits\par
  147         \par
  148         //check if actor is actif\par
  149         if(this->actor.actif==1)\par
  150         \{\par
  151             //normal actor\par
  152             if(this->actor.temporal == 0)\par
  153             \{\par
  154                 //not inverted actor\par
  155                 if(this->actor.inverted==0)\par
  156                 \{\par
  157                     this->normalAction(root[this->actor.primaryType].as<float>());              \par
  158                 \}\par
  159                 //inverted actor\par
  160                 else if(this->actor.inverted==1)\par
  161                 \{\par
  162                     this->invertedAction(root[this->actor.primaryType].as<float>());                \par
  163                 \}\par
  164             \}\par
  165             //temporal actor\par
  166             else if(this->actor.temporal == 1 )\par
  167             \{\par
  168                 //hour actor\par
  169                 if(this->actor.secondaryType=="hour")\par
  170                 \{\par
  171                     //mixed hour actor\par
  172                     if(root[this->actor.primaryType].success() )\par
  173                     \{\par
  174                         this->mixedHourAction(root[this->actor.secondaryType].as<int>(),root[this->actor.primaryType].as<float>());\par
  175                     \}\par
  176                     //normal hour actor\par
  177                     else\par
  178                     \{\par
  179                         this->hourAction(root[this->actor.secondaryType].as<int>());\par
  180                     \}\par
  181                 \par
  182                 \}\par
  183                 //minute actor\par
  184                 else if(this->actor.secondaryType=="minute")\par
  185                 \{\par
  186                     //mixed minute actor\par
  187                     if(root[this->actor.primaryType].success() )\par
  188                     \{\par
  189                         this->mixedMinuteAction(root[this->actor.secondaryType].as<int>(),root[this->actor.primaryType].as<float>());\par
  190                     \}\par
  191                     //normal minute actor\par
  192                     else\par
  193                     \{\par
  194                         this->minuteAction(root[this->actor.secondaryType].as<int>());\par
  195                     \}\par
  196                 \}\par
  197                 //hourMinute actor\par
  198                 else if(this->actor.secondaryType=="hourMinute")\par
  199                 \{\par
  200                     //mixed hourMinute actor\par
  201                     if(root[this->actor.primaryType].success() )\par
  202                     \{\par
  203                         this->mixedHourMinuteAction(root["hour"].as<int>(),root["minute"].as<int>(),root[this->actor.primaryType].as<float>());\par
  204                     \}\par
  205                     //normal hourMinute actor\par
  206                     else\par
  207                     \{\par
  208                         this->hourMinuteAction(root["hour"].as<int>(),root["minute"].as<int>());\par
  209                     \}\par
  210                 \}\par
  211                 //normal temporal actor\par
  212                 else if(this->actor.secondaryType=="")\par
  213                 \{\par
  214                     //mixed temporal actor\par
  215                     if(root[this->actor.primaryType].success() )\par
  216                     \{\par
  217                         this->mixedTemporalActionOn(root[this->actor.primaryType].as<float>());\par
  218                     \}\par
  219                     //normal temporal actor\par
  220                     else\par
  221                     \{\par
  222                         this->temporalActionOn();\par
  223                     \}\par
  224                                         \par
  225                 \}\par
  226 \par
  227             \}\par
  228         \}\par
  229         //inactif actor\par
  230         else if(this->actor.actif == 0 )\par
  231         \{\par
  232             //temporal actor\par
  233             if(this->actor.temporal==1)\par
  234             \{\par
  235                 //mixed temporal actor\par
  236                 if(root[this->actor.primaryType].success() )\par
  237                 \{\par
  238                     this->mixedTemporalActionOff(root[this->actor.primaryType].as<float>());\par
  239                 \}\par
  240                 //normal temporal actor\par
  241                 else\par
  242                 \{\par
  243                     this->temporalActionOff();\par
  244                 \}\par
  245             \}           \par
  246         \}\par
  247 \par
  248     \} \par
  249 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a96a45658d32c6b95caa2f385c7da32cd_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a96a45658d32c6b95caa2f385c7da32cd_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:hourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::hourAction (int  {\i hour})}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::hourAction( current hour ): This method is provided to handle hour actors. it changes the action according to:\par
hour >= hourLow : deactivate the actor hour >= hourHigh : activate the actor \par
}{
Definition at line 922 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   923 \{\par
  924 \par
  925 #if DEBUG == 1\par
  926     \par
  927     Serial.print(F("hour Actor "));\par
  928     Serial.println();\par
  929 \par
  930     Serial.print(F(" hour : "));\par
  931     Serial.println(hour);\par
  932 \par
  933     Serial.print(F("high hour : "));\par
  934     Serial.println(this->actor.hourHigh);\par
  935 \par
  936     Serial.print(F("low hour : "));\par
  937     Serial.println(this->actor.hourLow);\par
  938 \par
  939 #endif\par
  940 \par
  941     //stop the actor    \par
  942     if(hour >= this->actor.hourLow)\par
  943     \{\par
  944         this->write( 0) ;\par
  945 \par
  946     #if DEBUG == 1 \par
  947 \par
  948         Serial.println(F("actor OFF "));\par
  949 \par
  950     #endif  \par
  951 \par
  952     \}\par
  953     //starting the actor\par
  954     else if(hour >= this->actor.hourHigh)\par
  955     \{\par
  956         this->write( 1) ;\par
  957 \par
  958     #if DEBUG == 1 \par
  959 \par
  960         Serial.println(F("actor ON "));\par
  961 \par
  962     #endif  \par
  963     \par
  964     \}\par
  965 \par
  966 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_adf3b4e15b9d73681082112adf8ef95cb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_adf3b4e15b9d73681082112adf8ef95cb_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourMinuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:hourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::hourMinuteAction (int  {\i hour}, int  {\i minute})}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::minteAction( current hour,current minute ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : deactivate the actor\par
hour > hourLow : deactivate the actor\par
hour == hourHigh : minute >= minteHigh : activate the actor\par
hour > hourHigh : activate the actor \par
}{
Definition at line 1266 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1267 \{\par
 1268 \par
 1269 #if DEBUG == 1\par
 1270 \par
 1271     Serial.print(F("hourMinute Actor "));\par
 1272     Serial.println();\par
 1273 \par
 1274     Serial.print(F(" hour : "));\par
 1275     Serial.println(hour);\par
 1276     Serial.print(F(" minute : "));\par
 1277     Serial.println(minute);\par
 1278 \par
 1279     Serial.print(F("high hour : "));\par
 1280     Serial.println(this->actor.hourHigh);\par
 1281 \par
 1282     Serial.print(F("high minute : "));\par
 1283     Serial.println(this->actor.minuteHigh);\par
 1284 \par
 1285     Serial.print(F("low hour : "));\par
 1286     Serial.println(this->actor.hourLow);\par
 1287 \par
 1288     Serial.print(F("low minute : "));\par
 1289     Serial.println(this->actor.minuteLow);\par
 1290 \par
 1291 #endif\par
 1292     //stop the actor\par
 1293     if(hour==this->actor.hourLow)\par
 1294     \{\par
 1295         if(minute>= this->actor.minuteLow)\par
 1296         \{\par
 1297             this->write( 0) ;\par
 1298         #if DEBUG == 1 \par
 1299 \par
 1300             Serial.println(F("actor OFF "));\par
 1301 \par
 1302         #endif  \par
 1303         \}\par
 1304     \}\par
 1305     else if(hour > this->actor.hourLow)\par
 1306     \{\par
 1307 \par
 1308         this->write( 0) ;\par
 1309     #if DEBUG == 1 \par
 1310 \par
 1311         Serial.println(F("actor OFF "));\par
 1312 \par
 1313     #endif  \par
 1314     \par
 1315     \}\par
 1316     //start the actor\par
 1317     else if(hour==this->actor.hourHigh)\par
 1318     \{\par
 1319         if(minute>= this->actor.minuteHigh)\par
 1320         \{\par
 1321             this->write( 1) ;\par
 1322 \par
 1323         #if DEBUG == 1 \par
 1324 \par
 1325             Serial.println(F("actor ON "));\par
 1326 \par
 1327         #endif  \par
 1328         \}\par
 1329     \}\par
 1330     else if(hour > this->actor.hourHigh)\par
 1331     \{\par
 1332 \par
 1333         this->write( 1) ;\par
 1334 \par
 1335     #if DEBUG == 1 \par
 1336 \par
 1337         Serial.println(F("actor ON "));\par
 1338 \par
 1339     #endif      \par
 1340 \par
 1341     \}\par
 1342 \par
 1343     \par
 1344 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a1eb1fbca19bc80aad20d2686d52317f8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a1eb1fbca19bc80aad20d2686d52317f8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v invertedAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:invertedAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::invertedAction (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::invertedAction( measured value): This method is provided to handle inverted actors. it changes the action according to wether the measured value is: \par
{\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid rangeHigh (activate actor) \par
}< rangeLow ( deactivate actor ) \par
}{
Definition at line 589 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   590 \{\par
  591 #if DEBUG == 1\par
  592     \par
  593     Serial.print("inverted Actor ");\par
  594     Serial.println();\par
  595 \par
  596     Serial.print("measured value : ");\par
  597     Serial.println(measurment);\par
  598 \par
  599     Serial.print("high range : ");\par
  600     Serial.println(this->actor.rangeHigh);\par
  601 \par
  602     Serial.print("low range : ");\par
  603     Serial.println(this->actor.rangeLow);\par
  604 \par
  605 #endif\par
  606 \par
  607     //measured value lower than minimum range : deactivate actor\par
  608     if(measurment < this->actor.rangeLow)\par
  609     \{\par
  610         this->write( 0) ;\par
  611 \par
  612     #if DEBUG == 1 \par
  613 \par
  614         Serial.println(F("actor OFF "));\par
  615     \par
  616     #endif\par
  617 \par
  618     \}\par
  619     //measured value higher than maximum range : activate actor\par
  620     else if(measurment > this->actor.rangeHigh)\par
  621     \{\par
  622         this->write( 1) ;\par
  623 \par
  624     #if DEBUG == 1 \par
  625 \par
  626         Serial.println(F("actor ON "));\par
  627     \par
  628     #endif\par
  629 \par
  630     \}\par
  631 \par
  632 \par
  633 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_aae82b2e62f91be009d40f93c206f9bda_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_aae82b2e62f91be009d40f93c206f9bda_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v minuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:minuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::minuteAction (int  {\i minute})}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::minteAction( current minute ): This method is provided to handle minute actors. it changes the action according to:\par
minute >= minuteLow : deactivate the actor minute >= minuteHigh : activate the actor \par
}{
Definition at line 1090 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1091 \{\par
 1092 \par
 1093 #if DEBUG == 1\par
 1094     \par
 1095     Serial.print(F("minute Actor "));\par
 1096     Serial.println();\par
 1097 \par
 1098     Serial.print(F(" minute : "));\par
 1099     Serial.println(minute);\par
 1100 \par
 1101     Serial.print(F("high minute : "));\par
 1102     Serial.println(this->actor.minuteHigh);\par
 1103 \par
 1104     Serial.print(F("low minute : "));\par
 1105     Serial.println(this->actor.minuteLow);\par
 1106 \par
 1107 #endif\par
 1108 \par
 1109     //stop the actor    \par
 1110     if(minute >= this->actor.minuteLow)\par
 1111     \{\par
 1112         this->write( 0) ;\par
 1113 \par
 1114     #if DEBUG == 1 \par
 1115 \par
 1116         Serial.println(F("actor OFF "));\par
 1117 \par
 1118     #endif  \par
 1119 \par
 1120     \}   \par
 1121     //starting the actor\par
 1122     else if(minute >= this->actor.minuteHigh)\par
 1123     \{\par
 1124         this->write( 1) ;\par
 1125 \par
 1126     #if DEBUG == 1 \par
 1127 \par
 1128         Serial.println(F("actor ON "));\par
 1129 \par
 1130     #endif  \par
 1131 \par
 1132     \}\par
 1133 \par
 1134 \} \par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_af000944ce0b9abb9c6ee4b8fe839fb36_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_af000944ce0b9abb9c6ee4b8fe839fb36_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedHourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedHourAction (int  {\i hour}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedHourAction( current hour, measured value ): This method is provided to handle mixed hour actors. it changes the action according to :\par
hour >= hourLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
hour >= hourHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 983 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   984 \{\par
  985 \par
  986 #if DEBUG == 1\par
  987     \par
  988     Serial.print("mixed hour Actor N\'B0 : ");\par
  989     Serial.println();\par
  990 \par
  991     Serial.print(" hour : ");\par
  992     Serial.println(hour);\par
  993 \par
  994     Serial.print("high hour : ");\par
  995     Serial.println(this->actor.hourHigh);\par
  996 \par
  997     Serial.print("low hour : ");\par
  998     Serial.println(this->actor.hourLow);\par
  999 \par
 1000     Serial.print("measured value : ");\par
 1001     Serial.println(measurment);\par
 1002 \par
 1003     Serial.print("high range : ");\par
 1004     Serial.println(this->actor.rangeHigh);\par
 1005 \par
 1006     Serial.print("low range : ");\par
 1007     Serial.println(this->actor.rangeLow);\par
 1008 \par
 1009 #endif\par
 1010     //stop the actor    \par
 1011     if(hour >= this->actor.hourLow)\par
 1012     \{\par
 1013             if( measurment >= this->actor.rangeHigh )\par
 1014             \{\par
 1015                 this->write( 0) ;\par
 1016 \par
 1017             #if DEBUG == 1 \par
 1018 \par
 1019                 Serial.print(measurment);\par
 1020                 Serial.print(F(" > " ));\par
 1021                 Serial.println(this->actor.rangeHigh);\par
 1022 \par
 1023                 Serial.println(F("actor OFF "));\par
 1024 \par
 1025             #endif  \par
 1026 \par
 1027             \}\par
 1028             else \par
 1029             \{\par
 1030                 this->write( 1) ;\par
 1031 \par
 1032             #if DEBUG == 1 \par
 1033 \par
 1034                 Serial.print(measurment);\par
 1035                 Serial.print(F(" < " ));\par
 1036                 Serial.print(this->actor.rangeHigh);\par
 1037 \par
 1038                 Serial.println(F("actor ON "));\par
 1039 \par
 1040             #endif  \par
 1041                 \par
 1042             \}\par
 1043     \}\par
 1044     //starting the actor\par
 1045     else if(hour >= this->actor.hourHigh)\par
 1046     \{\par
 1047             if( measurment < this->actor.rangeLow )\par
 1048             \{\par
 1049                 this->write( 1) ;\par
 1050 \par
 1051             #if DEBUG == 1 \par
 1052 \par
 1053                 Serial.print(measurment);\par
 1054                 Serial.print(F(" < " ));\par
 1055                 Serial.println(this->actor.rangeLow);\par
 1056 \par
 1057                 Serial.println(F("actor ON "));\par
 1058 \par
 1059             #endif  \par
 1060             \}\par
 1061             else \par
 1062             \{\par
 1063                 this->write( 0) ;\par
 1064 \par
 1065             #if DEBUG == 1 \par
 1066 \par
 1067                 Serial.print(measurment);\par
 1068                 Serial.print(F(" > " ));\par
 1069                 Serial.println(this->actor.rangeLow);\par
 1070 \par
 1071                 Serial.println(F("actor OFF "));\par
 1072 \par
 1073             #endif                  \par
 1074             \}\par
 1075 \par
 1076     \}\par
 1077 \par
 1078 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a6d93a24502c56ced2ef7675c913a276b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a6d93a24502c56ced2ef7675c913a276b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourMinuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedHourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedHourMinuteAction (int  {\i hour}, int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::minteAction( current hour,current minute , measured Value ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour > hourLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour == hourHigh : minute >= minteHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor\par
hour > hourHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor \par
}{
Definition at line 1371 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1372 \{\par
 1373 \par
 1374 #if DEBUG == 1\par
 1375     \par
 1376     Serial.print("hourMinute Actor  ");\par
 1377     Serial.println();\par
 1378 \par
 1379     Serial.print(" hour : ");\par
 1380     Serial.println(hour);\par
 1381     Serial.print(" minute : ");\par
 1382     Serial.println(minute);\par
 1383 \par
 1384     Serial.print("high hour : ");\par
 1385     Serial.println(this->actor.hourHigh);\par
 1386 \par
 1387     Serial.print("high minute : ");\par
 1388     Serial.println(this->actor.minuteHigh);\par
 1389 \par
 1390     Serial.print("low hour : ");\par
 1391     Serial.println(this->actor.hourLow);\par
 1392 \par
 1393     Serial.print("low minute : ");\par
 1394     Serial.println(this->actor.minuteLow);\par
 1395 \par
 1396     Serial.print("measured value : ");\par
 1397     Serial.println(measurment);\par
 1398 \par
 1399     Serial.print("high range : ");\par
 1400     Serial.println(this->actor.rangeHigh);\par
 1401 \par
 1402     Serial.print("low range : ");\par
 1403     Serial.println(this->actor.rangeLow);\par
 1404 \par
 1405 #endif\par
 1406     //stop the actor\par
 1407     if(hour==this->actor.hourLow)\par
 1408     \{\par
 1409         if(minute>= this->actor.minuteLow)\par
 1410         \{\par
 1411             if( measurment >= this->actor.rangeHigh )\par
 1412             \{\par
 1413                 this->write( 0) ;\par
 1414 \par
 1415             #if DEBUG == 1 \par
 1416 \par
 1417                 Serial.print(measurment);\par
 1418                 Serial.print(F(" >= " ));\par
 1419                 Serial.println(this->actor.rangeHigh);\par
 1420 \par
 1421                 Serial.println(F("actor OFF "));\par
 1422 \par
 1423             #endif  \par
 1424 \par
 1425             \}\par
 1426             else \par
 1427             \{\par
 1428                 this->write( 1) ;\par
 1429 \par
 1430             #if DEBUG == 1 \par
 1431 \par
 1432                 Serial.print(measurment);\par
 1433                 Serial.print(F(" < " ));\par
 1434                 Serial.println(this->actor.rangeHigh);\par
 1435 \par
 1436                 Serial.println(F("actor ON "));\par
 1437 \par
 1438             #endif  \par
 1439                 \par
 1440             \}\par
 1441         \}\par
 1442     \}\par
 1443     else if(hour > this->actor.hourLow)\par
 1444     \{\par
 1445 \par
 1446         if( measurment >= this->actor.rangeHigh )\par
 1447         \{\par
 1448             this->write( 0) ;\par
 1449 \par
 1450         #if DEBUG == 1 \par
 1451 \par
 1452             Serial.print(measurment);\par
 1453             Serial.print(F(" >= " ));\par
 1454             Serial.println(this->actor.rangeHigh);\par
 1455 \par
 1456             Serial.println(F("actor OFF "));\par
 1457 \par
 1458         #endif  \par
 1459 \par
 1460         \}\par
 1461         else \par
 1462         \{\par
 1463             this->write( 1) ;\par
 1464 \par
 1465         #if DEBUG == 1 \par
 1466 \par
 1467             Serial.print(measurment);\par
 1468             Serial.print(F(" < " ));\par
 1469             Serial.println(this->actor.rangeHigh);\par
 1470 \par
 1471             Serial.println(F("actor ON "));\par
 1472 \par
 1473         #endif  \par
 1474             \par
 1475         \}\par
 1476 \par
 1477 \par
 1478     \}\par
 1479     //start the actor\par
 1480     else if(hour==this->actor.hourHigh)\par
 1481     \{\par
 1482         if(minute>= this->actor.minuteHigh)\par
 1483         \{\par
 1484             if( measurment < this->actor.rangeLow )\par
 1485             \{\par
 1486                 this->write( 1) ;\par
 1487 \par
 1488             #if DEBUG == 1 \par
 1489 \par
 1490                 Serial.print(measurment);\par
 1491                 Serial.print(F(" < " ));\par
 1492                 Serial.println(this->actor.rangeLow);\par
 1493 \par
 1494                 Serial.println(F("actor ON "));\par
 1495 \par
 1496             #endif  \par
 1497 \par
 1498             \}\par
 1499             else \par
 1500             \{\par
 1501                 this->write( 0) ;\par
 1502 \par
 1503             #if DEBUG == 1 \par
 1504 \par
 1505                 Serial.print(measurment);\par
 1506                 Serial.println(F(" > " ));\par
 1507                 Serial.print(this->actor.rangeLow);\par
 1508 \par
 1509                 Serial.println(F("actor OFF "));\par
 1510 \par
 1511             #endif  \par
 1512                 \par
 1513             \}\par
 1514         \}\par
 1515     \}\par
 1516     else if(hour > this->actor.hourHigh)\par
 1517     \{\par
 1518 \par
 1519         if( measurment < this->actor.rangeLow )\par
 1520         \{\par
 1521             this->write( 1) ;\par
 1522 \par
 1523         #if DEBUG == 1 \par
 1524 \par
 1525             Serial.print(measurment);\par
 1526             Serial.print(F(" < " ));\par
 1527             Serial.println(this->actor.rangeLow);\par
 1528 \par
 1529             Serial.println(F("actor ON "));\par
 1530 \par
 1531         #endif  \par
 1532 \par
 1533         \}\par
 1534         else \par
 1535         \{\par
 1536             this->write( 0) ;\par
 1537 \par
 1538         #if DEBUG == 1 \par
 1539 \par
 1540             Serial.print(measurment);\par
 1541             Serial.println(F(" > " ));\par
 1542             Serial.print(this->actor.rangeLow);\par
 1543 \par
 1544             Serial.println(F("actor OFF "));\par
 1545 \par
 1546         #endif  \par
 1547             \par
 1548         \}\par
 1549     \par
 1550     \}\par
 1551 \par
 1552 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ae6b2a17b0e73cfeb353ded2cc4e08109_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ae6b2a17b0e73cfeb353ded2cc4e08109_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedMinuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedMinuteAction (int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedMinuteAction( current minute, measured value ): This method is provided to handle mixed minute actors. it changes the action according to :\par
minute >= minuteLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
minute >= minuteHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 1150 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1151 \{\par
 1152 \par
 1153 #if DEBUG == 1\par
 1154     \par
 1155     Serial.print("mixed minute Actor ");\par
 1156     Serial.println();\par
 1157 \par
 1158     Serial.print(" minute : ");\par
 1159     Serial.println(minute);\par
 1160 \par
 1161     Serial.print("high minute : ");\par
 1162     Serial.println(this->actor.minuteHigh);\par
 1163 \par
 1164     Serial.print("low minute : ");\par
 1165     Serial.println(this->actor.minuteLow);\par
 1166 \par
 1167     Serial.print("measured value : ");\par
 1168     Serial.println(measurment);\par
 1169 \par
 1170     Serial.print("high range : ");\par
 1171     Serial.println(this->actor.rangeHigh);\par
 1172 \par
 1173     Serial.print("low range : ");\par
 1174     Serial.println(this->actor.rangeLow);\par
 1175 \par
 1176 #endif\par
 1177     //stop the actor    \par
 1178     if(minute >= this->actor.minuteLow)\par
 1179     \{\par
 1180             if( measurment > this->actor.rangeHigh )\par
 1181             \{\par
 1182                 this->write( 0) ;\par
 1183 \par
 1184             #if DEBUG == 1 \par
 1185 \par
 1186                 Serial.print(measurment);\par
 1187                 Serial.print(F(" > " ));\par
 1188                 Serial.println(this->actor.rangeHigh);\par
 1189 \par
 1190                 Serial.println(F("actor OFF "));\par
 1191 \par
 1192             #endif\par
 1193     \par
 1194             \}\par
 1195             else \par
 1196             \{\par
 1197                 this->write( 1) ;\par
 1198 \par
 1199             #if DEBUG == 1 \par
 1200 \par
 1201                 Serial.print(measurment);\par
 1202                 Serial.print(F(" < " ));\par
 1203                 Serial.println(this->actor.rangeHigh);\par
 1204 \par
 1205                 Serial.println(F("actor ON "));\par
 1206 \par
 1207             #endif  \par
 1208                 \par
 1209             \}\par
 1210     \}   \par
 1211     //starting the actor\par
 1212     else if(minute >= this->actor.minuteHigh)\par
 1213     \{\par
 1214             if( measurment < this->actor.rangeLow )\par
 1215             \{\par
 1216                 this->write( 1) ;\par
 1217 \par
 1218             #if DEBUG == 1 \par
 1219 \par
 1220                 Serial.print(measurment);\par
 1221                 Serial.print(F(" < " ));\par
 1222                 Serial.println(this->actor.rangeLow);\par
 1223 \par
 1224                 Serial.println(F("actor ON "));\par
 1225 \par
 1226             #endif  \par
 1227 \par
 1228             \}\par
 1229             else \par
 1230             \{\par
 1231                 this->write( 0) ;\par
 1232             \par
 1233             #if DEBUG == 1 \par
 1234 \par
 1235                 Serial.print(measurment);\par
 1236                 Serial.print(F(" > " ));\par
 1237                 Serial.println(this->actor.rangeLow);\par
 1238 \par
 1239                 Serial.println(F("actor OFF "));\par
 1240 \par
 1241             #endif  \par
 1242                 \par
 1243             \}\par
 1244 \par
 1245     \}\par
 1246 \par
 1247 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a2b8a79a27288d5246e3e3860ae76770d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a2b8a79a27288d5246e3e3860ae76770d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOff\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedTemporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedTemporalActionOff (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedTemporalActionOff( measured value ): This method is provided to handle mixed temporal actors. it changes the action according to:\par
currentTime - startTime >= timeHigh : measured value >= rangeHigh : deactivate actor measured value < rangeHigh : activate actor \par
}{
Definition at line 695 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   696 \{\par
  697 \par
  698 #if DEBUG == 1\par
  699     \par
  700     Serial.print("mixed Temporal Actor N\'B0 : ");\par
  701     Serial.println();\par
  702 \par
  703     Serial.print("measured value : ");\par
  704     Serial.println(measurment);\par
  705 \par
  706     Serial.print("high range : ");\par
  707     Serial.println(this->actor.rangeHigh);\par
  708 \par
  709     Serial.print("time high : ");\par
  710     Serial.println(this->actor.timeHigh);\par
  711 \par
  712     Serial.print("actif Time : ");\par
  713     Serial.println(this->actor.actifTime);\par
  714 \par
  715     Serial.print(F("millis : "));\par
  716     Serial.println(millis());\par
  717 \par
  718 #endif\par
  719     if( ( millis()- this->actor.actifTime  ) >= (  this->actor.timeHigh  ) )\par
  720     \{   \par
  721         if( measurment >= this->actor.rangeHigh )\par
  722         \{\par
  723             //stop the actor\par
  724             this->write( 0) ;\par
  725 \par
  726             //make the actor inactif:\par
  727             this->actor.actif=0;\par
  728 \par
  729             //start the low timer\par
  730             this->actor.inactifTime=millis();\par
  731 \par
  732         #if DEBUG == 1 \par
  733 \par
  734             Serial.print(F("actor was on for at least "));\par
  735             Serial.print(this->actor.timeHigh);\par
  736             Serial.println(F(" ms "));\par
  737 \par
  738             Serial.print(measurment);\par
  739             Serial.print(F(" > " ));\par
  740             Serial.println(this->actor.rangeHigh);\par
  741 \par
  742             \par
  743             Serial.println(F("actor OFF "));\par
  744 \par
  745         #endif\par
  746 \par
  747         \}\par
  748         else \par
  749         \{\par
  750             this->write( 1) ;\par
  751 \par
  752         #if DEBUG == 1 \par
  753             \par
  754             Serial.print(F("actor was on for at least "));\par
  755             Serial.print(this->actor.timeHigh);\par
  756             Serial.println(F(" ms "));\par
  757 \par
  758             Serial.print(measurment);\par
  759             Serial.print(F(" < " ));\par
  760             Serial.println(this->actor.rangeHigh);\par
  761 \par
  762             Serial.println(F("actor ON "));\par
  763 \par
  764         #endif              \par
  765 \par
  766         \}           \par
  767     \}\par
  768 \par
  769 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a00b29c4abf0388551aa6812372113cf1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a00b29c4abf0388551aa6812372113cf1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOn\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedTemporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedTemporalActionOn (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedTemporalActionOn( measured value ): This method is provided to handle mixed temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : measured value >= rangeLow : deactivate actor measured value < rangeLow : activate actor \par
}{
Definition at line 833 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   834 \{\par
  835 \par
  836 #if DEBUG == 1\par
  837     \par
  838     Serial.print("mixed Temporal Actor  ");\par
  839     Serial.println();\par
  840 \par
  841     Serial.print("measured value : ");\par
  842     Serial.println(measurment);\par
  843 \par
  844     Serial.print("low range : ");\par
  845     Serial.println(this->actor.rangeLow);\par
  846 \par
  847     Serial.print("time low : ");\par
  848     Serial.println(this->actor.timeLow);\par
  849 \par
  850     Serial.print("inactif Time : ");\par
  851     Serial.println(this->actor.inactifTime);\par
  852 \par
  853     Serial.print(F("millis : "));\par
  854     Serial.println(millis());\par
  855 \par
  856 #endif\par
  857 \par
  858     if( ( millis() - this->actor.inactifTime ) >= (  this->actor.timeLow  ) )\par
  859     \{\par
  860         if( measurment < this->actor.rangeLow )\par
  861         \{\par
  862             //start the actor\par
  863             this->write( 1) ;\par
  864 \par
  865             //make the actor actif:\par
  866             this->actor.actif=1;\par
  867 \par
  868             //start the low timer\par
  869             this->actor.actifTime=millis();\par
  870 \par
  871         #if DEBUG == 1 \par
  872 \par
  873             Serial.print(F("actor was off for at least "));\par
  874             Serial.print(this->actor.timeLow);\par
  875             Serial.println(F(" ms "));\par
  876 \par
  877             Serial.print(measurment);\par
  878             Serial.print(F(" < " ));\par
  879             Serial.println(this->actor.rangeLow);\par
  880     \par
  881             Serial.println(F("actor ON "));\par
  882     \par
  883         #endif  \par
  884 \par
  885         \}\par
  886         else \par
  887         \{\par
  888             this->write( 0) ;   \par
  889 \par
  890         #if DEBUG == 1 \par
  891 \par
  892             Serial.print(F("actor was off for at least "));\par
  893             Serial.print(this->actor.timeLow);\par
  894             Serial.println(F(" ms "));\par
  895 \par
  896             Serial.print(measurment);\par
  897             Serial.print(F(" > " ));\par
  898             Serial.println(this->actor.rangeLow);\par
  899 \par
  900             Serial.println(F("actor OFF "));\par
  901     \par
  902         #endif              \par
  903 \par
  904         \}\par
  905 \par
  906     \}\par
  907 \par
  908     \par
  909 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a216aa7a0cfd1f31d0025cc91c2ecd5dd_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a216aa7a0cfd1f31d0025cc91c2ecd5dd_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v normalAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:normalAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::normalAction (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::normalAction( measured value): This method is provided to handle normal actors. it changes the action according to wether the measured value is: > rangeHigh ( deactivate actor) or < rangeLow (activate actor ) \par
}{
Definition at line 532 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   533 \{\par
  534 \par
  535 #if DEBUG == 1\par
  536     \par
  537     Serial.print(F("none inverted Actor"));\par
  538     Serial.println();\par
  539 \par
  540     Serial.print(F("measured value : "));\par
  541     Serial.println(measurment);\par
  542 \par
  543     Serial.print(F("high range : "));\par
  544     Serial.println(this->actor.rangeHigh);\par
  545 \par
  546     Serial.print(F("low range : "));\par
  547     Serial.println(this->actor.rangeLow);\par
  548 \par
  549 #endif\par
  550 \par
  551     //measured value lower than minimum range : activate actor\par
  552     if(measurment < this->actor.rangeLow)\par
  553     \{\par
  554         this->write( 1) ;\par
  555 \par
  556     #if DEBUG == 1 \par
  557 \par
  558         Serial.println(F("actor ON "));s\par
  559     \par
  560     #endif\par
  561                 \par
  562     \}\par
  563     //measured value higher than maximum range : deactivate actor\par
  564     else if(measurment > this->actor.rangeHigh)\par
  565     \{\par
  566         this->write( 0) ;\par
  567 \par
  568     #if DEBUG == 1 \par
  569 \par
  570         Serial.println(F("actor OFF "));\par
  571     \par
  572     #endif\par
  573     \par
  574     \}\par
  575 \par
  576 \par
  577 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a81229abf5895f4d3b0355050b822b438_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a81229abf5895f4d3b0355050b822b438_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoardActor}
{\xe \v CoolBoardActor\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::printConf ()}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 458 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   459 \{\par
  460 \par
  461 #if DEBUG == 1 \par
  462 \par
  463     Serial.println( F("Enter CoolBoardActor.printConf() ") );\par
  464     Serial.println();\par
  465 \par
  466 #endif \par
  467     Serial.println(F( "CoolBoardActor configuration " ) ) ;\par
  468  \par
  469     Serial.print(F(" actif :"));\par
  470     Serial.println(this->actor.actif);\par
  471     \par
  472 \par
  473     Serial.print(F(" temporal :"));\par
  474     Serial.println(this->actor.temporal);\par
  475 \par
  476 \par
  477     Serial.print(F(" inverted :"));\par
  478     Serial.println(this->actor.inverted);\par
  479 \par
  480 \par
  481 \par
  482     Serial.print(F(" primary Type :"));\par
  483     Serial.println(this->actor.primaryType);\par
  484 \par
  485     Serial.print(F(" secondary Type :"));       \par
  486     Serial.println(this->actor.secondaryType);\par
  487 \par
  488 \par
  489     Serial.print(F(" range Low :"));\par
  490     Serial.println(this->actor.rangeLow);\par
  491 \par
  492 \par
  493     Serial.print(F(" time Low :"));\par
  494     Serial.println(this->actor.timeLow);\par
  495 \par
  496 \par
  497     Serial.print(F(" hour low:"));\par
  498     Serial.println(this->actor.hourLow);\par
  499 \par
  500 \par
  501     Serial.print(F(" minute low:"));\par
  502     Serial.println(this->actor.minuteLow);\par
  503 \par
  504 \par
  505     Serial.print(F(" range High:"));\par
  506     Serial.println(this->actor.rangeHigh);\par
  507 \par
  508 \par
  509     Serial.print(F(" time High:"));\par
  510     Serial.println(this->actor.timeHigh);\par
  511 \par
  512 \par
  513     Serial.print(F(" hour high:"));\par
  514     Serial.println(this->actor.hourHigh);\par
  515 \par
  516 \par
  517     Serial.print(F(" minute high:"));\par
  518     Serial.println(this->actor.minuteHigh);\par
  519 \par
  520     Serial.println(); \par
  521 \par
  522 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_aabb10e7aebc3249ffc940530de29f84a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOff\:CoolBoardActor}
{\xe \v CoolBoardActor\:temporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::temporalActionOff ()}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::temporalActionOff( )}: This method is provided to handle temporal actors. it changes the action according to:\par
currentTime - startTime > timeHigh : deactivate actor \par
}{
Definition at line 644 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   645 \{\par
  646 \par
  647 #if DEBUG == 1\par
  648     \par
  649     Serial.print(F("temporal Actor  "));\par
  650     Serial.println();\par
  651 \par
  652     Serial.print(F("millis : "));\par
  653     Serial.println(millis());\par
  654 \par
  655     Serial.print(F("actif Time : "));\par
  656     Serial.println(this->actor.actifTime);\par
  657 \par
  658     Serial.print(F("high time : "));\par
  659     Serial.println(this->actor.timeHigh);\par
  660 \par
  661 \par
  662 #endif\par
  663     \par
  664     if( ( millis()- this->actor.actifTime  ) >= (  this->actor.timeHigh  ) )\par
  665     \{\par
  666         //stop the actor\par
  667         this->write( 0) ;\par
  668 \par
  669         //make the actor inactif:\par
  670         this->actor.actif=0;\par
  671 \par
  672         //start the low timer\par
  673         this->actor.inactifTime=millis();\par
  674 \par
  675     #if DEBUG == 1 \par
  676 \par
  677         Serial.println(F("actor OFF "));\par
  678     \par
  679     #endif\par
  680                 \par
  681     \}   \par
  682 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a02698bd647df49cabbe74513d4d88918_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a02698bd647df49cabbe74513d4d88918_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOn\:CoolBoardActor}
{\xe \v CoolBoardActor\:temporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::temporalActionOn ()}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::temporalActionOn( )}: This method is provided to handle temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : activate actor \par
}{
Definition at line 781 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   782 \{\par
  783 \par
  784 #if DEBUG == 1\par
  785     \par
  786     Serial.print(F("temporal Actor "));\par
  787     Serial.println();\par
  788 \par
  789     Serial.print(F("millis : "));\par
  790     Serial.println(millis());\par
  791 \par
  792     Serial.print(F("inactif Time : "));\par
  793     Serial.println(this->actor.inactifTime);\par
  794 \par
  795     Serial.print(F("low time : "));\par
  796     Serial.println(this->actor.timeLow);\par
  797 \par
  798 \par
  799 #endif\par
  800     \par
  801      if( ( millis() - this->actor.inactifTime ) >= (  this->actor.timeLow  ) )\par
  802     \{\par
  803         //start the actor\par
  804         this->write( 1) ;\par
  805 \par
  806         //make the actor actif:\par
  807         this->actor.actif=1;\par
  808 \par
  809         //start the low timer\par
  810         this->actor.actifTime=millis();\par
  811 \par
  812     #if DEBUG == 1 \par
  813 \par
  814         Serial.println(F("actor ON "));\par
  815 \par
  816     #endif              \par
  817 \par
  818     \}\par
  819 \par
  820 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ada603785c203fdb0b41cc967d70bdc4d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ada603785c203fdb0b41cc967d70bdc4d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:CoolBoardActor}
{\xe \v CoolBoardActor\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::write (bool  {\i action})}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::write(action): This method is provided to write the given action to the {\b CoolBoardActor}. \par
}{
Definition at line 71 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    72 \{\par
   73 \par
   74 #if DEBUG == 1\par
   75 \par
   76     Serial.println( F("Entering CoolBoardActor.write()") );\par
   77     Serial.println();\par
   78 \par
   79     Serial.println( F("writing this action : ") );\par
   80     Serial.println(action,BIN);\par
   81     Serial.println();\par
   82 \par
   83 #endif \par
   84     \par
   85     digitalWrite(this->pin,action);\par
   86     \par
   87 \par
   88 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a958786ff01ea1056ee72c72d439f86da_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actor\:CoolBoardActor}
{\xe \v CoolBoardActor\:actor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoolBoardActor::state} CoolBoardActor::actor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pin\:CoolBoardActor}
{\xe \v CoolBoardActor\:pin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoardActor::pin = 15{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pin Number value the only available pin that can be used to run a small actor is pin 15 \par
}{
Definition at line 178 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardLed Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardLed}
{\xe \v CoolBoardLed}
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board. }}\par
{
{\f2 #include <CoolBoardLed.h>}}\par
Collaboration diagram for CoolBoardLed:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d22/class_cool_board_led__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (int R, int G, int B)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b activate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fade} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blink} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fadeIn} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fadeOut} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b strobe} (int R, int G, int B, float T)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NeoPixelBus< NeoGrbFeature, Neo800KbpsMethod > * {\b neoPixelLed} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ledActive} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board. \par
}{
Definition at line 45 of file CoolBoardLed.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v activate\:CoolBoardLed}
{\xe \v CoolBoardLed\:activate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::activate ()}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::activate()}: This method is provided to activate the Led Object without the configuration file \par
}{
Definition at line 441 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   442 \{\par
  443 \par
  444     this->ledActive=1;\par
  445 \par
  446 \}\par
}
}
{\xe \v begin\:CoolBoardLed}
{\xe \v CoolBoardLed\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::begin ()}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::begin()}: This method is provided to start the Led Object by setting the correct pin and creating a dynamic neoPixelBus \par
}{
Definition at line 249 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   250 \{\par
  251 \par
  252 #if DEBUG == 1\par
  253 \par
  254     Serial.println( F("Entering CoolBoardLed.begin() ") );\par
  255 \par
  256 #endif\par
  257     yield();\par
  258     if(this->ledActive == 1 )\par
  259     \{\par
  260         pinMode(5,OUTPUT);\par
  261         digitalWrite(5,HIGH);\par
  262         neoPixelLed = new NeoPixelBus<NeoGrbFeature, Neo800KbpsMethod>(1,2); \par
  263         neoPixelLed->Begin();\par
  264         neoPixelLed->Show();\par
  265 \par
  266     \}\par
  267 \par
  268 \} \par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_ae3cbde8affcc6f011cbd698c8ef911f6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v blink\:CoolBoardLed}
{\xe \v CoolBoardLed\:blink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::blink (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::blink( Red , Green , Blue , Time in seconds ): Blink animation: Led On for T seconds Led off \par
}{
Definition at line 91 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    92 \{\par
   93 \par
   94 #if DEBUG == 1\par
   95 \par
   96     Serial.println( F("Entering CoolBoardLed.blink()"));\par
   97     Serial.println();\par
   98     Serial.print( F("R : "));\par
   99     Serial.println(R);\par
  100     Serial.print( F("G : ") );\par
  101     Serial.println(G);\par
  102     Serial.print( F("B : ") );\par
  103     Serial.println(B);\par
  104     Serial.print( F("Time :") );\par
  105     Serial.println(T);\par
  106     Serial.println();\par
  107 \par
  108 #endif  \par
  109 \par
  110     if(this->ledActive == 1 )\par
  111     \{\par
  112         neoPixelLed->SetPixelColor(0, RgbColor(R, G, B));\par
  113         neoPixelLed->Show();\par
  114         delay(T);\par
  115         neoPixelLed->SetPixelColor(0, RgbColor(0, 0, 0));\par
  116         neoPixelLed->Show();\par
  117     \}\par
  118 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a96e1ea13003eee34c9dbcef340404426_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoardLed}
{\xe \v CoolBoardLed\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardLed::config ()}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::config()}: This method is provided to configure the Led Object : -ledActive=0 : deactivated -ledActive=1 : activated \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the configuration done, false otherwise \par
}}{
Definition at line 308 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   309 \{\par
  310 \par
  311 #if DEBUG == 1 \par
  312         \par
  313     Serial.println( F("Entering CoolBoardLed.config()") );\par
  314     Serial.println();\par
  315 \par
  316 #endif\par
  317     \par
  318     File coolBoardLedConfig = SPIFFS.open("/coolBoardLedConfig.json", "r");\par
  319 \par
  320     if (!coolBoardLedConfig) \par
  321     \{\par
  322     \par
  323     #if DEBUG == 1\par
  324 \par
  325         Serial.println( F("failed to read /coolBoardLedConfig.json") );\par
  326         Serial.println();\par
  327 \par
  328     #endif\par
  329 \par
  330         return(false);\par
  331     \}\par
  332     else\par
  333     \{\par
  334         size_t size = coolBoardLedConfig.size();\par
  335         // Allocate a buffer to store contents of the file.\par
  336         std::unique_ptr<char[]> buf(new char[size]);\par
  337 \par
  338         coolBoardLedConfig.readBytes(buf.get(), size);\par
  339         DynamicJsonBuffer jsonBuffer;\par
  340         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  341         if (!json.success()) \par
  342         \{\par
  343         \par
  344         #if DEBUG == 1\par
  345 \par
  346             Serial.println( F("failed to parse json") );\par
  347             Serial.println();\par
  348         \par
  349         #endif\par
  350 \par
  351             return(false);\par
  352         \} \par
  353         else\par
  354         \{\par
  355         \par
  356         #if DEBUG == 1\par
  357     \par
  358             Serial.println( F("read configuration file : ") );\par
  359             json.printTo(Serial);\par
  360             Serial.println();\par
  361             \par
  362             Serial.print(F("jsonBuffer size :"));\par
  363             Serial.println(jsonBuffer.size());\par
  364             Serial.println();\par
  365 \par
  366         #endif\par
  367   \par
  368             if(json["ledActive"].success() )\par
  369             \{\par
  370                 this->ledActive = json["ledActive"]; \par
  371             \}\par
  372             else\par
  373             \{\par
  374                 this->ledActive=this->ledActive;            \par
  375             \}\par
  376             \par
  377             json["ledActive"]=this->ledActive;\par
  378             coolBoardLedConfig.close();\par
  379             \par
  380             coolBoardLedConfig = SPIFFS.open("/coolBoardLedConfig.json", "w");\par
  381             if(!coolBoardLedConfig)\par
  382             \{\par
  383             \par
  384             #if DEBUG == 1 \par
  385 \par
  386                 Serial.println( F("failed to write to /coolBoardLedConfig.json") );\par
  387                 Serial.println();\par
  388 \par
  389             #endif\par
  390 \par
  391                 return(false);          \par
  392             \}\par
  393 \par
  394             json.printTo(coolBoardLedConfig);\par
  395             coolBoardLedConfig.close();\par
  396 \par
  397         #if DEBUG == 1\par
  398     \par
  399             Serial.println( F("saved Led Config is : ") );\par
  400             json.printTo(Serial);\par
  401             Serial.println();\par
  402 \par
  403         #endif\par
  404 \par
  405             return(true); \par
  406         \}\par
  407     \}   \par
  408 \par
  409 \}               \par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a1b60e5e30bea96c49ed62ed1bf1ffc8b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v end\:CoolBoardLed}
{\xe \v CoolBoardLed\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::end ()}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::end()} : this method is provided to delete the dynamically created neoPixelLed \par
}{
Definition at line 230 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232 \par
  233 #if DEBUG == 1 \par
  234     \par
  235     Serial.println( F("Entering CoolBoardLed.end()") );\par
  236 \par
  237 #endif\par
  238 \par
  239     delete neoPixelLed;\par
  240 \}\par
}
}
{\xe \v fade\:CoolBoardLed}
{\xe \v CoolBoardLed\:fade}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::fade (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::fade} ( Red , Green , Blue, Time in seconds ): fade animation: Fade In over T(seconds) Fade Out over T(seconds) \par
}{
Definition at line 50 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52 \par
   53 #if DEBUG == 1\par
   54 \par
   55     Serial.println( F("Entering CoolBoardLed.fade()") );\par
   56     Serial.println();\par
   57     Serial.print( F("R : ") );\par
   58     Serial.println(R);\par
   59     Serial.print( F("G : ") );\par
   60     Serial.println(G);\par
   61     Serial.print( F("B : ") );\par
   62     Serial.println(B);\par
   63     Serial.print( F("Time : ") );\par
   64     Serial.println(T);\par
   65     Serial.println();\par
   66 \par
   67 #endif  \par
   68     if(this->ledActive == 1 )\par
   69     \{\par
   70         for (int k = 0; k < 1000; k++) \par
   71         \{\par
   72             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
   73             neoPixelLed->Show();\par
   74             delay(T);\par
   75         \}\par
   76         \par
   77         for (int k = 1000; k >= 0; k--) \par
   78         \{\par
   79             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
   80             neoPixelLed->Show();\par
   81             delay(T);\par
   82         \}\par
   83     \}\par
   84 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_af1cacbaa88db8bcf6042c1083ba41155_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fadeIn\:CoolBoardLed}
{\xe \v CoolBoardLed\:fadeIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::fadeIn (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::fadeIn(Red , Green , Blue , Time in seconds) Fade In animation: gradual increase over T(seconds) \par
}{
Definition at line 124 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   125 \{\par
  126 \par
  127 #if DEBUG == 1\par
  128 \par
  129     Serial.println( F("Entering CoolBoardLed.fadeIn()") );\par
  130     Serial.println();\par
  131     Serial.print( F("R : ") );\par
  132     Serial.println(R);\par
  133     Serial.print( F("G : ") );\par
  134     Serial.println(G);\par
  135     Serial.print( F("B : ") );\par
  136     Serial.println(B);\par
  137     Serial.print( F("Time :") );\par
  138     Serial.println(T);\par
  139     Serial.println();\par
  140 \par
  141 #endif  \par
  142     \par
  143     if(this->ledActive == 1 )\par
  144     \{\par
  145         for (int k = 0; k < 1000; k++) \par
  146         \{\par
  147             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
  148             neoPixelLed->Show();\par
  149             delay(T);\par
  150         \}\par
  151     \}\par
  152 \par
  153 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_ab778f5e7bed0ab74e3906d82110493c3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fadeOut\:CoolBoardLed}
{\xe \v CoolBoardLed\:fadeOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::fadeOut (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::fadeOut( Red , Green , Blue , Time in seconds) Fade Out animation: gradual decrease over T(seconds) \par
}{
Definition at line 159 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   160 \{\par
  161 \par
  162 #if DEBUG == 1 \par
  163 \par
  164     Serial.println( F("Entering CoolBoardLed.fadeOut()" ) );\par
  165     Serial.println();\par
  166     Serial.print( F("R : ") );\par
  167     Serial.println(R);\par
  168     Serial.print( F("G : ") );\par
  169     Serial.println(G);\par
  170     Serial.print( F("B : ") );\par
  171     Serial.println(B);\par
  172     Serial.print( F("Time :") );\par
  173     Serial.println(T);\par
  174     Serial.println();\par
  175 \par
  176 #endif  \par
  177 \par
  178     if(this->ledActive == 1 )\par
  179     \{\par
  180         for (int k = 1000; k >= 0; k--) \par
  181         \{\par
  182             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
  183             neoPixelLed->Show();\par
  184             delay(T);\par
  185         \}\par
  186     \}\par
  187 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a93d545679237e8cc858324367149775c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoardLed}
{\xe \v CoolBoardLed\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::printConf ()}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::printConf()}: This method is provided to print the Led Object Configuration to the Serial Monitor \par
}{
Definition at line 417 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   418 \{\par
  419 \par
  420 #if DEBUG == 1 \par
  421 \par
  422     Serial.println( F("Entering CoolBoardLed.printConf()") );\par
  423     Serial.println();\par
  424 \par
  425 #endif\par
  426 \par
  427     Serial.println("Led Configuration");\par
  428 \par
  429     Serial.print("ledActive : ");\par
  430     Serial.println(ledActive);\par
  431 \par
  432     Serial.println();   \par
  433 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a8ed3053a36f0ed4a131f43b5b17efb61_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v strobe\:CoolBoardLed}
{\xe \v CoolBoardLed\:strobe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::strobe (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::strobe(Red , Green , Blue , Time in seconds) Strobe animation: blinks over T(seconds) \par
}{
Definition at line 193 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   194 \{\par
  195 \par
  196 #if DEBUG == 1\par
  197 \par
  198     Serial.println( F("Entering CoolBoardLed.strobe()") );\par
  199     Serial.println();\par
  200     Serial.print( F("R : ") );\par
  201     Serial.println(R);\par
  202     Serial.print( F("G: ") );\par
  203     Serial.println(G);\par
  204     Serial.print( F("B : ") );\par
  205     Serial.println(B);\par
  206     Serial.print( F("Time :") );\par
  207     Serial.println(T);\par
  208     Serial.println();\par
  209 \par
  210 #endif  \par
  211 \par
  212     if(this->ledActive == 1 )\par
  213     \{   \par
  214         for (int k = 1000; k >= 0; k--) \par
  215         \{\par
  216             neoPixelLed->SetPixelColor(0, RgbColor(R, G, B));\par
  217             neoPixelLed->Show();\par
  218             delay(T);\par
  219             neoPixelLed->SetPixelColor(0, RgbColor(0, 0, 0));\par
  220             neoPixelLed->Show();\par
  221             delay(T);\par
  222         \}\par
  223     \}\par
  224 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_ad5f0de4c628cbfbf49896042831c64ad_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:CoolBoardLed}
{\xe \v CoolBoardLed\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::write (int  {\i R}, int  {\i G}, int  {\i B})}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::write(Red,Green,Blue): This method is provided to set the Color of the Led \par
}{
Definition at line 275 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   276 \{\par
  277 \par
  278 #if DEBUG == 1\par
  279 \par
  280     Serial.println( F("Entering CoolBoardLed.write()") );\par
  281     Serial.println();\par
  282     Serial.print( F("R : ") );\par
  283     Serial.println(R);\par
  284     Serial.print( F("G : ") );\par
  285     Serial.println(G);\par
  286     Serial.print( F("B : ") );\par
  287     Serial.println(B);\par
  288     Serial.println();   \par
  289 \par
  290 #endif\par
  291 \par
  292     if(this->ledActive == 1 )\par
  293     \{\par
  294         neoPixelLed->SetPixelColor(0, RgbColor(R, G, B));\par
  295         neoPixelLed->Show();\par
  296     \}\par
  297 \par
  298 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a30fadd4cbec17ceea428bf7a32207e87_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ledActive\:CoolBoardLed}
{\xe \v CoolBoardLed\:ledActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardLed::ledActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ledActive flag set to 1 if you want LED animation \par
}{
Definition at line 89 of file CoolBoardLed.h.}\par
}
{\xe \v neoPixelLed\:CoolBoardLed}
{\xe \v CoolBoardLed\:neoPixelLed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NeoPixelBus<NeoGrbFeature, Neo800KbpsMethod>* CoolBoardLed::neoPixelLed = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NeoPixel Led Instance \par
}{
Definition at line 83 of file CoolBoardLed.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardSensors Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardSensors}
{\xe \v CoolBoardSensors}
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors. }}\par
{
{\f2 #include <CoolBoardSensors.h>}}\par
Collaboration diagram for CoolBoardSensors:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/db9/class_cool_board_sensors__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b airActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b lightActive}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardSensors} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b allActive} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEnvSensorSettings} (uint8_t commInterface={\b I2C_MODE}, uint8_t I2CAddress=0x76, uint8_t runMode=3, uint8_t tStandby=0, uint8_t filter=0, uint8_t tempOverSample=1, uint8_t pressOverSample=1, uint8_t humidOverSample=1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readVBat} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readMoisture} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolSI114X} {\b lightSensor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BME280} {\b envSensor}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::lightActive} {\b lightDataActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::airActive} {\b airDataActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b EnMoisture} = 13\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b AnMplex} = 12\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vbatActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b soilMoistureActive} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors. \par
}{
Definition at line 48 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoolBoardSensors\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:CoolBoardSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolBoardSensors::CoolBoardSensors ()}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::CoolBoardSensors()}: This Constructor is provided to init the different used pins \par
}{
Definition at line 50 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52 \par
   53 #if DEBUG == 1\par
   54 \par
   55     Serial.println( F("Entering CoolBoardSensors Constructor") );\par
   56     Serial.println();\par
   57 \par
   58 #endif\par
   59     \par
   60     pinMode(AnMplex, OUTPUT);                //Declare Analog Multiplexer OUTPUT\par
   61     pinMode(EnMoisture, OUTPUT);             //Declare Moisture enable Pin\par
   62     digitalWrite(EnMoisture, HIGH);          //Prevent Wearing on the soil moisture fork\par
   63 \par
   64 \par
   65 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v allActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:allActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::allActive ()}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::allActive()}: This method is provided to allow activation of all the sensor board sensors without passing by the configuration file/method \par
}{
Definition at line 74 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75 \{\par
   76 \par
   77 #if DEBUG == 1 \par
   78 \par
   79     Serial.println( F("Entering CoolBoardSensors.allActive()") );\par
   80     Serial.println();\par
   81 \par
   82 #endif\par
   83     \par
   84     this->lightDataActive.visible=1;\par
   85     this->lightDataActive.ir=1;\par
   86     this->lightDataActive.uv=1; \par
   87 \par
   88     this->airDataActive.temperature=1;\par
   89     this->airDataActive.humidity=1;\par
   90     this->airDataActive.pressure=1;\par
   91 \par
   92 \par
   93     this->vbatActive=1;\par
   94 \par
   95     this->soilMoistureActive=1;\par
   96     \par
   97 \par
   98 \par
   99 \}\par
}
}
{\xe \v begin\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::begin ()}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::begin()}: This method is provided to start the sensors that are on the sensor board \par
}{
Definition at line 107 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   108 \{  \par
  109 \par
  110 #if DEBUG == 1 \par
  111      \par
  112     Serial.println( F("Entering CoolBoardSensors.begin()") );\par
  113     Serial.println();\par
  114 \par
  115 #endif\par
  116 \par
  117     while (!lightSensor.Begin()) \par
  118     \{\par
  119     \par
  120     #if DEBUG == 1\par
  121 \par
  122         Serial.println( F("Si1145 is not ready!  1 second") );\par
  123 \par
  124     #endif\par
  125 \par
  126         delay(1000);\par
  127     \}\par
  128      \par
  129     this->setEnvSensorSettings();\par
  130     delay(10);  //Make sure sensor had enough time to turn on. BME280 requires 2ms to start up.\par
  131     this->envSensor.begin();\par
  132     delay(10);  //Make sure sensor had enough time to turn on. BME280 requires 2ms to start up.\par
  133 \par
  134 #if DEBUG == 1 \par
  135     \par
  136     Serial.print( F("BME280 begin answer is :") );\par
  137     Serial.println(envSensor.begin(), HEX);\par
  138     Serial.println();\par
  139 \par
  140 #endif\par
  141 \par
  142 #if DEBUG == 0\par
  143 \par
  144     Serial.println( F("Onboard Sensors : OK"));\par
  145     Serial.println();\par
  146 \par
  147 #endif\par
  148 \par
  149 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a97095823ef7c8f5290812f1405b966b3_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a97095823ef7c8f5290812f1405b966b3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::config ()}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::config()}: This method is provided to configure the sensor board : -activate 1 -deactivate 0\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if configuration is successful, false otherwise \par
}}{
Definition at line 273 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   274 \{\par
  275 \par
  276 #if DEBUG == 1\par
  277 \par
  278     Serial.println( F("Entering CoolBoardSensors.config()") );\par
  279     Serial.println();\par
  280 \par
  281 #endif\par
  282 \par
  283 #if DEBUG == 0\par
  284 \par
  285     Serial.println( F("Reading Sensor Configuration..."));\par
  286 \par
  287 #endif\par
  288     //read config file\par
  289     //update data\par
  290     File coolBoardSensorsConfig = SPIFFS.open("/coolBoardSensorsConfig.json", "r");\par
  291 \par
  292     if (!coolBoardSensorsConfig) \par
  293     \{\par
  294     \par
  295         Serial.println( F("failed to read /coolBoardSensorsConfig.json") );\par
  296         Serial.println();\par
  297 \par
  298         return(false);\par
  299     \}\par
  300     else\par
  301     \{\par
  302         size_t size = coolBoardSensorsConfig.size();\par
  303         // Allocate a buffer to store contents of the file.\par
  304         std::unique_ptr<char[]> buf(new char[size]);\par
  305 \par
  306         coolBoardSensorsConfig.readBytes(buf.get(), size);\par
  307         DynamicJsonBuffer jsonBuffer;\par
  308         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  309         if (!json.success()) \par
  310         \{\par
  311 \par
  312             Serial.println( F("failed to parse coolBoardSensorsConfig json") );\par
  313             Serial.println();\par
  314     \par
  315             return(false);\par
  316         \} \par
  317         else\par
  318         \{\par
  319 \par
  320         #if DEBUG == 1\par
  321 \par
  322             Serial.println( F("Configuration Json is :") );\par
  323             json.printTo(Serial);\par
  324             Serial.println();\par
  325 \par
  326             Serial.print(F("jsonBuffer size: "));\par
  327             Serial.println(jsonBuffer.size());\par
  328             Serial.println();\par
  329         \par
  330         #endif\par
  331             \par
  332             if(json["BME280"]["temperature"].success() )\par
  333             \{           \par
  334                 this->airDataActive.temperature=json["BME280"]["temperature"];\par
  335             \}\par
  336             else\par
  337             \{\par
  338                 this->airDataActive.temperature=this->airDataActive.temperature;            \par
  339             \}\par
  340             json["BME280"]["temperature"]=this->airDataActive.temperature;\par
  341             \par
  342             \par
  343             if(json["BME280"]["humidity"].success() )\par
  344             \{           \par
  345             \par
  346                 this->airDataActive.humidity=json["BME280"]["humidity"];\par
  347             \}\par
  348             else\par
  349             \{\par
  350                 this->airDataActive.humidity=this->airDataActive.humidity;\par
  351             \}\par
  352             json["BME280"]["humidity"]=this->airDataActive.humidity;\par
  353             \par
  354             \par
  355             if(json["BME280"]["pressure"].success() )\par
  356             \{\par
  357                 this->airDataActive.pressure=json["BME280"]["pressure"];\par
  358             \}\par
  359             else\par
  360             \{\par
  361                 this->airDataActive.pressure=this->airDataActive.pressure;\par
  362             \}\par
  363             json["BME280"]["pressure"]=this->airDataActive.pressure;\par
  364 \par
  365             \par
  366             if(json["SI114X"]["visible"].success() )\par
  367             \{\par
  368                 this->lightDataActive.visible=json["SI114X"]["visible"];\par
  369             \}\par
  370             else\par
  371             \{\par
  372                 this->lightDataActive.visible=this->lightDataActive.visible;\par
  373             \}\par
  374             json["SI114X"]["visible"]=this->lightDataActive.visible;\par
  375             \par
  376             \par
  377             if(json["SI114X"]["ir"].success() )\par
  378             \{           \par
  379                 this->lightDataActive.ir=json["SI114X"]["ir"];\par
  380             \}\par
  381             else\par
  382             \{\par
  383                 this->lightDataActive.ir=this->lightDataActive.ir;\par
  384             \}\par
  385             json["SI114X"]["ir"]=this->lightDataActive.ir;\par
  386 \par
  387             \par
  388             if(json["SI114X"]["uv"].success() )         \par
  389             \{           \par
  390                 this->lightDataActive.uv=json["SI114X"]["uv"];\par
  391             \}\par
  392             else\par
  393             \{\par
  394                 this->lightDataActive.uv=this->lightDataActive.uv;\par
  395             \}\par
  396             json["SI114X"]["uv"]=this->lightDataActive.uv;\par
  397 \par
  398 \par
  399             if(json["vbat"].success() )\par
  400             \{\par
  401                 this->vbatActive=json["vbat"];\par
  402             \}\par
  403             else\par
  404             \{\par
  405                 this->vbatActive=this->vbatActive;\par
  406             \}\par
  407             json["vbat"]=this->vbatActive;\par
  408 \par
  409             \par
  410             if(json["soilMoisture"].success() )\par
  411             \{           \par
  412                 this->soilMoistureActive= json["soilMoisture"];\par
  413             \}\par
  414             else\par
  415             \{\par
  416                 this->soilMoistureActive=this->soilMoistureActive;\par
  417             \}\par
  418             json["soilMoisture"]=this->soilMoistureActive;\par
  419 \par
  420             coolBoardSensorsConfig.close();         \par
  421             coolBoardSensorsConfig = SPIFFS.open("/coolBoardSensorsConfig.json", "w");          \par
  422             if(!coolBoardSensorsConfig)\par
  423             \{\par
  424 \par
  425                 Serial.println( F("failed to write to /coolBoardSensorsConfig.json") );\par
  426                 Serial.println();\par
  427 \par
  428                 return(false);          \par
  429             \}  \par
  430 \par
  431             json.printTo(coolBoardSensorsConfig);\par
  432             coolBoardSensorsConfig.close();         \par
  433             \par
  434         #if DEBUG == 1\par
  435 \par
  436             Serial.println( F("Saved Configuration Json is : ") );\par
  437             json.printTo(Serial);\par
  438             Serial.println();\par
  439         \par
  440         #endif\par
  441 \par
  442         #if DEBUG == 0\par
  443             Serial.println( F("Configuration loaded : OK"));\par
  444         #endif\par
  445 \par
  446             return(true); \par
  447         \}\par
  448     \}   \par
  449 \par
  450 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a9a218895c5423375c33c08f2c56fb23a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v end\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::end ()}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::end()}: This method is provided to end the sensors on the sensor board \par
}{
Definition at line 156 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   157 \{\par
  158 \par
  159 #if DEBUG == 1  \par
  160     Serial.println( F("Entering CoolBoardSensors.end()") );\par
  161     Serial.println();\par
  162 \par
  163 #endif\par
  164 \par
  165     lightSensor.DeInit();\par
  166 \par
  167 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a4902b69f6e628bd6557193758fdd2bae_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::printConf ()}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 458 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   459 \{\par
  460 \par
  461 #if DEBUG == 1\par
  462 \par
  463     Serial.println( F("Entering CoolBoardSensors.printConf()") );\par
  464     Serial.println();\par
  465 \par
  466 #endif\par
  467 \par
  468     Serial.println( F("Sensors Configuration : "));\par
  469     \par
  470     Serial.print( F("airDataActive.temperature : "));\par
  471     Serial.println(this->airDataActive.temperature);\par
  472 \par
  473     Serial.print( F("airDataActive.humidity : "));\par
  474     Serial.println(airDataActive.humidity);\par
  475 \par
  476     Serial.print( F("airDataActive.pressure : "));\par
  477     Serial.println(airDataActive.pressure);\par
  478 \par
  479     Serial.print( F("lightDataActive.visible : "));\par
  480     Serial.println(lightDataActive.visible);\par
  481 \par
  482     Serial.print( F("lightDataActive.ir : "));\par
  483     Serial.println(lightDataActive.ir);\par
  484 \par
  485     Serial.print( F("lightDataActive.uv : "));\par
  486     Serial.println(lightDataActive.uv);\par
  487     \par
  488     Serial.print( F("vbatActive : "));\par
  489     Serial.println(vbatActive);\par
  490 \par
  491     Serial.print( F("soilMoitureActive : "));\par
  492     Serial.println(soilMoistureActive);\par
  493 \par
  494     Serial.println();\par
  495 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_af6fd79505815b204c178617ecf54c873_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoardSensors::read ()}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::read()}: This method is provided to return the data read by the sensor board\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a json string containing the sensors data \par
}}{
Definition at line 177 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   178 \{\par
  179 \par
  180 #if DEBUG == 1 \par
  181     \par
  182     Serial.println( F("Entering CoolBoardSensors.read()") );\par
  183     Serial.println();\par
  184 \par
  185 #endif\par
  186 \par
  187 #if DEBUG == 0\par
  188 \par
  189     Serial.println( F("Reading Sensors..."));\par
  190 \par
  191 #endif\par
  192 \par
  193     String data;\par
  194     DynamicJsonBuffer  jsonBuffer ;\par
  195     JsonObject& root = jsonBuffer.createObject();\par
  196 \par
  197     delay(100);\par
  198     //light data\par
  199     if(lightDataActive.visible)\par
  200     \{\par
  201         root["visibleLight"] =lightSensor.ReadVisible() ;\par
  202     \}\par
  203     \par
  204     if(lightDataActive.ir)\par
  205     \{\par
  206         root["infraRed"] = lightSensor.ReadIR();\par
  207     \}\par
  208 \par
  209     if(lightDataActive.uv)\par
  210     \{\par
  211         float tempUV = (float)lightSensor.ReadUV()/100 ;\par
  212         root["ultraViolet"] = tempUV;\par
  213     \}\par
  214     \par
  215     //BME280 data\par
  216     if(airDataActive.pressure)  \par
  217     \{\par
  218         root["Pressure"] =envSensor.readFloatPressure();\par
  219     \}\par
  220     \par
  221         \par
  222     if(airDataActive.humidity)  \par
  223     \{   \par
  224         root["Humidity"] =envSensor.readFloatHumidity() ;\par
  225     \}   \par
  226     \par
  227     if(airDataActive.temperature)\par
  228     \{\par
  229         root["Temperature"]=envSensor.readTempC();\par
  230     \}\par
  231     \par
  232     //Vbat\par
  233     if(vbatActive)  \par
  234     \{   \par
  235         root["Vbat"]=this->readVBat();\par
  236     \}\par
  237     \par
  238     //earth Moisture\par
  239     if(soilMoistureActive)\par
  240     \{   \par
  241         root["soilMoisture"]=this->readMoisture();\par
  242     \}\par
  243     \par
  244     \par
  245     root.printTo(data);\par
  246 \par
  247     Serial.println( F("CoolBoardSensors data is :") );\par
  248     root.printTo(Serial);\par
  249     Serial.println();\par
  250     Serial.println();\par
  251 \par
  252 #if DEBUG == 1\par
  253     Serial.print(F("jsonBuffer size: "));\par
  254     Serial.println(jsonBuffer.size());\par
  255     Serial.println();\par
  256 \par
  257 #endif\par
  258 \par
  259     return(data);   \par
  260     \par
  261 \par
  262 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a91badb2539d91fda8679f2a597874c48_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a91badb2539d91fda8679f2a597874c48_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readMoisture\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:readMoisture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CoolBoardSensors::readMoisture ()}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::readMoisture()}: This method is provided to red the Soil Moisture\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a float represnting the soil moisture \par
}}{
Definition at line 581 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   582 \{\par
  583 \par
  584 #if DEBUG == 1\par
  585     \par
  586     Serial.println( F("Entering CoolBoardSensors.readMoisture()") );\par
  587     Serial.println();\par
  588     \par
  589 #endif\par
  590 \par
  591     digitalWrite(EnMoisture, LOW);                 //enable moisture sensor and waith a bit\par
  592 \par
  593     digitalWrite(AnMplex, HIGH);            //enable analog Switch to get the moisture\par
  594 \par
  595     delay(2000);\par
  596 \par
  597     int val = analogRead(A0);                       //read the value form the moisture sensor\par
  598 \par
  599     if (val >= 891)\{\par
  600         val = 890;\par
  601     \}\par
  602     float result = (float)map(val, 0, 890, 0, 100); \par
  603 \par
  604     digitalWrite(EnMoisture, HIGH);                  //disable moisture sensor for minimum wear\par
  605     \par
  606 #if DEBUG == 1 \par
  607 \par
  608     Serial.println( F("RAW Moisture  is : "));\par
  609     Serial.println(val);\par
  610     Serial.println( F("Soil Moisture is : ") );\par
  611     Serial.println(result);\par
  612     Serial.println();\par
  613 \par
  614 #endif \par
  615 \par
  616     return (result);\par
  617 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a8761bff50373c485f4465c8db47d0633_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readVBat\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:readVBat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CoolBoardSensors::readVBat ()}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::readVBat()}: This method is provided to read the Battery Voltage.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a float representing the battery voltage \par
}}{
Definition at line 544 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   545 \{\par
  546 \par
  547 #if DEBUG == 1\par
  548 \par
  549     Serial.println( F("Entering CoolBoardSensors.readVBat()") );\par
  550     Serial.println();\par
  551 \par
  552 #endif\par
  553 \par
  554     digitalWrite(this->AnMplex, LOW);                            //Enable Analog Switch to get the batterie tension\par
  555     \par
  556     delay(200);\par
  557     \par
  558     int raw = analogRead(A0);                                    //read in batterie tension\par
  559     \par
  560     float val = 6.04 / 1024 * raw;                               //convert it apprimatly right tension in volts\par
  561     \par
  562 #if DEBUG == 1\par
  563 \par
  564     Serial.println( F("Vbat is : ") );\par
  565     Serial.println(val);\par
  566     Serial.println();\par
  567 \par
  568 #endif\par
  569 \par
  570     return (val);   \par
  571 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a6944b6ea7bce8e2fce1b434acfd9d5f3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setEnvSensorSettings\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:setEnvSensorSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::setEnvSensorSettings (uint8_t  {\i commInterface} = {\f2 {\b I2C_MODE}}, uint8_t  {\i I2CAddress} = {\f2 0x76}, uint8_t  {\i runMode} = {\f2 3}, uint8_t  {\i tStandby} = {\f2 0}, uint8_t  {\i filter} = {\f2 0}, uint8_t  {\i tempOverSample} = {\f2 1}, uint8_t  {\i pressOverSample} = {\f2 1}, uint8_t  {\i humidOverSample} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardSensors::setEnvSensorSetting(): This method is provided to set the enviornment sensor settings , if argument is ommitted , default value will be assigned \par
}{
Definition at line 504 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   509 \{\par
  510 \par
  511 #if DEBUG == 1\par
  512     \par
  513     Serial.println( F("Entering CoolBoardSensors.setEnvSensorSettings()") );\par
  514     Serial.println();\par
  515 \par
  516 #endif\par
  517   \par
  518     this->envSensor.settings.commInterface = commInterface;      \par
  519 \par
  520     this->envSensor.settings.I2CAddress = I2CAddress;\par
  521 \par
  522     this->envSensor.settings.runMode = runMode; \par
  523 \par
  524     this->envSensor.settings.tStandby = tStandby; \par
  525 \par
  526     this->envSensor.settings.filter = filter; \par
  527 \par
  528     this->envSensor.settings.tempOverSample = tempOverSample;\par
  529 \par
  530     this->envSensor.settings.pressOverSample = pressOverSample;\par
  531 \par
  532     this->envSensor.settings.humidOverSample = humidOverSample;\par
  533 \par
  534 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a406307ffd70272282d91479c7ed8d66f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v airDataActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:airDataActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoolBoardSensors::airActive} CoolBoardSensors::airDataActive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AnMplex\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:AnMplex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoardSensors::AnMplex = 12{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analog Multiplexer LOW=Vbat , HIGH=Moisture \par
}{
Definition at line 139 of file CoolBoardSensors.h.}\par
}
{\xe \v EnMoisture\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:EnMoisture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoardSensors::EnMoisture = 13{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moisture Enable Pin \par
}{
Definition at line 134 of file CoolBoardSensors.h.}\par
}
{\xe \v envSensor\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:envSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BME280} CoolBoardSensors::envSensor}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b BME280} environment sensor instance \par
}{
Definition at line 94 of file CoolBoardSensors.h.}\par
}
{\xe \v lightDataActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:lightDataActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoolBoardSensors::lightActive} CoolBoardSensors::lightDataActive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lightSensor\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:lightSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolSI114X} CoolBoardSensors::lightSensor}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SI114X light sensor instance \par
}{
Definition at line 89 of file CoolBoardSensors.h.}\par
}
{\xe \v soilMoistureActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:soilMoistureActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::soilMoistureActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set soilMoistureActive to 1 to have soil Moisture Readings \par
}{
Definition at line 149 of file CoolBoardSensors.h.}\par
}
{\xe \v vbatActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:vbatActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::vbatActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set vbatActive to 1 to have battery voltage Readings \par
}{
Definition at line 144 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolFileSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolFileSystem}
{\xe \v CoolFileSystem}
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system. }}\par
{
{\f2 #include <CoolFileSystem.h>}}\par
Collaboration diagram for CoolFileSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d8f/class_cool_file_system__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b updateConfigFiles} (String answer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fileUpdate} (String update, const char *path)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveSensorData} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveSensorDataCSV} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isDataSaved} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String * {\b getSensorSavedData} (int &size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b incrementsavedData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getsavedData} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b savedData} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b linesToSkip} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system. \par
}{
Definition at line 46 of file CoolFileSystem.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolFileSystem}
{\xe \v CoolFileSystem\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::begin ()}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::begin()}: This method is provided to start the SPIFFS object.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if SPIFFS was initialized correctly, false otherwise \par
}}{
Definition at line 50 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52     bool sResult=SPIFFS.begin();\par
   53     \par
   54 \par
   55 #if DEBUG == 1\par
   56 \par
   57     Serial.println( F("Entering CoolFileSystem.begin()") );\par
   58     Serial.println();   \par
   59     Serial.print( F("SPIFFS success ? ") );\par
   60     Serial.println(sResult);\par
   61     Serial.println(  );\par
   62 \par
   63 #endif\par
   64     //get the data from the files\par
   65     this->getsavedData();\par
   66 \par
   67     return( sResult  );                                   //Initialize Filesystem\par
   68 \par
   69 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a6ba6f666ed4c530174f8569d2c636748_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a6ba6f666ed4c530174f8569d2c636748_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fileUpdate\:CoolFileSystem}
{\xe \v CoolFileSystem\:fileUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::fileUpdate (String  {\i update}, const char *  {\i path})}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::fileUpdate( update msg, file path): This method is provided to ensure the correct update for each configuration file in the File system\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful , false otherwise \par
}}{
Definition at line 1003 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1004 \{\par
 1005 \par
 1006 #if DEBUG == 1\par
 1007 \par
 1008     Serial.println( F("Entering CoolFileSystem.fileUpdate()") );\par
 1009     Serial.println();\par
 1010     \par
 1011     Serial.println(F("update msg is :"));\par
 1012     Serial.println(update);\par
 1013     \par
 1014     Serial.println(F("file path is : "));\par
 1015     Serial.println(path);   \par
 1016 \par
 1017 #endif\par
 1018     //transfer update String to json\par
 1019     DynamicJsonBuffer updateBuffer;\par
 1020     JsonObject& updateJson = updateBuffer.parseObject(update.c_str() );\par
 1021     \par
 1022     if(updateJson.success())\par
 1023     \{\par
 1024     \par
 1025     #if DEBUG ==1\par
 1026         \par
 1027         Serial.println(F("root parsing success :"));\par
 1028         updateJson.printTo(Serial);\par
 1029     \par
 1030     #endif\par
 1031 \par
 1032     \}\par
 1033     else\par
 1034     \{\par
 1035     \par
 1036     #if DEBUG == 1 \par
 1037     \par
 1038         Serial.println(F("root parsing failure "));\par
 1039     \par
 1040     #endif\par
 1041         \par
 1042         return(false);  \par
 1043 \par
 1044     \}\par
 1045     \par
 1046     //open file in read mode\par
 1047     File configFile = SPIFFS.open( path , "r");\par
 1048     \par
 1049     if(!configFile)\par
 1050     \{   \par
 1051     #if DEBUG == 1\par
 1052         \par
 1053         Serial.print( F("failed to read ") );\par
 1054         Serial.println(path);\par
 1055 \par
 1056     #endif\par
 1057         return(false);\par
 1058     \}\par
 1059 \par
 1060     //copy file to a json\par
 1061     size_t size = configFile.size();\par
 1062 \par
 1063     // Allocate a buffer to store contents of the file.\par
 1064     std::unique_ptr < char[] > buf(new char[size]);\par
 1065 \par
 1066     configFile.readBytes(buf.get(), size);\par
 1067 \par
 1068     DynamicJsonBuffer fileBuffer;\par
 1069 \par
 1070     JsonObject & fileJson = fileBuffer.parseObject(buf.get());\par
 1071 \par
 1072     if (!fileJson.success())\par
 1073     \{\par
 1074 \par
 1075     #if DEBUG == 1\par
 1076 \par
 1077         Serial.println( F("failed to parse json") );\par
 1078 \par
 1079     #endif\par
 1080 \par
 1081         return(false);\par
 1082     \}\par
 1083     \par
 1084     //modify root to contain all the json keys: updated ones and non updated ones\par
 1085     for (auto kv : fileJson) \par
 1086     \{\par
 1087         if( updateJson[kv.key].success() )\par
 1088         \{\par
 1089             fileJson[kv.key]=updateJson[kv.key];            \par
 1090         \}\par
 1091         else\par
 1092         \{\par
 1093             fileJson[kv.key]=fileJson[kv.key];\par
 1094         \}\par
 1095 \par
 1096                 \par
 1097     \}\par
 1098 \par
 1099 #if DEBUG == 1\par
 1100 \par
 1101     Serial.println(F("fileJson is now : "));\par
 1102     fileJson.printTo(Serial);\par
 1103 \par
 1104 #endif\par
 1105 \par
 1106     //close the file\par
 1107     configFile.close();\par
 1108 \par
 1109     //open file in w mode\par
 1110     configFile = SPIFFS.open( path , "w");\par
 1111     \par
 1112     if(!configFile)\par
 1113     \{   \par
 1114     #if DEBUG == 1\par
 1115         \par
 1116         Serial.print( F("failed to open ") );\par
 1117         Serial.println(path);\par
 1118 \par
 1119     #endif\par
 1120         return(false);\par
 1121     \}\par
 1122     //print json to file    \par
 1123     \par
 1124     fileJson.printTo(configFile);\par
 1125     \par
 1126     //close file\par
 1127     configFile.close();\par
 1128 \par
 1129 \par
 1130 #if DEBUG == 1\par
 1131 \par
 1132     Serial.println( F("config is") );\par
 1133     fileJson.printTo(Serial);\par
 1134     Serial.println();\par
 1135 \par
 1136 #endif\par
 1137     \par
 1138     return(true);\par
 1139     \par
 1140 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a13f2958f5b87757c31fc53797a30d23a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getsavedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:getsavedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolFileSystem::getsavedData ()}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::getsavedData()}: This method is provided to get the savedData flag from the file system \par
}{
Definition at line 1202 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1203 \{\par
 1204 \par
 1205 \par
 1206 #if DEBUG == 1\par
 1207     \par
 1208     Serial.println(F("Entering CoolFileSystem.getsavedData()"));    \par
 1209     \par
 1210 #endif\par
 1211     //open file\par
 1212     File file=SPIFFS.open("/savedDataFlag.txt","r");    \par
 1213     //read file\par
 1214     if( !file)  \par
 1215     \{\par
 1216         Serial.println( F("failed to read savedDataFlag.txt") );\par
 1217         \par
 1218     \}\par
 1219     else\par
 1220     \{       \par
 1221         //read from file    \par
 1222         String temp=file.readStringUntil(' ');\par
 1223         \par
 1224         this->savedData=temp.toInt();\par
 1225 \par
 1226         \par
 1227         temp=file.readStringUntil('\\n');\par
 1228         this-> linesToSkip=temp.toInt();;   \par
 1229         \par
 1230         file.close();   \par
 1231     \}\par
 1232     \par
 1233 #if DEBUG == 1\par
 1234 \par
 1235     Serial.print(F("number of lines to read :"));\par
 1236     Serial.println(this->savedData);\par
 1237     \par
 1238     Serial.print(F("number of lines to skip :"));\par
 1239     Serial.println(this->linesToSkip);\par
 1240 \par
 1241 #endif\par
 1242     \par
 1243 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a70701d05e811604af1b531f4f6dc69ed_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getSensorSavedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:getSensorSavedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String * CoolFileSystem::getSensorSavedData (int &  {\i lines})}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::getSensorData(int &lines): This method is provided to return the sensor data saved in the File System 10 lines at a time\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid String array containing 50 first lines from the file modifies tge lines argument to reflect the number of lines left \par
}}{
Definition at line 842 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   843 \{\par
  844     int maxString=50;\par
  845     String *sensorsDataArray=new String[maxString];\par
  846     lines=0;\par
  847 \par
  848 #if DEBUG == 1 \par
  849 \par
  850     Serial.println( F("Entering CoolFileSystem.getSensorSavedData()") );\par
  851     Serial.println();\par
  852 \par
  853 #endif\par
  854 \par
  855     //open sensors data file\par
  856     File sensorsData=SPIFFS.open("/sensorsData.json","r");\par
  857     \par
  858     if (!sensorsData)\par
  859     \{\par
  860 \par
  861     #if DEBUG == 1 \par
  862 \par
  863         Serial.println( F("Failed to read /sensorsData.json") );\par
  864 \par
  865     #endif\par
  866          \par
  867         sensorsDataArray[0]="Failed to read /sensorsData.json";\par
  868         lines++;\par
  869 \par
  870         //result=sensorsDataArray;\par
  871         return(sensorsDataArray);\par
  872 \par
  873     \}\par
  874 \par
  875     else\par
  876     \{\par
  877         //read the file line by line and put it in the String array(aka String*)        \par
  878 \par
  879         //while loop until EOF is reached\par
  880         String temp;\par
  881         while(sensorsData.available())\par
  882         \{\par
  883             yield();\par
  884             \par
  885             temp=sensorsData.readStringUntil('\\r');\par
  886 \par
  887             if(linesToSkip>0)\par
  888             \{\par
  889 \par
  890                 linesToSkip--;\par
  891         \par
  892             \}\par
  893             else\par
  894             \{\par
  895 \par
  896             #if DEBUG == 1\par
  897 \par
  898                 Serial.println(F("temp String : "));\par
  899                 Serial.println(temp);\par
  900                 Serial.println();\par
  901             \par
  902             #endif\par
  903             \par
  904                 sensorsDataArray[lines]=temp;\par
  905                 sensorsData.read();\par
  906             \par
  907             \par
  908         \par
  909             #if DEBUG== 1\par
  910      \par
  911                 Serial.print(F("read String N\'B0"));\par
  912                 Serial.print(lines);\par
  913                 Serial.println(F(" is : "));\par
  914                 Serial.println( sensorsDataArray[lines] );\par
  915                 Serial.println();\par
  916                 Serial.println(F("next char is : "));\par
  917                 Serial.println((char)sensorsData.peek());\par
  918                 Serial.println();           \par
  919             \par
  920             #endif\par
  921                 lines++;\par
  922             \par
  923                 //maximum size is maxString(index : 0..maxString-1)\par
  924                 if(lines>=maxString)\par
  925                 \{\par
  926                     break;\par
  927                 \}\par
  928             \par
  929                 yield();\par
  930             \par
  931             \}\par
  932 \par
  933         \}\par
  934         \par
  935                     \par
  936         //close the file\par
  937         sensorsData.close();\par
  938 \par
  939         //position the saved data flag to the number of unread lines\par
  940         this->savedData=savedData-lines;\par
  941         \par
  942         //position the number of lines to skip to the number of read lines  \par
  943         this->linesToSkip=lines;\par
  944 \par
  945         //delete data in the file only if savedData<=0\par
  946         if(this->savedData<=0)\par
  947         \{\par
  948             File sensorsData=SPIFFS.open("/sensorsData.json","w");\par
  949             File sensorsDataCSV=SPIFFS.open("/sensorsData.csv","w");\par
  950             if( (!sensorsData)||(!sensorsDataCSV) ) \par
  951             \{\par
  952             #if DEBUG == 1\par
  953     \par
  954                 Serial.println( F("failed to delete data in the file") );\par
  955     \par
  956             #endif\par
  957                 lines++;\par
  958                 sensorsDataArray[lines]="failed to delete data in the file";\par
  959 \par
  960                 return(sensorsDataArray);\par
  961 \par
  962             \}\par
  963 \par
  964             sensorsData.close();\par
  965             sensorsDataCSV.close();\par
  966             \par
  967             this->linesToSkip=0;\par
  968         \par
  969         \}\par
  970 \par
  971         //save the changes to linesToSkip and savedData in the file system\par
  972         this->incrementsavedData();\par
  973 \par
  974         //return the string\par
  975         #if DEBUG == 1\par
  976         \par
  977             for(int i=0;i<lines;i++)\par
  978             \{\par
  979                 Serial.print(F("String N\'B0"));\par
  980                 Serial.println(i);\par
  981                 Serial.println(sensorsDataArray[i]);\par
  982                 Serial.println();           \par
  983             \}\par
  984     \par
  985         #endif\par
  986         return(sensorsDataArray);\par
  987         \par
  988         \par
  989         \par
  990     \}\par
  991 \par
  992 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a3223ffff4266a6300988fab956d6b4b2_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a3223ffff4266a6300988fab956d6b4b2_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v incrementsavedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:incrementsavedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::incrementsavedData ()}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::incrementsavedData()}: This method is provided to increment the savedData flag\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful , false otherwise \par
}}{
Definition at line 1152 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1153 \{\par
 1154 \par
 1155 \par
 1156 #if DEBUG == 1\par
 1157     \par
 1158     Serial.println(F("Entering CoolFileSystem.incrementsavedData()"));  \par
 1159     \par
 1160 #endif\par
 1161     //open file\par
 1162     File file=SPIFFS.open("/savedDataFlag.txt","w");    \par
 1163     //read file\par
 1164     if( !file)  \par
 1165     \{\par
 1166         Serial.println( F("failed to open savedDataFlag.txt") );\par
 1167         \par
 1168         return(false);      \par
 1169     \}\par
 1170     else\par
 1171     \{       \par
 1172         //write to file \par
 1173         file.print(this->savedData);\par
 1174         \par
 1175         file.print(" ");\par
 1176         \par
 1177         file.println(this->linesToSkip);\par
 1178     \par
 1179         file.close();\par
 1180 \par
 1181     #if DEBUG == 1\par
 1182 \par
 1183         Serial.print(F("number of lines to read :"));\par
 1184         Serial.println(this->savedData);\par
 1185     \par
 1186         Serial.print(F("number of lines to skip :"));\par
 1187         Serial.println(this->linesToSkip);\par
 1188 \par
 1189     #endif\par
 1190         \par
 1191         return(true);\par
 1192     \}\par
 1193     \par
 1194 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_aae045125288f255f3e258073dcada2a6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isDataSaved\:CoolFileSystem}
{\xe \v CoolFileSystem\:isDataSaved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolFileSystem::isDataSaved ()}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::isDataSaved()}: This method is provided to report wether there is sensor data saved in the File System.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if there is data saved, false otherwise \par
}}{
Definition at line 782 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   783 \{\par
  784 \par
  785 #if DEBUG == 1 \par
  786 \par
  787     Serial.println( F("Entering CoolFileSystem.isDataSaved()") );\par
  788     Serial.println();\par
  789 \par
  790     FSInfo fs_info;\par
  791 \par
  792     if(SPIFFS.info(fs_info)==true)\par
  793     \{\par
  794         Serial.print(F("used bytes/total bytes : "));   \par
  795         Serial.print(fs_info.usedBytes);\par
  796         Serial.print(F("/"));\par
  797         Serial.print(fs_info.totalBytes);\par
  798         Serial.println();\par
  799 \par
  800     \}\par
  801 \par
  802     File sensorsData=SPIFFS.open("/sensorsData.json","r");\par
  803     File sensorsDataCSV=SPIFFS.open("/sensorsData.csv","r");\par
  804     \par
  805     if( (!sensorsData)||(!sensorsDataCSV) ) \par
  806     \{\par
  807         Serial.println( F("failed to open files") );        \par
  808     \}\par
  809     else\par
  810     \{       \par
  811             Serial.print(F("sensors Data file size in bytes : "));\par
  812             Serial.println(sensorsData.size());\par
  813             Serial.println();\par
  814             \par
  815             Serial.print(F("sensors Data CSV file size in bytes : "));              \par
  816             Serial.println(sensorsDataCSV.size());\par
  817             Serial.println();\par
  818     \}\par
  819 \par
  820 \par
  821 \par
  822     Serial.print( F("savedData : ") );\par
  823     Serial.println(this->savedData);\par
  824 \par
  825 #endif\par
  826 \par
  827     return( this->savedData );\par
  828 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_ac86a40e7c3a1842f7342f698d34324f9_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v saveSensorData\:CoolFileSystem}
{\xe \v CoolFileSystem\:saveSensorData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::saveSensorData (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::saveSensorData( data ): This method is provided to save the data on the local memory when there is no internet available\par
increments the saved data flag when successful\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the data was saved, false otherwise \par
}}{
Definition at line 81 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82 \{\par
   83 \par
   84 #if DEBUG == 1\par
   85 \par
   86     Serial.println( F("Entering CoolFileSystem.saveSensorData()") );\par
   87     Serial.println();\par
   88 \par
   89 #endif\par
   90     \par
   91     File sensorsData=SPIFFS.open("/sensorsData.json","a");\par
   92 \par
   93     if(!sensorsData)\par
   94     \{\par
   95     \par
   96     #if DEBUG == 1\par
   97     \par
   98         Serial.println( F("failed to append to /sensorsData.json") );\par
   99         Serial.println();\par
  100     \par
  101     #endif\par
  102         //keep the old data\par
  103         this->savedData=savedData;\par
  104 \par
  105         return (false); \par
  106     \}   \par
  107 \par
  108     DynamicJsonBuffer jsonBuffer;\par
  109     JsonObject& root = jsonBuffer.parseObject(data);\par
  110 \par
  111     if( root.success() )\par
  112     \{\par
  113         root.printTo(sensorsData);\par
  114         sensorsData.println();\par
  115         sensorsData.close();\par
  116 \par
  117 \par
  118     #if DEBUG == 1\par
  119         \par
  120         Serial.print(F("jsonBuffer size: "));\par
  121         Serial.println(jsonBuffer.size());\par
  122         Serial.println();\par
  123 \par
  124         sensorsData=SPIFFS.open("/sensorsData.json","r");\par
  125         \par
  126         if(!sensorsData)\par
  127         \{\par
  128             \par
  129             Serial.println(F("failed to reopen /sensorsData.json"));\par
  130             return(true);\par
  131                         \par
  132         \}\par
  133     \par
  134         Serial.println( F("saved data is : ") );\par
  135         root.printTo(Serial);\par
  136         Serial.println();\par
  137 \par
  138         Serial.println(F("/sensorsData.json") );\par
  139         while (sensorsData.available()) \par
  140         \{\par
  141             Serial.println(sensorsData.readString()) ;\par
  142         \}\par
  143         \par
  144         Serial.println();\par
  145         \par
  146         sensorsData.close();\par
  147     \par
  148     #endif\par
  149 \par
  150         this->saveSensorDataCSV(data);      \par
  151 \par
  152         //new data\par
  153         this->savedData++;\par
  154 \par
  155         this->incrementsavedData();\par
  156         \par
  157         return (true);      \par
  158     \}\par
  159     else\par
  160     \{\par
  161     \par
  162     #if DEBUG == 1\par
  163 \par
  164         Serial.println( F("failed to parse json") );\par
  165     \par
  166     #endif\par
  167         //old data\par
  168         this->savedData=savedData;\par
  169 \par
  170         return(false);\par
  171     \}\par
  172     \par
  173 \par
  174 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_afa3a4feae94871d4d3b6bebb701c2e67_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_afa3a4feae94871d4d3b6bebb701c2e67_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v saveSensorDataCSV\:CoolFileSystem}
{\xe \v CoolFileSystem\:saveSensorDataCSV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::saveSensorDataCSV (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::saveSensorDataCSV( data ): This method is provided to save the data on the local memory in CSV format.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the data was saved, false otherwise \par
}}{
Definition at line 185 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   186 \{\par
  187 #if DEBUG == 1\par
  188 \par
  189     Serial.println( F("Entering CoolFileSystem.saveSensorDataCSV()") );\par
  190     Serial.println();\par
  191 \par
  192 #endif\par
  193     //parsing json\par
  194     DynamicJsonBuffer jsonBuffer;\par
  195     JsonObject& root = jsonBuffer.parseObject(data);\par
  196     String header="",values="";\par
  197     \par
  198     //if json parse success\par
  199     if( root.success() )\par
  200     \{       \par
  201         for (auto kv : root) \par
  202         \{\par
  203             //print the header(json keys ) to header string\par
  204             header+=kv.key;\par
  205             header+=',';\par
  206             \par
  207             //print the values to header string\par
  208             values+=( kv.value.as<char*>() );\par
  209             values+=',';\par
  210         \}\par
  211 \par
  212         header.remove(header.lastIndexOf(','), 1);\par
  213         values.remove(values.lastIndexOf(','), 1);      \par
  214     \par
  215     #if DEBUG == 1\par
  216     \par
  217         Serial.println( F(" data is : ") );\par
  218         root.printTo(Serial);\par
  219         Serial.println();\par
  220         \par
  221         Serial.println(F(" header is :" ) ) ;\par
  222         Serial.println(header);\par
  223         Serial.println(F(" values are : "));\par
  224         Serial.println(values);\par
  225         \par
  226         Serial.print(F("jsonBuffer size: "));\par
  227         Serial.println(jsonBuffer.size());\par
  228         Serial.println();\par
  229 \par
  230     \par
  231     #endif\par
  232     \par
  233     \}\par
  234     //failed to parse json\par
  235     else\par
  236     \{\par
  237     \par
  238     #if DEBUG == 1\par
  239 \par
  240         Serial.println( F("failed to parse json") );\par
  241     \par
  242     #endif\par
  243 \par
  244         return(false);\par
  245     \}\par
  246 \par
  247     //check if file exists\par
  248     File sensorsData=SPIFFS.open("/sensorsData.csv","r");\par
  249     \par
  250     //file doesn't exist\par
  251     if( (!sensorsData) || (sensorsData.size()==0 ) )\par
  252     \{\par
  253     \par
  254     #if DEBUG == 1\par
  255     \par
  256         Serial.println( F("/sensorsData.csv not found") );\par
  257         Serial.println( F("creating /sensorsData.csv") );\par
  258         Serial.println();\par
  259     \par
  260     #endif\par
  261         //create file\par
  262         sensorsData=SPIFFS.open("/sensorsData.csv","w");\par
  263         \par
  264         if(!sensorsData)\par
  265         \{\par
  266 \par
  267         #if DEBUG == 1\par
  268         \par
  269             Serial.println( F("failed to create /sensorsData.csv") );\par
  270             Serial.println();\par
  271         \par
  272         #endif\par
  273         \par
  274             return(false);\par
  275 \par
  276         \}\par
  277         \par
  278         //print the header(json keys ) to the CSV file\par
  279         sensorsData.println(header);\par
  280 \par
  281         //print the values to the CSV file\par
  282         sensorsData.println(values);\par
  283         \par
  284         sensorsData.close();\par
  285     \par
  286     #if DEBUG == 1\par
  287 \par
  288         sensorsData=SPIFFS.open("/sensorsData.csv","r");\par
  289         \par
  290         if(!sensorsData)\par
  291         \{\par
  292             Serial.println(F("failed to reopen /sensorsData.csv "));\par
  293             return(false);      \par
  294         \}\par
  295 \par
  296         Serial.println( F("/sensorsData.csv : ") );\par
  297 \par
  298         while (sensorsData.available()) \par
  299         \{\par
  300             Serial.print(sensorsData.readString()) ;\par
  301         \}\par
  302         Serial.println();\par
  303 \par
  304         //close the file\par
  305         sensorsData.close();\par
  306 \par
  307     #endif\par
  308         \par
  309 \par
  310         \par
  311         return(true);\par
  312         \par
  313     \}\par
  314 \par
  315     //file exist\par
  316     else\par
  317     \{\par
  318 \par
  319     #if DEBUG == 1\par
  320     \par
  321         Serial.println( F("/sensorsData.csv  found") );\par
  322         Serial.println( F("appending to /sensorsData.csv") );\par
  323         Serial.println();\par
  324     \par
  325     #endif\par
  326 \par
  327         //append to file\par
  328         sensorsData=SPIFFS.open("/sensorsData.csv","a");\par
  329         \par
  330         if(!sensorsData)\par
  331         \{\par
  332         \par
  333         #if DEBUG == 1\par
  334             \par
  335             Serial.println( F("failed to open /sensorsData.csv") );\par
  336             Serial.println();\par
  337 \par
  338         #endif\par
  339             \par
  340             return(false);\par
  341         \par
  342         \}\par
  343 \par
  344         //print the values to the CSV file\par
  345         sensorsData.println(values);\par
  346         \par
  347         sensorsData.close();\par
  348 \par
  349     #if DEBUG == 1\par
  350 \par
  351         sensorsData=SPIFFS.open("/sensorsData.csv","r");\par
  352         \par
  353         if(!sensorsData)\par
  354         \{\par
  355             Serial.println(F("failed to reopen /sensorsData.csv "));\par
  356             return(false);      \par
  357         \}\par
  358 \par
  359         \par
  360         Serial.println( F("/sensorsData.csv : ") );\par
  361 \par
  362         while (sensorsData.available()) \par
  363         \{\par
  364             Serial.println(sensorsData.readString()) ;\par
  365         \}\par
  366         \par
  367         Serial.println();\par
  368         \par
  369         sensorsData.close();\par
  370         \par
  371     #endif      \par
  372         \par
  373         return(true);\par
  374     \par
  375     \}   \par
  376 \par
  377 \par
  378 \par
  379 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_ab78704d5d21ce10fc6f1138ab5ab46c8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v updateConfigFiles\:CoolFileSystem}
{\xe \v CoolFileSystem\:updateConfigFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::updateConfigFiles (String  {\i answer})}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::updateConfigFiles( mqtt answer ): This method is provided to update the configuration files when the appropriate mqtt answer is received\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the files are updated correctly, false otherwise \par
}}{
Definition at line 390 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   391 \{\par
  392 \par
  393 #if DEBUG == 1\par
  394 \par
  395     Serial.println( F("Entering CoolFileSystem.updateConfigFiles") );\par
  396     Serial.println();\par
  397     \par
  398     Serial.println( F("input answer : ") );\par
  399     Serial.println(answer);\par
  400 #endif\par
  401 \par
  402     //total json object \par
  403     DynamicJsonBuffer jsonBuffer;\par
  404     JsonObject& root = jsonBuffer.parseObject( answer.c_str() );\par
  405 \par
  406 #if DEBUG == 1\par
  407     \par
  408     Serial.println( F("json object : ") );  \par
  409     root.printTo(Serial);\par
  410     Serial.println();\par
  411     \par
  412     Serial.print(F("jsonBuffer size: "));\par
  413     Serial.println(jsonBuffer.size());\par
  414     Serial.println();\par
  415 \par
  416 \par
  417 #endif\par
  418 \par
  419     if(! ( root.success() ))\par
  420     \{\par
  421     \par
  422     #if DEBUG == 1\par
  423 \par
  424         Serial.println( F("failed to parse root ") );\par
  425         Serial.println();\par
  426     \par
  427     #endif\par
  428 \par
  429         return(false);\par
  430     \}\par
  431     else\par
  432     \{\par
  433     #if DEBUG == 1\par
  434         \par
  435         Serial.println( F("success to parse root ") );\par
  436         Serial.println();\par
  437         \par
  438     #endif  \par
  439     \}\par
  440     \par
  441 #if DEBUG == 1\par
  442 \par
  443     Serial.println( F("input message is : ") );\par
  444     root.printTo(Serial);\par
  445     Serial.println();\par
  446 \par
  447 #endif\par
  448     //temp string\par
  449     String temp;\par
  450 \par
  451     //CoolBoard Configuration File\par
  452 \par
  453         JsonObject& jsonCoolBoard=root["CoolBoard"];\par
  454 \par
  455 #if DEBUG == 1\par
  456 \par
  457     Serial.println( F("before config CoolBoard json") );\par
  458     jsonCoolBoard.printTo(Serial);\par
  459 \par
  460 #endif\par
  461 \par
  462     if(jsonCoolBoard.success())\par
  463     \{\par
  464         String update;\par
  465     \par
  466         jsonCoolBoard.printTo(update);\par
  467 \par
  468         this->fileUpdate(update,"/coolBoardConfig.json");       \par
  469         \par
  470     \}\par
  471     else\par
  472     \{\par
  473     \par
  474     #if DEBUG == 1 \par
  475 \par
  476         Serial.println( F("failed to parse CoolBoard ") );\par
  477     \par
  478     #endif\par
  479 \par
  480     \}       \par
  481 \par
  482     \par
  483     //Cool Board Sensors Configuration File\par
  484         JsonObject& jsonSensorsBoard=root["CoolSensorsBoard"];\par
  485 \par
  486 #if DEBUG == 1 \par
  487 \par
  488     Serial.println( F("before config CoolSensorsBoard json") );\par
  489     jsonSensorsBoard.printTo(Serial);\par
  490 \par
  491 #endif \par
  492     \par
  493     if(jsonSensorsBoard.success())\par
  494     \{   \par
  495         String update;\par
  496     \par
  497         jsonSensorsBoard.printTo(update);\par
  498 \par
  499         this->fileUpdate(update,"/coolBoardSensorsConfig.json");        \par
  500 \par
  501     \}\par
  502     else\par
  503     \{\par
  504 \par
  505     #if DEBUG == 1\par
  506 \par
  507         Serial.println( F("failed to parse CoolSensorsBoard sensors ") );   \par
  508     \par
  509     #endif\par
  510 \par
  511     \}\par
  512 \par
  513     //Cool Board Actor Configuration File\par
  514         JsonObject& jsonCoolBoardActor=root["CoolBoardActor"];\par
  515 \par
  516 #if DEBUG == 1 \par
  517 \par
  518     Serial.println( F("before config CoolBoardActor json") );\par
  519     jsonCoolBoardActor.printTo(Serial);\par
  520 \par
  521 #endif \par
  522     \par
  523     if(jsonCoolBoardActor.success())\par
  524     \{   \par
  525         String update;\par
  526     \par
  527         jsonCoolBoardActor.printTo(update);\par
  528 \par
  529         this->fileUpdate(update,"/coolBoardActorConfig.json");      \par
  530 \par
  531     \}\par
  532     else\par
  533     \{\par
  534 \par
  535     #if DEBUG == 1\par
  536 \par
  537         Serial.println( F("failed to parse CoolBoardActor json ") );    \par
  538     \par
  539     #endif\par
  540 \par
  541     \}\par
  542 \par
  543     \par
  544     //rtc configuration file\par
  545         JsonObject& jsonRTC=root["rtc"];\par
  546 \par
  547 #if DEBUG == 1 \par
  548     \par
  549     Serial.println( F("before config rtc json") );\par
  550     jsonRTC.printTo(Serial);\par
  551 \par
  552 #endif\par
  553     if(jsonRTC.success() )\par
  554     \{\par
  555         String update;\par
  556 \par
  557         jsonRTC.printTo(update);\par
  558 \par
  559         this->fileUpdate(update,"/rtcConfig.json");         \par
  560     \}\par
  561     else\par
  562     \{\par
  563     \par
  564     #if DEBUG == 1 \par
  565 \par
  566         Serial.println( F("failed to parse rtc ") );\par
  567     \par
  568     #endif\par
  569 \par
  570     \}\par
  571     \par
  572     \par
  573         //cool board led configuration\par
  574         JsonObject& jsonLedBoard=root["led"];\par
  575     \par
  576 #if DEBUG == 1 \par
  577 \par
  578     Serial.println( F("before config Led json") );\par
  579     jsonLedBoard.printTo(Serial);\par
  580 \par
  581 #endif\par
  582 \par
  583     if(jsonLedBoard.success())\par
  584     \{   \par
  585         String update;\par
  586     \par
  587         jsonLedBoard.printTo(update);\par
  588 \par
  589         this->fileUpdate(update,"/coolBoardLedConfig.json");        \par
  590 \par
  591     \par
  592     \}\par
  593     else\par
  594     \{\par
  595     \par
  596     #if DEBUG == 1 \par
  597 \par
  598         Serial.println( F("failed to parse led") );\par
  599     \par
  600     #endif \par
  601 \par
  602     \}\par
  603         \par
  604 \par
  605     \par
  606 \par
  607     //jetpack configuration\par
  608         JsonObject& jsonJetpack=root["jetPack"];\par
  609 \par
  610 #if DEBUG == 1 \par
  611 \par
  612     Serial.println( F("before config jetpack json") );\par
  613     jsonJetpack.printTo(Serial);\par
  614 \par
  615 #endif\par
  616 \par
  617     if(jsonJetpack.success())\par
  618     \{\par
  619     \par
  620         String update;\par
  621     \par
  622         jsonJetpack.printTo(update);\par
  623 \par
  624         this->fileUpdate(update,"/jetPackConfig.json");     \par
  625 \par
  626     \}\par
  627 \par
  628     else\par
  629     \{\par
  630     \par
  631     #if DEBUG == 1 \par
  632 \par
  633         Serial.println( F("failed to parse jetpack") ); \par
  634     \par
  635     #endif\par
  636 \par
  637     \}\par
  638     \par
  639     //irene configuration   \par
  640         JsonObject& jsonIrene=root["irene3000"];\par
  641     \par
  642 #if DEBUG == 1 \par
  643 \par
  644     Serial.println( F("before config irene json") );    \par
  645     jsonIrene.printTo(Serial);\par
  646 \par
  647 #endif \par
  648 \par
  649     if(jsonIrene.success())\par
  650     \{\par
  651 \par
  652         String update;\par
  653     \par
  654         jsonIrene.printTo(update);\par
  655 \par
  656         this->fileUpdate(update,"/irene3000Config.json");       \par
  657     \par
  658     \}\par
  659     else\par
  660     \{\par
  661     \par
  662     #if DEBUG == 1 \par
  663 \par
  664         Serial.println( F("failed to parse irene") );   \par
  665     \par
  666     #endif \par
  667 \par
  668 \par
  669     \}\par
  670     \par
  671     //external sensors\par
  672         JsonObject& jsonExternalSensors=root["externalSensors"];\par
  673 \par
  674 #if DEBUG == 1 \par
  675 \par
  676     Serial.println( F("before config external Sensors json") );\par
  677     jsonExternalSensors.printTo(Serial);\par
  678 \par
  679 #endif\par
  680 \par
  681     if(jsonExternalSensors.success())\par
  682     \{\par
  683 \par
  684         String update;\par
  685     \par
  686         jsonExternalSensors.printTo(update);\par
  687 \par
  688         this->fileUpdate(update,"/externalSensorsConfig.json");     \par
  689 \par
  690     \}\par
  691 \par
  692     else\par
  693     \{   \par
  694 \par
  695     #if DEBUG == 1\par
  696         \par
  697         Serial.println( F("failed to parse external sensors") );\par
  698 \par
  699     #endif\par
  700 \par
  701 \par
  702     \}\par
  703 \par
  704     \par
  705     //mqtt config\par
  706         JsonObject& jsonMQTT=root["mqtt"];\par
  707     \par
  708 #if DEBUG == 1 \par
  709 \par
  710     Serial.println( F("before config mqtt json") );\par
  711     jsonMQTT.printTo(Serial);\par
  712 \par
  713 #endif\par
  714 \par
  715     if(jsonMQTT.success())\par
  716     \{\par
  717 \par
  718         String update;\par
  719     \par
  720         jsonMQTT.printTo(update);\par
  721 \par
  722         this->fileUpdate(update,"/mqttConfig.json");        \par
  723 \par
  724     \}\par
  725     else\par
  726     \{\par
  727 \par
  728     #if DEBUG == 1 \par
  729 \par
  730         Serial.println( F("failed to parse mqtt") );\par
  731     \par
  732     #endif\par
  733 \par
  734     \par
  735     \}   \par
  736 \par
  737     //wifi config\par
  738         JsonObject& jsonWifi=root["wifi"];\par
  739     \par
  740 #if DEBUG == 1 \par
  741 \par
  742     Serial.println( F("before config wifi json") );\par
  743     jsonWifi.printTo(Serial);\par
  744 \par
  745 #endif\par
  746 \par
  747     if(jsonWifi.success())\par
  748     \{\par
  749 \par
  750         String update;\par
  751     \par
  752         jsonWifi.printTo(update);\par
  753 \par
  754         this->fileUpdate(update,"/wifiConfig.json");        \par
  755 \par
  756     \}\par
  757     else\par
  758     \{\par
  759 \par
  760     #if DEBUG == 1 \par
  761 \par
  762         Serial.println( F("failed to parse wifi") );\par
  763     \par
  764     #endif\par
  765 \par
  766     \par
  767     \}   \par
  768         \par
  769     return true;\par
  770 \par
  771 \}   \par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_adfa8e2e80641ae6f0cceabd348a9b841_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_adfa8e2e80641ae6f0cceabd348a9b841_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v linesToSkip\:CoolFileSystem}
{\xe \v CoolFileSystem\:linesToSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolFileSystem::linesToSkip =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of lines to Skip when retrieving saved Data \par
}{
Definition at line 80 of file CoolFileSystem.h.}\par
}
{\xe \v savedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:savedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolFileSystem::savedData =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of lines to read when retrieving saved Data \par
}{
Definition at line 74 of file CoolFileSystem.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolMQTT Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolMQTT}
{\xe \v CoolMQTT}
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client. }}\par
{
{\f2 #include <CoolMQTT.h>}}\par
Collaboration diagram for CoolMQTT:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/def/class_cool_m_q_t_t__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b connect} (unsigned long keepAlive)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *data, unsigned long logInterval)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b config} (const char {\b mqttServer}[], const char {\b inTopic}[], const char {\b outTopic}[], const char {\b user}[], int {\b bufferSize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b callback} (char *topic, byte *payload, unsigned int length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b state} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mqttLoop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getUser} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b mqttServer} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b msg} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b inTopic} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b outTopic} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b user} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufferSize} =3000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WiFiClient {\b espClient}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} {\b client}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b newMsg} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b previousLogTime} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client. \par
}{
Definition at line 45 of file CoolMQTT.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolMQTT}
{\xe \v CoolMQTT\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::begin ()}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::begin()}: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size \par
}{
Definition at line 54 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{ \par
   56 \par
   57 #if DEBUG == 1 \par
   58 \par
   59     Serial.println( F("Entering CoolMQTT.begin()") );\par
   60     Serial.println();\par
   61 \par
   62 #endif\par
   63 \par
   64     client.setClient(espClient);\par
   65     client.setServer(mqttServer, 1883); \par
   66     client.setCallback([this] (char* topic, byte* payload, unsigned int length) \{ this->callback(topic, payload, length); \});\par
   67     client.setBufferSize((unsigned short)bufferSize);\par
   68 \par
   69 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ac9248808641ebf3054ed0620ea9d0100_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ac9248808641ebf3054ed0620ea9d0100_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v callback\:CoolMQTT}
{\xe \v CoolMQTT\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::callback (char *  {\i topic}, byte *  {\i payload}, unsigned int  {\i length})}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic.\par
Arguments are automatically assigned in client.setCallback() \par
}{
Definition at line 310 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   311 \{\par
  312 \par
  313 #if DEBUG == 1\par
  314 \par
  315     Serial.println( F("Entering CoolMQTT.callback() ") );\par
  316     Serial.println();\par
  317 \par
  318 #endif \par
  319 \par
  320     if(this->newMsg==false)\par
  321     \{\par
  322         char temp[length+1];\par
  323 \par
  324     #if DEBUG == 1\par
  325 \par
  326         Serial.println( F("received temp msg : ") );\par
  327         \par
  328     #endif\par
  329         \par
  330         for (unsigned int i = 0; i < length; i++) \par
  331         \{\par
  332             temp[i]=(char)payload[i];\par
  333         \par
  334         #if DEBUG == 1 \par
  335 \par
  336             Serial.print( (char)payload[i] );\par
  337         \par
  338         #endif\par
  339 \par
  340         \}\par
  341     \par
  342     #if DEBUG == 1 \par
  343 \par
  344         Serial.println();\par
  345         Serial.println( F("storing new message : ") );\par
  346 \par
  347         Serial.print(F("length : "));\par
  348         Serial.println(length);\par
  349         \par
  350         Serial.print(F("size : "));\par
  351         Serial.print(sizeof(payload));\par
  352         Serial.println();\par
  353     \par
  354     #endif\par
  355 \par
  356         this->newMsg=true;\par
  357 \par
  358         temp[length+1]='\\0';\par
  359 \par
  360         this->msg=String(temp);\par
  361         this->msg.remove(length,1);\par
  362     \par
  363     #if DEBUG == 1 \par
  364 \par
  365         Serial.println( F("stored message : ") );\par
  366         Serial.println(this->msg);\par
  367     \par
  368     #endif\par
  369 \par
  370     \}\par
  371     else\par
  372     \{\par
  373     \par
  374     #if DEBUG == 1\par
  375 \par
  376         Serial.println( F("did not read last message") );\par
  377     \par
  378     #endif \par
  379         \par
  380     \}\par
  381 \par
  382 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a30d82ad665bfb603f46ecdbc290775df_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolMQTT}
{\xe \v CoolMQTT\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::config (const char  {\i mqttServer}[], const char  {\i inTopic}[], const char  {\i outTopic}[], const char  {\i user}[], int  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client \par
}{
Definition at line 627 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   628 \{\par
  629 \par
  630 #if DEBUG == 1\par
  631 \par
  632     Serial.println( F("Entering CoolMQTT.config() , no SPIFFS variant") );\par
  633     Serial.println();\par
  634 \par
  635 #endif\par
  636 \par
  637     for(int i =0;i< 50 ;i++)\par
  638     \{\par
  639         this->mqttServer[i]=mqttServer[i];\par
  640         this->inTopic[i]=inTopic[i];\par
  641         this->outTopic[i]=outTopic[i];\par
  642         this->user[i]=user[i];\par
  643     \}\par
  644     this->bufferSize=bufferSize;\par
  645     \par
  646 \par
  647 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a9b703de4f1358f0ee7a5e8c44979c648_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolMQTT}
{\xe \v CoolMQTT\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::config ()}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::config()}: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 430 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   431 \{\par
  432 \par
  433 #if DEBUG == 1 \par
  434 \par
  435     Serial.println( F("Entering CoolMQTT.config()") );\par
  436     Serial.println();\par
  437 \par
  438 #endif\par
  439 \par
  440     //read config file\par
  441     //update data\par
  442     File configFile = SPIFFS.open("/mqttConfig.json", "r");\par
  443 \par
  444     if (!configFile) \par
  445     \{\par
  446     \par
  447     #if DEBUG == 1 \par
  448 \par
  449         Serial.println( F("failed to read /mqttConfig.json") );\par
  450         Serial.println();\par
  451 \par
  452     #endif\par
  453 \par
  454         return(false);\par
  455     \}\par
  456     else\par
  457     \{\par
  458         size_t size = configFile.size();\par
  459         // Allocate a buffer to store contents of the file.\par
  460         std::unique_ptr<char[]> buf(new char[size]);\par
  461 \par
  462         configFile.readBytes(buf.get(), size);\par
  463         DynamicJsonBuffer jsonBuffer;\par
  464         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  465         if (!json.success()) \par
  466         \{\par
  467         \par
  468         #if DEBUG == 1 \par
  469 \par
  470             Serial.println( F("failed to parse json ") );\par
  471             Serial.println();\par
  472         \par
  473         #endif\par
  474             \par
  475             return(false);\par
  476         \} \par
  477         else\par
  478         \{\par
  479         \par
  480         #if DEBUG == 1 \par
  481         \par
  482             Serial.println( F("configuration json is ") );\par
  483             json.printTo(Serial);\par
  484             Serial.println();\par
  485 \par
  486             Serial.print(F("jsonBuffer size: "));\par
  487             Serial.println(jsonBuffer.size());\par
  488             Serial.println();\par
  489 \par
  490 \par
  491         #endif\par
  492 \par
  493             if(json["mqttServer"].success() )\par
  494             \{           \par
  495                 const char* tempmqttServer = json["mqttServer"]; \par
  496                 for(int i =0;i< 50 ;i++)\par
  497                 \{\par
  498                     mqttServer[i]=tempmqttServer[i];\par
  499                 \}\par
  500             \}\par
  501             else\par
  502             \{\par
  503                 for(int i =0;i< 50 ;i++)\par
  504                 \{\par
  505                     this->mqttServer[i]=this->mqttServer[i];\par
  506                 \}\par
  507 \par
  508             \}\par
  509             json["mqttServer"]=this->mqttServer;\par
  510 \par
  511             \par
  512             if(json["inTopic"].success() )\par
  513             \{\par
  514                 const char* tempInTopic = json["inTopic"]; \par
  515                 for(int i =0;i< 50;i++)\par
  516                 \{\par
  517                     inTopic[i]=tempInTopic[i];\par
  518                 \}\par
  519             \}\par
  520             else\par
  521             \{\par
  522                 String tempMAC = WiFi.macAddress();\par
  523                 tempMAC.replace(":","");\par
  524                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC.c_str());   \par
  525             \par
  526             #if DEBUG == 1              \par
  527                 \par
  528                 Serial.print( F("Set Incomming MQTT Channel to : ") );\par
  529                 Serial.println(inTopic);\par
  530             \par
  531             #endif  \par
  532 \par
  533             \}\par
  534             json["inTopic"]=this->inTopic;\par
  535             \par
  536             \par
  537             if(json["outTopic"].success() )\par
  538             \{\par
  539                 const char* tempOutTopic = json["outTopic"]; \par
  540                 for(int i =0;i<50;i++)\par
  541                 \{\par
  542                     outTopic[i]=tempOutTopic[i];\par
  543                 \}\par
  544             \}\par
  545             else\par
  546             \{\par
  547                 String tempMAC = WiFi.macAddress();\par
  548                 tempMAC.replace(":","");\par
  549                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC.c_str());\par
  550             \par
  551             #if DEBUG == 1 \par
  552 \par
  553                 Serial.print( F("Set Outgoing MQTT Channel to : ") );\par
  554                 Serial.println(outTopic);\par
  555             \par
  556             #endif\par
  557 \par
  558             \}\par
  559             json["outTopic"]=this->outTopic;\par
  560         \par
  561             \par
  562             if(json["user"].success() )\par
  563             \{               \par
  564                 const char* tempUser = json["user"]; \par
  565                 for(int i =0;i<50;i++)\par
  566                 \{\par
  567                     user[i]=tempUser[i];\par
  568                 \}\par
  569             \}\par
  570             else\par
  571             \{\par
  572                 for(int i=0;i<50;i++)\par
  573                 \{\par
  574                     this->user[i]=this->user[i];\par
  575                 \}               \par
  576             \}\par
  577             json["user"]=this->user;\par
  578             \par
  579             if(json["bufferSize"].success() )\par
  580             \{\par
  581                 int tempBufferSize = json["bufferSize"]; \par
  582                 bufferSize=tempBufferSize;\par
  583             \}\par
  584             else\par
  585             \{\par
  586                 this->bufferSize=this->bufferSize;\par
  587             \}\par
  588             json["bufferSize"]=this->bufferSize;\par
  589 \par
  590             configFile.close();\par
  591             configFile = SPIFFS.open("/mqttConfig.json", "w");\par
  592             if(!configFile)\par
  593             \{\par
  594             \par
  595             #if DEBUG == 1 \par
  596 \par
  597                 Serial.println( F("failed to write to /mqttConfig.json") );\par
  598             \par
  599             #endif\par
  600 \par
  601                 return(false);              \par
  602             \}\par
  603             \par
  604             json.printTo(configFile);\par
  605             configFile.close();\par
  606 \par
  607         #if DEBUG == 1 \par
  608 \par
  609             Serial.println( F("saved configuration is :") );\par
  610             json.printTo(Serial);\par
  611             Serial.println();\par
  612         \par
  613         #endif\par
  614 \par
  615             return(true); \par
  616         \}\par
  617     \}   \par
  618     \par
  619 \par
  620 \}\par
}
}
{\xe \v connect\:CoolMQTT}
{\xe \v CoolMQTT\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolMQTT::connect (unsigned long  {\i keepAlive})}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::connect( time to keep the connection alive in seconds ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid mqtt client state \par
}}{
Definition at line 110 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111 \{       \par
  112 \par
  113     int i=0;\par
  114 \par
  115 #if DEBUG == 1 \par
  116 \par
  117     Serial.println( F("Entering CoolMQTT.connect()") );\par
  118 \par
  119 #endif\par
  120     Serial.println( F("MQTT connecting...") );\par
  121     \par
  122     while( ( !this->client.connected() ) && ( i<100 ) ) \par
  123     \{\par
  124         // Attempt to connect\par
  125         if( this->client.connect( this-> user,keepAlive*10  ) )\par
  126         \{\par
  127             client.subscribe( this->inTopic );\par
  128 \par
  129         #if DEBUG == 1 \par
  130 \par
  131             Serial.println( F(" subscribed , leavin ") ) ;\par
  132         \par
  133         #endif\par
  134 \par
  135             return( this->state() );\par
  136         \}\par
  137 \par
  138         else\par
  139         \{\par
  140         \par
  141         #if DEBUG == 1 \par
  142 \par
  143             Serial.println( F("not connected , retrying") );\par
  144         \par
  145         #endif\par
  146 \par
  147             \par
  148         \}\par
  149 \par
  150     delay(5);\par
  151     i++;\par
  152     \}\par
  153     if (state() == 0)\par
  154     \{\par
  155         Serial.println( F("MQTT connected : OK") );\par
  156         Serial.println();\par
  157     \}\par
  158     else Serial.println( F("MQTT not jet connected..."));\par
  159     return( this->state() );\par
  160 \par
  161 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a50075d0ab23a327ab897fd6adad20eda_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a50075d0ab23a327ab897fd6adad20eda_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getUser\:CoolMQTT}
{\xe \v CoolMQTT\:getUser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolMQTT::getUser ()}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::getUser()}: This method is provided to get the user name \par
}{
Definition at line 690 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   691 \{\par
  692 \par
  693 #if DEBUG == 1 \par
  694     Serial.println( F("Entering CoolMQTT.getUser()") );\par
  695     Serial.println();\par
  696     \par
  697     Serial.print( F("user : ") );\par
  698     Serial.println(this->user);\par
  699 \par
  700 #endif\par
  701 \par
  702     return String(this->user);\par
  703 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a373cc92fca7760d886f02d8a6e5b3f63_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mqttLoop\:CoolMQTT}
{\xe \v CoolMQTT\:mqttLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::mqttLoop ()}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::mqttLoop()}: This method is provided to allow the client to process the data\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 274 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   275 \{\par
  276 \par
  277     unsigned long lastTime=millis();\par
  278 \par
  279 #if DEBUG == 1\par
  280 \par
  281     Serial.println( F("Entering CoolMQTT.mqttLoop()") );\par
  282     Serial.println();\par
  283 \par
  284 #endif  \par
  285 \par
  286     while( ( millis() - lastTime ) < 1000)\par
  287     \{\par
  288         this->client.loop();\par
  289         yield();\par
  290     \}\par
  291 \par
  292 #if DEBUG == 1 \par
  293     \par
  294     Serial.print( F("loop result : ") );\par
  295     Serial.println( this->client.loop() );\par
  296     Serial.println();\par
  297 \par
  298 #endif\par
  299 \par
  300     return( this->client.loop() );\par
  301 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_aa5eaae967b562b62cbcf2b8d81f6e5d5_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_aa5eaae967b562b62cbcf2b8d81f6e5d5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolMQTT}
{\xe \v CoolMQTT\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::printConf ()}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 654 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   655 \{\par
  656 \par
  657 #if DEBUG == 1 \par
  658 \par
  659     Serial.println( F("Entering CoolMQTT.printConf()") );\par
  660     Serial.println();   \par
  661 \par
  662 #endif\par
  663     \par
  664     Serial.println("MQTT configuration ");\par
  665 \par
  666     Serial.print("mqttServer : ");\par
  667     Serial.println(this->mqttServer);\par
  668 \par
  669     Serial.print("inTopic : ");\par
  670     Serial.println(this->inTopic);\par
  671 \par
  672     Serial.print("outTopic : ");\par
  673     Serial.println(this->outTopic);\par
  674 \par
  675     Serial.print("user : ");\par
  676     Serial.println(this->user);\par
  677 \par
  678     Serial.print("bufferSize : ");\par
  679     Serial.println(this->bufferSize);\par
  680 \par
  681     Serial.println();\par
  682 \par
  683 \par
  684 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a40553a0ad4b5ecf1cb4411ab54ca85fb_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolMQTT}
{\xe \v CoolMQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::publish (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::publish(data): This method is provided to publish data to the out topic\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if publish successful, false otherwise \par
}}{
Definition at line 171 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   172 \{\par
  173 \par
  174 #if DEBUG == 1 \par
  175 \par
  176     Serial.println( F("Entering CoolMQTT.publish()") );\par
  177     Serial.println();\par
  178     //data is in JSON, publish it directly\par
  179 \par
  180     Serial.println( F("data to publish : ") );\par
  181     Serial.println(data);\par
  182     Serial.print( F("data size : ") );\par
  183     Serial.println(strlen(data));\par
  184 \par
  185     Serial.println();\par
  186 \par
  187 #endif\par
  188 #if DEBUG == 0\par
  189     Serial.println( F("Publishing Message : "));\par
  190     Serial.println(data);\par
  191     Serial.println();\par
  192 #endif\par
  193 \par
  194     bool pub=client.publish( this->outTopic,(byte*) data,strlen(data),false  );\par
  195 \par
  196 #if DEBUG == 1 \par
  197 \par
  198     Serial.print( F("success : ") );\par
  199     Serial.println(pub);    \par
  200 \par
  201 #endif\par
  202 #if DEBUG == 0\par
  203     if (pub == 1)\par
  204     \{\par
  205         Serial.println( F("Publish : OK"));\par
  206     \}\par
  207     else Serial.println( F("Publish : FAIL!!!"));\par
  208 #endif\par
  209 \par
  210     return(pub);\par
  211 \par
  212 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ace977b3e90ab14b1199fe5c4fb0a13ec_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ace977b3e90ab14b1199fe5c4fb0a13ec_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolMQTT}
{\xe \v CoolMQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::publish (const char *  {\i data}, unsigned long  {\i logInterval})}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval in seconds\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if publish successful, false otherwise \par
}}{
Definition at line 222 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{\par
  224 \par
  225 #if DEBUG == 1 \par
  226 \par
  227     Serial.println( F("Entering CoolMQTT.publish() every logInterval ") );\par
  228     Serial.println();\par
  229 \par
  230 #endif \par
  231     //log interval is passed in seconds, logInterval*1000 = logInterval in ms\par
  232     if( ( millis() - ( this->previousLogTime)  ) >= ( logInterval*1000 ) )\par
  233     \{\par
  234     \par
  235     #if DEBUG == 1\par
  236 \par
  237         Serial.println( F("log Interval has passed ") );\par
  238         Serial.println();\par
  239     \par
  240     #endif\par
  241 \par
  242         this->publish(data);\par
  243 \par
  244         this->previousLogTime=millis();\par
  245     \par
  246     #if DEBUG == 1 \par
  247 \par
  248         Serial.print( F("last log time : ") );\par
  249         Serial.println(this->previousLogTime);\par
  250 \par
  251     #endif\par
  252 \par
  253         return(true);\par
  254     \}\par
  255 \par
  256 #if DEBUG == 1 \par
  257 \par
  258     Serial.println( F("log Interval still didn't pass ") ); \par
  259     Serial.println();\par
  260 \par
  261 #endif\par
  262 \par
  263     return(false);\par
  264 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a613c5e3927ae85bb94fbf648d84d8780_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:CoolMQTT}
{\xe \v CoolMQTT\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolMQTT::read ()}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::read()}: This method is provided to return the last read message. \par
}{
Definition at line 389 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   390 \{   \par
  391 \par
  392 #if DEBUG == 1 \par
  393 \par
  394     Serial.println( F("Entering CoolMQTT.read()") );\par
  395     Serial.println();\par
  396 \par
  397 #endif \par
  398 \par
  399     if(this->newMsg==true)\par
  400     \{\par
  401         \par
  402         this->newMsg=false;\par
  403 \par
  404 #if DEBUG == 1 \par
  405         Serial.println( F("received new message") );\par
  406         Serial.println( F("message : ") );\par
  407         Serial.println(this->msg);\par
  408         Serial.println();\par
  409 \par
  410 #endif\par
  411 \par
  412         return(this->msg);\par
  413         \par
  414     \}\par
  415     return("");\par
  416 \par
  417 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ae3c18f6ae9723746d32765f1c8f176ca_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v state\:CoolMQTT}
{\xe \v CoolMQTT\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolMQTT::state ()}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::state()}: This method is provided to return the mqtt client's state. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect \par
}}{
Definition at line 87 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    88 \{\par
   89 \par
   90 #if DEBUG == 1 \par
   91 \par
   92     Serial.println( F("Entering CoolMQTT.state()") );\par
   93     Serial.println();   \par
   94     Serial.print( F("state : ") );\par
   95     Serial.println( this->client.state() );\par
   96 \par
   97 #endif\par
   98     \par
   99     return( this->client.state() );\par
  100 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a5d003307eff78efbd585e42b43b72b6d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a5d003307eff78efbd585e42b43b72b6d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bufferSize\:CoolMQTT}
{\xe \v CoolMQTT\:bufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolMQTT::bufferSize =3000{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT inner bufferSize \par
}{
Definition at line 104 of file CoolMQTT.h.}\par
}
{\xe \v client\:CoolMQTT}
{\xe \v CoolMQTT\:client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} CoolMQTT::client{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT Client instance \par
}{
Definition at line 114 of file CoolMQTT.h.}\par
}
{\xe \v espClient\:CoolMQTT}
{\xe \v CoolMQTT\:espClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiClient CoolMQTT::espClient{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WifiClient instance \par
}{
Definition at line 109 of file CoolMQTT.h.}\par
}
{\xe \v inTopic\:CoolMQTT}
{\xe \v CoolMQTT\:inTopic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::inTopic[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT Topic to subscribe/listen to \par
}{
Definition at line 89 of file CoolMQTT.h.}\par
}
{\xe \v mqttServer\:CoolMQTT}
{\xe \v CoolMQTT\:mqttServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::mqttServer[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT Server name/ip \par
}{
Definition at line 79 of file CoolMQTT.h.}\par
}
{\xe \v msg\:CoolMQTT}
{\xe \v CoolMQTT\:msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolMQTT::msg =""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
String to store incoming messages \par
}{
Definition at line 84 of file CoolMQTT.h.}\par
}
{\xe \v newMsg\:CoolMQTT}
{\xe \v CoolMQTT\:newMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::newMsg =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
new message flag \par
}{
Definition at line 119 of file CoolMQTT.h.}\par
}
{\xe \v outTopic\:CoolMQTT}
{\xe \v CoolMQTT\:outTopic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::outTopic[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT topic to publish/write to \par
}{
Definition at line 94 of file CoolMQTT.h.}\par
}
{\xe \v previousLogTime\:CoolMQTT}
{\xe \v CoolMQTT\:previousLogTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolMQTT::previousLogTime =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
last time the Client sent a Message over MQTT in ms \par
}{
Definition at line 125 of file CoolMQTT.h.}\par
}
{\xe \v user\:CoolMQTT}
{\xe \v CoolMQTT\:user}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::user[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MQTT user name \par
}{
Definition at line 99 of file CoolMQTT.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolPubSubClient Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolPubSubClient}
{\xe \v CoolPubSubClient}
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
\par
{
{\f2 #include <CoolPubSubClient.h>}}\par
Collaboration diagram for CoolPubSubClient:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d7b/class_cool_pub_sub_client__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CoolPubSubClient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setServer} (IPAddress {\b ip}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setServer} (uint8_t *{\b ip}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setServer} (const char *{\b domain}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setCallback} ({\b MQTT_CALLBACK_SIGNATURE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setClient} (Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setStream} (Stream &{\b stream})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setTimeout} (uint16_t {\b socketTimeout})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, const char *user, const char *pass, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, const char *willTopic, uint8_t willQos, boolean willRetain, const char *willMessage, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, const char *user, const char *pass, const char *willTopic, uint8_t willQos, boolean willRetain, const char *willMessage, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disconnect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const char *payload)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const char *payload, boolean retained)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, boolean retained)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish_P} (const char *topic, const uint8_t *payload, unsigned int plength, boolean retained)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b subscribe} (const char *topic)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b subscribe} (const char *topic, uint8_t qos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b unsubscribe} (const char *topic)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b loop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connected} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b state} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b setBufferSize} (uint16_t size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getBufferSize} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b readPacket} (uint8_t *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b readByte} (uint8_t *result)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b readByte} (uint8_t *result, uint16_t *index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b write} (uint8_t header, uint8_t *buf, uint16_t length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b writeString} (const char *string, uint8_t *buf, uint16_t pos)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client * {\b _client}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t * {\b buffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b buffer_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b nextMsgId}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastOutActivity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastInActivity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pingOutstanding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT_CALLBACK_SIGNATURE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b ip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b domain}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Stream * {\b stream}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _state}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b keepAlive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b socketTimeout}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 88 of file CoolPubSubClient.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient ()}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    14                                    \{\par
   15     this->_state = MQTT_DISCONNECTED;\par
   16     this->_client = NULL;\par
   17     this->stream = NULL;\par
   18     setCallback(NULL);\par
   19     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   20     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   21 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a2e54e36217bb0969b91b5dee9a27410f_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23                                                  \{\par
   24     this->_state = MQTT_DISCONNECTED;\par
   25     setClient(client);\par
   26     this->stream = NULL;\par
   27     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   28     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   29 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0563a12cb4e9339bf2605cfc655e717d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    31                                                                                 \{\par
   32     this->_state = MQTT_DISCONNECTED;\par
   33     setServer(addr, port);\par
   34     setClient(client);\par
   35     this->stream = NULL;\par
   36     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   37     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   38 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a4548ad6f306f6181e337a86c0b21a89a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    39                                                                                                 \{\par
   40     this->_state = MQTT_DISCONNECTED;\par
   41     setServer(addr,port);\par
   42     setClient(client);\par
   43     setStream(stream);\par
   44     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   45     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   46 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_af8b1aeb169366da52e3289bb6c238b6b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    47                                                                                                          \{\par
   48     this->_state = MQTT_DISCONNECTED;\par
   49     setServer(addr, port);\par
   50     setCallback(callback);\par
   51     setClient(client);\par
   52     this->stream = NULL;\par
   53     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   54     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   55 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a1743a9eeef19b3b6ff1db5be8df55a9c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    56                                                                                                                          \{\par
   57     this->_state = MQTT_DISCONNECTED;\par
   58     setServer(addr,port);\par
   59     setCallback(callback);\par
   60     setClient(client);\par
   61     setStream(stream);\par
   62     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   63     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   64 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0797679d710bf2b1aa802107bdb1a2fe_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    66                                                                              \{\par
   67     this->_state = MQTT_DISCONNECTED;\par
   68     setServer(ip, port);\par
   69     setClient(client);\par
   70     this->stream = NULL;\par
   71     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   72     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   73 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a15e4dd41ebda943c377539086f70469d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    74                                                                                              \{\par
   75     this->_state = MQTT_DISCONNECTED;\par
   76     setServer(ip,port);\par
   77     setClient(client);\par
   78     setStream(stream);\par
   79     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   80     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   81 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a3e7d7fa4b55e36f0ac8912335993d650_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82                                                                                                       \{\par
   83     this->_state = MQTT_DISCONNECTED;\par
   84     setServer(ip, port);\par
   85     setCallback(callback);\par
   86     setClient(client);\par
   87     this->stream = NULL;\par
   88     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   89     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   90 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_afc703702b40ba925377d0b9cd401319e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    91                                                                                                                       \{\par
   92     this->_state = MQTT_DISCONNECTED;\par
   93     setServer(ip,port);\par
   94     setCallback(callback);\par
   95     setClient(client);\par
   96     setStream(stream);\par
   97     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   98     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   99 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a08309a2cf058099fa5c96c198f777647_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101                                                                                     \{\par
  102     this->_state = MQTT_DISCONNECTED;\par
  103     setServer(domain,port);\par
  104     setClient(client);\par
  105     this->stream = NULL;\par
  106     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  107     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  108 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a469eefe7429f0cbb6d7d443b52488411_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   109                                                                                                     \{\par
  110     this->_state = MQTT_DISCONNECTED;\par
  111     setServer(domain,port);\par
  112     setClient(client);\par
  113     setStream(stream);\par
  114     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  115     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  116 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a103e7286407babde84d63bb735c4e4b6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   117                                                                                                              \{\par
  118     this->_state = MQTT_DISCONNECTED;\par
  119     setServer(domain,port);\par
  120     setCallback(callback);\par
  121     setClient(client);\par
  122     this->stream = NULL;\par
  123     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  124     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  125 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a2aea0a9487dc15b9db1caf0f069eb877_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   126                                                                                                                              \{\par
  127     this->_state = MQTT_DISCONNECTED;\par
  128     setServer(domain,port);\par
  129     setCallback(callback);\par
  130     setClient(client);\par
  131     setStream(stream);\par
  132     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  133     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  134 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a6466f55abe5820d410b1c9cf7a70ec7e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ~CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:~CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::~CoolPubSubClient ()}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   136                                     \{\par
  137   free(this->buffer);\par
  138 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   140                                                                                             \{\par
  141     return connect(id,NULL,NULL,0,0,0,0,keepAlive,socketTimeout);\par
  142  \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a2664c2ebc302b2fa49f493a339ecc891_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, const char *  {\i user}, const char *  {\i pass}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144                                                                                                                                 \{\par
  145     return connect(id,user,pass,0,0,0,0,keepAlive,socketTimeout);\par
  146  \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7f30e39bf4ca5ea5fb9747c403639a03_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, const char *  {\i willTopic}, uint8_t  {\i willQos}, boolean  {\i willRetain}, const char *  {\i willMessage}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   148                                                                                                                                                                                  \{\par
  149     return connect(id,NULL,NULL,willTopic,willQos,willRetain,willMessage,keepAlive,socketTimeout);\par
  150  \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_af461a5a08fda1c3237e706965704ddb6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, const char *  {\i user}, const char *  {\i pass}, const char *  {\i willTopic}, uint8_t  {\i willQos}, boolean  {\i willRetain}, const char *  {\i willMessage}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   152                                                                                                                                                                                                                      \{  \par
  153     if (!connected()) \{\par
  154         int result = 0;\par
  155 \par
  156         if (domain != NULL) \{\par
  157             result = _client->connect(this->domain, this->port);\par
  158         \} else \{\par
  159             result = _client->connect(this->ip, this->port);\par
  160         \}\par
  161         if (result == 1) \{\par
  162             nextMsgId = 1;\par
  163             // Leave room in the buffer for header and variable length field\par
  164             uint16_t length = 5;\par
  165             unsigned int j;\par
  166 \par
  167 #if MQTT_VERSION == MQTT_VERSION_3_1\par
  168             uint8_t d[9] = \{0x00,0x06,'M','Q','I','s','d','p', MQTT_VERSION\};\par
  169 #define MQTT_HEADER_VERSION_LENGTH 9\par
  170 #elif MQTT_VERSION == MQTT_VERSION_3_1_1\par
  171             uint8_t d[7] = \{0x00,0x04,'M','Q','T','T',MQTT_VERSION\};\par
  172 #define MQTT_HEADER_VERSION_LENGTH 7\par
  173 #endif\par
  174             for (j = 0;j<MQTT_HEADER_VERSION_LENGTH;j++) \{\par
  175                 buffer[length++] = d[j];\par
  176             \}\par
  177 \par
  178             uint8_t v;\par
  179             if (willTopic) \{\par
  180                 v = 0x06|(willQos<<3)|(willRetain<<5);\par
  181             \} else \{\par
  182                 v = 0x02;\par
  183             \}\par
  184 \par
  185             if(user != NULL) \{\par
  186                 v = v|0x80;\par
  187 \par
  188                 if(pass != NULL) \{\par
  189                     v = v|(0x80>>1);\par
  190                 \}\par
  191             \}\par
  192 \par
  193             buffer[length++] = v;\par
  194 \par
  195             if (keepAlive > 0) \{\par
  196                 this->keepAlive = keepAlive;\par
  197             \} else \{\par
  198                 this->keepAlive = MQTT_KEEPALIVE;\par
  199             \}\par
  200 \par
  201             buffer[length++] = ((this->keepAlive) >> 8);\par
  202             buffer[length++] = ((this->keepAlive) & 0xFF);\par
  203 \par
  204             length = writeString(id,buffer,length);\par
  205             if (willTopic) \{\par
  206                 length = writeString(willTopic,buffer,length);\par
  207                 length = writeString(willMessage,buffer,length);\par
  208             \}\par
  209 \par
  210             if(user != NULL) \{\par
  211                 length = writeString(user,buffer,length);\par
  212                 if(pass != NULL) \{\par
  213                     length = writeString(pass,buffer,length);\par
  214                 \}\par
  215             \}\par
  216 \par
  217             write(MQTTCONNECT,buffer,length-5);\par
  218 \par
  219             lastInActivity = lastOutActivity = millis();\par
  220         \par
  221         if (socketTimeout > 0) \{\par
  222                 this->socketTimeout = socketTimeout;\par
  223             \} else \{\par
  224                 this->socketTimeout = MQTT_SOCKET_TIMEOUT;\par
  225             \}\par
  226 \par
  227 \par
  228             while (!_client->available()) \{\par
  229                 unsigned long t = millis();\par
  230                 if (t-lastInActivity >= ((int32_t) this->socketTimeout*1000UL)) \{\par
  231                     _state = MQTT_CONNECTION_TIMEOUT;\par
  232                     _client->stop();\par
  233                     return false;\par
  234                 \}\par
  235             \}\par
  236             uint8_t llen;\par
  237             uint16_t len = readPacket(&llen);\par
  238 \par
  239             if (len == 4) \{\par
  240                 if (buffer[3] == 0) \{\par
  241                     lastInActivity = millis();\par
  242                     pingOutstanding = false;\par
  243                     _state = MQTT_CONNECTED;\par
  244                     return true;\par
  245                 \} else \{\par
  246                     _state = buffer[3];\par
  247                 \}\par
  248             \}\par
  249             _client->stop();\par
  250         \} else \{\par
  251             _state = MQTT_CONNECT_FAILED;\par
  252         \}\par
  253         return false;\par
  254     \}\par
  255     return true;\par
  256 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7e5a85731dd25d90a41f6d859e61da77_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connected\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connected ()}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 588 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   588                                     \{\par
  589     boolean rc;\par
  590     if (_client == NULL ) \{\par
  591         rc = false;\par
  592     \} else \{\par
  593         rc = (int)_client->connected();\par
  594         if (!rc) \{\par
  595             if (this->_state == MQTT_CONNECTED) \{\par
  596                 this->_state = MQTT_CONNECTION_LOST;\par
  597                 _client->flush();\par
  598                 _client->stop();\par
  599             \}\par
  600         \}\par
  601     \}\par
  602     return rc;\par
  603 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a3d5a5da4ddb1e5c1bea64d80c665d148_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v disconnect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:disconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolPubSubClient::disconnect ()}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 565 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   565                                   \{\par
  566     buffer[0] = MQTTDISCONNECT;\par
  567     buffer[1] = 0;\par
  568     _client->write(buffer,2);\par
  569     _state = MQTT_DISCONNECTED;\par
  570     _client->stop();\par
  571     lastInActivity = lastOutActivity = millis();\par
  572 \}\par
}
}
{\xe \v getBufferSize\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:getBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::getBufferSize ()}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 648 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   648                                          \{\par
  649   return this->buffer_size;\par
  650 \}\par
}
}
{\xe \v loop\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::loop ()}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 334 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   334                                \{\par
  335     if (connected()) \{\par
  336         unsigned long t = millis();\par
  337         if ((t - lastInActivity > this->keepAlive*1000UL) || (t - lastOutActivity > this->keepAlive*1000UL)) \{ \par
  338             if (pingOutstanding) \{\par
  339                 this->_state = MQTT_CONNECTION_TIMEOUT;\par
  340                 _client->stop();\par
  341                 return false;\par
  342             \} else \{\par
  343                 buffer[0] = MQTTPINGREQ;\par
  344                 buffer[1] = 0;\par
  345                 _client->write(buffer,2);\par
  346                 lastOutActivity = t;\par
  347                 lastInActivity = t;\par
  348                 pingOutstanding = true;\par
  349             \}\par
  350         \}\par
  351         if (_client->available()) \{\par
  352             uint8_t llen;\par
  353             uint16_t len = readPacket(&llen);\par
  354             uint16_t msgId = 0;\par
  355             uint8_t *payload;\par
  356             if (len > 0) \{\par
  357                 lastInActivity = t;\par
  358                 uint8_t type = buffer[0]&0xF0;\par
  359                 if (type == MQTTPUBLISH) \{\par
  360                     if (callback) \{\par
  361                         uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; /* topic length in bytes */\par
  362                         memmove(buffer+llen+2,buffer+llen+3,tl); /* move topic inside buffer 1 byte to front */\par
  363                         buffer[llen+2+tl] = 0; /* end the topic as a 'C' string with \\x00 */\par
  364                         char *topic = (char*) buffer+llen+2;\par
  365                         // msgId only present for QOS>0\par
  366                         if ((buffer[0]&0x06) == MQTTQOS1) \{\par
  367                             msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];\par
  368                             payload = buffer+llen+3+tl+2;\par
  369                             callback(topic,payload,len-llen-3-tl-2);\par
  370 \par
  371                             buffer[0] = MQTTPUBACK;\par
  372                             buffer[1] = 2;\par
  373                             buffer[2] = (msgId >> 8);\par
  374                             buffer[3] = (msgId & 0xFF);\par
  375                             _client->write(buffer,4);\par
  376                             lastOutActivity = t;\par
  377 \par
  378                         \} else \{\par
  379                             payload = buffer+llen+3+tl;\par
  380                             callback(topic,payload,len-llen-3-tl);\par
  381                         \}\par
  382                     \}\par
  383                 \} else if (type == MQTTPINGREQ) \{\par
  384                     buffer[0] = MQTTPINGRESP;\par
  385                     buffer[1] = 0;\par
  386                     _client->write(buffer,2);\par
  387                 \} else if (type == MQTTPINGRESP) \{\par
  388                     pingOutstanding = false;\par
  389                 \}\par
  390             \}\par
  391         \}\par
  392         return true;\par
  393     \}\par
  394     return false;\par
  395 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_afc15900f0fc4886a19394508e61793b8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_afc15900f0fc4886a19394508e61793b8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const char *  {\i payload})}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 397 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   397                                                                         \{\par
  398     return publish(topic,(const uint8_t*)payload,strlen(payload),false);\par
  399 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ab6ad5fa2d3db8f91454027257f225a89_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const char *  {\i payload}, boolean  {\i retained})}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 401 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   401                                                                                           \{\par
  402     return publish(topic,(const uint8_t*)payload,strlen(payload),retained);\par
  403 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0b01cef98af0b57d8da4df373e196448_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength})}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 405 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   405                                                                                                  \{\par
  406     return publish(topic, payload, plength, false);\par
  407 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_abf184c0968a6655b68b5fdfbbc0c87d1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, boolean  {\i retained})}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 409 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   409                                                                                                                    \{\par
  410     if (connected()) \{\par
  411         if (this->buffer_size < 5 + 2+strlen(topic) + plength) \{\par
  412             // Too long\par
  413             return false;\par
  414         \}\par
  415         // Leave room in the buffer for header and variable length field\par
  416         uint16_t length = 5;\par
  417         length = writeString(topic,buffer,length);\par
  418         uint16_t i;\par
  419         for (i=0;i<plength;i++) \{\par
  420             buffer[length++] = payload[i];\par
  421         \}\par
  422         uint8_t header = MQTTPUBLISH;\par
  423         if (retained) \{\par
  424             header |= 1;\par
  425         \}\par
  426         return write(header,buffer,length-5);\par
  427     \}\par
  428     return false;\par
  429 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_adef968760eb87b70e3fed03e60da76f7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish_P\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish_P (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, boolean  {\i retained})}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 431 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   431                                                                                                                      \{\par
  432     uint8_t llen = 0;\par
  433     uint8_t digit;\par
  434     unsigned int rc = 0;\par
  435     uint16_t tlen;\par
  436     unsigned int pos = 0;\par
  437     unsigned int i;\par
  438     uint8_t header;\par
  439     unsigned int len;\par
  440 \par
  441     if (!connected()) \{\par
  442         return false;\par
  443     \}\par
  444 \par
  445     tlen = strlen(topic);\par
  446 \par
  447     header = MQTTPUBLISH;\par
  448     if (retained) \{\par
  449         header |= 1;\par
  450     \}\par
  451     buffer[pos++] = header;\par
  452     len = plength + 2 + tlen;\par
  453     do \{\par
  454         digit = len % 128;\par
  455         len = len / 128;\par
  456         if (len > 0) \{\par
  457             digit |= 0x80;\par
  458         \}\par
  459         buffer[pos++] = digit;\par
  460         llen++;\par
  461     \} while(len>0);\par
  462 \par
  463     pos = writeString(topic,buffer,pos);\par
  464 \par
  465     rc += _client->write(buffer,pos);\par
  466 \par
  467     for (i=0;i<plength;i++) \{\par
  468         rc += _client->write((char)pgm_read_byte_near(payload + i));\par
  469     \}\par
  470 \par
  471     lastOutActivity = millis();\par
  472 \par
  473     return rc == tlen + 4 + plength;\par
  474 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a55458d47cf01f590e9b6647d5a418ab6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readByte\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:readByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::readByte (uint8_t *  {\i result}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 259 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   259                                                    \{\par
  260    uint32_t previousMillis = millis();\par
  261    while(!_client->available()) \par
  262    \{\par
  263      uint32_t currentMillis = millis();\par
  264      if(currentMillis - previousMillis >= ((int32_t) this->socketTimeout * 1000))\par
  265      \{ \par
  266        return false;\par
  267      \}\par
  268    \}\par
  269    *result = _client->read();\par
  270    return true;\par
  271 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ad409bbd287d5894f0cf082f62446c002_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readByte\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:readByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::readByte (uint8_t *  {\i result}, uint16_t *  {\i index}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 274 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   274                                                                     \{\par
  275   uint16_t current_index = *index;\par
  276   uint8_t * write_address = &(result[current_index]);\par
  277   if(readByte(write_address))\{\par
  278     *index = current_index + 1;\par
  279     return true;\par
  280   \}\par
  281   return false;\par
  282 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_abef3735bb9a2a8c87b3da659dc4ade03_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readPacket\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:readPacket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::readPacket (uint8_t *  {\i lengthLength}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 284 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   284                                                            \{\par
  285     uint16_t len = 0;\par
  286     if(!readByte(buffer, &len)) return 0;\par
  287     bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;\par
  288     uint32_t multiplier = 1;\par
  289     uint16_t length = 0;\par
  290     uint8_t digit = 0;\par
  291     uint16_t skip = 0;\par
  292     uint8_t start = 0;\par
  293 \par
  294     do \{\par
  295         if(!readByte(&digit)) return 0;\par
  296         buffer[len++] = digit;\par
  297         length += (digit & 127) * multiplier;\par
  298         multiplier *= 128;\par
  299     \} while ((digit & 128) != 0);\par
  300     *lengthLength = len-1;\par
  301 \par
  302     if (isPublish) \{\par
  303         // Read in topic length to calculate bytes to skip over for Stream writing\par
  304         if(!readByte(buffer, &len)) return 0;\par
  305         if(!readByte(buffer, &len)) return 0;\par
  306         skip = (buffer[*lengthLength+1]<<8)+buffer[*lengthLength+2];\par
  307         start = 2;\par
  308         if (buffer[0]&MQTTQOS1) \{\par
  309             // skip message id\par
  310             skip += 2;\par
  311         \}\par
  312     \}\par
  313 \par
  314     for (uint16_t i = start;i<length;i++) \{\par
  315         if(!readByte(&digit)) return 0;\par
  316         if (this->stream) \{\par
  317             if (isPublish && len-*lengthLength-2>skip) \{\par
  318                 this->stream->write(digit);\par
  319             \}\par
  320         \}\par
  321         if (len < this->buffer_size) \{\par
  322             buffer[len] = digit;\par
  323         \}\par
  324         len++;\par
  325     \}\par
  326 \par
  327     if (!this->stream && len > this->buffer_size) \{\par
  328         len = 0; // This will cause the packet to be ignored.\par
  329     \}\par
  330 \par
  331     return len;\par
  332 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a25a8779149cfa809b7c06f63568b25cf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a25a8779149cfa809b7c06f63568b25cf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBufferSize\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::setBufferSize (uint16_t  {\i size})}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 642 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   642                                                      \{\par
  643   this->buffer = (uint8_t*)realloc(this->buffer, size);\par
  644   this->buffer_size = size;\par
  645   return (this->buffer == NULL);\par
  646 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a4f83e54f1ba96e32f725d93cdec283b7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setCallback\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setCallback ({\b MQTT_CALLBACK_SIGNATURE} )}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 623 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   623                                                                        \{\par
  624     this->callback = callback;\par
  625     return *this;\par
  626 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ac5cab7658f1bdded32131241e468e661_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setClient (Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 628 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   628                                                            \{\par
  629     this->_client = &client;\par
  630     return *this;\par
  631 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7ee119b786010561ab6a9afa0798e91d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setServer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setServer (IPAddress  {\i ip}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 610 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   610                                                                          \{\par
  611     this->ip = ip;\par
  612     this->port = port;\par
  613     this->domain = NULL;\par
  614     return *this;\par
  615 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a947e70c394c66c7d08d0c53caf8425e3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setServer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setServer (uint8_t *  {\i ip}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 605 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   605                                                                          \{\par
  606     IPAddress addr(ip[0],ip[1],ip[2],ip[3]);\par
  607     return setServer(addr,port);\par
  608 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ad589f977fc2799b9341dc5f4fcdb483a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setServer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setServer (const char *  {\i domain}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 617 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   617                                                                                 \{\par
  618     this->domain = domain;\par
  619     this->port = port;\par
  620     return *this;\par
  621 \}\par
}
}
{\xe \v setStream\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setStream (Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 633 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   633                                                            \{\par
  634     this->stream = &stream;\par
  635     return *this;\par
  636 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ae97e40823ea689ff9e36d5bdd71bb933_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setTimeout\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setTimeout (uint16_t  {\i socketTimeout})}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 652 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   652                                                                     \{\par
  653     this->socketTimeout = socketTimeout;\par
  654     return *this;\par
  655 \}\par
}
}
{\xe \v state\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolPubSubClient::state ()}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 638 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   638                             \{\par
  639     return this->_state;\par
  640 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a3245a5afc6d22e61270dcfe392ccb866_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subscribe\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::subscribe (const char *  {\i topic})}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 518 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   518                                                      \{\par
  519     return subscribe(topic, 0);\par
  520 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ac1ebc9ad874128aefa985d78496d2e8f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subscribe\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::subscribe (const char *  {\i topic}, uint8_t  {\i qos})}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 522 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   522                                                                   \{\par
  523     if (qos < 0 || qos > 1) \{\par
  524         return false;\par
  525     \}\par
  526     if (this->buffer_size < 9 + strlen(topic)) \{\par
  527         // Too long\par
  528         return false;\par
  529     \}\par
  530     if (connected()) \{\par
  531         // Leave room in the buffer for header and variable length field\par
  532         uint16_t length = 5;\par
  533         nextMsgId++;\par
  534         if (nextMsgId == 0) \{\par
  535             nextMsgId = 1;\par
  536         \}\par
  537         buffer[length++] = (nextMsgId >> 8);\par
  538         buffer[length++] = (nextMsgId & 0xFF);\par
  539         length = writeString((char*)topic, buffer,length);\par
  540         buffer[length++] = qos;\par
  541         return write(MQTTSUBSCRIBE|MQTTQOS1,buffer,length-5);\par
  542     \}\par
  543     return false;\par
  544 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_aebf684e98588c52a72af1014f7957bee_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v unsubscribe\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:unsubscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::unsubscribe (const char *  {\i topic})}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 546 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   546                                                        \{\par
  547     if (this->buffer_size < 9 + strlen(topic)) \{\par
  548         // Too long\par
  549         return false;\par
  550     \}\par
  551     if (connected()) \{\par
  552         uint16_t length = 5;\par
  553         nextMsgId++;\par
  554         if (nextMsgId == 0) \{\par
  555             nextMsgId = 1;\par
  556         \}\par
  557         buffer[length++] = (nextMsgId >> 8);\par
  558         buffer[length++] = (nextMsgId & 0xFF);\par
  559         length = writeString(topic, buffer,length);\par
  560         return write(MQTTUNSUBSCRIBE|MQTTQOS1,buffer,length-5);\par
  561     \}\par
  562     return false;\par
  563 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a850554280e314d6b5c33c73fd9e809fc_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::write (uint8_t  {\i header}, uint8_t *  {\i buf}, uint16_t  {\i length}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 476 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   476                                                                              \{\par
  477     uint8_t lenBuf[4];\par
  478     uint8_t llen = 0;\par
  479     uint8_t digit;\par
  480     uint8_t pos = 0;\par
  481     uint16_t rc;\par
  482     uint16_t len = length;\par
  483     do \{\par
  484         digit = len % 128;\par
  485         len = len / 128;\par
  486         if (len > 0) \{\par
  487             digit |= 0x80;\par
  488         \}\par
  489         lenBuf[pos++] = digit;\par
  490         llen++;\par
  491     \} while(len>0);\par
  492 \par
  493     buf[4-llen] = header;\par
  494     for (int i=0;i<llen;i++) \{\par
  495         buf[5-llen+i] = lenBuf[i];\par
  496     \}\par
  497 \par
  498 #ifdef MQTT_MAX_TRANSFER_SIZE\par
  499     uint8_t* writeBuf = buf+(4-llen);\par
  500     uint16_t bytesRemaining = length+1+llen;  //Match the length type\par
  501     uint8_t bytesToWrite;\par
  502     boolean result = true;\par
  503     while((bytesRemaining > 0) && result) \{\par
  504         bytesToWrite = (bytesRemaining > MQTT_MAX_TRANSFER_SIZE)?MQTT_MAX_TRANSFER_SIZE:bytesRemaining;\par
  505         rc = _client->write(writeBuf,bytesToWrite);\par
  506         result = (rc == bytesToWrite);\par
  507         bytesRemaining -= rc;\par
  508         writeBuf += rc;\par
  509     \}\par
  510     return result;\par
  511 #else\par
  512     rc = _client->write(buf+(4-llen),length+1+llen);\par
  513     lastOutActivity = millis();\par
  514     return (rc == 1+llen+length);\par
  515 #endif\par
  516 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7a8e4854a1846eaa668046d3854d47ad_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeString\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:writeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::writeString (const char *  {\i string}, uint8_t *  {\i buf}, uint16_t  {\i pos}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 574 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   574                                                                                      \{\par
  575     const char* idp = string;\par
  576     uint16_t i = 0;\par
  577     pos += 2;\par
  578     while (*idp) \{\par
  579         buf[pos++] = *idp++;\par
  580         i++;\par
  581     \}\par
  582     buf[pos-i-2] = (i >> 8);\par
  583     buf[pos-i-1] = (i & 0xFF);\par
  584     return pos;\par
  585 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0e3d7e776d4cf4427f9569b28868905a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _client\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:_client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Client* CoolPubSubClient::_client{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolPubSubClient.h.}\par
}
{\xe \v _state\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolPubSubClient::_state{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file CoolPubSubClient.h.}\par
}
{\xe \v buffer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t* CoolPubSubClient::buffer{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolPubSubClient.h.}\par
}
{\xe \v buffer_size\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:buffer_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::buffer_size{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolPubSubClient.h.}\par
}
{\xe \v domain\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:domain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CoolPubSubClient::domain{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolPubSubClient.h.}\par
}
{\xe \v ip\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress CoolPubSubClient::ip{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file CoolPubSubClient.h.}\par
}
{\xe \v keepAlive\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:keepAlive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::keepAlive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolPubSubClient.h.}\par
}
{\xe \v lastInActivity\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:lastInActivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolPubSubClient::lastInActivity{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file CoolPubSubClient.h.}\par
}
{\xe \v lastOutActivity\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:lastOutActivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolPubSubClient::lastOutActivity{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CALLBACK_SIGNATURE\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:MQTT_CALLBACK_SIGNATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::MQTT_CALLBACK_SIGNATURE{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file CoolPubSubClient.h.}\par
}
{\xe \v nextMsgId\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:nextMsgId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::nextMsgId{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file CoolPubSubClient.h.}\par
}
{\xe \v pingOutstanding\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:pingOutstanding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolPubSubClient::pingOutstanding{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolPubSubClient.h.}\par
}
{\xe \v port\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::port{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file CoolPubSubClient.h.}\par
}
{\xe \v socketTimeout\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:socketTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::socketTimeout{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolPubSubClient.h.}\par
}
{\xe \v stream\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Stream* CoolPubSubClient::stream{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolPubSubClient.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolSI114X Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolSI114X}
{\xe \v CoolSI114X}
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\par
{
{\f2 #include <CoolSI114X.h>}}\par
Collaboration diagram for CoolSI114X:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d2d/class_cool_s_i114_x__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Begin} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Reset} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeInit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ReadParamData} (uint8_t Reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b WriteParamData} (uint8_t Reg, uint8_t Value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadVisible} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadIR} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadProximity} (uint8_t PSn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadUV} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteByte} (uint8_t Reg, uint8_t Value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ReadByte} (uint8_t Reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadHalfWord} (uint8_t Reg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 165 of file CoolSI114X.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Begin\:CoolSI114X}
{\xe \v CoolSI114X\:Begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolSI114X::Begin (void )}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    92 \{\par
   93   Wire.begin(2,14);\par
   94   //\par
   95   //Init IIC  and reset si1145\par
   96   //\par
   97   if(ReadByte(CoolSI114X_PART_ID)!=0X45)\par
   98   \{\par
   99     return false;\par
  100   \}\par
  101   Reset();\par
  102   //\par
  103   //INIT \par
  104   //\par
  105   DeInit();\par
  106   return true;\par
  107 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a206b36aca7049f63be1d11088c30a09f_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a206b36aca7049f63be1d11088c30a09f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DeInit\:CoolSI114X}
{\xe \v CoolSI114X\:DeInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolSI114X::DeInit (void )}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    42 \{  \par
   43   //ENABLE UV reading  \par
   44   //these reg must be set to the fixed value\par
   45   WriteByte(CoolSI114X_UCOEFF0, 0x29);\par
   46   WriteByte(CoolSI114X_UCOEFF1, 0x89);\par
   47   WriteByte(CoolSI114X_UCOEFF2, 0x02);\par
   48   WriteByte(CoolSI114X_UCOEFF3, 0x00);\par
   49   WriteParamData(CoolSI114X_CHLIST, CoolSI114X_CHLIST_ENUV |CoolSI114X_CHLIST_ENALSIR | CoolSI114X_CHLIST_ENALSVIS |CoolSI114X_CHLIST_ENPS1);\par
   50   //\par
   51   //set LED1 CURRENT(22.4mA)(It is a normal value for many LED)\par
   52   //\par
   53   WriteParamData(CoolSI114X_PS1_ADCMUX, CoolSI114X_ADCMUX_LARGE_IR);\par
   54   WriteByte(CoolSI114X_PS_LED21, CoolSI114X_LED_CURRENT_22MA);\par
   55   WriteParamData(CoolSI114X_PSLED12_SELECT, CoolSI114X_PSLED12_SELECT_PS1_LED1); //\par
   56   //\par
   57   //PS ADC SETTING\par
   58   //\par
   59   WriteParamData(CoolSI114X_PS_ADC_GAIN, CoolSI114X_ADC_GAIN_DIV1);\par
   60   WriteParamData(CoolSI114X_PS_ADC_COUNTER, CoolSI114X_ADC_COUNTER_511ADCCLK);\par
   61   WriteParamData(CoolSI114X_PS_ADC_MISC, CoolSI114X_ADC_MISC_HIGHRANGE|CoolSI114X_ADC_MISC_ADC_RAWADC); \par
   62   //\par
   63   //VIS ADC SETTING\par
   64   //\par
   65   WriteParamData(CoolSI114X_ALS_VIS_ADC_GAIN, CoolSI114X_ADC_GAIN_DIV1);\par
   66   WriteParamData(CoolSI114X_ALS_VIS_ADC_COUNTER, CoolSI114X_ADC_COUNTER_511ADCCLK);\par
   67   WriteParamData(CoolSI114X_ALS_VIS_ADC_MISC, CoolSI114X_ADC_MISC_HIGHRANGE);\par
   68   //\par
   69   //IR ADC SETTING\par
   70   //\par
   71   WriteParamData(CoolSI114X_ALS_IR_ADC_GAIN, CoolSI114X_ADC_GAIN_DIV1);\par
   72   WriteParamData(CoolSI114X_ALS_IR_ADC_COUNTER, CoolSI114X_ADC_COUNTER_511ADCCLK);\par
   73   WriteParamData(CoolSI114X_ALS_IR_ADC_MISC, CoolSI114X_ADC_MISC_HIGHRANGE);\par
   74   //\par
   75   //interrupt enable\par
   76   //\par
   77   WriteByte(CoolSI114X_INT_CFG, CoolSI114X_INT_CFG_INTOE);  \par
   78   WriteByte(CoolSI114X_IRQ_ENABLE, CoolSI114X_IRQEN_ALS);  \par
   79   //\par
   80   //AUTO RUN\par
   81   //\par
   82   WriteByte(CoolSI114X_MEAS_RATE0, 0xFF);\par
   83   WriteByte(CoolSI114X_COMMAND, CoolSI114X_PSALS_AUTO);\par
   84 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a6840abd53a2e3d71a6bb918077c6d6e6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a6840abd53a2e3d71a6bb918077c6d6e6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadByte\:CoolSI114X}
{\xe \v CoolSI114X\:ReadByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CoolSI114X::ReadByte (uint8_t  {\i Reg}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144 \{\par
  145     Wire.beginTransmission(CoolSI114X_ADDR);\par
  146     Wire.write(Reg);\par
  147     Wire.endTransmission();\par
  148     Wire.requestFrom(CoolSI114X_ADDR, 1);  \par
  149     return Wire.read();\par
  150 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_acc20f8037e156ec4aadcbe90780b1e8b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadHalfWord\:CoolSI114X}
{\xe \v CoolSI114X\:ReadHalfWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadHalfWord (uint8_t  {\i Reg}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157   uint16_t Value;\par
  158   Wire.beginTransmission(CoolSI114X_ADDR);\par
  159   Wire.write(Reg); \par
  160   Wire.endTransmission(); \par
  161   Wire.requestFrom(CoolSI114X_ADDR, 2);\par
  162   Value = Wire.read();\par
  163   Value |= (uint16_t)Wire.read() << 8; \par
  164   return Value;\par
  165 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a1d25c9e137874af529804c2ec796a6b9_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadIR\:CoolSI114X}
{\xe \v CoolSI114X\:ReadIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadIR (void )}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 200 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   201 \{\par
  202   return ReadHalfWord(CoolSI114X_ALS_IR_DATA0);     \par
  203 \} \par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abc536ee7ae8e3ba9d1069acc3889a2cf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abc536ee7ae8e3ba9d1069acc3889a2cf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadParamData\:CoolSI114X}
{\xe \v CoolSI114X\:ReadParamData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CoolSI114X::ReadParamData (uint8_t  {\i Reg})}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 170 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   171 \{\par
  172     WriteByte(CoolSI114X_COMMAND, Reg | CoolSI114X_QUERY);\par
  173     return ReadByte(CoolSI114X_RD);\par
  174 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a33cf431103c722442f6a0cc93848d640_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadProximity\:CoolSI114X}
{\xe \v CoolSI114X\:ReadProximity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadProximity (uint8_t  {\i PSn})}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 208 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   209 \{\par
  210   return ReadHalfWord(PSn);     \par
  211 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a194fede1105508c7803dbb567cbdcc67_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadUV\:CoolSI114X}
{\xe \v CoolSI114X\:ReadUV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadUV (void )}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218 \{\par
  219   return (ReadHalfWord(CoolSI114X_AUX_DATA0_UVINDEX0));     \par
  220 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a14ced664d74e93438440b0274109c111_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a14ced664d74e93438440b0274109c111_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadVisible\:CoolSI114X}
{\xe \v CoolSI114X\:ReadVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadVisible (void )}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194   return ReadHalfWord(CoolSI114X_ALS_VIS_DATA0);    \par
  195 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a42e0e574256341443c647a4c0eda87d5_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a42e0e574256341443c647a4c0eda87d5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Reset\:CoolSI114X}
{\xe \v CoolSI114X\:Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolSI114X::Reset (void )}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114 \{\par
  115   WriteByte(CoolSI114X_MEAS_RATE0, 0);\par
  116   WriteByte(CoolSI114X_MEAS_RATE1, 0);\par
  117   WriteByte(CoolSI114X_IRQ_ENABLE, 0);\par
  118   WriteByte(CoolSI114X_IRQ_MODE1, 0);\par
  119   WriteByte(CoolSI114X_IRQ_MODE2, 0);\par
  120   WriteByte(CoolSI114X_INT_CFG, 0);\par
  121   WriteByte(CoolSI114X_IRQ_STATUS, 0xFF);\par
  122 \par
  123   WriteByte(CoolSI114X_COMMAND, CoolSI114X_RESET);\par
  124   delay(10);\par
  125   WriteByte(CoolSI114X_HW_KEY, 0x17);\par
  126   delay(10);\par
  127 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a9d9f9c9129c0c29ed497f8563f3dd823_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a9d9f9c9129c0c29ed497f8563f3dd823_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WriteByte\:CoolSI114X}
{\xe \v CoolSI114X\:WriteByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolSI114X::WriteByte (uint8_t  {\i Reg}, uint8_t  {\i Value}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   133 \{\par
  134   Wire.beginTransmission(CoolSI114X_ADDR); \par
  135   Wire.write(Reg); \par
  136   Wire.write(Value); \par
  137   Wire.endTransmission(); \par
  138 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_ac5c8dc5ade604da7a1c8cd1586feefc2_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WriteParamData\:CoolSI114X}
{\xe \v CoolSI114X\:WriteParamData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CoolSI114X::WriteParamData (uint8_t  {\i Reg}, uint8_t  {\i Value})}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 179 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   180 \{\par
  181     //write Value into PARAMWR reg first\par
  182    WriteByte(CoolSI114X_WR, Value);\par
  183    WriteByte(CoolSI114X_COMMAND, Reg | CoolSI114X_SET);\par
  184    //CoolSI114X writes value out to PARAM_RD,read and confirm its right\par
  185    return ReadByte(CoolSI114X_RD);\par
  186 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abf45eb10a6de1be16e68a51624fa2608_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abf45eb10a6de1be16e68a51624fa2608_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolTime Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolTime}
{\xe \v CoolTime}
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC . }}\par
{
{\f2 #include <CoolTime.h>}}\par
Collaboration diagram for CoolTime:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d40/class_cool_time__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b config} (IPAddress {\b timeServer}, unsigned int {\b localPort})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDateTime} (int year, int month, int day, int hour, int minutes, int seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tmElements_t {\b getTimeDate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getESDate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getLastSyncTime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTimeSync} (unsigned long seconds=604800)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b getNtpTime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendNTPpacket} (IPAddress &address)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b formatDigits} (int digits)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveTimeSync} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeSync} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b timeServer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WiFiUDP {\b Udp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b localPort} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b packetBuffer} [{\b NTP_PACKET_SIZE}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tmElements_t {\b tmSet}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DS1337RTC {\b rtc}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC . \par
}{
Definition at line 54 of file CoolTime.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolTime}
{\xe \v CoolTime\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::begin ()}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::begin()}: This method is provided to init the udp connection \par
}{
Definition at line 54 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56 \par
   57 #if DEBUG == 1 \par
   58 \par
   59     Serial.println( F("Entering CoolTime.begin()") );\par
   60     Serial.println();\par
   61 \par
   62 #endif \par
   63 \par
   64 \par
   65     Udp.begin(localPort);\par
   66     \par
   67     this->update();\par
   68     \par
   69 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ab1976cf718b950bc31e003c3323b8adb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ab1976cf718b950bc31e003c3323b8adb_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolTime}
{\xe \v CoolTime\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolTime::config ()}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::config()}: This method is provided to configure the {\b CoolTime} object through a configuration file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 427 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   428 \{\par
  429 \par
  430 #if DEBUG == 1 \par
  431 \par
  432     Serial.println( F("Enter CoolTime.config()") );\par
  433     Serial.println();\par
  434 \par
  435 #endif \par
  436 \par
  437     File rtcConfig = SPIFFS.open("/rtcConfig.json", "r");\par
  438 \par
  439     if (!rtcConfig) \par
  440     \{\par
  441     \par
  442         Serial.println( F("failed to read /rtcConfig.json") );\par
  443         Serial.println();\par
  444 \par
  445         return(false);\par
  446     \}\par
  447     else\par
  448     \{\par
  449         size_t size = rtcConfig.size();\par
  450         // Allocate a buffer to store contents of the file.\par
  451         std::unique_ptr<char[]> buf(new char[size]);\par
  452 \par
  453         rtcConfig.readBytes(buf.get(), size);\par
  454         DynamicJsonBuffer jsonBuffer;\par
  455         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  456         if (!json.success()) \par
  457         \{\par
  458 \par
  459             Serial.println( F("failed to parse rtcConfig json") );\par
  460             Serial.println();\par
  461 \par
  462             return(false);\par
  463         \} \par
  464         else\par
  465         \{  \par
  466         \par
  467         #if DEBUG == 1 \par
  468 \par
  469             Serial.println( F("configuration json is :") );\par
  470             json.printTo(Serial);\par
  471             Serial.println();\par
  472 \par
  473             Serial.print(F("jsonBuffer size: "));\par
  474             Serial.println(jsonBuffer.size());\par
  475             Serial.println();\par
  476 \par
  477 \par
  478         #endif\par
  479 \par
  480             String ip;\par
  481             \par
  482             if(json["timeServer"].success() )\par
  483             \{           \par
  484                  ip=json["timeServer"].as<String>();\par
  485                 this->timeServer.fromString(ip);\par
  486                 \par
  487             \}\par
  488             else\par
  489             \{\par
  490                 this->timeServer=this->timeServer;\par
  491             \}\par
  492             json["timeServer"]=ip;\par
  493             \par
  494             if(json["localPort"].success() )\par
  495             \{                       \par
  496                 this->localPort=json["localPort"];\par
  497             \}\par
  498             else\par
  499             \{\par
  500                 this->localPort=this->localPort;\par
  501             \}\par
  502             json["localPort"]=this->localPort;\par
  503 \par
  504 \par
  505             if( json["timeSync"].success() )\par
  506             \{\par
  507 \par
  508                 this->timeSync=json["timeSync"];\par
  509             \}\par
  510             else\par
  511             \{\par
  512                 this->timeSync=this->timeSync;\par
  513             \}\par
  514             json["timeSync"]=this->timeSync;\par
  515 \par
  516             rtcConfig.close();\par
  517             rtcConfig= SPIFFS.open("/rtcConfig.json", "w");\par
  518             \par
  519             if(!rtcConfig)\par
  520             \{\par
  521             \par
  522             #if DEBUG == 1\par
  523 \par
  524                 Serial.println( F("failed to write to /rtcConfig.json") );\par
  525                 Serial.println();\par
  526             \par
  527             #endif\par
  528 \par
  529                 return(false);\par
  530             \}\par
  531             \par
  532             json.printTo(rtcConfig);\par
  533             rtcConfig.close();\par
  534 \par
  535         #if DEBUG == 1 \par
  536 \par
  537             Serial.println( F("configuration is :") );\par
  538             json.printTo(Serial);\par
  539             Serial.println();\par
  540         \par
  541         #endif\par
  542         \par
  543             return(true); \par
  544         \}\par
  545     \}   \par
  546 \par
  547 \par
  548 \par
  549 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a87c28260c1bc77091162cbcf1ee2e129_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolTime}
{\xe \v CoolTime\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::config (IPAddress  {\i timeServer}, unsigned int  {\i localPort})}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::config(Time server IP , udp Port): This method is provided to do manual configuration. \par
}{
Definition at line 404 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   405 \{\par
  406 \par
  407 #if DEBUG == 1 \par
  408 \par
  409     Serial.println( F("Enter CoomTime.config() , no SPIFFS variant ") );\par
  410     Serial.println();\par
  411 \par
  412 #endif \par
  413 \par
  414     this->timeServer=timeServer;\par
  415     this->localPort=localPort;\par
  416     \par
  417 \} \par
}
}
{\xe \v formatDigits\:CoolTime}
{\xe \v CoolTime\:formatDigits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolTime::formatDigits (int  {\i digits})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::printDigits(digit)\par
utility method for digital clock display adds leading 0\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid formatted string of the input digit \par
}}{
Definition at line 708 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{\par
  710 \par
  711 #if DEBUG == 1 \par
  712 \par
  713     Serial.println( F("Entering CoolTime.formatDigits()") );\par
  714     Serial.println();\par
  715 \par
  716 #endif \par
  717 \par
  718     if(digits < 10)\par
  719     \{\par
  720     \par
  721     #if DEBUG == 1\par
  722 \par
  723         Serial.println( F("output digit : ") );\par
  724         Serial.println( String("0") + String(digits) );\par
  725 \par
  726     #endif\par
  727 \par
  728         return( String("0") + String(digits) );\par
  729     \}\par
  730     \par
  731 #if DEBUG == 1 \par
  732 \par
  733     Serial.println( F("output digit : ") );\par
  734     Serial.println(digits);\par
  735 \par
  736 #endif\par
  737 \par
  738     return( String(digits) );\par
  739 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_acd537cd4210d7bde4e1f5c47d2ac0456_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getESDate\:CoolTime}
{\xe \v CoolTime\:getESDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolTime::getESDate ()}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::getESD(): This method is provided to return an Elastic Search compatible date Format\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid date String in Elastic Search format \par
}}{
Definition at line 206 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   207 \{\par
  208 \par
  209 #if DEBUG == 1 \par
  210 \par
  211     Serial.println( F("Entering CoolTime.getESDate()") );\par
  212     Serial.println();\par
  213 \par
  214 #endif \par
  215 \par
  216     tmElements_t tm=this->getTimeDate();\par
  217 \par
  218     //"20yy-mm-ddT00:00:00Z"\par
  219     String elasticSearchString =String(tm.Year+1970)+"-"+this->formatDigits(tm.Month)+"-";\par
  220 \par
  221     elasticSearchString +=this->formatDigits(tm.Day)+"T"+this->formatDigits(tm.Hour)+":";\par
  222     \par
  223     elasticSearchString +=this->formatDigits(tm.Minute)+":"+this->formatDigits(tm.Second)+"Z";\par
  224 \par
  225 #if DEBUG == 1 \par
  226 \par
  227     Serial.print( F("elastic Search date : ") );\par
  228     Serial.println(elasticSearchString);\par
  229     Serial.println();\par
  230 \par
  231 #endif\par
  232 \par
  233     return (elasticSearchString);\par
  234 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ac4f32ee513c1328d984306645e8785a4_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ac4f32ee513c1328d984306645e8785a4_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getLastSyncTime\:CoolTime}
{\xe \v CoolTime\:getLastSyncTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolTime::getLastSyncTime ()}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::getLastSyncTime()}: This method is provided to get the last time we syncronised the time\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid unsigned long representation of last syncronisation time in seconds \par
}}{
Definition at line 244 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   245 \{\par
  246 \par
  247 #if DEBUG == 1 \par
  248 \par
  249     Serial.println( F("Entering CoolTime.getLastSyncTime()") );\par
  250     Serial.println();\par
  251     \par
  252     Serial.print( F("last sync time : ") );\par
  253     Serial.println(this->timeSync);\par
  254 \par
  255 #endif \par
  256 \par
  257     return(this->timeSync);\par
  258 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a5d17f707a9d337720493b2bce9d41c21_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getNtpTime\:CoolTime}
{\xe \v CoolTime\:getNtpTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t CoolTime::getNtpTime ()}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::getNtopTime(): This method is provided to get the Time through an NTP request to a Time Server\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a time_t (unsigned long ) timestamp in seconds \par
}}{
Definition at line 310 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   311 \{\par
  312 \par
  313 #if DEBUG == 1 \par
  314 \par
  315     Serial.println( F("Entering CoolTime.getNtpTime()") );\par
  316     Serial.println();\par
  317 \par
  318 #endif \par
  319 \par
  320     while (Udp.parsePacket() > 0) ; // discard any previously received packets\par
  321 \par
  322     Serial.println( F("Transmit NTP Request") );\par
  323 \par
  324     sendNTPpacket(timeServer);\par
  325 \par
  326     uint32_t beginWait = millis();\par
  327 \par
  328     while (millis() - beginWait < 1500) \par
  329     \{\par
  330         int size = Udp.parsePacket();\par
  331         if (size >= NTP_PACKET_SIZE) \par
  332         \{\par
  333         \par
  334         #if DEBUG == 1\par
  335 \par
  336             Serial.println( F("Receive NTP Response") );\par
  337         \par
  338         #endif\par
  339 \par
  340             Udp.read(packetBuffer, NTP_PACKET_SIZE);  // read packet into the buffer\par
  341             unsigned long secsSince1900;\par
  342             // convert four bytes starting at location 40 to a long integer\par
  343             secsSince1900 =  (unsigned long)packetBuffer[40] << 24;\par
  344             secsSince1900 |= (unsigned long)packetBuffer[41] << 16;\par
  345             secsSince1900 |= (unsigned long)packetBuffer[42] << 8;\par
  346             secsSince1900 |= (unsigned long)packetBuffer[43];\par
  347         \par
  348         #if DEBUG == 1 \par
  349     \par
  350             Serial.print( F("received unix time : ") );\par
  351             Serial.println(secsSince1900 - 2208988800UL);\par
  352             Serial.println();\par
  353 \par
  354         #endif \par
  355 \par
  356             return secsSince1900 - 2208988800UL ;\par
  357         \}\par
  358     \}\par
  359     \par
  360     Serial.println( F("No NTP Response :-(") );\par
  361 \par
  362     return 0; // return 0 if unable to get the time\par
  363 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a41fbbbfd651c2079f54d4b2911e4c705_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a41fbbbfd651c2079f54d4b2911e4c705_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTimeDate\:CoolTime}
{\xe \v CoolTime\:getTimeDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tmElements_t CoolTime::getTimeDate ()}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::getTimeDate()}: This method is provided to get the RTC Time\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a tmElements_t structre that has the time in it \par
}}{
Definition at line 163 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   164 \{\par
  165 \par
  166 #if DEBUG == 1 \par
  167     \par
  168     Serial.println( F("Entering CoolTime.getTimeDate()") );\par
  169     Serial.println();\par
  170 \par
  171 #endif\par
  172 \par
  173     tmElements_t tm;\par
  174     time_t timeDate = this->rtc.get(CLOCK_ADDRESS);\par
  175     breakTime(timeDate,tm);\par
  176 \par
  177 #if DEBUG == 1\par
  178     \par
  179     Serial.print( F("time is : ") );\par
  180     Serial.print(tm.Year+ 1970 );\par
  181     Serial.print( F("-") );\par
  182     Serial.print( this->formatDigits( tm.Month ) );\par
  183     Serial.print( F("-") );\par
  184     Serial.print( this->formatDigits( tm.Day ) );\par
  185     Serial.print( F("T") );\par
  186     Serial.print( this->formatDigits( tm.Hour ) );\par
  187     Serial.print( F(":") );\par
  188     Serial.print( this->formatDigits( tm.Minute ) );\par
  189     Serial.print( F(":") );\par
  190     Serial.print( this->formatDigits( tm.Second ) );\par
  191     Serial.print( F("Z") );\par
  192 \par
  193 #endif\par
  194     \par
  195     return(tm);\par
  196 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a7a7501c5ca77dd1248bea704c44f986c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a7a7501c5ca77dd1248bea704c44f986c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isTimeSync\:CoolTime}
{\xe \v CoolTime\:isTimeSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolTime::isTimeSync (unsigned long  {\i seconds} = {\f2 604800})}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::isTimeSync( time in seconds): This method is provided to test if the time is syncronised or not. By default we test once per week.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if time is syncronised,false otherwise \par
}}{
Definition at line 270 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271 \{\par
  272 \par
  273 #if DEBUG == 1\par
  274 \par
  275     Serial.println( F("Entering CoolTime.isTimeSync() ") );\par
  276     Serial.println();\par
  277 \par
  278 #endif \par
  279 \par
  280 #if DEBUG == 0\par
  281 \par
  282     Serial.println( F("Check if Clock is ok and in sync..."));\par
  283 \par
  284 #endif\par
  285 \par
  286     //default is once per week we try to get a time update\par
  287     if( ( RTC.get(CLOCK_ADDRESS) - this->getLastSyncTime() ) > ( seconds ) ) \par
  288     \{\par
  289 \par
  290         Serial.println( F("time is not syncronised ") );\par
  291     \par
  292         return(false);  \par
  293     \}\par
  294     \par
  295     Serial.println( F("time is syncronised : OK") );\par
  296     Serial.println();\par
  297 \par
  298     return(true);\par
  299 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a5ae038a4498602b189f76a10bf02adf8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a5ae038a4498602b189f76a10bf02adf8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolTime}
{\xe \v CoolTime\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::printConf ()}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::printConf()}: This method is provided to print the {\b CoolTime} configuration to the Serial Monitor \par
}{
Definition at line 681 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   682 \{\par
  683 \par
  684 #if DEBUG == 1\par
  685 \par
  686     Serial.println( F("Entering CoolTime.printConf()") );\par
  687     Serial.println();\par
  688 \par
  689 #endif \par
  690 \par
  691     Serial.println("RTC Configuration") ;\par
  692 \par
  693     Serial.print("timeServer : ");\par
  694     Serial.println(timeServer);\par
  695     \par
  696     Serial.print("localPort : :");\par
  697     Serial.println(localPort);\par
  698 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_af355e7f9b3898211cd2ff25eab5933b1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v saveTimeSync\:CoolTime}
{\xe \v CoolTime\:saveTimeSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolTime::saveTimeSync ()}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::saveTimeSync()} This method is provided to save the last sync time in the SPIFFS.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 560 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   561 \{\par
  562     Serial.println( F("Enter CoolTime.saveTimeSync()") );\par
  563     Serial.println();\par
  564 \par
  565     File rtcConfig = SPIFFS.open("/rtcConfig.json", "r");\par
  566 \par
  567     if (!rtcConfig) \par
  568     \{\par
  569         Serial.println( F("failed to read /rtcConfig.json") );\par
  570         Serial.println();\par
  571 \par
  572         return(false);\par
  573     \}\par
  574     else\par
  575     \{\par
  576         size_t size = rtcConfig.size();\par
  577         // Allocate a buffer to store contents of the file.\par
  578         std::unique_ptr<char[]> buf(new char[size]);\par
  579 \par
  580         rtcConfig.readBytes(buf.get(), size);\par
  581         DynamicJsonBuffer jsonBuffer;\par
  582         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  583         if (!json.success()) \par
  584         \{\par
  585 \par
  586             Serial.println( F("failed to parse json") );\par
  587             Serial.println();\par
  588 \par
  589             return(false);\par
  590         \} \par
  591         else\par
  592         \{\par
  593 \par
  594         #if DEBUG == 1\par
  595     \par
  596             Serial.println( F("configuration json is :") );\par
  597             json.printTo(Serial);\par
  598             Serial.println();\par
  599 \par
  600             Serial.print(F("jsonBuffer size: "));\par
  601             Serial.println(jsonBuffer.size());\par
  602             Serial.println();\par
  603 \par
  604         #endif\par
  605 \par
  606             String ip;\par
  607                     \par
  608             if(json["timeServer"].success() )\par
  609             \{           \par
  610                  ip=json["timeServer"].as<String>();\par
  611                 this->timeServer.fromString(ip);\par
  612                 \par
  613             \}\par
  614             else\par
  615             \{\par
  616                 this->timeServer=this->timeServer;\par
  617             \}\par
  618             json["timeServer"]=ip;\par
  619             \par
  620             if(json["localPort"].success() )\par
  621             \{                       \par
  622                 this->localPort=json["localPort"];\par
  623             \}\par
  624             else\par
  625             \{\par
  626                 this->localPort=this->localPort;\par
  627             \}\par
  628             json["localPort"]=this->localPort;\par
  629 \par
  630 \par
  631             if( json["timeSync"].success() )\par
  632             \{\par
  633                 json["timeSync"]=this->timeSync;\par
  634             \}\par
  635             else\par
  636             \{\par
  637                 this->timeSync=this->timeSync;\par
  638             \}\par
  639             json["timeSync"]=this->timeSync;\par
  640 \par
  641 \par
  642             rtcConfig.close();\par
  643             rtcConfig= SPIFFS.open("/rtcConfig.json", "w");\par
  644             \par
  645             if(!rtcConfig)\par
  646             \{\par
  647             #if DEBUG == 1\par
  648 \par
  649                 Serial.println( F("failed to write timeSync to /rtcConfig.json") );\par
  650                 Serial.println();\par
  651             \par
  652             #endif\par
  653 \par
  654                 return(false);\par
  655             \}\par
  656             \par
  657             json.printTo(rtcConfig);\par
  658             rtcConfig.close();\par
  659     \par
  660         #if DEBUG == 1\par
  661 \par
  662             Serial.println( F("configuration is :") );\par
  663             json.printTo(Serial);\par
  664             Serial.println();\par
  665         \par
  666         #endif\par
  667             return(true); \par
  668         \}\par
  669     \}   \par
  670 \par
  671 \par
  672 \par
  673 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ae9658c9b377510d469e3b88edf33ee85_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sendNTPpacket\:CoolTime}
{\xe \v CoolTime\:sendNTPpacket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::sendNTPpacket (IPAddress &  {\i address})}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::sendNTPpacket( Time Server IP address): This method is provided to send an NTP request to the time server at the given address \par
}{
Definition at line 370 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   371 \{\par
  372 \par
  373 #if DEBUG == 1 \par
  374 \par
  375     Serial.println( F("Enter CoolTime.sendNTPpacket()") );\par
  376     Serial.println();\par
  377 \par
  378 #endif\par
  379 \par
  380     memset(packetBuffer, 0, NTP_PACKET_SIZE);\par
  381     // Initialize values needed to form NTP request\par
  382     // (see URL above for details on the packets)\par
  383     packetBuffer[0] = 0b11100011;   // LI, Version, Mode\par
  384     packetBuffer[1] = 0;     // Stratum, or type of clock\par
  385     packetBuffer[2] = 6;     // Polling Interval\par
  386     packetBuffer[3] = 0xEC;  // Peer Clock Precision\par
  387     // 8 bytes of zero for Root Delay & Root Dispersion\par
  388     packetBuffer[12]  = 49;\par
  389     packetBuffer[13]  = 0x4E;\par
  390     packetBuffer[14]  = 49;\par
  391     packetBuffer[15]  = 52;\par
  392     // all NTP fields have been given values, now\par
  393     // you can send a packet requesting a timestamp:                 \par
  394     Udp.beginPacket(address, 123); //NTP requests are to port 123\par
  395     Udp.write(packetBuffer, NTP_PACKET_SIZE);\par
  396     Udp.endPacket();    \par
  397 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a236a38d120dc53bc67456d763838c5a1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setDateTime\:CoolTime}
{\xe \v CoolTime\:setDateTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::setDateTime (int  {\i year}, int  {\i month}, int  {\i day}, int  {\i hour}, int  {\i minutes}, int  {\i seconds})}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::setDateTime(year,month,dat,hour,minutes,seconds): This method is provided to manually set the RTc Time \par
}{
Definition at line 109 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   110 \{ \par
  111 \par
  112 #if DEBUG == 1\par
  113 \par
  114     Serial.println( F("Entering CoolTime.setDateTime") );\par
  115     Serial.println();\par
  116 \par
  117 #endif\par
  118 \par
  119     tmElements_t tm;\par
  120     tm.Second=seconds; \par
  121     tm.Minute=minutes; \par
  122     tm.Hour=hour; \par
  123     tm.Day=day;\par
  124     tm.Month=month; \par
  125     tm.Year=year;\par
  126     \par
  127     this->rtc.set(makeTime(tm),CLOCK_ADDRESS);   \par
  128 \par
  129 #if DEBUG == 1\par
  130 \par
  131     Serial.print( F("setting time to : ") );//"20yy-mm-ddT00:00:00Z\par
  132 \par
  133     Serial.print(tm.Year);\par
  134     Serial.print( F("-") );\par
  135     Serial.print( this->formatDigits( tm.Month ) );\par
  136     Serial.print( F("-") );\par
  137     Serial.print( this->formatDigits( tm.Day ) );\par
  138     Serial.print( F("T") );\par
  139     Serial.print( this->formatDigits( tm.Hour ) );\par
  140     Serial.print( F(":") );\par
  141     Serial.print( this->formatDigits( tm.Minute ) );\par
  142     Serial.print( F(":") );\par
  143     Serial.print( this->formatDigits( tm.Second ) );\par
  144     Serial.print( F("Z") );\par
  145 \par
  146     Serial.println();\par
  147     \par
  148     Serial.print( F("time set to : ") );\par
  149     Serial.println(this->getESDate());\par
  150     Serial.println();\par
  151 \par
  152 #endif\par
  153 \par
  154 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ab81ea7fdaace111aa01cc1ec84c6d297_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v update\:CoolTime}
{\xe \v CoolTime\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::update ()}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::update()}: This method is provided to correct the rtc Time when it drifts,once every week. \par
}{
Definition at line 76 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    77 \{\par
   78 \par
   79 #if DEBUG == 1\par
   80 \par
   81     Serial.println( F("Entering CoolTime.update()") );\par
   82     Serial.println();\par
   83 \par
   84 #endif \par
   85 \par
   86     if( !( this->isTimeSync() ) )\par
   87     \{\par
   88     \par
   89     #if DEBUG == 1\par
   90 \par
   91         Serial.println( F("waiting for sync") );\par
   92         Serial.println();\par
   93 \par
   94     #endif \par
   95 \par
   96         this->timeSync=this->getNtpTime();\par
   97         breakTime(this->getNtpTime(), this->tmSet);\par
   98         this->rtc.set(makeTime(this->tmSet), CLOCK_ADDRESS); // set the clock\par
   99         this->saveTimeSync();\par
  100     \}\par
  101     \par
  102 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_aae601f795452cfa48d9fb337aed483a8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_aae601f795452cfa48d9fb337aed483a8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v localPort\:CoolTime}
{\xe \v CoolTime\:localPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CoolTime::localPort =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
port number for UDP packets \par
}{
Definition at line 107 of file CoolTime.h.}\par
}
{\xe \v packetBuffer\:CoolTime}
{\xe \v CoolTime\:packetBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte CoolTime::packetBuffer[{\b NTP_PACKET_SIZE}]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UDP buffer to hold incoming & outgoing packets \par
}{
Definition at line 113 of file CoolTime.h.}\par
}
{\xe \v rtc\:CoolTime}
{\xe \v CoolTime\:rtc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DS1337RTC CoolTime::rtc{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
RTC instance \par
}{
Definition at line 123 of file CoolTime.h.}\par
}
{\xe \v timeServer\:CoolTime}
{\xe \v CoolTime\:timeServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress CoolTime::timeServer{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NTP Server IP Address \par
}{
Definition at line 97 of file CoolTime.h.}\par
}
{\xe \v timeSync\:CoolTime}
{\xe \v CoolTime\:timeSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolTime::timeSync =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
last Time the RTC syncronised with the NTP server unix Time \par
}{
Definition at line 92 of file CoolTime.h.}\par
}
{\xe \v tmSet\:CoolTime}
{\xe \v CoolTime\:tmSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tmElements_t CoolTime::tmSet{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time Elements Instance to hold various Time Values \par
}{
Definition at line 118 of file CoolTime.h.}\par
}
{\xe \v Udp\:CoolTime}
{\xe \v CoolTime\:Udp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiUDP CoolTime::Udp{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UDP Client instance \par
}{
Definition at line 102 of file CoolTime.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolWifi Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolWifi}
{\xe \v CoolWifi}
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection . }}\par
{
{\f2 #include <CoolWifi.h>}}\par
Collaboration diagram for CoolWifi:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dff/class_cool_wifi__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} (String {\b ssid}[], String {\b pass}[], int wifiNumber, int APTimeOut, bool {\b nomad})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b connect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b connectWifiMulti} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b connectAP} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b state} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addWifi} (String {\b ssid}, String {\b pass}="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ESP8266WiFiMulti {\b wifiMulti}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wifiCount} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b ssid} [50] =\{"0"\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b pass} [50] =\{"0"\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b timeOut} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b nomad} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection . \par
}{
Definition at line 52 of file CoolWifi.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addWifi\:CoolWifi}
{\xe \v CoolWifi\:addWifi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::addWifi (String  {\i ssid}, String  {\i pass} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolWifi::addWifi(ssid,pass) This method is provided to add new WiFi detected by the {\b WiFiManager} to the jsonConfig(if used )\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successfull , false otherwise \par
}}{
Definition at line 570 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   571 \{\par
  572 \par
  573 #if DEBUG == 1\par
  574     \par
  575     Serial.println("Entering CoolWifi.addWifi() ") ;\par
  576 \par
  577 #endif  \par
  578     \par
  579     this->wifiCount++;\par
  580     if( this->wifiCount >=50)\par
  581     \{\par
  582     \par
  583     #if DEBUG == 1\par
  584 \par
  585         Serial.println("You have reached the limit of 50");\par
  586         return(false);  \par
  587     \par
  588     #endif\par
  589 \par
  590     \}\par
  591 \par
  592     this->ssid[this->wifiCount-1]=ssid;\par
  593     this->pass[this->wifiCount-1]=pass;\par
  594     \par
  595     //read config file\par
  596     //update data\par
  597     File configFile = SPIFFS.open("/wifiConfig.json", "r");\par
  598 \par
  599     if (!configFile) \par
  600     \{\par
  601     \par
  602     #if DEBUG == 1 \par
  603 \par
  604         Serial.println( F("failed to read /wifiConfig.json") );\par
  605         Serial.println();\par
  606 \par
  607     #endif\par
  608     \}\par
  609     else\par
  610     \{\par
  611         size_t size = configFile.size();\par
  612         // Allocate a buffer to store contents of the file.\par
  613         std::unique_ptr<char[]> buf(new char[size]);\par
  614 \par
  615         configFile.readBytes(buf.get(), size);\par
  616         DynamicJsonBuffer jsonBuffer;\par
  617         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  618         if (!json.success()) \par
  619         \{\par
  620         \par
  621         #if DEBUG == 1 \par
  622 \par
  623             Serial.println( F("failed to parse json ") );\par
  624             Serial.println();\par
  625         \par
  626         #endif\par
  627         \} \par
  628         else\par
  629         \{\par
  630         \par
  631         #if DEBUG == 1 \par
  632         \par
  633             Serial.println( F("configuration json is ") );\par
  634             json.printTo(Serial);\par
  635             Serial.println();\par
  636 \par
  637             Serial.print(F("jsonBuffer size: "));\par
  638             Serial.println(jsonBuffer.size());\par
  639             Serial.println();\par
  640 \par
  641 \par
  642         #endif\par
  643             //wifiCount\par
  644             if(json["wifiCount"].success() )\par
  645             \{           \par
  646                 json["wifiCount"]=this->wifiCount;\par
  647             \}\par
  648             else\par
  649             \{\par
  650                 this->wifiCount=this->wifiCount;\par
  651             \}\par
  652             json["wifiCount"]=this->wifiCount;\par
  653 \par
  654             \par
  655             //AP timeOut\par
  656             if(json["timeOut"].success() )\par
  657             \{\par
  658                 this->timeOut=json["timeOut"];\par
  659             \}\par
  660             else\par
  661             \{\par
  662                 this->timeOut=this->timeOut;\par
  663 \par
  664             \}\par
  665             json["timeOut"]=this->timeOut;\par
  666             \par
  667             \par
  668             //new Wifi SSID and PASS\par
  669             JsonObject& newWifi = json.createNestedObject( "Wifi"+String( this->wifiCount-1 ) );\par
  670             \par
  671             newWifi["ssid"] =this->ssid[this->wifiCount-1];\par
  672             newWifi["pass"] = this->pass[this->wifiCount-1];\par
  673             \par
  674 \par
  675             configFile.close();\par
  676             configFile = SPIFFS.open("/wifiConfig.json", "w");\par
  677             if(!configFile)\par
  678             \{\par
  679             \par
  680             #if DEBUG == 1 \par
  681 \par
  682                 Serial.println( F("failed to write to /wifiConfig.json") );\par
  683             \par
  684             #endif\par
  685 \par
  686             \}\par
  687             \par
  688             json.printTo(configFile);\par
  689             configFile.close();\par
  690 \par
  691         #if DEBUG == 1 \par
  692 \par
  693             Serial.println( F("saved configuration is :") );\par
  694             json.printTo(Serial);\par
  695             Serial.println();\par
  696         \par
  697         #endif\par
  698 \par
  699             return(true); \par
  700         \}\par
  701     \}   \par
  702 \par
  703     \par
  704     return(true);\par
  705     \par
  706 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a914d7a1df14dd6b75345fb614c34e9d6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v begin\:CoolWifi}
{\xe \v CoolWifi\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolWifi::begin ()}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::begin()}: This method is provided to set the wifiMulti Access points and the wifiManager time out \par
}{
Definition at line 51 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52 \{ \par
   53 \par
   54 #if DEBUG == 1 \par
   55 \par
   56     Serial.println( F("Entering CoolWifi.begin()") );\par
   57     Serial.println();\par
   58 \par
   59 #endif\par
   60     for(int i =0;i<this->wifiCount;i++)\par
   61     \{\par
   62          this->wifiMulti.addAP(this->ssid[i].c_str() , this->pass[i].c_str() ); \par
   63     \}\par
   64     \par
   65 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a46942fed90e475112cc10b78a32e7aaa_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolWifi}
{\xe \v CoolWifi\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::config ()}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::config()}: This method is provided to set the wifi parameters : -ssid -pass -AP timeOut -wifiCount\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 297 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   298 \{\par
  299 \par
  300 #if DEBUG == 1 \par
  301 \par
  302     Serial.println( F("Entering CoolWifi.config()") );\par
  303     Serial.println();\par
  304 \par
  305 #endif\par
  306 #if DEBUG == 0\par
  307 \par
  308     Serial.println( "Reading Wifi Configuration..");\par
  309     delay(100);\par
  310 #endif \par
  311 \par
  312     //read config file\par
  313     //update data\par
  314     File configFile = SPIFFS.open("/wifiConfig.json", "r");\par
  315 \par
  316     if (!configFile) \par
  317     \{\par
  318     \par
  319         Serial.println( F("failed to read /wifiConfig.json") );\par
  320         Serial.println();\par
  321 \par
  322         return(false);\par
  323     \}\par
  324     else\par
  325     \{\par
  326         size_t size = configFile.size();\par
  327         // Allocate a buffer to store contents of the file.\par
  328         std::unique_ptr<char[]> buf(new char[size]);\par
  329 \par
  330         configFile.readBytes(buf.get(), size);\par
  331         DynamicJsonBuffer jsonBuffer;\par
  332         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  333         if (!json.success()) \par
  334         \{\par
  335 \par
  336             Serial.println( F("failed to parse json ") );\par
  337             Serial.println();\par
  338 \par
  339             return(false);\par
  340         \} \par
  341         else\par
  342         \{\par
  343         \par
  344         #if DEBUG == 1 \par
  345         \par
  346             Serial.println( F("configuration json is ") );\par
  347             json.printTo(Serial);\par
  348             Serial.println();\par
  349 \par
  350             Serial.print(F("jsonBuffer size: "));\par
  351             Serial.println(jsonBuffer.size());\par
  352             Serial.println();\par
  353 \par
  354 \par
  355         #endif\par
  356             //wifiCount\par
  357             if(json["wifiCount"].success() )\par
  358             \{           \par
  359                 this->wifiCount=json["wifiCount"];\par
  360             \}\par
  361             else\par
  362             \{\par
  363                 this->wifiCount=this->wifiCount;\par
  364             \}\par
  365             json["wifiCount"]=this->wifiCount;\par
  366 \par
  367             \par
  368             //AP timeOut\par
  369             if(json["timeOut"].success() )\par
  370             \{\par
  371                 this->timeOut=json["timeOut"];\par
  372             \}\par
  373             else\par
  374             \{\par
  375                 this->timeOut=this->timeOut;\par
  376 \par
  377             \}\par
  378             json["timeOut"]=this->timeOut;\par
  379 \par
  380             //nomad\par
  381             if(json["nomad"].success() )\par
  382             \{\par
  383                 this->nomad=json["nomad"];\par
  384             \}\par
  385             else\par
  386             \{\par
  387                 this->nomad=this->nomad;\par
  388 \par
  389             \}\par
  390             json["nomad"]=this->nomad;\par
  391 \par
  392             \par
  393             \par
  394             //Wifis SSID and PASS\par
  395             for(int i =0; i<this->wifiCount ;i++)\par
  396             \{\par
  397                 if ( json["Wifi"+String(i)].success() )\par
  398                 \{\par
  399                     \par
  400                     if( json["Wifi"+String(i)]["ssid"].success() )\par
  401                     \{\par
  402                         const char* tempSsid=json["Wifi"+String(i)]["ssid"]; \par
  403                         this->ssid[i]=tempSsid;                 \par
  404                     \}\par
  405                     else\par
  406                     \{\par
  407                         this->ssid[i]=this->ssid[i];                    \par
  408                     \}\par
  409                     json["Wifi"+String(i)]["ssid"]=this->ssid[i].c_str();\par
  410                     \par
  411                     \par
  412                     if( json["Wifi"+String(i)]["pass"].success() )\par
  413                     \{\par
  414                         const char* tempPass =json["Wifi"+String(i)]["pass"];\par
  415                         this->pass[i]=tempPass ;                    \par
  416                     \}\par
  417                     else\par
  418                     \{\par
  419                         this->pass[i]=this->pass[i];                    \par
  420                     \}\par
  421                     json["Wifi"+String(i)]["pass"]=this->pass[i].c_str();           \par
  422                 \par
  423                 \}\par
  424                 else\par
  425                 \{\par
  426                     \par
  427                     this->ssid[i]=this->ssid[i];\par
  428                     this->pass[i]=this->pass[i];                    \par
  429                     \par
  430                 \}\par
  431                 json["Wifi"+String(i)]["ssid"]=this->ssid[i].c_str();\par
  432                 json["Wifi"+String(i)]["pass"]=this->pass[i].c_str();           \par
  433                         \par
  434             \}\par
  435 \par
  436             configFile.close();\par
  437             configFile = SPIFFS.open("/wifiConfig.json", "w");\par
  438             if(!configFile)\par
  439             \{\par
  440             \par
  441                 Serial.println( F("failed to write to /wifiConfig.json") );\par
  442             \par
  443                 return(false);              \par
  444             \}\par
  445             \par
  446             json.printTo(configFile);\par
  447             configFile.close();\par
  448 \par
  449         #if DEBUG == 1 \par
  450 \par
  451             Serial.println( F("saved configuration is :") );\par
  452             json.printTo(Serial);\par
  453             Serial.println();\par
  454         \par
  455         #endif\par
  456         #if DEBUG == 0\par
  457             Serial.println( F("Configuration loaded : OK"));\par
  458         #endif\par
  459             return(true); \par
  460         \}\par
  461     \}   \par
  462     \par
  463 \par
  464 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a4eb2f6b9b09dd588964b88b6c70122c0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolWifi}
{\xe \v CoolWifi\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::config (String  {\i ssid}[], String  {\i pass}[], int  {\i wifiNumber}, int  {\i APTimeOut}, bool  {\i nomad})}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolWifi::config(ssid array, pass array, number of wifis, AP timeout,nomad flag ); This method is provided to configure the Wifi without SPIFFS\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successfull, false otherwise \par
}}{
Definition at line 472 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   473 \{\par
  474 \par
  475 #if DEBUG == 1 \par
  476     \par
  477     Serial.println("Entering CoolWifi.config(), no SPIFFS variant ") ;\par
  478     \par
  479 #endif\par
  480     \par
  481     if(wifiNumber>50)\par
  482     \{\par
  483     \par
  484     #if DEBUG == 1 \par
  485         \par
  486         Serial.println("the limit of WiFis is 50 " );\par
  487         \par
  488     #endif\par
  489         return(false);  \par
  490     \}\par
  491 \par
  492     this->wifiCount=wifiNumber;\par
  493 \par
  494     this->timeOut=APTimeOut;\par
  495 \par
  496     this->nomad=nomad;\par
  497     \par
  498     for(int i=0;i<wifiNumber;i++)\par
  499     \{\par
  500         this->ssid[i]=ssid[i];\par
  501         \par
  502         this->pass[i]=pass[i];\par
  503     \}\par
  504         \par
  505     return(true);\par
  506 \par
  507 \}\par
}
}
{\xe \v connect\:CoolWifi}
{\xe \v CoolWifi\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::connect ()}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::connect( )}: This method is provided to connect to the strongest WiFi in the provided list of wiFis. If none are found , it starts the AP mode.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi state \par
}}{
Definition at line 104 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   105 \{       \par
  106 \par
  107 \par
  108 \par
  109 #if DEBUG == 1 \par
  110 \par
  111     Serial.println( F("Entering CoolWifi.connect()") );\par
  112 \par
  113 #endif\par
  114 \par
  115     Serial.println( F("Wifi connecting...") );\par
  116 \par
  117 \par
  118     //if WifiCount > 0 , lunch wifiMulti\par
  119     //else no need to , skip this part\par
  120     // to wifiManager  \par
  121     if(this->wifiCount !=0)\par
  122     \{\par
  123     \par
  124         this->connectWifiMulti();\par
  125         \par
  126         //if nomad is true, only check wifi list\par
  127         if(this->nomad == true)\par
  128         \{\par
  129     \par
  130         #if DEBUG == 1\par
  131     \par
  132             Serial.print(F("nomad mode :"));\par
  133             Serial.println(this->nomad);\par
  134         \par
  135             Serial.print(F("Wifi status: "));\par
  136             Serial.println(WiFi.status());\par
  137         \par
  138         #endif  \par
  139             return(WiFi.status());  \par
  140         \}\par
  141 \par
  142     \}\par
  143 \par
  144 \par
  145     //Wifi Manager\par
  146     if( WiFi.status() != WL_CONNECTED ) \par
  147     \{\par
  148 \par
  149     #if DEBUG == 1 \par
  150     \par
  151         Serial.println(F("No matching wifi Found ") );\par
  152         Serial.println( F("Starting Access Point ") );  \par
  153         Serial.println();\par
  154 \par
  155     #endif\par
  156         \par
  157         this->connectAP();      \par
  158         \par
  159     \}\par
  160     else\par
  161     \{\par
  162 \par
  163         Serial.println(F("connected to "));\par
  164         Serial.println( WiFi.SSID() );\par
  165         Serial.println();\par
  166     \par
  167     \}\par
  168     \par
  169     return( WiFi.status() ) ;\par
  170 \par
  171 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_ad060353050f40d032a2dbf9e54a768bf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_ad060353050f40d032a2dbf9e54a768bf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectAP\:CoolWifi}
{\xe \v CoolWifi\:connectAP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::connectAP ()}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::connectAP()} This function is provided to run the WifiManager part of the Wifi connection process\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi state \par
}}{
Definition at line 231 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   232 \{\par
  233 \par
  234 #if DEBUG == 1 \par
  235     \par
  236     Serial.println( F("Entering CoolWifi.connectAP()") );   \par
  237     Serial.println();\par
  238 \par
  239 #endif\par
  240     WiFiManager wifiManager;\par
  241     \par
  242     wifiManager.setRemoveDuplicateAPs(true);\par
  243 \par
  244     wifiManager.setTimeout(this->timeOut);\par
  245     \par
  246     String tempMAC = WiFi.macAddress();\par
  247     tempMAC.replace(":","");\par
  248 \par
  249     String name="CoolBoard-"+tempMAC;   \par
  250 \par
  251     if(!wifiManager.autoConnect(name.c_str())) \par
  252     \{\par
  253 \par
  254         Serial.println( F("failed to connect and hit timeout") );\par
  255 \par
  256         delay(30);\par
  257 \par
  258     \} \par
  259 \par
  260     //if you get here you have connected to the WiFi\par
  261 \par
  262     if(WiFi.status()==WL_CONNECTED)\par
  263     \{\par
  264 \par
  265     #if DEBUG == 1\par
  266 \par
  267         Serial.println( F("connected...yeey :)" ));\par
  268         Serial.println("connected to ");\par
  269         Serial.println( WiFi.SSID() );\par
  270         //Serial.println( WiFi.psk() ) ;\par
  271         \par
  272     #endif\par
  273 \par
  274         this->addWifi( WiFi.SSID() , WiFi.psk() );\par
  275         \par
  276     \}\par
  277     else\par
  278     \{\par
  279         Serial.println( F("Not connected...:(" ));\par
  280     \}\par
  281     \par
  282     return(WiFi.status());\par
  283 \par
  284 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a7c857f27161782f5ef1d62d552aff971_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a7c857f27161782f5ef1d62d552aff971_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectWifiMulti\:CoolWifi}
{\xe \v CoolWifi\:connectWifiMulti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::connectWifiMulti ()}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::connectWifiMulti()} This function is provided to run the WifiMulti part of the Wifi connection process\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi state \par
}}{
Definition at line 181 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182 \{\par
  183     int i=0;\par
  184 \par
  185 #if DEBUG == 1 \par
  186 \par
  187     Serial.println(F("Entering CoolWifi.connectWifiMulti()"));\par
  188     Serial.println();\par
  189     \par
  190     Serial.println( F("entry time to multi : ") );\par
  191     Serial.println(millis() ) ;\par
  192 \par
  193 #endif\par
  194     \par
  195     //Wifi MULTI\par
  196     while( (this->wifiMulti.run() != WL_CONNECTED) && (i<500)  ) \par
  197     \{\par
  198 \par
  199     #if DEBUG == 1\par
  200 \par
  201         Serial.print(F("."));\par
  202         \par
  203     #endif\par
  204         i++;\par
  205         delay(5);\par
  206         \}   \par
  207 \par
  208 #if DEBUG == 1 \par
  209 \par
  210     Serial.println();   \par
  211     Serial.println(F("exit point from multi : "));\par
  212     Serial.println(millis() );\par
  213     \par
  214     Serial.print(F("Wifi Status :"));\par
  215     Serial.println(WiFi.status());\par
  216 #endif\par
  217 \par
  218     return(WiFi.status());\par
  219 \par
  220 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a419de92d738f14b7444cf822b3ab0070_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolWifi}
{\xe \v CoolWifi\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolWifi::printConf ()}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 515 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   516 \{\par
  517 \par
  518 #if DEBUG == 1 \par
  519 \par
  520     Serial.println( F("Entering CoolWifi.printConf()") );\par
  521     Serial.println();   \par
  522 \par
  523 #endif\par
  524     \par
  525     Serial.println(F("Wifi configuration "));\par
  526 \par
  527     \par
  528     Serial.println(F("wifiCount : "));\par
  529     Serial.println(this->wifiCount);\par
  530     \par
  531     for(int i=0;i<this->wifiCount;i++)\par
  532     \{   \par
  533         Serial.print(F("SSID"));\par
  534         Serial.print(i);\par
  535         Serial.println(F(" : "));\par
  536         Serial.println(this->ssid[i]);\par
  537                 \par
  538 \par
  539         //Serial.print("PASS");\par
  540         //Serial.print(i);\par
  541         //Serial.println(" : ");\par
  542 \par
  543         //Serial.print(F("PASS"));\par
  544         //Serial.print(i);\par
  545         //Serial.println(F(" : "));\par
  546 \par
  547         //Serial.println(this->pass[i]);\par
  548         \par
  549     \}\par
  550     \par
  551     Serial.println(F("timeOut : "));\par
  552     Serial.println(this->timeOut);\par
  553 \par
  554     Serial.println(F("nomad : "));\par
  555     Serial.println(this->nomad);\par
  556 \par
  557     Serial.println();\par
  558 \par
  559 \par
  560 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a9e6105c6d13d35ec510f6633da9e0223_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v state\:CoolWifi}
{\xe \v CoolWifi\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::state ()}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::state()}: This method is provided to return the Wifi client's state. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi client state: WL_NO_SHIELD = 255, WL_IDLE_STATUS = 0, WL_NO_SSID_AVAIL = 1, WL_SCAN_COMPLETED = 2, WL_CONNECTED = 3, WL_CONNECT_FAILED = 4, WL_CONNECTION_LOST = 5, WL_DISCONNECTED = 6 \par
}}{
Definition at line 81 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82 \{\par
   83 \par
   84 #if DEBUG == 1 \par
   85 \par
   86     Serial.println( F("Entering CoolWifi.state()") );\par
   87     Serial.println();   \par
   88     Serial.print( F("state : ") );\par
   89     Serial.println( WiFi.status() );\par
   90 \par
   91 #endif\par
   92     \par
   93     return( WiFi.status() ) ;\par
   94 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a1c7b4d82a4098d346e7593dce92039fa_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v nomad\:CoolWifi}
{\xe \v CoolWifi\:nomad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::nomad =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
nomad Mode Flag in Nomad Mode , the Wifi Access Point will Only Lunch on Start when there's NO saved wifis ( wifiCount = 0) After that, the Wifi will ONLY try to connect to known Wifis via WifiMulti \par
}{
Definition at line 108 of file CoolWifi.h.}\par
}
{\xe \v pass\:CoolWifi}
{\xe \v CoolWifi\:pass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolWifi::pass[50] =\{"0"\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WiFi PASS Array \par
}{
Definition at line 94 of file CoolWifi.h.}\par
}
{\xe \v ssid\:CoolWifi}
{\xe \v CoolWifi\:ssid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolWifi::ssid[50] =\{"0"\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WiFi SSID Array \par
}{
Definition at line 89 of file CoolWifi.h.}\par
}
{\xe \v timeOut\:CoolWifi}
{\xe \v CoolWifi\:timeOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolWifi::timeOut =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WiFi Access Point TimeOut Value in Seconds \par
}{
Definition at line 99 of file CoolWifi.h.}\par
}
{\xe \v wifiCount\:CoolWifi}
{\xe \v CoolWifi\:wifiCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolWifi::wifiCount =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
number of saved WiFi's \par
}{
Definition at line 84 of file CoolWifi.h.}\par
}
{\xe \v wifiMulti\:CoolWifi}
{\xe \v CoolWifi\:wifiMulti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ESP8266WiFiMulti CoolWifi::wifiMulti{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESP8266WiFiMulti instance \par
}{
Definition at line 79 of file CoolWifi.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensor< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensor< T >}
{\xe \v ExternalSensor< T >}
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor}. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for ExternalSensor< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d93/class_external_sensor__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for ExternalSensor< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d2f/class_external_sensor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b sensor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>\par
class ExternalSensor< T >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the generic Template for an external sensor This class works automatically with sensors that provide the following methods :{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constructor(void);\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t/bool {\b begin(void)};\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b read(void)};\par}
If your sensor doesn't provide these methods or is not present in the specialized templates feel free to implement your own specializiation, following the provided generic template , or contact us and we will be glad to expand our list of supported external sensors \par
}{
Definition at line 137 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExternalSensor\:ExternalSensor}
{\xe \v ExternalSensor\:ExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b ExternalSensor}< T >::{\b ExternalSensor} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic Constructor \par
}{
Definition at line 143 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144     \{\par
  145     \par
  146     #if DEBUGExternal == 1 \par
  147 \par
  148         Serial.println( "ExternalSensor <Generic> Constructor" );\par
  149         Serial.println();\par
  150     \par
  151     #endif\par
  152 \par
  153         sensor();\par
  154     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensor}
{\xe \v ExternalSensor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > virtual uint8_t {\b ExternalSensor}< T >::begin (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic begin method \par
}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 161 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162     \{\par
  163     \par
  164     #if DEBUGExternal == 1 \par
  165 \par
  166         Serial.println( "ExternalSensor <Generic> begin()" );\par
  167         Serial.println();\par
  168     \par
  169     #endif\par
  170 \par
  171         return(sensor.begin() );    \par
  172     \}\par
}
}
{\xe \v read\:ExternalSensor}
{\xe \v ExternalSensor\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > virtual float {\b ExternalSensor}< T >::read (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic read method \par
}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 177 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   178     \{\par
  179     \par
  180     #if DEBUGExternal == 1 \par
  181 \par
  182         Serial.println( "ExternalSensor <Generic> read() " );\par
  183         Serial.println();\par
  184         \par
  185     #endif\par
  186 \par
  187         return(sensor.read());\par
  188     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sensor\:ExternalSensor}
{\xe \v ExternalSensor\:sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > T {\b ExternalSensor}< T >::sensor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 194 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensor< DallasTemperature > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >}
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for ExternalSensor< DallasTemperature >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d74/class_external_sensor_3_01_dallas_temperature_01_4__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for ExternalSensor< DallasTemperature >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d86/class_external_sensor_3_01_dallas_temperature_01_4__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensor} (OneWire *{\b oneWire})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DallasTemperature {\b sensor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DeviceAddress {\b dallasAddress}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<>\par
class ExternalSensor< DallasTemperature >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor. \par
}{
Definition at line 330 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExternalSensor\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:ExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExternalSensor}< DallasTemperature >::{\b ExternalSensor} (OneWire *  {\i oneWire}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor()}: DallasTemperature specific constructor \par
}{
Definition at line 337 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   338     \{\par
  339         \par
  340     #if DEBUGExternal == 1 \par
  341 \par
  342         Serial.println( "ExternalSensor <DallasTemperature> constructor" );\par
  343         Serial.println();\par
  344     \par
  345     #endif\par
  346         sensor=DallasTemperature(oneWire);\par
  347     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t {\b ExternalSensor}< DallasTemperature >::begin (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b begin()}: DallasTemperature specific begin method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 355 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   356     \{\par
  357     \par
  358     #if DEBUGExternal == 1 \par
  359 \par
  360         Serial.println( "ExternalSensor <DallasTemperature> begin()" );\par
  361         Serial.println();\par
  362     \par
  363     #endif\par
  364 \par
  365         sensor.begin(); \par
  366         delay(5);\par
  367         sensor.getAddress(this->dallasAddress, 0);  \par
  368         return(true);\par
  369     \}\par
}
}
{\xe \v read\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float {\b ExternalSensor}< DallasTemperature >::read (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b read()}: DallasTemperature specific read method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the temperature in \'B0C \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 376 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   377     \{\par
  378 \par
  379         sensor.requestTemperatures(); // Send the command to get temperatures\par
  380         float result=(float) sensor.getTempCByIndex(0);\par
  381     #if DEBUGExternal == 1 \par
  382 \par
  383         Serial.println( "ExternalSensor <DallasTemperature> read()" );\par
  384         Serial.println();\par
  385 \par
  386         Serial.print("Requesting temperature...");\par
  387 \par
  388         Serial.print( "temperature : ");\par
  389         Serial.print( result );\par
  390         Serial.print( "\'B0C" );\par
  391         Serial.println();\par
  392     \par
  393     #endif\par
  394         \par
  395         return( result );\par
  396     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dallasAddress\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:dallasAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DeviceAddress {\b ExternalSensor}< DallasTemperature >::dallasAddress{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 402 of file ExternalSensor.h.}\par
}
{\xe \v sensor\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DallasTemperature {\b ExternalSensor}< DallasTemperature >::sensor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 401 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensor< NDIR_I2C > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >}
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for ExternalSensor< NDIR_I2C >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d1b/class_external_sensor_3_01_n_d_i_r___i2_c_01_4__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for ExternalSensor< NDIR_I2C >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d03/class_external_sensor_3_01_n_d_i_r___i2_c_01_4__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensor} (uint8_t i2c_addr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NDIR_I2C} {\b sensor} =NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<>\par
class ExternalSensor< NDIR_I2C >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor. \par
}{
Definition at line 205 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExternalSensor\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:ExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExternalSensor}< {\b NDIR_I2C} >::{\b ExternalSensor} (uint8_t  {\i i2c_addr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor(I2C address)}: {\b NDIR_I2C} specific constructor \par
}{
Definition at line 213 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   214     \{\par
  215     \par
  216     #if DEBUGExternal == 1 \par
  217 \par
  218         Serial.println( "ExternalSensor <NDIR_I2C> constructor");\par
  219         Serial.println();\par
  220     \par
  221     #endif\par
  222 \par
  223         sensor=NDIR_I2C(i2c_addr);\par
  224     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t {\b ExternalSensor}< {\b NDIR_I2C} >::begin (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b begin()}: {\b NDIR_I2C} specific begin method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful, false otherwise \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 233 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   234     \{\par
  235     \par
  236     #if DEBUGExternal == 1 \par
  237 \par
  238         Serial.println( "ExternalSensor <NDIR_I2C> begin()" );\par
  239         Serial.println();\par
  240     \par
  241     #endif \par
  242 \par
  243         if (sensor.begin()) \par
  244         \{\par
  245         \par
  246         #if DEBUGExternal == 1 \par
  247             \par
  248             Serial.println( "NDIR_I2C init : wait 10 seconds" );\par
  249             Serial.println();\par
  250         \par
  251         #endif\par
  252 \par
  253             delay(10000);\par
  254             return(true);\par
  255 \par
  256             \}\par
  257         else \par
  258         \{\par
  259         \par
  260         #if DEBUGExternal == 1 \par
  261 \par
  262             Serial.println( "NDIR_I2C init : fail " );\par
  263             Serial.println();\par
  264         \par
  265         #endif\par
  266 \par
  267             return(false);\par
  268         \}   \par
  269     \}\par
}
}
{\xe \v read\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float {\b ExternalSensor}< {\b NDIR_I2C} >::read (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b read()}: {\b NDIR_I2C} specific read method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ppm value if successful, else return -42 \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 278 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279     \{\par
  280         \par
  281     #if DEBUGExternal == 1 \par
  282         \par
  283         Serial.println( "ExternalSensor <NDIR_I2C> read()" );\par
  284         Serial.println();\par
  285 \par
  286     #endif\par
  287 \par
  288         if (sensor.measure())\par
  289         \{\par
  290         \par
  291         #if DEBUGExternal == 1 \par
  292 \par
  293             Serial.print( "NDIR_I2C ppm :" );\par
  294             Serial.println( (float) sensor.ppm);\par
  295             \par
  296             Serial.println();           \par
  297 \par
  298         #endif\par
  299 \par
  300             return( (float) sensor.ppm);\par
  301             \par
  302         \}\par
  303         \par
  304         else\par
  305         \{\par
  306         \par
  307         #if DEBUGExternal == 1 \par
  308 \par
  309             Serial.println( "NDIR_I2C read fail " );\par
  310             Serial.println();\par
  311         \par
  312         #endif\par
  313 \par
  314             return(-42);\par
  315         \}\par
  316     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sensor\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NDIR_I2C} {\b ExternalSensor}< {\b NDIR_I2C} >::sensor =NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 320 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensors Class Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensors}
{\xe \v ExternalSensors}
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions. }}\par
{
{\f2 #include <ExternalSensors.h>}}\par
Collaboration diagram for ExternalSensors:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/df9/class_external_sensors__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sensor}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} (String reference[], String type[], uint8_t address[], int {\b sensorsNumber})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExternalSensors::sensor} {\b sensors} [50]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sensorsNumber} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions. \par
}{
Definition at line 47 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensors}
{\xe \v ExternalSensors\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExternalSensors::begin (void )}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::begin()}: This method is provided to initialise the external sensors. \par
}{
Definition at line 58 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{\par
   60 \par
   61 #if DEBUG == 1\par
   62 \par
   63     Serial.println( F("Enter ExternalSensors.begin()") );\par
   64     Serial.println();\par
   65 \par
   66 #endif \par
   67 \par
   68     for(int i=0;i< this->sensorsNumber ; i++)\par
   69     \{\par
   70         if( (sensors[i].reference) == "NDIR_I2C" )\par
   71         \{   \par
   72             std::unique_ptr< ExternalSensor<NDIR_I2C> > sensorCO2(new ExternalSensor<NDIR_I2C>( this->sensors[i].address) );\par
   73 \par
   74 \par
   75             sensors[i].exSensor= sensorCO2.release();\par
   76             sensors[i].exSensor->begin();\par
   77             sensors[i].exSensor->read();\par
   78 \par
   79         \}\par
   80         if( (sensors[i].reference) == "DallasTemperature")\par
   81         \{\par
   82 \par
   83             std::unique_ptr< ExternalSensor<DallasTemperature> > dallasTemp(new ExternalSensor<DallasTemperature> (&oneWire));\par
   84              \par
   85             sensors[i].exSensor=dallasTemp.release();\par
   86             sensors[i].exSensor->begin();\par
   87             sensors[i].exSensor->read();\par
   88         \}\par
   89         \par
   90         \par
   91     \}\par
   92 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a58ede0d786a86417254708870f04a21e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a58ede0d786a86417254708870f04a21e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:ExternalSensors}
{\xe \v ExternalSensors\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExternalSensors::config ()}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::config()}: This method is provided to configure the externalSensors through a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 175 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     //read config file\par
  178     //update data\par
  179     File externalSensorsConfig = SPIFFS.open("/externalSensorsConfig.json", "r");\par
  180 \par
  181     if (!externalSensorsConfig) \par
  182     \{\par
  183     \par
  184     #if DEBUG == 1\par
  185         \par
  186         Serial.println( F("failed to read /externalSensorsConfig.json") );\par
  187         Serial.println();\par
  188     \par
  189     #endif\par
  190         \par
  191         return(false);\par
  192     \}\par
  193     else\par
  194     \{\par
  195         size_t size = externalSensorsConfig.size();\par
  196         // Allocate a buffer to store contents of the file.\par
  197         std::unique_ptr<char[]> buf(new char[size]);\par
  198 \par
  199         externalSensorsConfig.readBytes(buf.get(), size);\par
  200         DynamicJsonBuffer jsonBuffer;\par
  201         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  202 \par
  203         if (!json.success()) \par
  204         \{\par
  205         \par
  206         #if DEBUG == 1 \par
  207 \par
  208             Serial.println( F("failed to parse json") );\par
  209             Serial.println();\par
  210         \par
  211         #endif\par
  212 \par
  213             return(false);\par
  214         \} \par
  215         else\par
  216         \{\par
  217         \par
  218         #if DEBUG == 1 \par
  219     \par
  220             Serial.println( F("configuration json is : ") );\par
  221             json.printTo(Serial);\par
  222             Serial.println();\par
  223 \par
  224             Serial.print(F("jsonBuffer size: "));\par
  225             Serial.println(jsonBuffer.size());\par
  226             Serial.println();\par
  227 \par
  228         \par
  229         #endif          \par
  230             if(json["sensorsNumber"]!=NULL)\par
  231             \{\par
  232                 this->sensorsNumber = json["sensorsNumber"];\par
  233                 \par
  234                 \par
  235 \par
  236                 for(int i=0;i<sensorsNumber;i++)\par
  237                 \{   String name="sensor"+String(i);\par
  238                     \par
  239                     if(json[name].success())\par
  240                     \{  \par
  241                         JsonObject& sensorJson=json[name];\par
  242                         \par
  243                         if(sensorJson["reference"].success() )\par
  244                         \{  \par
  245                             this->sensors[i].reference =sensorJson["reference"].as<String>();\par
  246                         \}\par
  247                         else\par
  248                         \{\par
  249                             this->sensors[i].reference=this->sensors[i].reference;                          \par
  250                                     \par
  251                         \}\par
  252                         sensorJson["reference"]=this->sensors[i].reference;\par
  253 \par
  254                     \par
  255                         if(sensorJson["type"].success() )\par
  256                         \{                   \par
  257                             this->sensors[i].type=sensorJson["type"].as<String>();\par
  258                         \}\par
  259                         else\par
  260                         \{\par
  261                             this->sensors[i].type=this->sensors[i].type;\par
  262 \par
  263                         \}\par
  264                         sensorJson["type"]=this->sensors[i].type;\par
  265                     \par
  266                         if(sensorJson["address"].success() )\par
  267                         \{                   \par
  268                             this->sensors[i].address=sensorJson["address"];\par
  269                         \}\par
  270                         else\par
  271                         \{   \par
  272                             this->sensors[i].address=this->sensors[i].address;\par
  273 \par
  274                         \}\par
  275                         sensorJson["address"]=this->sensors[i].address;\par
  276                     \par
  277     \par
  278                     \}\par
  279                     else\par
  280                     \{\par
  281                         this->sensors[i]=this->sensors[i];                  \par
  282                     \}\par
  283                                             \par
  284                     json[name]["reference"]=this->sensors[i].reference;\par
  285                     json[name]["type"]=this->sensors[i].type;\par
  286                     json[name]["address"]=this->sensors[i].address;\par
  287                 \}\par
  288  \par
  289             \}\par
  290             else\par
  291             \{\par
  292                 this->sensorsNumber=this->sensorsNumber;\par
  293             \}\par
  294             json["sensorsNumber"]=this->sensorsNumber;\par
  295 \par
  296             externalSensorsConfig.close();\par
  297             externalSensorsConfig = SPIFFS.open("/externalSensorsConfig.json", "w");\par
  298 \par
  299             if(!externalSensorsConfig)\par
  300             \{\par
  301             \par
  302             #if DEBUG == 1 \par
  303 \par
  304                 Serial.println( F("failed to write to /externalSensorsConfig.json") );\par
  305                 Serial.println();\par
  306             \par
  307             #endif\par
  308 \par
  309                 return(false);\par
  310             \}\par
  311             \par
  312             json.printTo(externalSensorsConfig);\par
  313             externalSensorsConfig.close();\par
  314             \par
  315         #if DEBUG == 1 \par
  316 \par
  317             Serial.println( F("saved configuration is : ") );\par
  318             json.printTo(Serial);\par
  319             Serial.println();\par
  320         \par
  321         #endif\par
  322 \par
  323             return(true); \par
  324         \}\par
  325     \}   \par
  326     \par
  327 \par
  328 \par
  329 \par
  330 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a862a4bd11346b37270d0244c2adabe5a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:ExternalSensors}
{\xe \v ExternalSensors\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExternalSensors::config (String  {\i reference}[], String  {\i type}[], uint8_t  {\i address}[], int  {\i sensorsNumber})}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::config(String reference[],String type[],uint8_t address[],int sensorsNumber)}: This method is provided to configure the externalSensors without a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 340 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   341 \{\par
  342 \par
  343 #if DEBUG == 1\par
  344 \par
  345     Serial.println( F("Entering ExternalSensors.conf(reference[], type[], address[], sensorsNumber)") );\par
  346     Serial.println();\par
  347 \par
  348 #endif  \par
  349     if(sensorsNumber>50)\par
  350     \{\par
  351     \par
  352     #if DEBUG == 1\par
  353     \par
  354         Serial.println(F("you can't add more than 50 sensors"));    \par
  355     \par
  356     #endif  \par
  357     \par
  358         return(false);\par
  359     \}\par
  360 \par
  361     this->sensorsNumber=sensorsNumber;\par
  362     \par
  363     for(int i=0;i<sensorsNumber;i++)\par
  364     \{\par
  365     \par
  366         this->sensors[i].reference=reference[i];\par
  367         \par
  368         this->sensors[i].type=type[i];\par
  369 \par
  370         this->sensors[i].address=address[i];\par
  371     \par
  372     \}\par
  373     \par
  374     return(true);\par
  375 \par
  376 \}\par
}
}
{\xe \v printConf\:ExternalSensors}
{\xe \v ExternalSensors\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExternalSensors::printConf ()}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 383 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   384 \{\par
  385 \par
  386 #if DEBUG == 1\par
  387 \par
  388     Serial.println( F("Entering ExternalSensors.printConf()") );\par
  389     Serial.println();\par
  390 \par
  391 #endif \par
  392 \par
  393     Serial.println("External Sensors configuration ");\par
  394 \par
  395     Serial.print("sensorsNumber : ");\par
  396     Serial.println(sensorsNumber);\par
  397 \par
  398     for(int i=0;i<sensorsNumber;i++)\par
  399     \{\par
  400         Serial.print("sensor ");\par
  401         Serial.print(i);\par
  402         Serial.print(" reference : ");\par
  403         Serial.println(this->sensors[i].reference);\par
  404 \par
  405         Serial.print("sensor ");\par
  406         Serial.print(i);\par
  407         Serial.print(" type : ");\par
  408         Serial.println(this->sensors[i].type);\par
  409                 \par
  410         Serial.print("sensor ");\par
  411         Serial.print(i);\par
  412         Serial.print(" address : ");\par
  413         Serial.println(this->sensors[i].address);\par
  414     \par
  415     \}\par
  416 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a78c2bf55084435dd51d3c559b2d3c6f3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:ExternalSensors}
{\xe \v ExternalSensors\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String ExternalSensors::read (void )}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::read()}: This method is provided to read the data from the external sensors\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string that contains the sensors data \par
}}{
Definition at line 102 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   103 \{\par
  104 \par
  105 #if DEBUG == 1\par
  106 \par
  107     Serial.println( F("Entering ExternalSensors.read()") );\par
  108     Serial.println();\par
  109 \par
  110 #endif \par
  111 \par
  112     String data;\par
  113     DynamicJsonBuffer  jsonBuffer ;\par
  114     JsonObject& root = jsonBuffer.createObject();\par
  115 \par
  116     if(!root.success() )\par
  117     \{\par
  118  \par
  119     #if DEBUG == 1\par
  120 \par
  121         Serial.println( F("failed to create json ") );\par
  122     \par
  123     #endif \par
  124 \par
  125         return("00");\par
  126     \}\par
  127     else\par
  128     \{\par
  129         if(sensorsNumber>0)\par
  130         \{\par
  131             for(int i=0;i<sensorsNumber;i++)\par
  132             \{\par
  133                 if(sensors[i].exSensor != NULL )\par
  134                 \{\par
  135                     root[sensors[i].type]=sensors[i].exSensor->read();      \par
  136                 \}\par
  137             \par
  138             #if DEBUG == 1\par
  139                 else\par
  140                 \{\par
  141                     Serial.println(F("null pointer "));\par
  142                 \}\par
  143             #endif  \par
  144             \}\par
  145         \}   \par
  146         \par
  147         root.printTo(data);\par
  148     \par
  149     #if DEBUG == 1\par
  150 \par
  151         Serial.println( F("sensors data :") );\par
  152         Serial.println(data);\par
  153         Serial.println();\par
  154 \par
  155         Serial.print(F("jsonBuffer size: "));\par
  156         Serial.println(jsonBuffer.size());\par
  157         Serial.println();\par
  158 \par
  159     \par
  160     #endif\par
  161     \par
  162         return(data);\par
  163     \}\par
  164 \par
  165 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a53177b81eca3be89508b5511ddcd00fc_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sensors\:ExternalSensors}
{\xe \v ExternalSensors\:sensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ExternalSensors::sensor} ExternalSensors::sensors[50]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sensorsNumber\:ExternalSensors}
{\xe \v ExternalSensors\:sensorsNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExternalSensors::sensorsNumber =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
External Sensors Number Maximum is 50 \par
}{
Definition at line 88 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Irene3000 Class Reference\par \pard\plain 
{\tc\tcl2 \v Irene3000}
{\xe \v Irene3000}
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield. }}\par
{
{\f2 #include <Irene3000.h>}}\par
Collaboration diagram for Irene3000:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d7b/class_irene3000__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b parameters_T}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readButton} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGain} ({\b adsGain_t} gain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readADSChannel2} ({\b adsGain_t} gain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readPh} (double t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readTemp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetParams} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calibratepH7} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calibratepH4} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calcpHSlope} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b gainConvert} (uint16_t tempGain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveParams} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_ADS1115} {\b ads}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::parameters_T} {\b params}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state} {\b waterTemp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state} {\b phProbe}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state} {\b adc2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b vRef} = 1.024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b opampGain} = 5.25\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield. \par
}{
Definition at line 59 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Irene3000}
{\xe \v Irene3000\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::begin (void )}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::begin()}: This method is provided to start the {\b Irene3000} \par
}{
Definition at line 52 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    53 \{\par
   54     this->ads.begin();\par
   55 \par
   56     delay(2000);\par
   57 \par
   58 #if DEBUG == 1 \par
   59 \par
   60 \par
   61     Serial.println( F("Entering Irene3000.begin()") );\par
   62     Serial.println();\par
   63     \par
   64     \par
   65     \par
   66 \par
   67 #endif\par
   68     Serial.println(F("Press the button to calibrate the Ph probe "));\par
   69 \par
   70     delay(2000);\par
   71 \par
   72     int bValue=this->readButton();\par
   73     \par
   74     while(bValue<500)\par
   75     \{\par
   76         bValue=this->readButton();\par
   77         delay(10);  \par
   78     \}\par
   79 \par
   80     if(  bValue > 20000 )\par
   81     \{\par
   82     \par
   83 \par
   84         \par
   85         Serial.println(F("calibrating the Ph probe " ) );\par
   86         \par
   87         Serial.println(F("ph7 calibration for 25 seconds"));\par
   88         \par
   89         delay(10000);\par
   90         \par
   91         this->calibratepH7();\par
   92 \par
   93         delay(15000);       \par
   94     \par
   95         this->calibratepH7();\par
   96 \par
   97         delay(1000);\par
   98         Serial.println(F("ph 7 calibration ok"));\par
   99         Serial.println();\par
  100     \par
  101 \par
  102         Serial.println(F("ph 4 calibration for 25 seconds"));\par
  103     \par
  104         delay(10000);       \par
  105 \par
  106         this->calibratepH4();\par
  107 \par
  108         delay(15000);\par
  109         \par
  110         this->calibratepH4();\par
  111     \par
  112         delay(1000);        \par
  113 \par
  114         Serial.println(F("ph 4 calibration ok"));\par
  115         Serial.println();\par
  116     \par
  117 \par
  118 \par
  119         this->saveParams();\par
  120     \par
  121     \}\par
  122 \par
  123 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ad5891806c500ae1007afe52b9e304c2b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ad5891806c500ae1007afe52b9e304c2b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calcpHSlope\:Irene3000}
{\xe \v Irene3000\:calcpHSlope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::calcpHSlope ()}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::calcpHSlop(): This method is provided to calculate th PH slope \par
}{
Definition at line 685 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   686 \{\par
  687 \par
  688 #if DEBUG == 1 \par
  689 \par
  690     Serial.println( F("Entering Irene3000.calcpHSlope()") );\par
  691     Serial.println();\par
  692 \par
  693 #endif \par
  694 \par
  695     params.pHStep = ((((vRef * (float)(params.pH7Cal - params.pH4Cal)) / 32767) * 1000) / opampGain) / 3;\par
  696 \par
  697  \par
  698 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a81f6a79e546679692053f7ac1af49613_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calibratepH4\:Irene3000}
{\xe \v Irene3000\:calibratepH4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::calibratepH4 ()}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::calibratepH4()}: This method is provided to calibrate the PH probe to 4 \par
}{
Definition at line 659 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   660 \{\par
  661 \par
  662 #if DEBUG == 1 \par
  663 \par
  664     Serial.println( F("Entering Irene3000.calibraph4()") );\par
  665     Serial.println();\par
  666 \par
  667 #endif \par
  668     delay(1000);\par
  669 \par
  670     this->setGain(GAIN_FOUR);\par
  671 \par
  672     this->params.pH4Cal =  ads.readADC_SingleEnded(ph);\par
  673 \par
  674     this->calcpHSlope();\par
  675 \par
  676 \par
  677 \par
  678 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aa140dd026922a04981edfd04d46cabbe_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aa140dd026922a04981edfd04d46cabbe_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calibratepH7\:Irene3000}
{\xe \v Irene3000\:calibratepH7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::calibratepH7 ()}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::calibratepH7()}: This method is provided to calibrate the PH probe to 7 \par
}{
Definition at line 632 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   633 \{\par
  634 \par
  635 #if DEBUG == 1 \par
  636 \par
  637     Serial.println( F("Entering Irene3000.calibratepH7() ") );\par
  638     Serial.println();\par
  639     \par
  640     \par
  641 \par
  642 #endif \par
  643     delay(1000);\par
  644 \par
  645     this->setGain(GAIN_FOUR);\par
  646         \par
  647     this->params.pH7Cal = ads.readADC_SingleEnded(ph);\par
  648  \par
  649     this->calcpHSlope();\par
  650 \par
  651 \par
  652 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a1d3299202e4cb7afcff9c9e3e95d94c1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a1d3299202e4cb7afcff9c9e3e95d94c1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:Irene3000}
{\xe \v Irene3000\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Irene3000::config ()}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::config()}: This method is provided to configure the {\b Irene3000} shield through a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 203 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   204 \{\par
  205 \par
  206 #if DEBUG == 1 \par
  207 \par
  208     Serial.println( F("Entering Irene3000.config()") );\par
  209     Serial.println();\par
  210 \par
  211 #endif\par
  212 \par
  213     File irene3000Config = SPIFFS.open("/irene3000Config.json", "r");\par
  214 \par
  215     if (!irene3000Config) \par
  216     \{\par
  217     \par
  218     #if DEBUG == 1 \par
  219 \par
  220         Serial.println( F("failed to read /irene3000Config.json") );\par
  221         Serial.println();\par
  222     \par
  223     #endif\par
  224 \par
  225         return(false);\par
  226     \}\par
  227     else\par
  228     \{\par
  229         size_t size = irene3000Config.size();\par
  230         // Allocate a buffer to store contents of the file.\par
  231         std::unique_ptr<char[]> buf(new char[size]);\par
  232             uint16_t tempGain;\par
  233         irene3000Config.readBytes(buf.get(), size);\par
  234         DynamicJsonBuffer jsonBuffer;\par
  235         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  236         if (!json.success()) \par
  237         \{\par
  238         \par
  239         #if DEBUG == 1 \par
  240 \par
  241             Serial.println( F("failed to parse json ") );\par
  242             Serial.println();\par
  243         \par
  244         #endif\par
  245             \par
  246             return(false);\par
  247         \} \par
  248         else\par
  249         \{\par
  250         \par
  251         #if DEBUG == 1 \par
  252     \par
  253             Serial.println( F("read configuration file ") );\par
  254             json.printTo(Serial);\par
  255             Serial.println();\par
  256 \par
  257             Serial.print(F("jsonBuffer size: "));\par
  258             Serial.println(jsonBuffer.size());\par
  259             Serial.println();\par
  260 \par
  261         \par
  262 \par
  263         #endif          \par
  264             if(json["waterTemp"]["active"].success() )\par
  265             \{           \par
  266                 this->waterTemp.active = json["waterTemp"]["active"]; \par
  267             \}\par
  268             else\par
  269             \{\par
  270                 this->waterTemp.active=this->waterTemp.active;\par
  271             \}\par
  272             json["waterTemp"]["active"]=this->waterTemp.active;\par
  273 \par
  274             \par
  275             if(json["phProbe"]["active"].success())\par
  276             \{\par
  277                 this->phProbe.active=json["phProbe"]["active"];\par
  278             \}\par
  279             else\par
  280             \{\par
  281                 this->phProbe.active=this->phProbe.active;\par
  282             \}\par
  283             json["phProbe"]["active"]=this->phProbe.active;\par
  284 \par
  285             \par
  286             if(json["adc2"]["active"].success() )\par
  287             \{\par
  288                 this->adc2.active=json["adc2"]["active"];\par
  289             \}\par
  290             else\par
  291             \{\par
  292                 this->adc2.active=this->adc2.active;\par
  293             \}\par
  294             json["adc2"]["active"]=this->adc2.active;\par
  295 \par
  296             \par
  297             if(json["adc2"]["gain"].success() )\par
  298             \{           \par
  299                 tempGain=json["adc2"]["gain"];\par
  300                 this->adc2.gain=this->gainConvert(tempGain);\par
  301             \}\par
  302             else\par
  303             \{\par
  304                 this->adc2.gain=this->adc2.gain;\par
  305             \}\par
  306             json["adc2"]["gain"]=this->adc2.gain;\par
  307 \par
  308             \par
  309             if(json["adc2"]["type"].success() )\par
  310             \{\par
  311                 this->adc2.type=json["adc2"]["type"].as<String>(); \par
  312             \}\par
  313             else\par
  314             \{\par
  315                 this->adc2.type=this->adc2.type;\par
  316             \}\par
  317             json["adc2"]["type"]=this->adc2.type;\par
  318 \par
  319 \par
  320             if(json["pH7Cal"].success())\par
  321             \{\par
  322                 this->params.pH7Cal=json["pH7Cal"];         \par
  323             \}\par
  324             else\par
  325             \{\par
  326                 this->params.pH7Cal=this->params.pH7Cal;\par
  327             \}\par
  328             json["pH7Cal"]=this->params.pH7Cal;\par
  329 \par
  330             \par
  331             if(json["pH4Cal"].success())\par
  332             \{\par
  333                 this->params.pH4Cal=json["pH4Cal"];         \par
  334             \}\par
  335             else\par
  336             \{\par
  337                 this->params.pH4Cal=this->params.pH4Cal;\par
  338             \}\par
  339             json["pH4Cal"]=this->params.pH4Cal;\par
  340 \par
  341 \par
  342             if(json["pHStep"].success())\par
  343             \{\par
  344                 this->params.pHStep=json["pHStep"];         \par
  345             \}\par
  346             else\par
  347             \{\par
  348                 this->params.pHStep=this->params.pHStep;\par
  349             \}\par
  350             json["pHStep"]=this->params.pHStep;\par
  351 \par
  352 \par
  353             irene3000Config.close();\par
  354             irene3000Config = SPIFFS.open("/irene3000Config.json", "w");\par
  355 \par
  356             if(!irene3000Config)\par
  357             \{\par
  358             \par
  359             #if DEBUG == 1\par
  360 \par
  361                 Serial.println( F("failed to write to /irene3000Config.json") );\par
  362                 Serial.println();\par
  363             \par
  364             #endif \par
  365 \par
  366                 return(false);\par
  367             \}\par
  368 \par
  369             json.printTo(irene3000Config);\par
  370             irene3000Config.close();\par
  371             \par
  372         #if DEBUG == 1 \par
  373 \par
  374             Serial.println( F("saved configuration file :")  );\par
  375             json.printTo(Serial);\par
  376             Serial.println();\par
  377         \par
  378         #endif\par
  379 \par
  380             return(true); \par
  381         \}\par
  382     \}   \par
  383 \par
  384 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_afed5c35e4b23963c157847ef27c11e9c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_afed5c35e4b23963c157847ef27c11e9c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v gainConvert\:Irene3000}
{\xe \v Irene3000\:gainConvert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Irene3000::gainConvert (uint16_t  {\i tempGain})}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::gainConvert}( gain : \{ 0.67 ,1,2,4,8,16 \} ) This method is provided to convert the gain to Internal Constants\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid internal representation of the ADS gain \par
}}{
Definition at line 732 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   733 \{\par
  734 \par
  735 #if DEBUG == 1 \par
  736 \par
  737     Serial.println( F("Entering Irene3000.gainConvert()") );\par
  738     Serial.println();\par
  739 \par
  740 #endif \par
  741     \par
  742     switch(tempGain)\par
  743     \{\par
  744         case(1): return (GAIN_ONE);\par
  745         case(2) : return(GAIN_TWO);\par
  746         case(4): return(GAIN_FOUR) ;   \par
  747         case(8):return(GAIN_EIGHT)  ;  \par
  748         case(16):return(GAIN_SIXTEEN);\par
  749         default: return(GAIN_TWOTHIRDS);    \par
  750     \}\par
  751 \par
  752     return(GAIN_ONE);\par
  753 \par
  754 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_abcad62d1201a59f8dd3ba87048002728_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:Irene3000}
{\xe \v Irene3000\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::printConf ()}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 391 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   392 \{\par
  393 \par
  394 #if DEBUG == 1 \par
  395 \par
  396     Serial.println( F("Entering Irene3000.printConf()") );\par
  397     Serial.println();\par
  398 \par
  399 #endif \par
  400 \par
  401     Serial.println("Irene Configuration ");\par
  402 \par
  403     Serial.print("waterTemp.active : ");\par
  404     Serial.println(waterTemp.active);\par
  405 \par
  406     Serial.print("waterTemp.gain : ");\par
  407     Serial.println(waterTemp.gain,HEX); \par
  408 \par
  409     Serial.print("phProbe.active : ");\par
  410     Serial.println(phProbe.active);\par
  411 \par
  412     Serial.print("phProbe.gain : ");\par
  413     Serial.println(phProbe.gain,HEX);\par
  414     \par
  415     Serial.print("adc2.active : ");\par
  416     Serial.println(adc2.active);\par
  417 \par
  418     Serial.print("adc2.gain : ");\par
  419     Serial.println(adc2.gain,HEX);\par
  420 \par
  421     Serial.print("adc2.type : ");\par
  422     Serial.println(adc2.type);\par
  423 \par
  424     Serial.println();\par
  425 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a7bc2414100b5e19eacc6630fa34b2654_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:Irene3000}
{\xe \v Irene3000\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Irene3000::read (void )}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000}:{\b read()}: This method is provided to read the {\b Irene3000} sensors data\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string of the sensors data \par
}}{
Definition at line 133 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134 \{\par
  135 \par
  136 #if DEBUG == 1 \par
  137     \par
  138     Serial.println( F("Entering Irene3000.read()") );\par
  139     Serial.println();\par
  140 \par
  141 #endif \par
  142 \par
  143     String data;\par
  144     DynamicJsonBuffer jsonBuffer;\par
  145     JsonObject& root = jsonBuffer.createObject();\par
  146     if( !( root.success()) )\par
  147     \{\par
  148     \par
  149     #if DEBUG == 1 \par
  150 \par
  151         Serial.println( F("failed to create json") );\par
  152     \par
  153     #endif \par
  154 \par
  155         return("");\par
  156     \}\par
  157 \par
  158         \par
  159     if(waterTemp.active)\par
  160     \{\par
  161         root["waterTemp"] = this->readTemp();\par
  162 \par
  163         if(phProbe.active)\par
  164         \{\par
  165             root["ph"] =this->readPh( root["waterTemp"].as<double>() ) ;\par
  166         \}\par
  167 \par
  168     \}\par
  169 \par
  170     if(adc2.active)\par
  171     \{\par
  172         root[adc2.type] =this->readADSChannel2(adc2.gain);\par
  173     \}\par
  174     \par
  175     root.printTo(data);\par
  176     \par
  177 #if DEBUG == 1 \par
  178 \par
  179     Serial.println( F("Irene data : ") );\par
  180     Serial.println(data);\par
  181     Serial.println();\par
  182 \par
  183     Serial.print(F("jsonBuffer size: "));\par
  184     Serial.println(jsonBuffer.size());\par
  185     Serial.println();\par
  186 \par
  187 \par
  188 #endif\par
  189     \par
  190     return(data);\par
  191     \par
  192     \par
  193 \par
  194 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a852a170feea994ea1df01c6b245b5d9a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a852a170feea994ea1df01c6b245b5d9a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADSChannel2\:Irene3000}
{\xe \v Irene3000\:readADSChannel2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::readADSChannel2 ({\b adsGain_t}  {\i gain})}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::readADSChannel2(gain): This method is provided to read from the ADS channel 2 . ADS Channel 2 is free and the user can connect another analog sensor to it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ADS Channel 2 value \par
}}{
Definition at line 484 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   485 \{   \par
  486 \par
  487 #if DEBUG == 1 \par
  488     \par
  489     Serial.println( F("Entering Irene3000.readADSChannel2()") );\par
  490     Serial.println();\par
  491 \par
  492 #endif\par
  493 \par
  494     this->setGain(gain);\par
  495     int result = this->ads.readADC_SingleEnded(freeAdc);\par
  496 #if DEBUG == 1 \par
  497     \par
  498     Serial.println( F("adc2 value : ") );\par
  499     Serial.println( );\par
  500     Serial.println();\par
  501 \par
  502 #endif\par
  503 \par
  504     return( result ) ;\par
  505 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ae73bd2ed14a199a7e83f4d6458476a7c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ae73bd2ed14a199a7e83f4d6458476a7c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readButton\:Irene3000}
{\xe \v Irene3000\:readButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::readButton ()}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::readButton()}: This method is provided to read the {\b Irene3000} button\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the button value \par
}}{
Definition at line 434 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   435 \{\par
  436 \par
  437 #if DEBUG == 1 \par
  438 \par
  439     Serial.println( F("Entering Irene3000.readButton()" ) );\par
  440     Serial.println();\par
  441 \par
  442 #endif \par
  443 \par
  444     this->setGain(GAIN_TWOTHIRDS);\par
  445     int result =this->ads.readADC_SingleEnded(button);\par
  446 #if DEBUG == 1\par
  447     \par
  448     Serial.println( F("button value : ") );\par
  449     Serial.println( result );\par
  450 \par
  451 #endif \par
  452 \par
  453     return( result );\par
  454     \par
  455 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a78a87eb7cf295b95c12b2ebd51c2bb77_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a78a87eb7cf295b95c12b2ebd51c2bb77_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readPh\:Irene3000}
{\xe \v Irene3000\:readPh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Irene3000::readPh (double  {\i t})}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::readPh(double t)}: This method is provided to read the PH probe note that for the best results, PH must be correlated to Temperature.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the PH probe value \par
}}{
Definition at line 515 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   516 \{\par
  517 \par
  518 #if DEBUG == 1 \par
  519 \par
  520     Serial.println( F("Entering Irene3000.readPh()") );\par
  521     Serial.println();\par
  522 \par
  523 #endif \par
  524 \par
  525     this->setGain(GAIN_FOUR);\par
  526     int adcR=ads.readADC_SingleEnded(ph);\par
  527     double Voltage =  REFERENCE_VOLTAGE_GAIN_4 * ( adcR ) / ADC_MAXIMUM_VALUE;\par
  528 \par
  529     float miliVolts = Voltage * 1000;\par
  530     float temporary = ((((vRef * (float)params.pH7Cal) / 32767) * 1000) - miliVolts) / opampGain;\par
  531     \par
  532     float phT=7 - (temporary / params.pHStep);\par
  533 \par
  534     float ph25= ( phT / ( 1 + 0.009*( t - 25 ) ) );\par
  535 \par
  536 #if DEBUG == 1 \par
  537 \par
  538     Serial.println( F("ph is : ") );\par
  539     Serial.println( phT ) ;\par
  540     \par
  541     Serial.println(F("corrected ph to 25\'B0C is : "));\par
  542     Serial.println(ph25);\par
  543 \par
  544 #endif \par
  545     if(isnan(ph25) )\par
  546     \{\par
  547         return(-42);    \par
  548     \}\par
  549 \par
  550     return(ph25);\par
  551 \par
  552 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a436fc0a06681cd0784aba56b9707f19a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a436fc0a06681cd0784aba56b9707f19a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTemp\:Irene3000}
{\xe \v Irene3000\:readTemp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Irene3000::readTemp ()}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::readTemp(gain): This method is provided to read the Temeperature probe\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the Temperature probe value \par
}}{
Definition at line 561 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   562 \{\par
  563 \par
  564 #if DEBUG == 1 \par
  565 \par
  566     Serial.println( F("Entering Irene3000.readTemp()") );\par
  567     Serial.println();\par
  568 \par
  569 #endif\par
  570 \par
  571     const double A = 3.9083E-3;\par
  572     const double B = -5.775E-7;\par
  573     double T;\par
  574 \par
  575     this->setGain(GAIN_EIGHT);\par
  576 \par
  577     double adc0 = ads.readADC_SingleEnded(temp);\par
  578 \par
  579 \par
  580     double R = ( ( adc0 * V_GAIN_8 ) / 0.095 ) / 1000 ;\par
  581 \par
  582     T = 0.0 - A;\par
  583     T += sqrt((A * A) - 4.0 * B * (1.0 - R));\par
  584     T /= (2.0 * B);\par
  585 \par
  586     if (T > 0 && T < 200) \par
  587     \{\par
  588 \par
  589     #if DEBUG == 1 \par
  590 \par
  591         Serial.print( F(" temperature : ") );\par
  592         Serial.println(T);\par
  593         Serial.println();\par
  594     \par
  595     #endif \par
  596         if(isnan(T))\par
  597         \{\par
  598             return(-300);           \par
  599         \}\par
  600 \par
  601         return T;\par
  602     \}\par
  603     else \par
  604     \{\par
  605         T = 0.0 - A;\par
  606         T -= sqrt((A * A) - 4.0 * B * (1.0 - R));\par
  607         T /= (2.0 * B);\par
  608     \par
  609     #if DEBUG == 1 \par
  610     \par
  611         Serial.println( F("temperature : ") );\par
  612         Serial.println(T);\par
  613         Serial.println();\par
  614     \par
  615     #endif\par
  616         if(isnan(T))\par
  617         \{\par
  618             return(-400);           \par
  619         \}\par
  620 \par
  621         return T;\par
  622     \}\par
  623 \par
  624 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a80bc6dfea106dc3bc54fa20204d4d5dc_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a80bc6dfea106dc3bc54fa20204d4d5dc_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetParams\:Irene3000}
{\xe \v Irene3000\:resetParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::resetParams (void )}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::resetParams()}: This method is provided to reset the PH configuration, assuming Ideal configuration \par
}{
Definition at line 706 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{\par
  708 \par
  709 #if DEBUG == 1 \par
  710 \par
  711     Serial.println( F("Entering Irene3000.resetParams()") );\par
  712     Serial.println();\par
  713 \par
  714 #endif \par
  715 \par
  716     //Restore to default set of parameters!\par
  717     params.WriteCheck = Write_Check;\par
  718     params.pH7Cal = 16384; //assume ideal probe and amp conditions 1/2 of 4096\par
  719     params.pH4Cal = 8192; //using ideal probe slope we end up this many 12bit units away on the 4 scale\par
  720     params.pHStep = 59.16;//ideal probe slope\par
  721 \par
  722 \par
  723 \}\par
}
}
{\xe \v saveParams\:Irene3000}
{\xe \v Irene3000\:saveParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Irene3000::saveParams ()}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 757 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   758 \{\par
  759 \par
  760 #if DEBUG == 1\par
  761         \par
  762     Serial.println(F("Entering Irene3000.saveParams()"));\par
  763     Serial.println();\par
  764     \par
  765     Serial.println(F("saving new params"));\par
  766 #endif\par
  767     \par
  768     //open file\par
  769     File irene3000Config = SPIFFS.open("/irene3000Config.json", "r");\par
  770 \par
  771     if (!irene3000Config) \par
  772     \{\par
  773     \par
  774     #if DEBUG == 1 \par
  775 \par
  776         Serial.println( F("failed to read /irene3000Config.json") );\par
  777         Serial.println();\par
  778     \par
  779     #endif\par
  780 \par
  781         return(false);\par
  782     \}\par
  783     else\par
  784     \{\par
  785         //read file into json\par
  786         size_t size = irene3000Config.size();\par
  787         // Allocate a buffer to store contents of the file.\par
  788         std::unique_ptr<char[]> buf(new char[size]);\par
  789             irene3000Config.readBytes(buf.get(), size);\par
  790         DynamicJsonBuffer jsonBuffer;\par
  791         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  792         if (!json.success()) \par
  793         \{\par
  794         \par
  795         #if DEBUG == 1 \par
  796 \par
  797             Serial.println( F("failed to parse json ") );\par
  798             Serial.println();\par
  799         \par
  800         #endif\par
  801             \par
  802             return(false);\par
  803         \} \par
  804         else\par
  805         \{\par
  806         \par
  807         #if DEBUG == 1 \par
  808     \par
  809             Serial.println( F("read configuration file ") );\par
  810             json.printTo(Serial);\par
  811             Serial.println();\par
  812 \par
  813             Serial.print(F("jsonBuffer size: "));\par
  814             Serial.println(jsonBuffer.size());\par
  815             Serial.println();\par
  816 \par
  817         \par
  818 \par
  819         #endif          \par
  820     \par
  821             //add params to json\par
  822             json["pH7Cal"]=this->params.pH7Cal;\par
  823             json["pH4Cal"]=this->params.pH4Cal;\par
  824             json["pHStep"]=this->params.pHStep;         \par
  825             \par
  826             irene3000Config.close();\par
  827             \par
  828             \par
  829             //save json to file\par
  830             irene3000Config = SPIFFS.open("/irene3000Config.json", "w");\par
  831 \par
  832             if(!irene3000Config)\par
  833             \{\par
  834             \par
  835             #if DEBUG == 1\par
  836 \par
  837                 Serial.println( F("failed to write to /irene3000Config.json") );\par
  838                 Serial.println();\par
  839             \par
  840             #endif \par
  841 \par
  842                 return(false);\par
  843             \}\par
  844 \par
  845             json.printTo(irene3000Config);\par
  846             irene3000Config.close();\par
  847             \par
  848         #if DEBUG == 1 \par
  849 \par
  850             Serial.println( F("saved configuration file :")  );\par
  851             json.printTo(Serial);\par
  852             Serial.println();\par
  853         \par
  854         #endif\par
  855 \par
  856             return(true); \par
  857         \}\par
  858     \}   \par
  859 \par
  860 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a63dbd38e79b8cd5f1fba4b245501a894_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setGain\:Irene3000}
{\xe \v Irene3000\:setGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::setGain ({\b adsGain_t}  {\i gain})}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::setGain(gain): This method is provided to set the ADS chip gain \par
}{
Definition at line 462 of file Irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   463 \{\par
  464 \par
  465 #if DEBUG == 1  \par
  466 \par
  467     Serial.println( F("Entering Irene3000.setGain()") );\par
  468     Serial.println();\par
  469 \par
  470 #endif\par
  471 \par
  472     this->ads.setGain(gain);\par
  473 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aff7c5da186b388e7272e63ff88a20c34_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aff7c5da186b388e7272e63ff88a20c34_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v adc2\:Irene3000}
{\xe \v Irene3000\:adc2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::state} Irene3000::adc2{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ads\:Irene3000}
{\xe \v Irene3000\:ads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Adafruit_ADS1115} Irene3000::ads{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ADS1115 instance \par
}{
Definition at line 99 of file Irene3000.h.}\par
}
{\xe \v opampGain\:Irene3000}
{\xe \v Irene3000\:opampGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float Irene3000::opampGain = 5.25{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
opAmpGain constant used for ADC conversion \par
}{
Definition at line 144 of file Irene3000.h.}\par
}
{\xe \v params\:Irene3000}
{\xe \v Irene3000\:params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::parameters_T} Irene3000::params{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phProbe\:Irene3000}
{\xe \v Irene3000\:phProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::state}  Irene3000::phProbe{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vRef\:Irene3000}
{\xe \v Irene3000\:vRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float Irene3000::vRef = 1.024{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
vRef constant used for ADC conversion \par
}{
Definition at line 139 of file Irene3000.h.}\par
}
{\xe \v waterTemp\:Irene3000}
{\xe \v Irene3000\:waterTemp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::state}  Irene3000::waterTemp{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Jetpack Class Reference\par \pard\plain 
{\tc\tcl2 \v Jetpack}
{\xe \v Jetpack}
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield. }}\par
{
{\f2 #include <Jetpack.h>}}\par
Collaboration diagram for Jetpack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/db7/class_jetpack__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (byte {\b action})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeBit} (byte pin, bool {\b state})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doAction} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalAction} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invertedAction} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOff} (int actorNumber)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOn} (int actorNumber)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOff} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOn} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourAction} (int actorNumber, int hour)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourAction} (int actorNumber, int hour, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b minuteAction} (int actorNumber, int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedMinuteAction} (int actorNumber, int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourMinuteAction} (int actorNumber, int hour, int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourMinuteAction} (int actorNumber, int hour, int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b action} = B00000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Jetpack::state} {\b actors} [8]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b clockPin} = 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b dataPin} = 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b EnI2C} =5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield. \par
}{
Definition at line 45 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Jetpack}
{\xe \v Jetpack\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::begin (void )}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack::begin()}: This method is provided to initialise the pin that control the {\b Jetpack} shield \par
}{
Definition at line 50 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52 \par
   53 #if DEBUG == 1 \par
   54  \par
   55     Serial.println( F("Entering Jetpack.begin() ") );\par
   56     Serial.println();\par
   57 \par
   58 #endif\par
   59 \par
   60     pinMode(EnI2C,OUTPUT);\par
   61     pinMode(dataPin,OUTPUT);\par
   62     pinMode(clockPin,OUTPUT);\par
   63     \par
   64     \par
   65 \par
   66 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a5a53e1ebf7aaf3bf3e0d37ea64ca09a7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:Jetpack}
{\xe \v Jetpack\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::config ()}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack::config()}: This method is provided to configure the {\b Jetpack} with a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 307 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309 \par
  310 #if DEBUG == 1 \par
  311 \par
  312     Serial.println( F("Entering Jetpack.config() ") );\par
  313     Serial.println();\par
  314 \par
  315 #endif\par
  316 \par
  317     File jetPackConfig = SPIFFS.open("/jetPackConfig.json", "r");\par
  318 \par
  319     if (!jetPackConfig) \par
  320     \{\par
  321 \par
  322     #if DEBUG == 1 \par
  323 \par
  324         Serial.println( F("failed to read /jetPackConfig.json ") );\par
  325         Serial.println();\par
  326 \par
  327     #endif\par
  328 \par
  329         return(false);\par
  330     \}\par
  331     else\par
  332     \{\par
  333         size_t size = jetPackConfig.size();\par
  334         // Allocate a buffer to store contents of the file.\par
  335         std::unique_ptr<char[]> buf(new char[size]);\par
  336 \par
  337         jetPackConfig.readBytes(buf.get(), size);\par
  338         DynamicJsonBuffer jsonBuffer;\par
  339         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  340         if (!json.success()) \par
  341         \{\par
  342         \par
  343         #if DEBUG == 1 \par
  344 \par
  345             Serial.println( F("failed to parse jetpack config json from file ") );\par
  346             Serial.println();\par
  347 \par
  348         #endif\par
  349 \par
  350             return(false);\par
  351         \} \par
  352         else\par
  353         \{ \par
  354         \par
  355         #if DEBUG == 1 \par
  356 \par
  357             Serial.println( F("read configuration file : ") );\par
  358             json.printTo(Serial);\par
  359             Serial.println();\par
  360 \par
  361             Serial.print(F("jsonBuffer size: "));\par
  362             Serial.println(jsonBuffer.size());\par
  363             Serial.println();\par
  364 \par
  365         \par
  366         #endif\par
  367   \par
  368             for(int i=0;i<8;i++)\par
  369             \{   \par
  370                 if(json[String("Act")+String(i)].success())\par
  371                 \{\par
  372                     //parsing actif key\par
  373                     if(json[String("Act")+String(i)]["actif"].success() )\par
  374                     \{\par
  375                         this->actors[i].actif=json[String("Act")+String(i)]["actif"];\par
  376                     \}\par
  377                     else\par
  378                     \{\par
  379                         this->actors[i].actif=this->actors[i].actif;\par
  380                     \}\par
  381                     json[String("Act")+String(i)]["actif"]=this->actors[i].actif;\par
  382                     \par
  383                     //parsing temporal key\par
  384                     if(json[String("Act")+String(i)]["temporal"].success() )\par
  385                     \{\par
  386                         this->actors[i].temporal=json[String("Act")+String(i)]["temporal"];\par
  387                     \}\par
  388                     else\par
  389                     \{\par
  390                         this->actors[i].temporal=this->actors[i].temporal;\par
  391                     \}\par
  392                     json[String("Act")+String(i)]["temporal"]=this->actors[i].temporal;\par
  393                     \par
  394                     //parsing inverted key\par
  395                     if(json[String("Act")+String(i)]["inverted"].success() )\par
  396                     \{\par
  397                         this->actors[i].inverted=json[String("Act")+String(i)]["inverted"];\par
  398                     \}\par
  399                     else\par
  400                     \{\par
  401                         this->actors[i].inverted=this->actors[i].inverted;\par
  402                     \}\par
  403                     json[String("Act")+String(i)]["inverted"]=this->actors[i].inverted;\par
  404 \par
  405                     //parsing inverted key\par
  406                     if(json[String("Act")+String(i)]["inverted"].success() )\par
  407                     \{\par
  408                         this->actors[i].inverted=json[String("Act")+String(i)]["inverted"];\par
  409                     \}\par
  410                     else\par
  411                     \{\par
  412                         this->actors[i].inverted=this->actors[i].inverted;\par
  413                     \}\par
  414                     json[String("Act")+String(i)]["inverted"]=this->actors[i].inverted;\par
  415                     \par
  416                     //parsing low key\par
  417                     if(json[String("Act")+String(i)]["low"].success() )\par
  418                     \{\par
  419                         this->actors[i].rangeLow=json[String("Act")+String(i)]["low"][0];\par
  420                         this->actors[i].timeLow=json[String("Act")+String(i)]["low"][1];\par
  421                         this->actors[i].hourLow=json[String("Act")+String(i)]["low"][2];                        \par
  422                         this->actors[i].minuteLow=json[String("Act")+String(i)]["low"][3];                      \par
  423                     \}\par
  424                     else\par
  425                     \{\par
  426                         this->actors[i].rangeLow=this->actors[i].rangeLow;\par
  427                         this->actors[i].timeLow=this->actors[i].timeLow;\par
  428                         this->actors[i].hourLow=this->actors[i].hourLow;\par
  429                         this->actors[i].minuteLow=this->actors[i].minuteLow;                        \par
  430                     \}\par
  431                     json[String("Act")+String(i)]["low"][0]=this->actors[i].rangeLow;\par
  432                     json[String("Act")+String(i)]["low"][1]=this->actors[i].timeLow;\par
  433                     json[String("Act")+String(i)]["low"][2]=this->actors[i].hourLow;\par
  434                     json[String("Act")+String(i)]["low"][3]=this->actors[i].minuteLow;\par
  435 \par
  436                     //parsing high key\par
  437                     if(json[String("Act")+String(i)]["high"].success() )\par
  438                     \{\par
  439                         this->actors[i].rangeHigh=json[String("Act")+String(i)]["high"][0];\par
  440                         this->actors[i].timeHigh=json[String("Act")+String(i)]["high"][1];\par
  441                         this->actors[i].hourHigh=json[String("Act")+String(i)]["high"][2];                      \par
  442                         this->actors[i].minuteHigh=json[String("Act")+String(i)]["high"][3];                        \par
  443                     \}\par
  444                     else\par
  445                     \{\par
  446                         this->actors[i].rangeHigh=this->actors[i].rangeHigh;\par
  447                         this->actors[i].timeHigh=this->actors[i].timeHigh;\par
  448                         this->actors[i].hourHigh=this->actors[i].hourHigh;\par
  449                         this->actors[i].minuteHigh=this->actors[i].minuteHigh;\par
  450                     \}\par
  451                     json[String("Act")+String(i)]["high"][0]=this->actors[i].rangeHigh;\par
  452                     json[String("Act")+String(i)]["high"][1]=this->actors[i].timeHigh;\par
  453                     json[String("Act")+String(i)]["high"][2]=this->actors[i].hourHigh;\par
  454                     json[String("Act")+String(i)]["high"][3]=this->actors[i].minuteHigh;\par
  455 \par
  456                     //parsing type key\par
  457                     if(json[String("Act")+String(i)]["type"].success() )\par
  458                     \{\par
  459                         this->actors[i].primaryType=json[String("Act")+String(i)]["type"][0].as<String>();\par
  460                         this->actors[i].secondaryType=json[String("Act")+String(i)]["type"][1].as<String>();                        \par
  461                         \par
  462                     \}\par
  463                     else\par
  464                     \{\par
  465                         this->actors[i].primaryType=this->actors[i].primaryType;\par
  466                         this->actors[i].secondaryType=this->actors[i].secondaryType;\par
  467                     \}\par
  468                     json[String("Act")+String(i)]["type"][0]=this->actors[i].primaryType;\par
  469                     json[String("Act")+String(i)]["type"][1]=this->actors[i].secondaryType;\par
  470                         \par
  471 \par
  472 \par
  473                     \par
  474                     \par
  475                      \par
  476                 \}\par
  477                 else\par
  478                 \{\par
  479                     this->actors[i]=this->actors[i];\par
  480                 \}\par
  481                 \par
  482                 json[String("Act")+String(i)]["actif"]=this->actors[i].actif;\par
  483                 json[String("Act")+String(i)]["temporal"]=this->actors[i].temporal;\par
  484                 json[String("Act")+String(i)]["inverted"]=this->actors[i].inverted;\par
  485 \par
  486                 json[String("Act")+String(i)]["low"][0]=this->actors[i].rangeLow;\par
  487                 json[String("Act")+String(i)]["low"][1]=this->actors[i].timeLow;\par
  488                 json[String("Act")+String(i)]["low"][2]=this->actors[i].hourLow;\par
  489                 json[String("Act")+String(i)]["low"][3]=this->actors[i].minuteLow;\par
  490 \par
  491                 json[String("Act")+String(i)]["high"][0]=this->actors[i].rangeHigh;\par
  492                 json[String("Act")+String(i)]["high"][1]=this->actors[i].timeHigh;\par
  493                 json[String("Act")+String(i)]["high"][2]=this->actors[i].hourHigh;\par
  494                 json[String("Act")+String(i)]["high"][3]=this->actors[i].minuteHigh;\par
  495 \par
  496                 json[String("Act")+String(i)]["type"][0]=this->actors[i].primaryType;\par
  497                 json[String("Act")+String(i)]["type"][1]=this->actors[i].secondaryType;\par
  498 \par
  499 \par
  500 \par
  501             \}\par
  502             \par
  503 \par
  504             jetPackConfig.close();          \par
  505             jetPackConfig = SPIFFS.open("/jetPackConfig.json", "w");            \par
  506             if(!jetPackConfig)\par
  507             \{\par
  508             \par
  509             #if DEBUG == 1 \par
  510 \par
  511                 Serial.println( F("failed to write to /jetPackConfig.json ") );\par
  512                 Serial.println();\par
  513             \par
  514             #endif\par
  515                 \par
  516                 return(false);          \par
  517             \}  \par
  518 \par
  519             json.printTo(jetPackConfig);\par
  520             jetPackConfig.close();\par
  521 \par
  522         #if DEBUG == 1 \par
  523             \par
  524             Serial.println(F("saved configuration : "));\par
  525             json.printTo(Serial );\par
  526             Serial.println();       \par
  527         \par
  528         #endif\par
  529 \par
  530             return(true); \par
  531         \}\par
  532     \}   \par
  533     \par
  534 \par
  535 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ab065ee83e244265a2223a22f3ee4a719_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v doAction\:Jetpack}
{\xe \v Jetpack\:doAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::doAction (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::doAction(sensor data ): This method is provided to automate the {\b Jetpack}.\par
The result action is the result of checking the different flags of an actor (actif , temporal ,inverted, primaryType and secondaryType ) and the corresponding call to the appropriate helping method \par
}{
Definition at line 144 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   145 \{\par
  146 \par
  147 #if DEBUG == 1 \par
  148 \par
  149     Serial.println( F("Entering Jetpack.doAction()") );\par
  150     Serial.println();\par
  151 \par
  152     Serial.println( F("input data is :") );\par
  153     Serial.println(data);\par
  154     Serial.println();\par
  155 \par
  156 #endif \par
  157 \par
  158     DynamicJsonBuffer jsonBuffer;\par
  159     JsonObject& root = jsonBuffer.parseObject(data);\par
  160     \par
  161     if (!root.success()) \par
  162     \{\par
  163     \par
  164     #if DEBUG == 1 \par
  165 \par
  166         Serial.println( F("failed to parse json object ") );\par
  167         Serial.println();\par
  168     \par
  169     #endif \par
  170 \par
  171     \}\par
  172     else\par
  173     \{\par
  174     \par
  175     #if DEBUG == 1 \par
  176 \par
  177         Serial.println( F("created Json object :") );\par
  178         root.printTo(Serial);\par
  179         Serial.println();\par
  180 \par
  181         Serial.print(F("jsonBuffer size: "));\par
  182         Serial.println(jsonBuffer.size());\par
  183         Serial.println();\par
  184 \par
  185     \par
  186     #endif \par
  187 \par
  188         //invert the current action state for each actor\par
  189         //if the value is outside the limits\par
  190         for(int i=0;i<8;i++)\par
  191         \{\par
  192             //check if actor is actif\par
  193             if(this->actors[i].actif==1)\par
  194             \{\par
  195                 //normal actor\par
  196                 if(this->actors[i].temporal == 0)\par
  197                 \{\par
  198                     //not inverted actor\par
  199                     if(this->actors[i].inverted==0)\par
  200                     \{\par
  201                         this->normalAction(i,root[this->actors[i].primaryType].as<float>());\par
  202             \par
  203                     \}\par
  204                     //inverted actor\par
  205                     else if(this->actors[i].inverted==1)\par
  206                     \{\par
  207                         this->invertedAction(i,root[this->actors[i].primaryType].as<float>());          \par
  208                     \}\par
  209                 \}\par
  210                 //temporal actor\par
  211                 else if(this->actors[i].temporal == 1 )\par
  212                 \{\par
  213                     //hour actor\par
  214                     if(this->actors[i].secondaryType=="hour")\par
  215                     \{\par
  216                         //mixed hour actor\par
  217                         if(root[this->actors[i].primaryType].success() )\par
  218                         \{\par
  219                             this->mixedHourAction(i,root[this->actors[i].secondaryType].as<int>(),root[this->actors[i].primaryType].as<float>());\par
  220                         \}\par
  221                         //normal hour actor\par
  222                         else\par
  223                         \{\par
  224                             this->hourAction(i,root[this->actors[i].secondaryType].as<int>());\par
  225                         \}\par
  226                     \par
  227                     \}\par
  228                     //minute actor\par
  229                     else if(this->actors[i].secondaryType=="minute")\par
  230                     \{\par
  231                         //mixed minute actor\par
  232                         if(root[this->actors[i].primaryType].success() )\par
  233                         \{\par
  234                             this->mixedMinuteAction(i,root[this->actors[i].secondaryType].as<int>(),root[this->actors[i].primaryType].as<float>());\par
  235                         \}\par
  236                         //normal minute actor\par
  237                         else\par
  238                         \{\par
  239                             this->minuteAction(i,root[this->actors[i].secondaryType].as<int>());\par
  240                         \}\par
  241                     \}\par
  242                     //hourMinute actor\par
  243                     else if(this->actors[i].secondaryType=="hourMinute")\par
  244                     \{\par
  245                         //mixed hourMinute actor\par
  246                         if(root[this->actors[i].primaryType].success() )\par
  247                         \{\par
  248                             this->mixedHourMinuteAction(i,root["hour"].as<int>(),root["minute"].as<int>(),root[this->actors[i].primaryType].as<float>());\par
  249                         \}\par
  250                         //normal hourMinute actor\par
  251                         else\par
  252                         \{\par
  253                             this->hourMinuteAction(i,root["hour"].as<int>(),root["minute"].as<int>());\par
  254                         \}\par
  255                     \}\par
  256                     //normal temporal actor\par
  257                     else if(this->actors[i].secondaryType=="")\par
  258                     \{\par
  259                         //mixed temporal actor\par
  260                         if(root[this->actors[i].primaryType].success() )\par
  261                         \{\par
  262                             this->mixedTemporalActionOn(i,root[this->actors[i].primaryType].as<float>());\par
  263                         \}\par
  264                         //normal temporal actor\par
  265                         else\par
  266                         \{\par
  267                             this->temporalActionOn(i);\par
  268                         \}\par
  269                                             \par
  270                     \}\par
  271 \par
  272                 \}\par
  273             \}\par
  274             //inactif actor\par
  275             else if(this->actors[i].actif == 0 )\par
  276             \{\par
  277                 //temporal actor\par
  278                 if(this->actors[i].temporal==1)\par
  279                 \{\par
  280                     //mixed temporal actor\par
  281                     if(root[this->actors[i].primaryType].success() )\par
  282                     \{\par
  283                         this->mixedTemporalActionOff(i,root[this->actors[i].primaryType].as<float>());\par
  284                     \}\par
  285                     //normal temporal actor\par
  286                     else\par
  287                     \{\par
  288                         this->temporalActionOff(i);\par
  289                     \}\par
  290                 \}           \par
  291             \}\par
  292 \par
  293         \}\par
  294 \par
  295         this->write(this->action);\par
  296 \par
  297     \} \par
  298 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a9e703197093094b963f9ad57817495b8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a9e703197093094b963f9ad57817495b8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourAction\:Jetpack}
{\xe \v Jetpack\:hourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::hourAction (int  {\i actorNumber}, int  {\i hour})}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::hourAction(actorNumber, current hour ): This method is provided to handle hour actors. it changes the action according to:\par
hour >= hourLow : deactivate the actor hour >= hourHigh : activate the actor \par
}{
Definition at line 1027 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1028 \{\par
 1029 \par
 1030 #if DEBUG == 1\par
 1031     \par
 1032     Serial.print(F("hour Actor N\'B0 : "));\par
 1033     Serial.println(actorNumber);\par
 1034 \par
 1035     Serial.print(F(" hour : "));\par
 1036     Serial.println(hour);\par
 1037 \par
 1038     Serial.print(F("high hour : "));\par
 1039     Serial.println(this->actors[actorNumber].hourHigh);\par
 1040 \par
 1041     Serial.print(F("low hour : "));\par
 1042     Serial.println(this->actors[actorNumber].hourLow);\par
 1043 \par
 1044 #endif\par
 1045 \par
 1046     //stop the actor    \par
 1047     if(hour >= this->actors[actorNumber].hourLow)\par
 1048     \{\par
 1049         bitWrite( this->action , actorNumber , 0) ;\par
 1050 \par
 1051     #if DEBUG == 1 \par
 1052 \par
 1053         Serial.println(F("actor OFF "));\par
 1054 \par
 1055     #endif  \par
 1056 \par
 1057     \}\par
 1058     //starting the actor\par
 1059     else if(hour >= this->actors[actorNumber].hourHigh)\par
 1060     \{\par
 1061         bitWrite( this->action , actorNumber , 1) ;\par
 1062 \par
 1063     #if DEBUG == 1 \par
 1064 \par
 1065         Serial.println(F("actor ON "));\par
 1066 \par
 1067     #endif  \par
 1068     \par
 1069     \}\par
 1070 \par
 1071 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_acd6889af2fe5b057c6bd51b6dac827ef_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourMinuteAction\:Jetpack}
{\xe \v Jetpack\:hourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::hourMinuteAction (int  {\i actorNumber}, int  {\i hour}, int  {\i minute})}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::minteAction(actorNumber, current hour,current minute ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : deactivate the actor\par
hour > hourLow : deactivate the actor\par
hour == hourHigh : minute >= minteHigh : activate the actor\par
hour > hourHigh : activate the actor \par
}{
Definition at line 1371 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1372 \{\par
 1373 \par
 1374 #if DEBUG == 1\par
 1375 \par
 1376     Serial.print(F("hourMinute Actor N\'B0 : "));\par
 1377     Serial.println(actorNumber);\par
 1378 \par
 1379     Serial.print(F(" hour : "));\par
 1380     Serial.println(hour);\par
 1381     Serial.print(F(" minute : "));\par
 1382     Serial.println(minute);\par
 1383 \par
 1384     Serial.print(F("high hour : "));\par
 1385     Serial.println(this->actors[actorNumber].hourHigh);\par
 1386 \par
 1387     Serial.print(F("high minute : "));\par
 1388     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1389 \par
 1390     Serial.print(F("low hour : "));\par
 1391     Serial.println(this->actors[actorNumber].hourLow);\par
 1392 \par
 1393     Serial.print(F("low minute : "));\par
 1394     Serial.println(this->actors[actorNumber].minuteLow);\par
 1395 \par
 1396 #endif\par
 1397     //stop the actor\par
 1398     if(hour==this->actors[actorNumber].hourLow)\par
 1399     \{\par
 1400         if(minute>= this->actors[actorNumber].minuteLow)\par
 1401         \{\par
 1402             bitWrite( this->action , actorNumber , 0) ;\par
 1403         #if DEBUG == 1 \par
 1404 \par
 1405             Serial.println(F("actor OFF "));\par
 1406 \par
 1407         #endif  \par
 1408         \}\par
 1409     \}\par
 1410     else if(hour > this->actors[actorNumber].hourLow)\par
 1411     \{\par
 1412 \par
 1413         bitWrite( this->action , actorNumber , 0) ;\par
 1414     #if DEBUG == 1 \par
 1415 \par
 1416         Serial.println(F("actor OFF "));\par
 1417 \par
 1418     #endif  \par
 1419     \par
 1420     \}\par
 1421     //start the actor\par
 1422     else if(hour==this->actors[actorNumber].hourHigh)\par
 1423     \{\par
 1424         if(minute>= this->actors[actorNumber].minuteHigh)\par
 1425         \{\par
 1426             bitWrite( this->action , actorNumber , 1) ;\par
 1427 \par
 1428         #if DEBUG == 1 \par
 1429 \par
 1430             Serial.println(F("actor ON "));\par
 1431 \par
 1432         #endif  \par
 1433         \}\par
 1434     \}\par
 1435     else if(hour > this->actors[actorNumber].hourHigh)\par
 1436     \{\par
 1437 \par
 1438         bitWrite( this->action , actorNumber , 1) ;\par
 1439 \par
 1440     #if DEBUG == 1 \par
 1441 \par
 1442         Serial.println(F("actor ON "));\par
 1443 \par
 1444     #endif      \par
 1445 \par
 1446     \}\par
 1447 \par
 1448     \par
 1449 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ae01c13c785ebdf1b0bb5500234aba1bd_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v invertedAction\:Jetpack}
{\xe \v Jetpack\:invertedAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::invertedAction (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::invertedAction(actorNumber , measured value): This method is provided to handle inverted actors. it changes the action according to wether the measured value is: \par
{\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid rangeHigh (activate actor) \par
}< rangeLow ( deactivate actor ) \par
}{
Definition at line 694 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   695 \{\par
  696 #if DEBUG == 1\par
  697     \par
  698     Serial.print("inverted Actor N\'B0 : ");\par
  699     Serial.println(actorNumber);\par
  700 \par
  701     Serial.print("measured value : ");\par
  702     Serial.println(measurment);\par
  703 \par
  704     Serial.print("high range : ");\par
  705     Serial.println(this->actors[actorNumber].rangeHigh);\par
  706 \par
  707     Serial.print("low range : ");\par
  708     Serial.println(this->actors[actorNumber].rangeLow);\par
  709 \par
  710 #endif\par
  711 \par
  712     //measured value lower than minimum range : deactivate actor\par
  713     if(measurment < this->actors[actorNumber].rangeLow)\par
  714     \{\par
  715         bitWrite( this->action , actorNumber , 0) ;\par
  716 \par
  717     #if DEBUG == 1 \par
  718 \par
  719         Serial.println(F("actor OFF "));\par
  720     \par
  721     #endif\par
  722 \par
  723     \}\par
  724     //measured value higher than maximum range : activate actor\par
  725     else if(measurment > this->actors[actorNumber].rangeHigh)\par
  726     \{\par
  727         bitWrite( this->action , actorNumber , 1) ;\par
  728 \par
  729     #if DEBUG == 1 \par
  730 \par
  731         Serial.println(F("actor ON "));\par
  732     \par
  733     #endif\par
  734 \par
  735     \}\par
  736 \par
  737 \par
  738 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_adacfc35fab4a621357caf98ce1c9cb54_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v minuteAction\:Jetpack}
{\xe \v Jetpack\:minuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::minuteAction (int  {\i actorNumber}, int  {\i minute})}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::minteAction(actorNumber, current minute ): This method is provided to handle minute actors. it changes the action according to:\par
minute >= minuteLow : deactivate the actor minute >= minuteHigh : activate the actor \par
}{
Definition at line 1195 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1196 \{\par
 1197 \par
 1198 #if DEBUG == 1\par
 1199     \par
 1200     Serial.print(F("minute Actor N\'B0 : "));\par
 1201     Serial.println(actorNumber);\par
 1202 \par
 1203     Serial.print(F(" minute : "));\par
 1204     Serial.println(minute);\par
 1205 \par
 1206     Serial.print(F("high minute : "));\par
 1207     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1208 \par
 1209     Serial.print(F("low minute : "));\par
 1210     Serial.println(this->actors[actorNumber].minuteLow);\par
 1211 \par
 1212 #endif\par
 1213 \par
 1214     //stop the actor    \par
 1215     if(minute >= this->actors[actorNumber].minuteLow)\par
 1216     \{\par
 1217         bitWrite( this->action , actorNumber , 0) ;\par
 1218 \par
 1219     #if DEBUG == 1 \par
 1220 \par
 1221         Serial.println(F("actor OFF "));\par
 1222 \par
 1223     #endif  \par
 1224 \par
 1225     \}   \par
 1226     //starting the actor\par
 1227     else if(minute >= this->actors[actorNumber].minuteHigh)\par
 1228     \{\par
 1229         bitWrite( this->action , actorNumber , 1) ;\par
 1230 \par
 1231     #if DEBUG == 1 \par
 1232 \par
 1233         Serial.println(F("actor ON "));\par
 1234 \par
 1235     #endif  \par
 1236 \par
 1237     \}\par
 1238 \par
 1239 \} \par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a97da41141c7b53ddee61143519c8d17d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourAction\:Jetpack}
{\xe \v Jetpack\:mixedHourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedHourAction (int  {\i actorNumber}, int  {\i hour}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedHourAction(actorNumber, current hour, measured value ): This method is provided to handle mixed hour actors. it changes the action according to :\par
hour >= hourLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
hour >= hourHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 1088 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1089 \{\par
 1090 \par
 1091 #if DEBUG == 1\par
 1092     \par
 1093     Serial.print("mixed hour Actor N\'B0 : ");\par
 1094     Serial.println(actorNumber);\par
 1095 \par
 1096     Serial.print(" hour : ");\par
 1097     Serial.println(hour);\par
 1098 \par
 1099     Serial.print("high hour : ");\par
 1100     Serial.println(this->actors[actorNumber].hourHigh);\par
 1101 \par
 1102     Serial.print("low hour : ");\par
 1103     Serial.println(this->actors[actorNumber].hourLow);\par
 1104 \par
 1105     Serial.print("measured value : ");\par
 1106     Serial.println(measurment);\par
 1107 \par
 1108     Serial.print("high range : ");\par
 1109     Serial.println(this->actors[actorNumber].rangeHigh);\par
 1110 \par
 1111     Serial.print("low range : ");\par
 1112     Serial.println(this->actors[actorNumber].rangeLow);\par
 1113 \par
 1114 #endif\par
 1115     //stop the actor    \par
 1116     if(hour >= this->actors[actorNumber].hourLow)\par
 1117     \{\par
 1118             if( measurment >= this->actors[actorNumber].rangeHigh )\par
 1119             \{\par
 1120                 bitWrite( this->action , actorNumber , 0) ;\par
 1121 \par
 1122             #if DEBUG == 1 \par
 1123 \par
 1124                 Serial.print(measurment);\par
 1125                 Serial.print(F(" > " ));\par
 1126                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1127 \par
 1128                 Serial.println(F("actor OFF "));\par
 1129 \par
 1130             #endif  \par
 1131 \par
 1132             \}\par
 1133             else \par
 1134             \{\par
 1135                 bitWrite( this->action , actorNumber , 1) ;\par
 1136 \par
 1137             #if DEBUG == 1 \par
 1138 \par
 1139                 Serial.print(measurment);\par
 1140                 Serial.print(F(" < " ));\par
 1141                 Serial.print(this->actors[actorNumber].rangeHigh);\par
 1142 \par
 1143                 Serial.println(F("actor ON "));\par
 1144 \par
 1145             #endif  \par
 1146                 \par
 1147             \}\par
 1148     \}\par
 1149     //starting the actor\par
 1150     else if(hour >= this->actors[actorNumber].hourHigh)\par
 1151     \{\par
 1152             if( measurment < this->actors[actorNumber].rangeLow )\par
 1153             \{\par
 1154                 bitWrite( this->action , actorNumber , 1) ;\par
 1155 \par
 1156             #if DEBUG == 1 \par
 1157 \par
 1158                 Serial.print(measurment);\par
 1159                 Serial.print(F(" < " ));\par
 1160                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1161 \par
 1162                 Serial.println(F("actor ON "));\par
 1163 \par
 1164             #endif  \par
 1165             \}\par
 1166             else \par
 1167             \{\par
 1168                 bitWrite( this->action , actorNumber , 0) ;\par
 1169 \par
 1170             #if DEBUG == 1 \par
 1171 \par
 1172                 Serial.print(measurment);\par
 1173                 Serial.print(F(" > " ));\par
 1174                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1175 \par
 1176                 Serial.println(F("actor OFF "));\par
 1177 \par
 1178             #endif                  \par
 1179             \}\par
 1180 \par
 1181     \}\par
 1182 \par
 1183 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ac1a49ab4867718cdb415ad74c2066b9d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourMinuteAction\:Jetpack}
{\xe \v Jetpack\:mixedHourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedHourMinuteAction (int  {\i actorNumber}, int  {\i hour}, int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::minteAction(actorNumber, current hour,current minute , measured Value ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour > hourLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour == hourHigh : minute >= minteHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor\par
hour > hourHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor \par
}{
Definition at line 1476 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1477 \{\par
 1478 \par
 1479 #if DEBUG == 1\par
 1480     \par
 1481     Serial.print("hourMinute Actor N\'B0 : ");\par
 1482     Serial.println(actorNumber);\par
 1483 \par
 1484     Serial.print(" hour : ");\par
 1485     Serial.println(hour);\par
 1486     Serial.print(" minute : ");\par
 1487     Serial.println(minute);\par
 1488 \par
 1489     Serial.print("high hour : ");\par
 1490     Serial.println(this->actors[actorNumber].hourHigh);\par
 1491 \par
 1492     Serial.print("high minute : ");\par
 1493     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1494 \par
 1495     Serial.print("low hour : ");\par
 1496     Serial.println(this->actors[actorNumber].hourLow);\par
 1497 \par
 1498     Serial.print("low minute : ");\par
 1499     Serial.println(this->actors[actorNumber].minuteLow);\par
 1500 \par
 1501     Serial.print("measured value : ");\par
 1502     Serial.println(measurment);\par
 1503 \par
 1504     Serial.print("high range : ");\par
 1505     Serial.println(this->actors[actorNumber].rangeHigh);\par
 1506 \par
 1507     Serial.print("low range : ");\par
 1508     Serial.println(this->actors[actorNumber].rangeLow);\par
 1509 \par
 1510 #endif\par
 1511     //stop the actor\par
 1512     if(hour==this->actors[actorNumber].hourLow)\par
 1513     \{\par
 1514         if(minute>= this->actors[actorNumber].minuteLow)\par
 1515         \{\par
 1516             if( measurment >= this->actors[actorNumber].rangeHigh )\par
 1517             \{\par
 1518                 bitWrite( this->action , actorNumber , 0) ;\par
 1519 \par
 1520             #if DEBUG == 1 \par
 1521 \par
 1522                 Serial.print(measurment);\par
 1523                 Serial.print(F(" >= " ));\par
 1524                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1525 \par
 1526                 Serial.println(F("actor OFF "));\par
 1527 \par
 1528             #endif  \par
 1529 \par
 1530             \}\par
 1531             else \par
 1532             \{\par
 1533                 bitWrite( this->action , actorNumber , 1) ;\par
 1534 \par
 1535             #if DEBUG == 1 \par
 1536 \par
 1537                 Serial.print(measurment);\par
 1538                 Serial.print(F(" < " ));\par
 1539                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1540 \par
 1541                 Serial.println(F("actor ON "));\par
 1542 \par
 1543             #endif  \par
 1544                 \par
 1545             \}\par
 1546         \}\par
 1547     \}\par
 1548     else if(hour > this->actors[actorNumber].hourLow)\par
 1549     \{\par
 1550 \par
 1551         if( measurment >= this->actors[actorNumber].rangeHigh )\par
 1552         \{\par
 1553             bitWrite( this->action , actorNumber , 0) ;\par
 1554 \par
 1555         #if DEBUG == 1 \par
 1556 \par
 1557             Serial.print(measurment);\par
 1558             Serial.print(F(" >= " ));\par
 1559             Serial.println(this->actors[actorNumber].rangeHigh);\par
 1560 \par
 1561             Serial.println(F("actor OFF "));\par
 1562 \par
 1563         #endif  \par
 1564 \par
 1565         \}\par
 1566         else \par
 1567         \{\par
 1568             bitWrite( this->action , actorNumber , 1) ;\par
 1569 \par
 1570         #if DEBUG == 1 \par
 1571 \par
 1572             Serial.print(measurment);\par
 1573             Serial.print(F(" < " ));\par
 1574             Serial.println(this->actors[actorNumber].rangeHigh);\par
 1575 \par
 1576             Serial.println(F("actor ON "));\par
 1577 \par
 1578         #endif  \par
 1579             \par
 1580         \}\par
 1581 \par
 1582 \par
 1583     \}\par
 1584     //start the actor\par
 1585     else if(hour==this->actors[actorNumber].hourHigh)\par
 1586     \{\par
 1587         if(minute>= this->actors[actorNumber].minuteHigh)\par
 1588         \{\par
 1589             if( measurment < this->actors[actorNumber].rangeLow )\par
 1590             \{\par
 1591                 bitWrite( this->action , actorNumber , 1) ;\par
 1592 \par
 1593             #if DEBUG == 1 \par
 1594 \par
 1595                 Serial.print(measurment);\par
 1596                 Serial.print(F(" < " ));\par
 1597                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1598 \par
 1599                 Serial.println(F("actor ON "));\par
 1600 \par
 1601             #endif  \par
 1602 \par
 1603             \}\par
 1604             else \par
 1605             \{\par
 1606                 bitWrite( this->action , actorNumber , 0) ;\par
 1607 \par
 1608             #if DEBUG == 1 \par
 1609 \par
 1610                 Serial.print(measurment);\par
 1611                 Serial.println(F(" > " ));\par
 1612                 Serial.print(this->actors[actorNumber].rangeLow);\par
 1613 \par
 1614                 Serial.println(F("actor OFF "));\par
 1615 \par
 1616             #endif  \par
 1617                 \par
 1618             \}\par
 1619         \}\par
 1620     \}\par
 1621     else if(hour > this->actors[actorNumber].hourHigh)\par
 1622     \{\par
 1623 \par
 1624         if( measurment < this->actors[actorNumber].rangeLow )\par
 1625         \{\par
 1626             bitWrite( this->action , actorNumber , 1) ;\par
 1627 \par
 1628         #if DEBUG == 1 \par
 1629 \par
 1630             Serial.print(measurment);\par
 1631             Serial.print(F(" < " ));\par
 1632             Serial.println(this->actors[actorNumber].rangeLow);\par
 1633 \par
 1634             Serial.println(F("actor ON "));\par
 1635 \par
 1636         #endif  \par
 1637 \par
 1638         \}\par
 1639         else \par
 1640         \{\par
 1641             bitWrite( this->action , actorNumber , 0) ;\par
 1642 \par
 1643         #if DEBUG == 1 \par
 1644 \par
 1645             Serial.print(measurment);\par
 1646             Serial.println(F(" > " ));\par
 1647             Serial.print(this->actors[actorNumber].rangeLow);\par
 1648 \par
 1649             Serial.println(F("actor OFF "));\par
 1650 \par
 1651         #endif  \par
 1652             \par
 1653         \}\par
 1654     \par
 1655     \}\par
 1656 \par
 1657 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a273dae1517b56f0242e28b8944edc26b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedMinuteAction\:Jetpack}
{\xe \v Jetpack\:mixedMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedMinuteAction (int  {\i actorNumber}, int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedMinuteAction(actorNumber, current minute, measured value ): This method is provided to handle mixed minute actors. it changes the action according to :\par
minute >= minuteLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
minute >= minuteHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 1255 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1256 \{\par
 1257 \par
 1258 #if DEBUG == 1\par
 1259     \par
 1260     Serial.print("mixed minute Actor N\'B0 : ");\par
 1261     Serial.println(actorNumber);\par
 1262 \par
 1263     Serial.print(" minute : ");\par
 1264     Serial.println(minute);\par
 1265 \par
 1266     Serial.print("high minute : ");\par
 1267     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1268 \par
 1269     Serial.print("low minute : ");\par
 1270     Serial.println(this->actors[actorNumber].minuteLow);\par
 1271 \par
 1272     Serial.print("measured value : ");\par
 1273     Serial.println(measurment);\par
 1274 \par
 1275     Serial.print("high range : ");\par
 1276     Serial.println(this->actors[actorNumber].rangeHigh);\par
 1277 \par
 1278     Serial.print("low range : ");\par
 1279     Serial.println(this->actors[actorNumber].rangeLow);\par
 1280 \par
 1281 #endif\par
 1282     //stop the actor    \par
 1283     if(minute >= this->actors[actorNumber].minuteLow)\par
 1284     \{\par
 1285             if( measurment > this->actors[actorNumber].rangeHigh )\par
 1286             \{\par
 1287                 bitWrite( this->action , actorNumber , 0) ;\par
 1288 \par
 1289             #if DEBUG == 1 \par
 1290 \par
 1291                 Serial.print(measurment);\par
 1292                 Serial.print(F(" > " ));\par
 1293                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1294 \par
 1295                 Serial.println(F("actor OFF "));\par
 1296 \par
 1297             #endif\par
 1298     \par
 1299             \}\par
 1300             else \par
 1301             \{\par
 1302                 bitWrite( this->action , actorNumber , 1) ;\par
 1303 \par
 1304             #if DEBUG == 1 \par
 1305 \par
 1306                 Serial.print(measurment);\par
 1307                 Serial.print(F(" < " ));\par
 1308                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1309 \par
 1310                 Serial.println(F("actor ON "));\par
 1311 \par
 1312             #endif  \par
 1313                 \par
 1314             \}\par
 1315     \}   \par
 1316     //starting the actor\par
 1317     else if(minute >= this->actors[actorNumber].minuteHigh)\par
 1318     \{\par
 1319             if( measurment < this->actors[actorNumber].rangeLow )\par
 1320             \{\par
 1321                 bitWrite( this->action , actorNumber , 1) ;\par
 1322 \par
 1323             #if DEBUG == 1 \par
 1324 \par
 1325                 Serial.print(measurment);\par
 1326                 Serial.print(F(" < " ));\par
 1327                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1328 \par
 1329                 Serial.println(F("actor ON "));\par
 1330 \par
 1331             #endif  \par
 1332 \par
 1333             \}\par
 1334             else \par
 1335             \{\par
 1336                 bitWrite( this->action , actorNumber , 0) ;\par
 1337             \par
 1338             #if DEBUG == 1 \par
 1339 \par
 1340                 Serial.print(measurment);\par
 1341                 Serial.print(F(" > " ));\par
 1342                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1343 \par
 1344                 Serial.println(F("actor OFF "));\par
 1345 \par
 1346             #endif  \par
 1347                 \par
 1348             \}\par
 1349 \par
 1350     \}\par
 1351 \par
 1352 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_acf8ed1fb594b9e8e224f4ed872a8e093_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOff\:Jetpack}
{\xe \v Jetpack\:mixedTemporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedTemporalActionOff (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedTemporalActionOff(actorNumber, measured value ): This method is provided to handle mixed temporal actors. it changes the action according to:\par
currentTime - startTime >= timeHigh : measured value >= rangeHigh : deactivate actor measured value < rangeHigh : activate actor \par
}{
Definition at line 800 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   801 \{\par
  802 \par
  803 #if DEBUG == 1\par
  804     \par
  805     Serial.print("mixed Temporal Actor N\'B0 : ");\par
  806     Serial.println(actorNumber);\par
  807 \par
  808     Serial.print("measured value : ");\par
  809     Serial.println(measurment);\par
  810 \par
  811     Serial.print("high range : ");\par
  812     Serial.println(this->actors[actorNumber].rangeHigh);\par
  813 \par
  814     Serial.print("time high : ");\par
  815     Serial.println(this->actors[actorNumber].timeHigh);\par
  816 \par
  817     Serial.print("actif Time : ");\par
  818     Serial.println(this->actors[actorNumber].actifTime);\par
  819 \par
  820     Serial.print(F("millis : "));\par
  821     Serial.println(millis());\par
  822 \par
  823 #endif\par
  824     if( ( millis()- this->actors[actorNumber].actifTime  ) >= (  this->actors[actorNumber].timeHigh  ) )\par
  825     \{   \par
  826         if( measurment >= this->actors[actorNumber].rangeHigh )\par
  827         \{\par
  828             //stop the actor\par
  829             bitWrite( this->action , actorNumber , 0) ;\par
  830 \par
  831             //make the actor inactif:\par
  832             this->actors[actorNumber].actif=0;\par
  833 \par
  834             //start the low timer\par
  835             this->actors[actorNumber].inactifTime=millis();\par
  836 \par
  837         #if DEBUG == 1 \par
  838 \par
  839             Serial.print(F("actor was on for at least "));\par
  840             Serial.print(this->actors[actorNumber].timeHigh);\par
  841             Serial.println(F(" ms "));\par
  842 \par
  843             Serial.print(measurment);\par
  844             Serial.print(F(" > " ));\par
  845             Serial.println(this->actors[actorNumber].rangeHigh);\par
  846 \par
  847             \par
  848             Serial.println(F("actor OFF "));\par
  849 \par
  850         #endif\par
  851 \par
  852         \}\par
  853         else \par
  854         \{\par
  855             bitWrite( this->action , actorNumber , 1) ;\par
  856 \par
  857         #if DEBUG == 1 \par
  858             \par
  859             Serial.print(F("actor was on for at least "));\par
  860             Serial.print(this->actors[actorNumber].timeHigh);\par
  861             Serial.println(F(" ms "));\par
  862 \par
  863             Serial.print(measurment);\par
  864             Serial.print(F(" < " ));\par
  865             Serial.println(this->actors[actorNumber].rangeHigh);\par
  866 \par
  867             Serial.println(F("actor ON "));\par
  868 \par
  869         #endif              \par
  870 \par
  871         \}           \par
  872     \}\par
  873 \par
  874 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_af2f567ef6311a8fc2f7bb948837667b7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOn\:Jetpack}
{\xe \v Jetpack\:mixedTemporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedTemporalActionOn (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedTemporalActionOn(actorNumber, measured value ): This method is provided to handle mixed temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : measured value >= rangeLow : deactivate actor measured value < rangeLow : activate actor \par
}{
Definition at line 938 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   939 \{\par
  940 \par
  941 #if DEBUG == 1\par
  942     \par
  943     Serial.print("mixed Temporal Actor N\'B0 : ");\par
  944     Serial.println(actorNumber);\par
  945 \par
  946     Serial.print("measured value : ");\par
  947     Serial.println(measurment);\par
  948 \par
  949     Serial.print("low range : ");\par
  950     Serial.println(this->actors[actorNumber].rangeLow);\par
  951 \par
  952     Serial.print("time low : ");\par
  953     Serial.println(this->actors[actorNumber].timeLow);\par
  954 \par
  955     Serial.print("inactif Time : ");\par
  956     Serial.println(this->actors[actorNumber].inactifTime);\par
  957 \par
  958     Serial.print(F("millis : "));\par
  959     Serial.println(millis());\par
  960 \par
  961 #endif\par
  962 \par
  963     if( ( millis() - this->actors[actorNumber].inactifTime ) >= (  this->actors[actorNumber].timeLow  ) )\par
  964     \{\par
  965         if( measurment < this->actors[actorNumber].rangeLow )\par
  966         \{\par
  967             //start the actor\par
  968             bitWrite( this->action , actorNumber , 1) ;\par
  969 \par
  970             //make the actor actif:\par
  971             this->actors[actorNumber].actif=1;\par
  972 \par
  973             //start the low timer\par
  974             this->actors[actorNumber].actifTime=millis();\par
  975 \par
  976         #if DEBUG == 1 \par
  977 \par
  978             Serial.print(F("actor was off for at least "));\par
  979             Serial.print(this->actors[actorNumber].timeLow);\par
  980             Serial.println(F(" ms "));\par
  981 \par
  982             Serial.print(measurment);\par
  983             Serial.print(F(" < " ));\par
  984             Serial.println(this->actors[actorNumber].rangeLow);\par
  985     \par
  986             Serial.println(F("actor ON "));\par
  987     \par
  988         #endif  \par
  989 \par
  990         \}\par
  991         else \par
  992         \{\par
  993             bitWrite( this->action , actorNumber , 0) ; \par
  994 \par
  995         #if DEBUG == 1 \par
  996 \par
  997             Serial.print(F("actor was off for at least "));\par
  998             Serial.print(this->actors[actorNumber].timeLow);\par
  999             Serial.println(F(" ms "));\par
 1000 \par
 1001             Serial.print(measurment);\par
 1002             Serial.print(F(" > " ));\par
 1003             Serial.println(this->actors[actorNumber].rangeLow);\par
 1004 \par
 1005             Serial.println(F("actor OFF "));\par
 1006     \par
 1007         #endif              \par
 1008 \par
 1009         \}\par
 1010 \par
 1011     \}\par
 1012 \par
 1013     \par
 1014 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_af44bc8a08818e4433dfb1c7104601f12_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v normalAction\:Jetpack}
{\xe \v Jetpack\:normalAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::normalAction (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::normalAction(actorNumber , measured value): This method is provided to handle normal actors. it changes the action according to wether the measured value is: > rangeHigh ( deactivate actor) or < rangeLow (activate actor ) \par
}{
Definition at line 637 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   638 \{\par
  639 \par
  640 #if DEBUG == 1\par
  641     \par
  642     Serial.print(F("none inverted Actor N\'B0 : "));\par
  643     Serial.println(actorNumber);\par
  644 \par
  645     Serial.print(F("measured value : "));\par
  646     Serial.println(measurment);\par
  647 \par
  648     Serial.print(F("high range : "));\par
  649     Serial.println(this->actors[actorNumber].rangeHigh);\par
  650 \par
  651     Serial.print(F("low range : "));\par
  652     Serial.println(this->actors[actorNumber].rangeLow);\par
  653 \par
  654 #endif\par
  655 \par
  656     //measured value lower than minimum range : activate actor\par
  657     if(measurment < this->actors[actorNumber].rangeLow)\par
  658     \{\par
  659         bitWrite( this->action , actorNumber , 1) ;\par
  660 \par
  661     #if DEBUG == 1 \par
  662 \par
  663         Serial.println(F("actor ON "));\par
  664     \par
  665     #endif\par
  666                 \par
  667     \}\par
  668     //measured value higher than maximum range : deactivate actor\par
  669     else if(measurment > this->actors[actorNumber].rangeHigh)\par
  670     \{\par
  671         bitWrite( this->action , actorNumber , 0) ;\par
  672 \par
  673     #if DEBUG == 1 \par
  674 \par
  675         Serial.println(F("actor OFF "));\par
  676     \par
  677     #endif\par
  678     \par
  679     \}\par
  680 \par
  681 \par
  682 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a65ce9533c39fa71e4945b970bf14b980_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:Jetpack}
{\xe \v Jetpack\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::printConf ()}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 543 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   544 \{\par
  545 \par
  546 #if DEBUG == 1 \par
  547 \par
  548     Serial.println( F("Enter Jetpack.printConf() ") );\par
  549     Serial.println();\par
  550 \par
  551 #endif \par
  552     Serial.println(F( "Jetpack configuration " ) ) ;\par
  553  \par
  554         for(int i=0;i<8;i++)\par
  555     \{   \par
  556         Serial.print(F("actor N\'B0"));\par
  557         Serial.print(i);\par
  558         Serial.print(F(" actif :"));\par
  559         Serial.println(this->actors[i].actif);\par
  560         \par
  561         Serial.print(F("actor N\'B0"));\par
  562         Serial.print(i);\par
  563         Serial.print(F(" temporal :"));\par
  564         Serial.println(this->actors[i].temporal);\par
  565 \par
  566         Serial.print(F("actor N\'B0"));\par
  567         Serial.print(i);\par
  568         Serial.print(F(" inverted :"));\par
  569         Serial.println(this->actors[i].inverted);\par
  570 \par
  571 \par
  572         Serial.print(F("actor N\'B0"));\par
  573         Serial.print(i);\par
  574         Serial.print(F(" primary Type :"));\par
  575         Serial.println(this->actors[i].primaryType);\par
  576 \par
  577         Serial.print(F("actor N\'B0"));\par
  578         Serial.print(i);\par
  579         Serial.print(F(" secondary Type :"));       \par
  580         Serial.println(this->actors[i].secondaryType);\par
  581 \par
  582         Serial.print(F("actor N\'B0"));\par
  583         Serial.print(i);\par
  584         Serial.print(F(" range Low :"));\par
  585         Serial.println(this->actors[i].rangeLow);\par
  586 \par
  587         Serial.print(F("actor N\'B0"));\par
  588         Serial.print(i);\par
  589         Serial.print(F(" time Low :"));\par
  590         Serial.println(this->actors[i].timeLow);\par
  591 \par
  592         Serial.print(F("actor N\'B0"));\par
  593         Serial.print(i);\par
  594         Serial.print(F(" hour low:"));\par
  595         Serial.println(this->actors[i].hourLow);\par
  596 \par
  597         Serial.print(F("actor N\'B0"));\par
  598         Serial.print(i);\par
  599         Serial.print(F(" minute low:"));\par
  600         Serial.println(this->actors[i].minuteLow);\par
  601 \par
  602         Serial.print(F("actor N\'B0"));\par
  603         Serial.print(i);\par
  604         Serial.print(F(" range High:"));\par
  605         Serial.println(this->actors[i].rangeHigh);\par
  606 \par
  607         Serial.print(F("actor N\'B0"));\par
  608         Serial.print(i);\par
  609         Serial.print(F(" time High:"));\par
  610         Serial.println(this->actors[i].timeHigh);\par
  611 \par
  612         Serial.print(F("actor N\'B0"));\par
  613         Serial.print(i);\par
  614         Serial.print(F(" hour high:"));\par
  615         Serial.println(this->actors[i].hourHigh);\par
  616 \par
  617         Serial.print(F("actor N\'B0"));\par
  618         Serial.print(i);\par
  619         Serial.print(F(" minute high:"));\par
  620         Serial.println(this->actors[i].minuteHigh);\par
  621 \par
  622         Serial.println(); \par
  623 \par
  624     \}\par
  625 \par
  626     Serial.println();\par
  627 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ac54a7bb4f9166bee32052253d9b1d306_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOff\:Jetpack}
{\xe \v Jetpack\:temporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::temporalActionOff (int  {\i actorNumber})}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::temporalActionOff(actorNumber ): This method is provided to handle temporal actors. it changes the action according to:\par
currentTime - startTime > timeHigh : deactivate actor \par
}{
Definition at line 749 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   750 \{\par
  751 \par
  752 #if DEBUG == 1\par
  753     \par
  754     Serial.print(F("temporal Actor N\'B0 : "));\par
  755     Serial.println(actorNumber);\par
  756 \par
  757     Serial.print(F("millis : "));\par
  758     Serial.println(millis());\par
  759 \par
  760     Serial.print(F("actif Time : "));\par
  761     Serial.println(this->actors[actorNumber].actifTime);\par
  762 \par
  763     Serial.print(F("high time : "));\par
  764     Serial.println(this->actors[actorNumber].timeHigh);\par
  765 \par
  766 \par
  767 #endif\par
  768     \par
  769     if( ( millis()- this->actors[actorNumber].actifTime  ) >= (  this->actors[actorNumber].timeHigh  ) )\par
  770     \{\par
  771         //stop the actor\par
  772         bitWrite( this->action , actorNumber , 0) ;\par
  773 \par
  774         //make the actor inactif:\par
  775         this->actors[actorNumber].actif=0;\par
  776 \par
  777         //start the low timer\par
  778         this->actors[actorNumber].inactifTime=millis();\par
  779 \par
  780     #if DEBUG == 1 \par
  781 \par
  782         Serial.println(F("actor OFF "));\par
  783     \par
  784     #endif\par
  785                 \par
  786     \}   \par
  787 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a2991b302cd99bf89325f9b66b104d575_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOn\:Jetpack}
{\xe \v Jetpack\:temporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::temporalActionOn (int  {\i actorNumber})}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::temporalActionOn(actorNumber ): This method is provided to handle temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : activate actor \par
}{
Definition at line 886 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   887 \{\par
  888 \par
  889 #if DEBUG == 1\par
  890     \par
  891     Serial.print(F("temporal Actor N\'B0 : "));\par
  892     Serial.println(actorNumber);\par
  893 \par
  894     Serial.print(F("millis : "));\par
  895     Serial.println(millis());\par
  896 \par
  897     Serial.print(F("inactif Time : "));\par
  898     Serial.println(this->actors[actorNumber].inactifTime);\par
  899 \par
  900     Serial.print(F("low time : "));\par
  901     Serial.println(this->actors[actorNumber].timeLow);\par
  902 \par
  903 \par
  904 #endif\par
  905     \par
  906      if( ( millis() - this->actors[actorNumber].inactifTime ) >= (  this->actors[actorNumber].timeLow  ) )\par
  907     \{\par
  908         //start the actor\par
  909         bitWrite( this->action , actorNumber , 1) ;\par
  910 \par
  911         //make the actor actif:\par
  912         this->actors[actorNumber].actif=1;\par
  913 \par
  914         //start the low timer\par
  915         this->actors[actorNumber].actifTime=millis();\par
  916 \par
  917     #if DEBUG == 1 \par
  918 \par
  919         Serial.println(F("actor ON "));\par
  920 \par
  921     #endif              \par
  922 \par
  923     \}\par
  924 \par
  925 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ad011d904f639accb5f94ef806846ef59_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:Jetpack}
{\xe \v Jetpack\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::write (byte  {\i action})}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::write(action): This method is provided to write the given action to the entire {\b Jetpack} action is a Byte (8 bits ), each bit goes to an output. MSBFirst \par
}{
Definition at line 77 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    78 \{\par
   79 \par
   80 #if DEBUG == 1\par
   81 \par
   82     Serial.println( F("Entering Jetpack.write()") );\par
   83     Serial.println();\par
   84 \par
   85     Serial.println( F("writing this action : ") );\par
   86     Serial.println(action,BIN);\par
   87     Serial.println();\par
   88 \par
   89 #endif \par
   90 \par
   91     this->action=action;\par
   92 \par
   93     \par
   94     digitalWrite(EnI2C, LOW);\par
   95     \par
   96     shiftOut(dataPin, clockPin, MSBFIRST, this->action);\par
   97 \par
   98     digitalWrite(EnI2C, HIGH);\par
   99 \par
  100 \par
  101 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a338f1af8cbc6504ac69b47c7328569b5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeBit\:Jetpack}
{\xe \v Jetpack\:writeBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::writeBit (byte  {\i pin}, bool  {\i state})}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin \par
}{
Definition at line 108 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   109 \{\par
  110 \par
  111 #if DEBUG == 1 \par
  112 \par
  113     Serial.println( F("Entering Jetpack.writeBit() ") );\par
  114 \par
  115     Serial.print( F("Writing ") );\par
  116     Serial.print(state);\par
  117 \par
  118     Serial.print( F("to pin N\'B0") );\par
  119     Serial.print(pin);\par
  120 \par
  121     Serial.println();\par
  122 \par
  123 #endif\par
  124 \par
  125     bitWrite(this->action, pin, state);\par
  126     digitalWrite(EnI2C, LOW);\par
  127     \par
  128     shiftOut(dataPin, clockPin, MSBFIRST, this->action);\par
  129 \par
  130     digitalWrite(EnI2C, HIGH);\par
  131 \par
  132 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a79ae7bc3c1828a0551a7c005c4f8bd00_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v action\:Jetpack}
{\xe \v Jetpack\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte Jetpack::action = B00000000{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\b Jetpack}'s Action \par
}{
Definition at line 90 of file Jetpack.h.}\par
}
{\xe \v actors\:Jetpack}
{\xe \v Jetpack\:actors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Jetpack::state} Jetpack::actors[8]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clockPin\:Jetpack}
{\xe \v Jetpack\:clockPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Jetpack::clockPin = 4{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clock pin for the shift register \par
}{
Definition at line 184 of file Jetpack.h.}\par
}
{\xe \v dataPin\:Jetpack}
{\xe \v Jetpack\:dataPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Jetpack::dataPin = 15{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data pin for the shift register \par
}{
Definition at line 189 of file Jetpack.h.}\par
}
{\xe \v EnI2C\:Jetpack}
{\xe \v Jetpack\:EnI2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Jetpack::EnI2C =5{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C Enable pin \par
}{
Definition at line 194 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardSensors::lightActive Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive}
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
Collaboration diagram for CoolBoardSensors::lightActive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d9f/struct_cool_board_sensors_1_1light_active__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ir} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b uv} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b lightActive} structure\par
set visible to 1 to have visibleLight Readings\par
set ir to 1 to have infraRed Readings\par
set uv to 1 to have ultraViolet Readings \par
}{
Definition at line 106 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ir\:CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive\:ir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::lightActive::ir =0}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolBoardSensors.h.}\par
}
{\xe \v uv\:CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive\:uv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::lightActive::uv =0}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file CoolBoardSensors.h.}\par
}
{\xe \v visible\:CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::lightActive::visible =0}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NDIR_I2C Class Reference\par \pard\plain 
{\tc\tcl2 \v NDIR_I2C}
{\xe \v NDIR_I2C}
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
\par
{
{\f2 #include <CoolNDIR_I2C.h>}}\par
Collaboration diagram for NDIR_I2C:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/dff/class_n_d_i_r___i2_c__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NDIR_I2C} (uint8_t {\b i2c_addr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b measure} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b i2c_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ppm}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b send} (uint8_t *pdata, uint8_t n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b receive} (uint8_t *pbuf, uint8_t n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b read_register} (uint8_t reg_addr, uint8_t *pval)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b write_register} (uint8_t reg_addr, uint8_t *pdata, uint8_t n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b write_register} (uint8_t reg_addr, uint8_t val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b parse} (uint8_t *pbuf)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint8_t {\b cmd_measure} [9] = \{0xFF,0x01,0x9C,0x00,0x00,0x00,0x00,0x00,0x63\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 27 of file CoolNDIR_I2C.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NDIR_I2C\:NDIR_I2C}
{\xe \v NDIR_I2C\:NDIR_I2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NDIR_I2C::NDIR_I2C (uint8_t  {\i i2c_addr})}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    78 \{\par
   79     if (i2c_addr >= 8 && i2c_addr < 120) \{\par
   80         NDIR_I2C::i2c_addr = i2c_addr;\par
   81     \} else \{\par
   82         NDIR_I2C::i2c_addr = 0;\par
   83     \}\par
   84 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:NDIR_I2C}
{\xe \v NDIR_I2C\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::begin (void )}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    88 \{\par
   89     if (i2c_addr) \{\par
   90         WIRE.begin(2,14);\par
   91         write_register(IOCONTROL, 0x08);\par
   92 \par
   93         if (write_register(FCR, 0x07)) \{\par
   94             if (write_register(LCR, 0x83)) \{\par
   95                 if (write_register(DLL, 0x60)) \{\par
   96                     if (write_register(DLH, 0x00)) \{\par
   97                         if (write_register(LCR, 0x03)) \{\par
   98                             if (measure()) \{\par
   99                                 return true;\par
  100                             \}\par
  101                         \}\par
  102                     \}\par
  103                 \}\par
  104             \}\par
  105         \}\par
  106     \}\par
  107 \par
  108     return false;\par
  109 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_acf82f3dcb41e75709a93f8b68d087a3c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v measure\:NDIR_I2C}
{\xe \v NDIR_I2C\:measure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::measure ()}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   112 \{\par
  113     uint8_t buf[9];\par
  114 \par
  115     if (i2c_addr) \{\par
  116         if (write_register(FCR, 0x07)) \{\par
  117             delayMicroseconds(1);\par
  118 \par
  119             if (send(cmd_measure, 9)) \{\par
  120                 if (receive(buf, 9)) \{\par
  121                     if (parse(buf)) \{\par
  122                         return true;\par
  123                     \}\par
  124                 \}\par
  125             \}\par
  126         \}\par
  127     \}\par
  128 \par
  129     return false;\par
  130 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_ab8f50d38501d498b802b822bd4844ede_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_ab8f50d38501d498b802b822bd4844ede_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v parse\:NDIR_I2C}
{\xe \v NDIR_I2C\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::parse (uint8_t *  {\i pbuf}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134 \{\par
  135     uint8_t i;\par
  136     uint8_t checksum = 0;\par
  137 \par
  138     for (i=0; i<9; i++) \{\par
  139         checksum += pbuf[i];\par
  140     \}\par
  141 \par
  142     if (pbuf[0] == 0xFF && pbuf[1] == 0x9C && checksum == 0xFF) \{\par
  143         ppm = (uint32_t)pbuf[2] << 24 | (uint32_t)pbuf[3] << 16 | (uint32_t)pbuf[4] << 8 | pbuf[5];\par
  144         return true;\par
  145     \} else \{\par
  146         return false;\par
  147     \}\par
  148 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_a907b756fc9244c7398b7d187b73cde94_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read_register\:NDIR_I2C}
{\xe \v NDIR_I2C\:read_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::read_register (uint8_t  {\i reg_addr}, uint8_t *  {\i pval}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 208 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   209 \{\par
  210     uint8_t result;\par
  211 \par
  212     WIRE.beginTransmission(i2c_addr);\par
  213     WIRE.write(reg_addr << 3);\par
  214 \par
  215     if (WIRE.endTransmission() != 0) \{\par
  216         return false;\par
  217     \}\par
  218 \par
  219     if (WIRE.requestFrom(i2c_addr, (uint8_t)1) != 1) \{\par
  220         return false;\par
  221     \}\par
  222 \par
  223    *pval = WIRE.read();\par
  224     return true;\par
  225 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aa72058e6e7c6174b14466fee4b2df1e0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v receive\:NDIR_I2C}
{\xe \v NDIR_I2C\:receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::receive (uint8_t *  {\i pbuf}, uint8_t  {\i n}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 166 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   166                                                   \{\par
  167     uint8_t  i;\par
  168     uint8_t  rx_level;\par
  169     uint32_t start = millis();\par
  170 \par
  171     while (n) \{\par
  172         if (read_register(RXLVL, &rx_level)) \{\par
  173             if (rx_level > n) \{\par
  174                 rx_level = n;\par
  175             \}\par
  176 \par
  177             if (rx_level) \{\par
  178                 WIRE.beginTransmission(i2c_addr);\par
  179                 WIRE.write(RHR << 3);\par
  180 \par
  181                 if (WIRE.endTransmission() != 0) \{\par
  182                     return false;\par
  183                 \}//delay(10);\par
  184 \par
  185                 if (rx_level == WIRE.requestFrom(i2c_addr, rx_level)) \{\par
  186                     for (i=0; i<rx_level; i++) \{\par
  187                        *pbuf = WIRE.read();\par
  188                         pbuf++;\par
  189                         n--;\par
  190                     \}\par
  191                 \} else \{\par
  192                     return false;\par
  193                 \}\par
  194             \}\par
  195         \} else \{\par
  196             return false;\par
  197         \}\par
  198 \par
  199         if (millis() - start > RECEIVE_TIMEOUT) \{\par
  200             return false;\par
  201         \}\par
  202     \}\par
  203 \par
  204     return true;\par
  205 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aa6d2b8dd287f9c9015461cebb18f9abc_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aa6d2b8dd287f9c9015461cebb18f9abc_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:NDIR_I2C}
{\xe \v NDIR_I2C\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::send (uint8_t *  {\i pdata}, uint8_t  {\i n}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   151                                                 \{\par
  152     uint8_t result;\par
  153 \par
  154     if (read_register(TXLVL, &result)) \{\par
  155         if (result >= n) \{\par
  156             if (write_register(THR, pdata, n)) \{\par
  157                 return true;\par
  158             \}\par
  159         \}\par
  160     \}\par
  161 \par
  162     return false;\par
  163 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aab0c04c2b7d08e99d12af044df179f0c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aab0c04c2b7d08e99d12af044df179f0c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write_register\:NDIR_I2C}
{\xe \v NDIR_I2C\:write_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::write_register (uint8_t  {\i reg_addr}, uint8_t *  {\i pdata}, uint8_t  {\i n}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 228 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   229 \{\par
  230     uint8_t result;\par
  231 \par
  232     WIRE.beginTransmission(i2c_addr);\par
  233     WIRE.write(reg_addr << 3);\par
  234 \par
  235     while (n--) \{\par
  236         WIRE.write(*pdata);\par
  237         pdata++;\par
  238     \}\par
  239 \par
  240     if (WIRE.endTransmission() != 0) \{\par
  241         return false;\par
  242     \} else \{\par
  243         return true;\par
  244     \}\par
  245 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_a5de6a044b00e985f035edca07521e319_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write_register\:NDIR_I2C}
{\xe \v NDIR_I2C\:write_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::write_register (uint8_t  {\i reg_addr}, uint8_t  {\i val}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 248 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     return write_register(reg_addr, &val, 1);\par
  251 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_a8ad2a76f9866b0a1f34810a147b4b20d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cmd_measure\:NDIR_I2C}
{\xe \v NDIR_I2C\:cmd_measure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::cmd_measure = \{0xFF,0x01,0x9C,0x00,0x00,0x00,0x00,0x00,0x63\}{\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolNDIR_I2C.h.}\par
}
{\xe \v i2c_addr\:NDIR_I2C}
{\xe \v NDIR_I2C\:i2c_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::i2c_addr}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolNDIR_I2C.h.}\par
}
{\xe \v ppm\:NDIR_I2C}
{\xe \v NDIR_I2C\:ppm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t NDIR_I2C::ppm}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file CoolNDIR_I2C.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Irene3000::parameters_T Struct Reference\par \pard\plain 
{\tc\tcl2 \v Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T}
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
Collaboration diagram for Irene3000::parameters_T:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/df5/struct_irene3000_1_1parameters___t__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b WriteCheck} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pH7Cal}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pH4Cal} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pHStep} =1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PH Sensor Calibration parameters\par
pH7Cal : PH 7 Calibration value\par
pH4Cal : PH 4 Calibration value\par
pHStep : PH Slope Step value \par
}{
Definition at line 111 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v pH4Cal\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:pH4Cal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::parameters_T::pH4Cal =0}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file Irene3000.h.}\par
}
{\xe \v pH7Cal\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:pH7Cal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::parameters_T::pH7Cal}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file Irene3000.h.}\par
}
{\xe \v pHStep\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:pHStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Irene3000::parameters_T::pHStep =1}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file Irene3000.h.}\par
}
{\xe \v WriteCheck\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:WriteCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Irene3000::parameters_T::WriteCheck =0}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensors::sensor Struct Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor}
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
Collaboration diagram for ExternalSensors::sensor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/db6/struct_external_sensors_1_1sensor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b reference} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b type} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b address} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BaseExternalSensor} * {\b exSensor} =NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of 50 External Sensors\par
An External Sensor is described by :\par
{\b sensor.reference} : the sensor's reference ( {\b NDIR_I2C}...)\par
{\b sensor.type} : the sensor's Type ( CO2 , Temperature , .... )\par
{\b sensor.address} : the sensor's Address if it has one\par
{\b sensor.exSensor} : pointer to the dynmacially instanciated sensor \par
}{
Definition at line 76 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v address\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ExternalSensors::sensor::address =0}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file ExternalSensors.h.}\par
}
{\xe \v exSensor\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:exSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BaseExternalSensor}* ExternalSensors::sensor::exSensor =NULL}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file ExternalSensors.h.}\par
}
{\xe \v reference\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String ExternalSensors::sensor::reference =""}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file ExternalSensors.h.}\par
}
{\xe \v type\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String ExternalSensors::sensor::type =""}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SensorCalibration Struct Reference\par \pard\plain 
{\tc\tcl2 \v SensorCalibration}
{\xe \v SensorCalibration}
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\par
{
{\f2 #include <CoolSparkFunBME280.h>}}\par
Collaboration diagram for SensorCalibration:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d4a/struct_sensor_calibration__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b dig_T1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_T2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_T3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b dig_P1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P5}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P6}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P7}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P9}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_H1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_H2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_H3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_H4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_H5}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_H6}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 115 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dig_H1\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorCalibration::dig_H1}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H2\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_H2}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H3\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorCalibration::dig_H3}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H4\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_H4}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H5\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_H5}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H6\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorCalibration::dig_H6}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P1\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SensorCalibration::dig_P1}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P2\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P2}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P3\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P3}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P4\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P4}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P5\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P5}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P6\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P6}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P7\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P7}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P8\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P8}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P9\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P9}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_T1\:SensorCalibration}
{\xe \v SensorCalibration\:dig_T1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SensorCalibration::dig_T1}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_T2\:SensorCalibration}
{\xe \v SensorCalibration\:dig_T2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_T2}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_T3\:SensorCalibration}
{\xe \v SensorCalibration\:dig_T3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_T3}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SensorSettings Struct Reference\par \pard\plain 
{\tc\tcl2 \v SensorSettings}
{\xe \v SensorSettings}
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
\par
{
{\f2 #include <CoolSparkFunBME280.h>}}\par
Collaboration diagram for SensorSettings:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d99/struct_sensor_settings__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b commInterface}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b I2CAddress}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b chipSelectPin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b runMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b tStandby}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b filter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b tempOverSample}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b pressOverSample}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b humidOverSample}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 95 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v chipSelectPin\:SensorSettings}
{\xe \v SensorSettings\:chipSelectPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::chipSelectPin}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolSparkFunBME280.h.}\par
}
{\xe \v commInterface\:SensorSettings}
{\xe \v SensorSettings\:commInterface}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::commInterface}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolSparkFunBME280.h.}\par
}
{\xe \v filter\:SensorSettings}
{\xe \v SensorSettings\:filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::filter}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolSparkFunBME280.h.}\par
}
{\xe \v humidOverSample\:SensorSettings}
{\xe \v SensorSettings\:humidOverSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::humidOverSample}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolSparkFunBME280.h.}\par
}
{\xe \v I2CAddress\:SensorSettings}
{\xe \v SensorSettings\:I2CAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::I2CAddress}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolSparkFunBME280.h.}\par
}
{\xe \v pressOverSample\:SensorSettings}
{\xe \v SensorSettings\:pressOverSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::pressOverSample}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolSparkFunBME280.h.}\par
}
{\xe \v runMode\:SensorSettings}
{\xe \v SensorSettings\:runMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::runMode}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolSparkFunBME280.h.}\par
}
{\xe \v tempOverSample\:SensorSettings}
{\xe \v SensorSettings\:tempOverSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::tempOverSample}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file CoolSparkFunBME280.h.}\par
}
{\xe \v tStandby\:SensorSettings}
{\xe \v SensorSettings\:tStandby}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::tStandby}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Irene3000::state Struct Reference\par \pard\plain 
{\tc\tcl2 \v Irene3000::state}
{\xe \v Irene3000::state}
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
Collaboration diagram for Irene3000::state:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d72/struct_irene3000_1_1state__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b active} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b gain} ={\b GAIN_TWOTHIRDS}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b type} =""\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene sensors state struct\par
active : if the related sensor is active or not\par
gain : what is the used gain for the related sensor (used only for the free channel)\par
type : the type of the used sensor(used only for the free channel ) \par
}{
Definition at line 128 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v active\:Irene3000::state}
{\xe \v Irene3000::state\:active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Irene3000::state::active =0}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file Irene3000.h.}\par
}
{\xe \v gain\:Irene3000::state}
{\xe \v Irene3000::state\:gain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Irene3000::state::gain ={\b GAIN_TWOTHIRDS}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file Irene3000.h.}\par
}
{\xe \v type\:Irene3000::state}
{\xe \v Irene3000::state\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Irene3000::state::type =""}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Jetpack::state Struct Reference\par \pard\plain 
{\tc\tcl2 \v Jetpack::state}
{\xe \v Jetpack::state}
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
Collaboration diagram for Jetpack::state:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/da1/struct_jetpack_1_1state__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b actif} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b temporal} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inverted} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b primaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b secondaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b actifTime} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b inactifTime} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the Actor's state \par
}{
Definition at line 95 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actif\:Jetpack::state}
{\xe \v Jetpack::state\:actif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::state::actif =0}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
actif flag set to 1 when using an actor set to 0 otherwise \par
}{
Definition at line 102 of file Jetpack.h.}\par
}
{\xe \v actifTime\:Jetpack::state}
{\xe \v Jetpack::state\:actifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::actifTime =0}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
actifTime : period of Time spent actif , used in Temporal mode in ms \par
}{
Definition at line 171 of file Jetpack.h.}\par
}
{\xe \v hourHigh\:Jetpack::state}
{\xe \v Jetpack::state\:hourHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::hourHigh =0}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 163 of file Jetpack.h.}\par
}
{\xe \v hourLow\:Jetpack::state}
{\xe \v Jetpack::state\:hourLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::hourLow =0}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file Jetpack.h.}\par
}
{\xe \v inactifTime\:Jetpack::state}
{\xe \v Jetpack::state\:inactifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::inactifTime =0}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inactifTime : period of Time spent inactif , used in Temporal mode in ms \par
}{
Definition at line 177 of file Jetpack.h.}\par
}
{\xe \v inverted\:Jetpack::state}
{\xe \v Jetpack::state\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::state::inverted =0}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inverted flag set to 1 to declare an inverted actor set to 0 to declare a normal actor \par
}{
Definition at line 116 of file Jetpack.h.}\par
}
{\xe \v minuteHigh\:Jetpack::state}
{\xe \v Jetpack::state\:minuteHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::minuteHigh =0}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file Jetpack.h.}\par
}
{\xe \v minuteLow\:Jetpack::state}
{\xe \v Jetpack::state\:minuteLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::minuteLow =0}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file Jetpack.h.}\par
}
{\xe \v primaryType\:Jetpack::state}
{\xe \v Jetpack::state\:primaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Jetpack::state::primaryType =""}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"type":["temperature","hour"] the primary type is related to the sensor's type (type[0]) the secondary type if present is hour or minute or hourMinute (type[1]) if both types are present and valid, the actor is a mixedActor \par
}{
Definition at line 124 of file Jetpack.h.}\par
}
{\xe \v rangeHigh\:Jetpack::state}
{\xe \v Jetpack::state\:rangeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::rangeHigh =0}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"high":[30,2000,17,1]\par
rangeHigh : this is the maximum at which the actor becomes inactif(high[0])\par
timeHigh : this is the time the actor is on in temporal mode(high[1]) (ms)\par
hourHigh : this is the hour when to turn on the actor in temporal/hour(hourMinute) mode(high[2])\par
minuteHigh : this is the minute when to turn on the actor in temporal/minute(hourMinute) mode (high[3]) \par
}{
Definition at line 159 of file Jetpack.h.}\par
}
{\xe \v rangeLow\:Jetpack::state}
{\xe \v Jetpack::state\:rangeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::rangeLow =0}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"low":[20,5000,18,10]\par
rangeLow : this is the minimum at which the actor becomes actif (low[0])\par
timeLow : this is the time the actor is off in temporal mode (low[1]) (ms)\par
hour low :this is the hour when to turn off the actor in temporal/hour(hourMinute) mode (low[2] )\par
minute low :this is the minute when to turn off the actor in temporal/minute(hourMinute) mode (low[3]) \par
}{
Definition at line 139 of file Jetpack.h.}\par
}
{\xe \v secondaryType\:Jetpack::state}
{\xe \v Jetpack::state\:secondaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Jetpack::state::secondaryType =""}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file Jetpack.h.}\par
}
{\xe \v temporal\:Jetpack::state}
{\xe \v Jetpack::state\:temporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::state::temporal =0}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
temporal flag set to 1 to declare a temporal actor set to 0 otherwise \par
}{
Definition at line 109 of file Jetpack.h.}\par
}
{\xe \v timeHigh\:Jetpack::state}
{\xe \v Jetpack::state\:timeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::timeHigh =0}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 161 of file Jetpack.h.}\par
}
{\xe \v timeLow\:Jetpack::state}
{\xe \v Jetpack::state\:timeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::timeLow =0}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardActor::state Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardActor::state}
{\xe \v CoolBoardActor::state}
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
Collaboration diagram for CoolBoardActor::state:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d44/struct_cool_board_actor_1_1state__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b actif} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b temporal} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inverted} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b primaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b secondaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b actifTime} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b inactifTime} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the Actor's state \par
}{
Definition at line 87 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actif\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:actif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::state::actif =0}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
actif flag set to 1 when using an actor set to 0 otherwise \par
}{
Definition at line 94 of file CoolBoardActor.h.}\par
}
{\xe \v actifTime\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:actifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::actifTime =0}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
actifTime : period of Time spent actif , used in Temporal mode in ms \par
}{
Definition at line 163 of file CoolBoardActor.h.}\par
}
{\xe \v hourHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:hourHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::hourHigh =0}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file CoolBoardActor.h.}\par
}
{\xe \v hourLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:hourLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::hourLow =0}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file CoolBoardActor.h.}\par
}
{\xe \v inactifTime\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:inactifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::inactifTime =0}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inactifTime : period of Time spent inactif , used in Temporal mode in ms \par
}{
Definition at line 169 of file CoolBoardActor.h.}\par
}
{\xe \v inverted\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::state::inverted =0}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inverted flag set to 1 to declare an inverted actor set to 0 to declare a normal actor \par
}{
Definition at line 108 of file CoolBoardActor.h.}\par
}
{\xe \v minuteHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:minuteHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::minuteHigh =0}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file CoolBoardActor.h.}\par
}
{\xe \v minuteLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:minuteLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::minuteLow =0}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file CoolBoardActor.h.}\par
}
{\xe \v primaryType\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:primaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoardActor::state::primaryType =""}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"type":["temperature","hour"] the primary type is related to the sensor's type (type[0]) the secondary type if present is hour or minute or hourMinute (type[1]) if both types are present and valid, the actor is a mixedActor \par
}{
Definition at line 116 of file CoolBoardActor.h.}\par
}
{\xe \v rangeHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:rangeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::rangeHigh =0}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"high":[30,2000,17,1]\par
rangeHigh : this is the maximum at which the actor becomes inactif(high[0])\par
timeHigh : this is the time the actor is on in temporal mode(high[1]) (ms)\par
hourHigh : this is the hour when to turn on the actor in temporal/hour(hourMinute) mode(high[2])\par
minuteHigh : this is the minute when to turn on the actor in temporal/minute(hourMinute) mode (high[3]) \par
}{
Definition at line 151 of file CoolBoardActor.h.}\par
}
{\xe \v rangeLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:rangeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::rangeLow =0}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"low":[20,5000,18,10]\par
rangeLow : this is the minimum at which the actor becomes actif (low[0])\par
timeLow : this is the time the actor is off in temporal mode (low[1]) (ms)\par
hour low :this is the hour when to turn off the actor in temporal/hour(hourMinute) mode (low[2] )\par
minute low :this is the minute when to turn off the actor in temporal/minute(hourMinute) mode (low[3]) \par
}{
Definition at line 131 of file CoolBoardActor.h.}\par
}
{\xe \v secondaryType\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:secondaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoardActor::state::secondaryType =""}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file CoolBoardActor.h.}\par
}
{\xe \v temporal\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:temporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::state::temporal =0}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
temporal flag set to 1 to declare a temporal actor set to 0 otherwise \par
}{
Definition at line 101 of file CoolBoardActor.h.}\par
}
{\xe \v timeHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:timeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::timeHigh =0}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file CoolBoardActor.h.}\par
}
{\xe \v timeLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:timeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::timeLow =0}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WiFiManager Class Reference\par \pard\plain 
{\tc\tcl2 \v WiFiManager}
{\xe \v WiFiManager}
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
\par
{
{\f2 #include <WiFiManagerReadFileButton.h>}}\par
Collaboration diagram for WiFiManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d8d/class_wi_fi_manager__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManager} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b autoConnect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b autoConnect} (char const *apName, char const *apPassword=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b startConfigPortal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b startConfigPortal} (char const *apName, char const *apPassword=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getConfigPortalSSID} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetSettings} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConfigPortalTimeout} (unsigned long seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTimeout} (unsigned long seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConnectTimeout} (unsigned long seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDebugOutput} (boolean debug)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumSignalQuality} (int quality=8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAPStaticIPConfig} (IPAddress ip, IPAddress gw, IPAddress sn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSTAStaticIPConfig} (IPAddress ip, IPAddress gw, IPAddress sn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAPCallback} (void(*func)({\b WiFiManager} *))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSaveConfigCallback} (void(*func)(void))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addParameter} ({\b WiFiManagerParameter} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBreakAfterConfig} (boolean shouldBreak)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCustomHeadElement} (const char *element)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRemoveDuplicateAPs} (boolean removeDuplicates)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupConfigPortal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startWPS} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b connectWifi} (String ssid, String pass)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b waitForConnectResult} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleRoot} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleWifi} (boolean scan)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleWifiSave} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleInfo} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleReset} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleNotFound} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle204} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b handleFileRead} (String path)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b captivePortal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getContentType} (String filename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getRSSIasQuality} (int RSSI)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b isIp} (String str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b toStringIp} (IPAddress ip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Generic > void {\b DEBUG_WM} (Generic text)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > auto {\b optionalIPFromString} (T *obj, const char *s) -> decltype(obj->fromString(s))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b optionalIPFromString} (...) -> bool\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::unique_ptr< DNSServer > {\b dnsServer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::unique_ptr< ESP8266WebServer > {\b server}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _apName} = "no-net"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _apPassword} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b _ssid} = ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b _pass} = ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b _configPortalTimeout} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b _connectTimeout} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b _configPortalStart} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _ap_static_ip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _ap_static_gw}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _ap_static_sn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _sta_static_ip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _sta_static_gw}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _sta_static_sn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _paramsCount} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _minimumQuality} = -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _removeDuplicateAPs} = true\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _shouldBreakAfterConfig} = false\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _tryWPS} = false\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _customHeadElement} = ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b status} = WL_IDLE_STATUS\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const byte {\b DNS_PORT} = 53\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _debug} = true\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b _apcallback} )({\b WiFiManager} *) = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b _savecallback} )(void) = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} * {\b _params} [{\b WIFI_MANAGER_MAX_PARAMS}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 67 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WiFiManager\:WiFiManager}
{\xe \v WiFiManager\:WiFiManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManager::WiFiManager ()}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    65                          \{\par
   66 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addParameter\:WiFiManager}
{\xe \v WiFiManager\:addParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::addParameter ({\b WiFiManagerParameter} *  {\i p})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    68                                                       \{\par
   69   _params[_paramsCount] = p;\par
   70   _paramsCount++;\par
   71   DEBUG_WM("Adding parameter");\par
   72   DEBUG_WM(p->getID());\par
   73 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a62907428e5874de097d83c33ef46c80d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v autoConnect\:WiFiManager}
{\xe \v WiFiManager\:autoConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::autoConnect ()}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   129                                  \{\par
  130   String ssid = "ESP" + String(ESP.getChipId());\par
  131   return autoConnect(ssid.c_str(), NULL);\par
  132 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae3cdfa6b02edcfe63d7da4f696b62136_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v autoConnect\:WiFiManager}
{\xe \v WiFiManager\:autoConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::autoConnect (char const *  {\i apName}, char const *  {\i apPassword} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134                                                                            \{\par
  135   DEBUG_WM(F(""));\par
  136   DEBUG_WM(F("AutoConnect"));\par
  137 \par
  138   // read eeprom for ssid and pass\par
  139   //String ssid = getSSID();\par
  140   //String pass = getPassword();\par
  141 \par
  142   // attempt to connect; should it fail, fall back to AP\par
  143   WiFi.mode(WIFI_STA);\par
  144 \par
  145   if (connectWifi("", "") == WL_CONNECTED)   \{\par
  146     DEBUG_WM(F("IP Address:"));\par
  147     DEBUG_WM(WiFi.localIP());\par
  148     //connected\par
  149     return true;\par
  150   \}\par
  151 \par
  152   return startConfigPortal(apName, apPassword);\par
  153 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ab1d094034e5e3e36e2e1b3624edad469_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v captivePortal\:WiFiManager}
{\xe \v WiFiManager\:captivePortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::captivePortal (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Redirect to captive portal if we got a request for another domain. Return true in that case so the page handler do not try to handle the request again. \par
}{
Definition at line 746 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   746                                    \{\par
  747   if (!isIp(server->hostHeader()) ) \{\par
  748     DEBUG_WM(F("Request redirected to captive portal"));\par
  749     server->sendHeader("Location", String("http://") + toStringIp(server->client().localIP()), true);\par
  750     server->send ( 302, "text/plain", ""); // Empty content inhibits Content-length header so we have to close the socket ourselves.\par
  751     server->client().stop(); // Stop is needed because we sent no content length\par
  752     return true;\par
  753   \}\par
  754   return false;\par
  755 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a4ef4298deb224212e5242c456669a973_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a4ef4298deb224212e5242c456669a973_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectWifi\:WiFiManager}
{\xe \v WiFiManager\:connectWifi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::connectWifi (String  {\i ssid}, String  {\i pass}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 222 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   222                                                      \{\par
  223   DEBUG_WM(F("Connecting as wifi client..."));\par
  224 \par
  225   // check if we've got static_ip settings, if we do, use those.\par
  226   if (_sta_static_ip) \{\par
  227     DEBUG_WM(F("Custom STA IP/GW/Subnet"));\par
  228     WiFi.config(_sta_static_ip, _sta_static_gw, _sta_static_sn);\par
  229     DEBUG_WM(WiFi.localIP());\par
  230   \}\par
  231   //fix for auto connect racing issue\par
  232   if (WiFi.status() == WL_CONNECTED) \{\par
  233     DEBUG_WM("Already connected. Bailing out.");\par
  234     return WL_CONNECTED;\par
  235   \}\par
  236   //check if we have ssid and pass and force those, if not, try with last saved values\par
  237   if (ssid != "") \{\par
  238     WiFi.begin(ssid.c_str(), pass.c_str());\par
  239   \} else \{\par
  240     if (WiFi.SSID()) \{\par
  241       DEBUG_WM("Using last saved values, should be faster");\par
  242       //trying to fix connection in progress hanging\par
  243       ETS_UART_INTR_DISABLE();\par
  244       wifi_station_disconnect();\par
  245       ETS_UART_INTR_ENABLE();\par
  246 \par
  247       WiFi.begin();\par
  248     \} else \{\par
  249       DEBUG_WM("No saved credentials");\par
  250     \}\par
  251   \}\par
  252 \par
  253   int connRes = waitForConnectResult();\par
  254   DEBUG_WM ("Connection result: ");\par
  255   DEBUG_WM ( connRes );\par
  256   //not connected, WPS enabled, no pass - first attempt\par
  257   if (_tryWPS && connRes != WL_CONNECTED && pass == "") \{\par
  258     startWPS();\par
  259     //should be connected at the end of WPS\par
  260     connRes = waitForConnectResult();\par
  261   \}\par
  262   return connRes;\par
  263 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae0ae27b5543b47585728c084c3bbdca7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae0ae27b5543b47585728c084c3bbdca7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DEBUG_WM\:WiFiManager}
{\xe \v WiFiManager\:DEBUG_WM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Generic > void WiFiManager::DEBUG_WM (Generic  {\i text}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 780 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   780                                        \{\par
  781   if (_debug) \{\par
  782     Serial.print("*WM: ");\par
  783     Serial.println(text);\par
  784   \}\par
  785 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae5f595c670ccbcf9a191baf50f5c7c26_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getConfigPortalSSID\:WiFiManager}
{\xe \v WiFiManager\:getConfigPortalSSID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::getConfigPortalSSID ()}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 314 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314                                         \{\par
  315   return _apName;\par
  316 \}\par
}
}
{\xe \v getContentType\:WiFiManager}
{\xe \v WiFiManager\:getContentType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::getContentType (String  {\i filename}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 821 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   821                                                  \{\par
  822   if(server->hasArg("download")) return "application/octet-stream";\par
  823   else if(filename.endsWith(".htm")) return "text/html";\par
  824   else if(filename.endsWith(".html")) return "text/html";\par
  825   else if(filename.endsWith(".css")) return "text/css";\par
  826   else if(filename.endsWith(".js")) return "application/javascript";\par
  827   else if(filename.endsWith(".png")) return "image/png";\par
  828   else if(filename.endsWith(".gif")) return "image/gif";\par
  829   else if(filename.endsWith(".jpg")) return "image/jpeg";\par
  830   else if(filename.endsWith(".ico")) return "image/x-icon";\par
  831   else if(filename.endsWith(".xml")) return "text/xml";\par
  832   else if(filename.endsWith(".pdf")) return "application/x-pdf";\par
  833   else if(filename.endsWith(".zip")) return "application/x-zip";\par
  834   else if(filename.endsWith(".gz")) return "application/x-gzip";\par
  835   else if (filename.endsWith(".csv")) return "text/csv";\par
  836   return "text/plain";\par
  837 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a40f123fd290c3e331c9785d19a88f3b8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getRSSIasQuality\:WiFiManager}
{\xe \v WiFiManager\:getRSSIasQuality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::getRSSIasQuality (int  {\i RSSI}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 787 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   787                                           \{\par
  788   int quality = 0;\par
  789 \par
  790   if (RSSI <= -100) \{\par
  791     quality = 0;\par
  792   \} else if (RSSI >= -50) \{\par
  793     quality = 100;\par
  794   \} else \{\par
  795     quality = 2 * (RSSI + 100);\par
  796   \}\par
  797   return quality;\par
  798 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae71cfd6bd70ada2ca02e1d20b152d0e5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handle204\:WiFiManager}
{\xe \v WiFiManager\:handle204}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handle204 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleFileRead\:WiFiManager}
{\xe \v WiFiManager\:handleFileRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool WiFiManager::handleFileRead (String  {\i path}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the read file button \par
}{
Definition at line 676 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   677 \{\par
  678 \par
  679     DEBUG_WM(F("handleFileRead" ));\par
  680     DEBUG_WM(F("path : "));\par
  681     DEBUG_WM(path);\par
  682 \par
  683     if(path.endsWith("/"))\par
  684     \{\par
  685         path += "index.htm";\par
  686     \}\par
  687 \par
  688     DEBUG_WM(F("path modified : "));\par
  689     DEBUG_WM(path);\par
  690     \par
  691     \par
  692     String contentType = getContentType(path);\par
  693     String pathWithGz = path + ".gz";\par
  694     if(SPIFFS.exists(pathWithGz) || SPIFFS.exists(path))\par
  695     \{\par
  696 \par
  697         if(SPIFFS.exists(pathWithGz))\par
  698         \{\par
  699             path += ".gz";\par
  700         \}\par
  701 \par
  702         File file = SPIFFS.open(path, "r");\par
  703         size_t sent = server->streamFile(file, contentType);\par
  704         file.close();\par
  705         return true;\par
  706 \par
  707     \}\par
  708 \par
  709     return false;\par
  710 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a9e802fa4ca834a622f058a7176f47806_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a9e802fa4ca834a622f058a7176f47806_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleInfo\:WiFiManager}
{\xe \v WiFiManager\:handleInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleInfo (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the info page \par
}{
Definition at line 598 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   598                              \{\par
  599   DEBUG_WM(F("Info"));\par
  600 \par
  601   String page = FPSTR(HTTP_HEAD);\par
  602   page.replace("\{v\}", "Info");\par
  603   page += FPSTR(HTTP_SCRIPT);\par
  604   page += FPSTR(HTTP_STYLE);\par
  605   page += _customHeadElement;\par
  606   page += FPSTR(HTTP_HEAD_END);\par
  607   page += F("<dl>");\par
  608   page += F("<dt>Chip ID</dt><dd>");\par
  609   page += ESP.getChipId();\par
  610   page += F("</dd>");\par
  611   page += F("<dt>Flash Chip ID</dt><dd>");\par
  612   page += ESP.getFlashChipId();\par
  613   page += F("</dd>");\par
  614   page += F("<dt>IDE Flash Size</dt><dd>");\par
  615   page += ESP.getFlashChipSize();\par
  616   page += F(" bytes</dd>");\par
  617   page += F("<dt>Real Flash Size</dt><dd>");\par
  618   page += ESP.getFlashChipRealSize();\par
  619   page += F(" bytes</dd>");\par
  620   page += F("<dt>Soft AP IP</dt><dd>");\par
  621   page += WiFi.softAPIP().toString();\par
  622   page += F("</dd>");\par
  623   page += F("<dt>Soft AP MAC</dt><dd>");\par
  624   page += WiFi.softAPmacAddress();\par
  625   page += F("</dd>");\par
  626   page += F("<dt>Station MAC</dt><dd>");\par
  627   page += WiFi.macAddress();\par
  628   page += F("</dd>");\par
  629   page += F("</dl>");\par
  630   page += FPSTR(HTTP_END);\par
  631 \par
  632   server->send(200, "text/html", page);\par
  633 \par
  634   DEBUG_WM(F("Sent info page"));\par
  635 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ac35e46661f8a209d84bba62d9aa43a35_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ac35e46661f8a209d84bba62d9aa43a35_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleNotFound\:WiFiManager}
{\xe \v WiFiManager\:handleNotFound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleNotFound (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 722 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   722                                  \{\par
  723   if (captivePortal()) \{\par
  724         return;\par
  725   \}\par
  726   String message = "File Not Found\\n\\n";\par
  727   message += "URI: ";\par
  728   message += server->uri();\par
  729   message += "\\nMethod: ";\par
  730   message += ( server->method() == HTTP_GET ) ? "GET" : "POST";\par
  731   message += "\\nArguments: ";\par
  732   message += server->args();\par
  733   message += "\\n";\par
  734 \par
  735   for ( uint8_t i = 0; i < server->args(); i++ ) \{\par
  736     message += " " + server->argName ( i ) + ": " + server->arg ( i ) + "\\n";\par
  737   \}\par
  738   server->sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");\par
  739   server->sendHeader("Pragma", "no-cache");\par
  740   server->sendHeader("Expires", "-1");\par
  741   server->send ( 404, "text/plain", message );\par
  742 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a7d01f7de3e4b76acdabffac79fa3d0ab_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a7d01f7de3e4b76acdabffac79fa3d0ab_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleReset\:WiFiManager}
{\xe \v WiFiManager\:handleReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleReset (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the reset page \par
}{
Definition at line 638 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   638                               \{\par
  639   DEBUG_WM(F("Reset"));\par
  640 \par
  641   String page = FPSTR(HTTP_HEAD);\par
  642   page.replace("\{v\}", "Info");\par
  643   page += FPSTR(HTTP_SCRIPT);\par
  644   page += FPSTR(HTTP_STYLE);\par
  645   page += _customHeadElement;\par
  646   page += FPSTR(HTTP_HEAD_END);\par
  647   page += F("Module will reset in a few seconds.");\par
  648   page += FPSTR(HTTP_END);\par
  649   server->send(200, "text/html", page);\par
  650 \par
  651   DEBUG_WM(F("Sent reset page"));\par
  652   delay(5000);\par
  653   \par
  654   DEBUG_WM(F("reset ESP and Wifi configuration file"));\par
  655 \par
  656  //create json wifi count = 0 ,timeout=300,nomad=0\par
  657  const size_t bufferSize = JSON_OBJECT_SIZE(3) + 40;\par
  658  DynamicJsonBuffer jsonBuffer(bufferSize);\par
  659 \par
  660  const char* json = "\{\\"wifiCount\\":0,\\"timeOut\\":300,\\"nomad\\":0\}";\par
  661 \par
  662  JsonObject& root = jsonBuffer.parseObject(json);\par
  663 \par
  664  //open wifi file in w : delete contents\par
  665  File configFile = SPIFFS.open("/wifiConfig.json", "w");\par
  666  //write json in file \par
  667  root.printTo(configFile);\par
  668  //close file \par
  669  configFile.close();\par
  670  delay(500);\par
  671  ESP.reset();\par
  672  delay(2000);\par
  673 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a94fb1a8fcfbd0d02714c69138bf72f9c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a94fb1a8fcfbd0d02714c69138bf72f9c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleRoot\:WiFiManager}
{\xe \v WiFiManager\:handleRoot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleRoot (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle root or redirect to captive portal \par
}{
Definition at line 361 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   361                              \{\par
  362   DEBUG_WM(F("Handle root"));\par
  363   if (captivePortal()) \{ // If caprive portal redirect instead of displaying the page.\par
  364     return;\par
  365   \}\par
  366 \par
  367   String page = FPSTR(HTTP_HEAD);\par
  368   page.replace("\{v\}", "Options");\par
  369   page += FPSTR(HTTP_SCRIPT);\par
  370   page += FPSTR(HTTP_STYLE);\par
  371   page += _customHeadElement;\par
  372   page += FPSTR(HTTP_HEAD_END);\par
  373   page += "<h1>";\par
  374   page += _apName;\par
  375   page += "</h1>";\par
  376   page += F("<h3>WiFiManager</h3>");\par
  377   page += FPSTR(HTTP_PORTAL_OPTIONS);\par
  378   page += FPSTR(HTTP_END);\par
  379 \par
  380   server->send(200, "text/html", page);\par
  381 \par
  382 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a47e4c7df7478f690c53ff9f5125c9760_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a47e4c7df7478f690c53ff9f5125c9760_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleWifi\:WiFiManager}
{\xe \v WiFiManager\:handleWifi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleWifi (boolean  {\i scan}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wifi config page handler \par
}{
Definition at line 385 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   385                                          \{\par
  386 \par
  387   String page = FPSTR(HTTP_HEAD);\par
  388   page.replace("\{v\}", "Config ESP");\par
  389   page += FPSTR(HTTP_SCRIPT);\par
  390   page += FPSTR(HTTP_STYLE);\par
  391   page += _customHeadElement;\par
  392   page += FPSTR(HTTP_HEAD_END);\par
  393 \par
  394   if (scan) \{\par
  395     int n = WiFi.scanNetworks();\par
  396     DEBUG_WM(F("Scan done"));\par
  397     if (n == 0) \{\par
  398       DEBUG_WM(F("No networks found"));\par
  399       page += F("No networks found. Refresh to scan again.");\par
  400     \} else \{\par
  401 \par
  402       //sort networks\par
  403       int indices[n];\par
  404       for (int i = 0; i < n; i++) \{\par
  405         indices[i] = i;\par
  406       \}\par
  407 \par
  408       // RSSI SORT\par
  409 \par
  410       // old sort\par
  411       for (int i = 0; i < n; i++) \{\par
  412         for (int j = i + 1; j < n; j++) \{\par
  413           if (WiFi.RSSI(indices[j]) > WiFi.RSSI(indices[i])) \{\par
  414             std::swap(indices[i], indices[j]);\par
  415           \}\par
  416         \}\par
  417       \}\par
  418 \par
  419       /*std::sort(indices, indices + n, [](const int & a, const int & b) -> bool\par
  420         \{\par
  421         return WiFi.RSSI(a) > WiFi.RSSI(b);\par
  422         \});*/\par
  423 \par
  424       // remove duplicates ( must be RSSI sorted )\par
  425       if (_removeDuplicateAPs) \{\par
  426         String cssid;\par
  427         for (int i = 0; i < n; i++) \{\par
  428           if (indices[i] == -1) continue;\par
  429           cssid = WiFi.SSID(indices[i]);\par
  430           for (int j = i + 1; j < n; j++) \{\par
  431             if (cssid == WiFi.SSID(indices[j])) \{\par
  432               DEBUG_WM("DUP AP: " + WiFi.SSID(indices[j]));\par
  433               indices[j] = -1; // set dup aps to index -1\par
  434             \}\par
  435           \}\par
  436         \}\par
  437       \}\par
  438 \par
  439       //display networks in page\par
  440       for (int i = 0; i < n; i++) \{\par
  441         if (indices[i] == -1) continue; // skip dups\par
  442         DEBUG_WM(WiFi.SSID(indices[i]));\par
  443         DEBUG_WM(WiFi.RSSI(indices[i]));\par
  444         int quality = getRSSIasQuality(WiFi.RSSI(indices[i]));\par
  445 \par
  446         if (_minimumQuality == -1 || _minimumQuality < quality) \{\par
  447           String item = FPSTR(HTTP_ITEM);\par
  448           String rssiQ;\par
  449           rssiQ += quality;\par
  450           item.replace("\{v\}", WiFi.SSID(indices[i]));\par
  451           item.replace("\{r\}", rssiQ);\par
  452           if (WiFi.encryptionType(indices[i]) != ENC_TYPE_NONE) \{\par
  453             item.replace("\{i\}", "l");\par
  454           \} else \{\par
  455             item.replace("\{i\}", "");\par
  456           \}\par
  457           //DEBUG_WM(item);\par
  458           page += item;\par
  459           delay(0);\par
  460         \} else \{\par
  461           DEBUG_WM(F("Skipping due to quality"));\par
  462         \}\par
  463 \par
  464       \}\par
  465       page += "<br/>";\par
  466     \}\par
  467   \}\par
  468 \par
  469   page += FPSTR(HTTP_FORM_START);\par
  470   char parLength[2];\par
  471   // add the extra parameters to the form\par
  472   for (int i = 0; i < _paramsCount; i++) \{\par
  473     if (_params[i] == NULL) \{\par
  474       break;\par
  475     \}\par
  476 \par
  477     String pitem = FPSTR(HTTP_FORM_PARAM);\par
  478     if (_params[i]->getID() != NULL) \{\par
  479       pitem.replace("\{i\}", _params[i]->getID());\par
  480       pitem.replace("\{n\}", _params[i]->getID());\par
  481       pitem.replace("\{p\}", _params[i]->getPlaceholder());\par
  482       snprintf(parLength, 2, "%d", _params[i]->getValueLength());\par
  483       pitem.replace("\{l\}", parLength);\par
  484       pitem.replace("\{v\}", _params[i]->getValue());\par
  485       pitem.replace("\{c\}", _params[i]->getCustomHTML());\par
  486     \} else \{\par
  487       pitem = _params[i]->getCustomHTML();\par
  488     \}\par
  489 \par
  490     page += pitem;\par
  491   \}\par
  492   if (_params[0] != NULL) \{\par
  493     page += "<br/>";\par
  494   \}\par
  495 \par
  496   if (_sta_static_ip) \{\par
  497 \par
  498     String item = FPSTR(HTTP_FORM_PARAM);\par
  499     item.replace("\{i\}", "ip");\par
  500     item.replace("\{n\}", "ip");\par
  501     item.replace("\{p\}", "Static IP");\par
  502     item.replace("\{l\}", "15");\par
  503     item.replace("\{v\}", _sta_static_ip.toString());\par
  504 \par
  505     page += item;\par
  506 \par
  507     item = FPSTR(HTTP_FORM_PARAM);\par
  508     item.replace("\{i\}", "gw");\par
  509     item.replace("\{n\}", "gw");\par
  510     item.replace("\{p\}", "Static Gateway");\par
  511     item.replace("\{l\}", "15");\par
  512     item.replace("\{v\}", _sta_static_gw.toString());\par
  513 \par
  514     page += item;\par
  515 \par
  516     item = FPSTR(HTTP_FORM_PARAM);\par
  517     item.replace("\{i\}", "sn");\par
  518     item.replace("\{n\}", "sn");\par
  519     item.replace("\{p\}", "Subnet");\par
  520     item.replace("\{l\}", "15");\par
  521     item.replace("\{v\}", _sta_static_sn.toString());\par
  522 \par
  523     page += item;\par
  524 \par
  525     page += "<br/>";\par
  526   \}\par
  527 \par
  528   page += FPSTR(HTTP_FORM_END);\par
  529   page += FPSTR(HTTP_SCAN_LINK);\par
  530 \par
  531   page += FPSTR(HTTP_END);\par
  532 \par
  533   server->send(200, "text/html", page);\par
  534 \par
  535 \par
  536   DEBUG_WM(F("Sent config page"));\par
  537 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a57a9048175c1918340ab9d0a2c53601f_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a57a9048175c1918340ab9d0a2c53601f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleWifiSave\:WiFiManager}
{\xe \v WiFiManager\:handleWifiSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleWifiSave (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the WLAN save form and redirect to WLAN config page again \par
}{
Definition at line 540 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   540                                  \{\par
  541   DEBUG_WM(F("WiFi save"));\par
  542 \par
  543   //SAVE/connect here\par
  544   _ssid = server->arg("s").c_str();\par
  545   _pass = server->arg("p").c_str();\par
  546 \par
  547   //parameters\par
  548   for (int i = 0; i < _paramsCount; i++) \{\par
  549     if (_params[i] == NULL) \{\par
  550       break;\par
  551     \}\par
  552     //read parameter\par
  553     String value = server->arg(_params[i]->getID()).c_str();\par
  554     //store it in array\par
  555     value.toCharArray(_params[i]->_value, _params[i]->_length);\par
  556     DEBUG_WM(F("Parameter"));\par
  557     DEBUG_WM(_params[i]->getID());\par
  558     DEBUG_WM(value);\par
  559   \}\par
  560 \par
  561   if (server->arg("ip") != "") \{\par
  562     DEBUG_WM(F("static ip"));\par
  563     DEBUG_WM(server->arg("ip"));\par
  564     //_sta_static_ip.fromString(server->arg("ip"));\par
  565     String ip = server->arg("ip");\par
  566     optionalIPFromString(&_sta_static_ip, ip.c_str());\par
  567   \}\par
  568   if (server->arg("gw") != "") \{\par
  569     DEBUG_WM(F("static gateway"));\par
  570     DEBUG_WM(server->arg("gw"));\par
  571     String gw = server->arg("gw");\par
  572     optionalIPFromString(&_sta_static_gw, gw.c_str());\par
  573   \}\par
  574   if (server->arg("sn") != "") \{\par
  575     DEBUG_WM(F("static netmask"));\par
  576     DEBUG_WM(server->arg("sn"));\par
  577     String sn = server->arg("sn");\par
  578     optionalIPFromString(&_sta_static_sn, sn.c_str());\par
  579   \}\par
  580 \par
  581   String page = FPSTR(HTTP_HEAD);\par
  582   page.replace("\{v\}", "Credentials Saved");\par
  583   page += FPSTR(HTTP_SCRIPT);\par
  584   page += FPSTR(HTTP_STYLE);\par
  585   page += _customHeadElement;\par
  586   page += FPSTR(HTTP_HEAD_END);\par
  587   page += FPSTR(HTTP_SAVED);\par
  588   page += FPSTR(HTTP_END);\par
  589 \par
  590   server->send(200, "text/html", page);\par
  591 \par
  592   DEBUG_WM(F("Sent wifi save page"));\par
  593 \par
  594   connect = true; //signal ready to connect/reset\par
  595 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a2a8c2b60aa86dfdeab8a1a90f7122dc7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a2a8c2b60aa86dfdeab8a1a90f7122dc7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIp\:WiFiManager}
{\xe \v WiFiManager\:isIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::isIp (String  {\i str}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is this an IP? \par
}{
Definition at line 801 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   801                                     \{\par
  802   for (int i = 0; i < str.length(); i++) \{\par
  803     int c = str.charAt(i);\par
  804     if (c != '.' && (c < '0' || c > '9')) \{\par
  805       return false;\par
  806     \}\par
  807   \}\par
  808   return true;\par
  809 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a9c78a8774f746ec22a99d03a53baa607_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v optionalIPFromString\:WiFiManager}
{\xe \v WiFiManager\:optionalIPFromString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > auto WiFiManager::optionalIPFromString (T *  {\i obj}, const char *  {\i s}) -> decltype(  obj->fromString(s)  ) {\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file WiFiManagerReadFileButton.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   192                                                                                          \{\par
  193       return  obj->fromString(s);\par
  194     \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a6a94f08eb43e0871932556a4ccfa11b7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v optionalIPFromString\:WiFiManager}
{\xe \v WiFiManager\:optionalIPFromString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto WiFiManager::optionalIPFromString (  {\i ...}) -> bool {\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 195 of file WiFiManagerReadFileButton.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195                                            \{\par
  196       DEBUG_WM("NO fromString METHOD ON IPAddress, you need ESP8266 core 2.1.0 or newer for Custom IP configuration to work.");\par
  197       return false;\par
  198     \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_aa248b818eee0423b14a88c637f7c4637_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetSettings\:WiFiManager}
{\xe \v WiFiManager\:resetSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::resetSettings ()}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 318 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   318                                 \{\par
  319   DEBUG_WM(F("settings invalidated"));\par
  320   DEBUG_WM(F("THIS MAY CAUSE AP NOT TO START UP PROPERLY. YOU NEED TO COMMENT IT OUT AFTER ERASING THE DATA."));\par
  321   WiFi.disconnect(true);\par
  322   //delay(200);\par
  323 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a0027749816b6c66bc845d7c5db760a33_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setAPCallback\:WiFiManager}
{\xe \v WiFiManager\:setAPCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setAPCallback (void(*)({\b WiFiManager} *)  {\i func})}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 758 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   758                                                                           \{\par
  759   _apcallback = func;\par
  760 \}\par
}
}
{\xe \v setAPStaticIPConfig\:WiFiManager}
{\xe \v WiFiManager\:setAPStaticIPConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setAPStaticIPConfig (IPAddress  {\i ip}, IPAddress  {\i gw}, IPAddress  {\i sn})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 340 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   340                                                                               \{\par
  341   _ap_static_ip = ip;\par
  342   _ap_static_gw = gw;\par
  343   _ap_static_sn = sn;\par
  344 \}\par
}
}
{\xe \v setBreakAfterConfig\:WiFiManager}
{\xe \v WiFiManager\:setBreakAfterConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setBreakAfterConfig (boolean  {\i shouldBreak})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 356 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   356                                                          \{\par
  357   _shouldBreakAfterConfig = shouldBreak;\par
  358 \}\par
}
}
{\xe \v setConfigPortalTimeout\:WiFiManager}
{\xe \v WiFiManager\:setConfigPortalTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setConfigPortalTimeout (unsigned long  {\i seconds})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 328 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   328                                                               \{\par
  329   _configPortalTimeout = seconds * 1000;\par
  330 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a904006cb4d2c769e93bfdef336853766_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setConnectTimeout\:WiFiManager}
{\xe \v WiFiManager\:setConnectTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setConnectTimeout (unsigned long  {\i seconds})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 332 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   332                                                          \{\par
  333   _connectTimeout = seconds * 1000;\par
  334 \}\par
}
}
{\xe \v setCustomHeadElement\:WiFiManager}
{\xe \v WiFiManager\:setCustomHeadElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setCustomHeadElement (const char *  {\i element})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 768 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   768                                                           \{\par
  769   _customHeadElement = element;\par
  770 \}\par
}
}
{\xe \v setDebugOutput\:WiFiManager}
{\xe \v WiFiManager\:setDebugOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setDebugOutput (boolean  {\i debug})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 336 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   336                                               \{\par
  337   _debug = debug;\par
  338 \}\par
}
}
{\xe \v setMinimumSignalQuality\:WiFiManager}
{\xe \v WiFiManager\:setMinimumSignalQuality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setMinimumSignalQuality (int  {\i quality} = {\f2 8})}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 352 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   352                                                      \{\par
  353   _minimumQuality = quality;\par
  354 \}\par
}
}
{\xe \v setRemoveDuplicateAPs\:WiFiManager}
{\xe \v WiFiManager\:setRemoveDuplicateAPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setRemoveDuplicateAPs (boolean  {\i removeDuplicates})}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 773 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   773                                                                 \{\par
  774   _removeDuplicateAPs = removeDuplicates;\par
  775 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a4dd1dbf4f22900f226a3897b88155212_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setSaveConfigCallback\:WiFiManager}
{\xe \v WiFiManager\:setSaveConfigCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setSaveConfigCallback (void(*)(void)  {\i func})}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 763 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   763                                                             \{\par
  764   _savecallback = func;\par
  765 \}\par
}
}
{\xe \v setSTAStaticIPConfig\:WiFiManager}
{\xe \v WiFiManager\:setSTAStaticIPConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setSTAStaticIPConfig (IPAddress  {\i ip}, IPAddress  {\i gw}, IPAddress  {\i sn})}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 346 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   346                                                                                \{\par
  347   _sta_static_ip = ip;\par
  348   _sta_static_gw = gw;\par
  349   _sta_static_sn = sn;\par
  350 \}\par
}
}
{\xe \v setTimeout\:WiFiManager}
{\xe \v WiFiManager\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setTimeout (unsigned long  {\i seconds})}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 324 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   324                                                   \{\par
  325   setConfigPortalTimeout(seconds);\par
  326 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_aa6493d59c284ff245edb767ff684756d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_aa6493d59c284ff245edb767ff684756d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setupConfigPortal\:WiFiManager}
{\xe \v WiFiManager\:setupConfigPortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setupConfigPortal (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75                                     \{\par
   76   dnsServer.reset(new DNSServer());\par
   77   server.reset(new ESP8266WebServer(80));\par
   78 \par
   79   DEBUG_WM(F(""));\par
   80   _configPortalStart = millis();\par
   81 \par
   82   DEBUG_WM(F("Configuring access point... "));\par
   83   DEBUG_WM(_apName);\par
   84   if (_apPassword != NULL) \{\par
   85     if (strlen(_apPassword) < 8 || strlen(_apPassword) > 63) \{\par
   86       // fail passphrase to short or long!\par
   87       DEBUG_WM(F("Invalid AccessPoint password. Ignoring"));\par
   88       _apPassword = NULL;\par
   89     \}\par
   90     DEBUG_WM(_apPassword);\par
   91   \}\par
   92 \par
   93   //optional soft ip config\par
   94   if (_ap_static_ip) \{\par
   95     DEBUG_WM(F("Custom AP IP/GW/Subnet"));\par
   96     WiFi.softAPConfig(_ap_static_ip, _ap_static_gw, _ap_static_sn);\par
   97   \}\par
   98 \par
   99   if (_apPassword != NULL) \{\par
  100     WiFi.softAP(_apName, _apPassword);//password option\par
  101   \} else \{\par
  102     WiFi.softAP(_apName);\par
  103   \}\par
  104 \par
  105   delay(500); // Without delay I've seen the IP address blank\par
  106   DEBUG_WM(F("AP IP address: "));\par
  107   DEBUG_WM(WiFi.softAPIP());\par
  108 \par
  109   /* Setup the DNS server redirecting all the domains to the apIP */\par
  110   dnsServer->setErrorReplyCode(DNSReplyCode::NoError);\par
  111   dnsServer->start(DNS_PORT, "*", WiFi.softAPIP());\par
  112 \par
  113   /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\par
  114   server->on("/", std::bind(&WiFiManager::handleRoot, this));\par
  115   server->on("/wifi", std::bind(&WiFiManager::handleWifi, this, true));\par
  116   server->on("/0wifi", std::bind(&WiFiManager::handleWifi, this, false));\par
  117   server->on("/wifisave", std::bind(&WiFiManager::handleWifiSave, this));\par
  118   server->on("/i", std::bind(&WiFiManager::handleInfo, this));\par
  119   server->on("/r", std::bind(&WiFiManager::handleReset, this));\par
  120   //server->on("/generate_204", std::bind(&WiFiManager::handle204, this));  //Android/Chrome OS captive portal check.\par
  121   server->on("/fwlink", std::bind(&WiFiManager::handleRoot, this));  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\par
  122   server->on("/sensorsData.csv", std::bind(&WiFiManager::handleFileRead, this,"/sensorsData.csv"));\par
  123   server->onNotFound (std::bind(&WiFiManager::handleNotFound, this));\par
  124   server->begin(); // Web server start\par
  125   DEBUG_WM(F("HTTP server started"));\par
  126 \par
  127 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a1743325d0dd86d011df96b22d2a0ddd6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a1743325d0dd86d011df96b22d2a0ddd6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startConfigPortal\:WiFiManager}
{\xe \v WiFiManager\:startConfigPortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::startConfigPortal ()}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   155                                        \{\par
  156   String ssid = "ESP" + String(ESP.getChipId());\par
  157   return startConfigPortal(ssid.c_str(), NULL);\par
  158 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ad781751307f7f623956126096a09a545_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startConfigPortal\:WiFiManager}
{\xe \v WiFiManager\:startConfigPortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::startConfigPortal (char const *  {\i apName}, char const *  {\i apPassword} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   160                                                                                   \{\par
  161   //setup AP\par
  162   WiFi.mode(WIFI_AP_STA);\par
  163   DEBUG_WM("SET AP STA");\par
  164 \par
  165   _apName = apName;\par
  166   _apPassword = apPassword;\par
  167 \par
  168   //notify we entered AP mode\par
  169   if ( _apcallback != NULL) \{\par
  170     _apcallback(this);\par
  171   \}\par
  172 \par
  173   connect = false;\par
  174   setupConfigPortal();\par
  175 \par
  176   while (_configPortalTimeout == 0 || millis() < _configPortalStart + _configPortalTimeout) \{\par
  177     //DNS\par
  178     dnsServer->processNextRequest();\par
  179     //HTTP\par
  180     server->handleClient();\par
  181 \par
  182 \par
  183     if (connect) \{\par
  184       connect = false;\par
  185       delay(2000);\par
  186       DEBUG_WM(F("Connecting to new AP"));\par
  187 \par
  188       // using user-provided  _ssid, _pass in place of system-stored ssid and pass\par
  189       if (connectWifi(_ssid, _pass) != WL_CONNECTED) \{\par
  190         DEBUG_WM(F("Failed to connect."));\par
  191       \} else \{\par
  192         //connected\par
  193         WiFi.mode(WIFI_STA);\par
  194         //notify that configuration has changed and any optional parameters should be saved\par
  195         if ( _savecallback != NULL) \{\par
  196           //todo: check if any custom parameters actually exist, and check if they really changed maybe\par
  197           _savecallback();\par
  198         \}\par
  199         break;\par
  200       \}\par
  201 \par
  202       if (_shouldBreakAfterConfig) \{\par
  203         //flag set to exit after config after trying to connect\par
  204         //notify that configuration has changed and any optional parameters should be saved\par
  205         if ( _savecallback != NULL) \{\par
  206           //todo: check if any custom parameters actually exist, and check if they really changed maybe\par
  207           _savecallback();\par
  208         \}\par
  209         break;\par
  210       \}\par
  211     \}\par
  212     yield();\par
  213   \}\par
  214 \par
  215   server.reset();\par
  216   dnsServer.reset();\par
  217 \par
  218   return  WiFi.status() == WL_CONNECTED;\par
  219 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_afaca5021edffb4d9a5bd39f7b0f7a686_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startWPS\:WiFiManager}
{\xe \v WiFiManager\:startWPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::startWPS (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 288 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   288                            \{\par
  289   DEBUG_WM("START WPS");\par
  290   WiFi.beginWPSConfig();\par
  291   DEBUG_WM("END WPS");\par
  292 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_abcc403fc26a47f7a111d1271f1d0869e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_abcc403fc26a47f7a111d1271f1d0869e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v toStringIp\:WiFiManager}
{\xe \v WiFiManager\:toStringIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::toStringIp (IPAddress  {\i ip}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IP to String? \par
}{
Definition at line 812 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   812                                            \{\par
  813   String res = "";\par
  814   for (int i = 0; i < 3; i++) \{\par
  815     res += String((ip >> (8 * i)) & 0xFF) + ".";\par
  816   \}\par
  817   res += String(((ip >> 8 * 3)) & 0xFF);\par
  818   return res;\par
  819 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a8dfd64cefecbdf26242b16eca335c20b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v waitForConnectResult\:WiFiManager}
{\xe \v WiFiManager\:waitForConnectResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t WiFiManager::waitForConnectResult (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   265                                           \{\par
  266   if (_connectTimeout == 0) \{\par
  267     return WiFi.waitForConnectResult();\par
  268   \} else \{\par
  269     DEBUG_WM (F("Waiting for connection result with time out"));\par
  270     unsigned long start = millis();\par
  271     boolean keepConnecting = true;\par
  272     uint8_t status;\par
  273     while (keepConnecting) \{\par
  274       status = WiFi.status();\par
  275       if (millis() > start + _connectTimeout) \{\par
  276         keepConnecting = false;\par
  277         DEBUG_WM (F("Connection timed out"));\par
  278       \}\par
  279       if (status == WL_CONNECTED || status == WL_CONNECT_FAILED) \{\par
  280         keepConnecting = false;\par
  281       \}\par
  282       delay(100);\par
  283     \}\par
  284     return status;\par
  285   \}\par
  286 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a89a3f33997aa662ad223d6c150c1eede_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a89a3f33997aa662ad223d6c150c1eede_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ap_static_gw\:WiFiManager}
{\xe \v WiFiManager\:_ap_static_gw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_ap_static_gw{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _ap_static_ip\:WiFiManager}
{\xe \v WiFiManager\:_ap_static_ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_ap_static_ip{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _ap_static_sn\:WiFiManager}
{\xe \v WiFiManager\:_ap_static_sn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_ap_static_sn{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _apcallback\:WiFiManager}
{\xe \v WiFiManager\:_apcallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* WiFiManager::_apcallback) ({\b WiFiManager} *) = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 183 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _apName\:WiFiManager}
{\xe \v WiFiManager\:_apName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManager::_apName = "no-net"{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _apPassword\:WiFiManager}
{\xe \v WiFiManager\:_apPassword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManager::_apPassword = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _configPortalStart\:WiFiManager}
{\xe \v WiFiManager\:_configPortalStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long WiFiManager::_configPortalStart = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _configPortalTimeout\:WiFiManager}
{\xe \v WiFiManager\:_configPortalTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long WiFiManager::_configPortalTimeout = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _connectTimeout\:WiFiManager}
{\xe \v WiFiManager\:_connectTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long WiFiManager::_connectTimeout = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _customHeadElement\:WiFiManager}
{\xe \v WiFiManager\:_customHeadElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManager::_customHeadElement = ""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _debug\:WiFiManager}
{\xe \v WiFiManager\:_debug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_debug = true{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 181 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _minimumQuality\:WiFiManager}
{\xe \v WiFiManager\:_minimumQuality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::_minimumQuality = -1{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _params\:WiFiManager}
{\xe \v WiFiManager\:_params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WiFiManagerParameter}* WiFiManager::_params[{\b WIFI_MANAGER_MAX_PARAMS}]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _paramsCount\:WiFiManager}
{\xe \v WiFiManager\:_paramsCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::_paramsCount = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _pass\:WiFiManager}
{\xe \v WiFiManager\:_pass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::_pass = ""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _removeDuplicateAPs\:WiFiManager}
{\xe \v WiFiManager\:_removeDuplicateAPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_removeDuplicateAPs = true{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _savecallback\:WiFiManager}
{\xe \v WiFiManager\:_savecallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* WiFiManager::_savecallback) (void) = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 184 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _shouldBreakAfterConfig\:WiFiManager}
{\xe \v WiFiManager\:_shouldBreakAfterConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_shouldBreakAfterConfig = false{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _ssid\:WiFiManager}
{\xe \v WiFiManager\:_ssid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::_ssid = ""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _sta_static_gw\:WiFiManager}
{\xe \v WiFiManager\:_sta_static_gw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_sta_static_gw{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _sta_static_ip\:WiFiManager}
{\xe \v WiFiManager\:_sta_static_ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_sta_static_ip{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _sta_static_sn\:WiFiManager}
{\xe \v WiFiManager\:_sta_static_sn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_sta_static_sn{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _tryWPS\:WiFiManager}
{\xe \v WiFiManager\:_tryWPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_tryWPS = false{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v connect\:WiFiManager}
{\xe \v WiFiManager\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::connect{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 180 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v DNS_PORT\:WiFiManager}
{\xe \v WiFiManager\:DNS_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const byte WiFiManager::DNS_PORT = 53{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 173 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v dnsServer\:WiFiManager}
{\xe \v WiFiManager\:dnsServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::unique_ptr<DNSServer> WiFiManager::dnsServer{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v server\:WiFiManager}
{\xe \v WiFiManager\:server}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::unique_ptr<ESP8266WebServer> WiFiManager::server{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v status\:WiFiManager}
{\xe \v WiFiManager\:status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::status = WL_IDLE_STATUS{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 154 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WiFiManagerParameter Class Reference\par \pard\plain 
{\tc\tcl2 \v WiFiManagerParameter}
{\xe \v WiFiManagerParameter}
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
\par
{
{\f2 #include <WiFiManagerReadFileButton.h>}}\par
Collaboration diagram for WiFiManagerParameter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d83/class_wi_fi_manager_parameter__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} (const char *custom)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} (const char *id, const char *placeholder, const char *defaultValue, int length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} (const char *id, const char *placeholder, const char *defaultValue, int length, const char *custom)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getID} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getValue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getPlaceholder} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getValueLength} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getCustomHTML} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (const char *id, const char *placeholder, const char *defaultValue, int length, const char *custom)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _placeholder}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b _value}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _customHTML}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WiFiManager}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 43 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManagerParameter::WiFiManagerParameter (const char *  {\i custom})}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    17                                                              \{\par
   18   _id = NULL;\par
   19   _placeholder = NULL;\par
   20   _length = 0;\par
   21   _value = NULL;\par
   22 \par
   23   _customHTML = custom;\par
   24 \}\par
}
}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManagerParameter::WiFiManagerParameter (const char *  {\i id}, const char *  {\i placeholder}, const char *  {\i defaultValue}, int  {\i length})}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    26                                                                                                                         \{\par
   27   init(id, placeholder, defaultValue, length, "");\par
   28 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a8e55ac907530d04ab60d30045e1382a1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManagerParameter::WiFiManagerParameter (const char *  {\i id}, const char *  {\i placeholder}, const char *  {\i defaultValue}, int  {\i length}, const char *  {\i custom})}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30                                                                                                                                             \{\par
   31   init(id, placeholder, defaultValue, length, custom);\par
   32 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a45967e1d29d52f5fc8e47e99cb693b98_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getCustomHTML\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getCustomHTML}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getCustomHTML ()}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61                                                 \{\par
   62   return _customHTML;\par
   63 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a596273c189eb40107500cee3ad31b13b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getID\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getID ()}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52                                         \{\par
   53   return _id;\par
   54 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_af57919615418fff788310ba9cc2664d8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getPlaceholder\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getPlaceholder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getPlaceholder ()}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55                                                  \{\par
   56   return _placeholder;\par
   57 \}\par
}
}
{\xe \v getValue\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getValue ()}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49                                            \{\par
   50   return _value;\par
   51 \}\par
}
}
{\xe \v getValueLength\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getValueLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManagerParameter::getValueLength ()}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    58                                          \{\par
   59   return _length;\par
   60 \}\par
}
}
{\xe \v init\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManagerParameter::init (const char *  {\i id}, const char *  {\i placeholder}, const char *  {\i defaultValue}, int  {\i length}, const char *  {\i custom}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    34                                                                                                                                  \{\par
   35   _id = id;\par
   36   _placeholder = placeholder;\par
   37   _length = length;\par
   38   _value = new char[length + 1];\par
   39   for (int i = 0; i < length; i++) \{\par
   40     _value[i] = 0;\par
   41   \}\par
   42   if (defaultValue != NULL) \{\par
   43     strncpy(_value, defaultValue, length);\par
   44   \}\par
   45 \par
   46   _customHTML = custom;\par
   47 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a137b764027d3851a428f3ab185a5660f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v WiFiManager\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b WiFiManager}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _customHTML\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_customHTML}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManagerParameter::_customHTML{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _id\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManagerParameter::_id{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _length\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManagerParameter::_length{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _placeholder\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_placeholder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManagerParameter::_placeholder{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _value\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* WiFiManagerParameter::_value{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/README.md}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/README.md}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.cpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "CoolBoard.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <Wire.h>}\par
{\f2 #include <memory>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoard.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d9d/_cool_board_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoard.cpp}
{\xe \v CoolBoard.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolBoard.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolFileSystem.h"}\par
{\f2 #include "CoolBoardSensors.h"}\par
{\f2 #include "CoolBoardLed.h"}\par
{\f2 #include "CoolTime.h"}\par
{\f2 #include "CoolMQTT.h"}\par
{\f2 #include "Jetpack.h"}\par
{\f2 #include "Irene3000.h"}\par
{\f2 #include "ExternalSensors.h"}\par
{\f2 #include "CoolWifi.h"}\par
{\f2 #include "CoolBoardActor.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoard.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d32/_cool_board_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/de0/_cool_board_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoard}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "CoolBoardActor.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardActor.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d36/_cool_board_actor_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoardActor.cpp}
{\xe \v CoolBoardActor.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolBoardActor.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardActor.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d6d/_cool_board_actor_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d07/_cool_board_actor_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoardActor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardActor::state}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.cpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <NeoPixelBus.h>}\par
{\f2 #include "CoolBoardLed.h"}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardLed.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d71/_cool_board_led_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoardLed.cpp}
{\xe \v CoolBoardLed.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolBoardLed.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include <NeoPixelBus.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardLed.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d68/_cool_board_led_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/df4/_cool_board_led_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoardLed}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "CoolBoardSensors.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardSensors.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/dd0/_cool_board_sensors_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoardSensors.cpp}
{\xe \v CoolBoardSensors.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolBoardSensors.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "internals/CoolSI114X.h"}\par
{\f2 #include "internals/CoolSparkFunBME280.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardSensors.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d72/_cool_board_sensors_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/daf/_cool_board_sensors_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoardSensors}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::lightActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::airActive}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <FS.h>}\par
{\f2 #include "CoolFileSystem.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolFileSystem.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc8/_cool_file_system_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolFileSystem.cpp}
{\xe \v CoolFileSystem.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolFileSystem.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolFileSystem.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d26/_cool_file_system_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/deb/_cool_file_system_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolFileSystem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include "CoolMQTT.h"}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolMQTT.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d20/_cool_m_q_t_t_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolMQTT.cpp}
{\xe \v CoolMQTT.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolMQTT.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include "internals/CoolPubSubClient.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolMQTT.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d5c/_cool_m_q_t_t_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d91/_cool_m_q_t_t_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolMQTT}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "CoolTime.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "TimeLib.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolTime.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d9d/_cool_time_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolTime.cpp}
{\xe \v CoolTime.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolTime.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "TimeLib.h"}\par
{\f2 #include <WiFiUdp.h>}\par
{\f2 #include <DS1337RTC.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolTime.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d60/_cool_time_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d65/_cool_time_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolTime}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC . }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NTP_PACKET_SIZE}\~ 48\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v NTP_PACKET_SIZE\:CoolTime.h}
{\xe \v CoolTime.h\:NTP_PACKET_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NTP_PACKET_SIZE\~ 48}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolTime.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.cpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include <ESP8266WiFiMulti.h>}\par
{\f2 #include "internals/WiFiManagerReadFileButton.h"}\par
{\f2 #include <CoolWifi.h>}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolWifi.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/dff/_cool_wifi_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolWifi.cpp}
{\xe \v CoolWifi.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolWifi.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include <ESP8266WiFiMulti.h>}\par
{\f2 #include <DNSServer.h>}\par
{\f2 #include <ESP8266WebServer.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolWifi.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d94/_cool_wifi_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2b/_cool_wifi_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolWifi}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection . }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensor.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensor.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensor.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "internals/CoolNDIR_I2C.h"}\par
{\f2 #include <DallasTemperature.h>}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ExternalSensor.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/df9/_external_sensor_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d63/_external_sensor_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BaseExternalSensor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensor< T >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensor< NDIR_I2C >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensor< DallasTemperature >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUGExternal}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUGExternal\:ExternalSensor.h}
{\xe \v ExternalSensor.h\:DEBUGExternal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUGExternal\~ 0}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file ExternalSensor.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.cpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "Wire.h"}\par
{\f2 #include "OneWire.h"}\par
{\f2 #include "ExternalSensors.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "ExternalSensor.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ExternalSensors.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d80/_external_sensors_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OneWire {\b oneWire} (0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:ExternalSensors.cpp}
{\xe \v ExternalSensors.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file ExternalSensors.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v oneWire\:ExternalSensors.cpp}
{\xe \v ExternalSensors.cpp\:oneWire}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
OneWire oneWire (0 )}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d09/_external_sensors_8cpp_af39fa3dad1ba161b384c0b26b8145e65_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.h}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "ExternalSensor.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ExternalSensors.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d97/_external_sensors_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d76/_external_sensors_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensors}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExternalSensors::sensor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.cpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "CoolAdafruit_ADS1015.h"}\par
{\f2 #include <Wire.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolAdafruit_ADS1015.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d37/_cool_adafruit___a_d_s1015_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint8_t {\b i2cread} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b i2cwrite} (uint8_t x)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b writeRegister} (uint8_t i2cAddress, uint8_t reg, uint16_t value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint16_t {\b readRegister} (uint8_t i2cAddress, uint8_t reg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v i2cread\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:i2cread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static uint8_t i2cread (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }}\par
{
Definition at line 36 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    36                              \{\par
   37   #if ARDUINO >= 100\par
   38   return Wire.read();\par
   39   #else\par
   40   return Wire.receive();\par
   41   #endif\par
   42 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_af89e2442d757f6ec8100c473022f6701_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v i2cwrite\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:i2cwrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void i2cwrite (uint8_t  {\i x}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }}\par
{
Definition at line 49 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49                                 \{\par
   50   #if ARDUINO >= 100\par
   51   Wire.write((uint8_t)x);\par
   52   #else\par
   53   Wire.send(x);\par
   54   #endif\par
   55 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a6db5edba66e20bba6d5b421c2789af54_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegister\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:readRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static uint16_t readRegister (uint8_t  {\i i2cAddress}, uint8_t  {\i reg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }}\par
{
Definition at line 75 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75                                                               \{\par
   76   Wire.beginTransmission(i2cAddress);\par
   77   i2cwrite(ADS1015_REG_POINTER_CONVERT);\par
   78   Wire.endTransmission();\par
   79   Wire.requestFrom(i2cAddress, (uint8_t)2);\par
   80   return ((i2cread() << 8) | i2cread());  \par
   81 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a319539381b7551b2f83a92b0b596e97d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a319539381b7551b2f83a92b0b596e97d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeRegister\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:writeRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void writeRegister (uint8_t  {\i i2cAddress}, uint8_t  {\i reg}, uint16_t  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }}\par
{
Definition at line 62 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    62                                                                            \{\par
   63   Wire.beginTransmission(i2cAddress);\par
   64   i2cwrite((uint8_t)reg);\par
   65   i2cwrite((uint8_t)(value>>8));\par
   66   i2cwrite((uint8_t)(value & 0xFF));\par
   67   Wire.endTransmission();\par
   68 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a00ef55774dfb93dd0a7bf561d8451b71_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a00ef55774dfb93dd0a7bf561d8451b71_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolAdafruit_ADS1015.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d26/_cool_adafruit___a_d_s1015_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/db3/_cool_adafruit___a_d_s1015_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Adafruit_ADS1015}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Adafruit_ADS1115}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_ADDRESS}\~ (0x48)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_CONVERSIONDELAY}\~ (1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1115_CONVERSIONDELAY}\~ (8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_MASK}\~ (0x03)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_CONVERT}\~ (0x00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_CONFIG}\~ (0x01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_LOWTHRESH}\~ (0x02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_HITHRESH}\~ (0x03)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_MASK}\~ (0x8000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_SINGLE}\~ (0x8000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_BUSY}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_NOTBUSY}\~ (0x8000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_MASK}\~ (0x7000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_0_1}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_0_3}\~ (0x1000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_1_3}\~ (0x2000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_2_3}\~ (0x3000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_0}\~ (0x4000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_1}\~ (0x5000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_2}\~ (0x6000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_3}\~ (0x7000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_MASK}\~ (0x0E00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_6_144V}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_4_096V}\~ (0x0200)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_2_048V}\~ (0x0400)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_1_024V}\~ (0x0600)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_0_512V}\~ (0x0800)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_0_256V}\~ (0x0A00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MODE_MASK}\~ (0x0100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MODE_CONTIN}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MODE_SINGLE}\~ (0x0100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_MASK}\~ (0x00E0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_128SPS}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_250SPS}\~ (0x0020)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_490SPS}\~ (0x0040)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_920SPS}\~ (0x0060)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_1600SPS}\~ (0x0080)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_2400SPS}\~ (0x00A0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_3300SPS}\~ (0x00C0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CMODE_MASK}\~ (0x0010)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CMODE_TRAD}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CMODE_WINDOW}\~ (0x0010)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CPOL_MASK}\~ (0x0008)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CPOL_ACTVLOW}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CPOL_ACTVHI}\~ (0x0008)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CLAT_MASK}\~ (0x0004)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CLAT_NONLAT}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CLAT_LATCH}\~ (0x0004)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_MASK}\~ (0x0003)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_1CONV}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_2CONV}\~ (0x0001)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_4CONV}\~ (0x0002)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_NONE}\~ (0x0003)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b adsGain_t} \{ {\b GAIN_TWOTHIRDS} = ADS1015_REG_CONFIG_PGA_6_144V, 
{\b GAIN_ONE} = ADS1015_REG_CONFIG_PGA_4_096V, 
{\b GAIN_TWO} = ADS1015_REG_CONFIG_PGA_2_048V, 
{\b GAIN_FOUR} = ADS1015_REG_CONFIG_PGA_1_024V, 
{\b GAIN_EIGHT} = ADS1015_REG_CONFIG_PGA_0_512V, 
{\b GAIN_SIXTEEN} = ADS1015_REG_CONFIG_PGA_0_256V
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ADS1015_ADDRESS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_ADDRESS\~ (0x48)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_CONVERSIONDELAY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_CONVERSIONDELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_CONVERSIONDELAY\~ (1)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CLAT_LATCH\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CLAT_LATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CLAT_LATCH\~ (0x0004)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CLAT_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CLAT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CLAT_MASK\~ (0x0004)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CLAT_NONLAT\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CLAT_NONLAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CLAT_NONLAT\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CMODE_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CMODE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CMODE_MASK\~ (0x0010)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CMODE_TRAD\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CMODE_TRAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CMODE_TRAD\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CMODE_WINDOW\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CMODE_WINDOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CMODE_WINDOW\~ (0x0010)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CPOL_ACTVHI\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CPOL_ACTVHI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CPOL_ACTVHI\~ (0x0008)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CPOL_ACTVLOW\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CPOL_ACTVLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CPOL_ACTVLOW\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CPOL_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CPOL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CPOL_MASK\~ (0x0008)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_1CONV\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_1CONV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_1CONV\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_2CONV\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_2CONV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_2CONV\~ (0x0001)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_4CONV\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_4CONV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_4CONV\~ (0x0002)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_MASK\~ (0x0003)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_NONE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_NONE\~ (0x0003)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_128SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_128SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_128SPS\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_1600SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_1600SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_1600SPS\~ (0x0080)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_2400SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_2400SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_2400SPS\~ (0x00A0)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_250SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_250SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_250SPS\~ (0x0020)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_3300SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_3300SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_3300SPS\~ (0x00C0)}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_490SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_490SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_490SPS\~ (0x0040)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_920SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_920SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_920SPS\~ (0x0060)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_MASK\~ (0x00E0)}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MODE_CONTIN\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MODE_CONTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MODE_CONTIN\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MODE_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MODE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MODE_MASK\~ (0x0100)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MODE_SINGLE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MODE_SINGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MODE_SINGLE\~ (0x0100)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_0_1\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_0_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_0_1\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_0_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_0_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_0_3\~ (0x1000)}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_1_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_1_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_1_3\~ (0x2000)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_2_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_2_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_2_3\~ (0x3000)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_MASK\~ (0x7000)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_0\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_0\~ (0x4000)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_1\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_1\~ (0x5000)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_2\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_2\~ (0x6000)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_3\~ (0x7000)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_BUSY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_BUSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_BUSY\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_MASK\~ (0x8000)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_NOTBUSY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_NOTBUSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_NOTBUSY\~ (0x8000)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_SINGLE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_SINGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_SINGLE\~ (0x8000)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_0_256V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_0_256V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_0_256V\~ (0x0A00)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_0_512V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_0_512V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_0_512V\~ (0x0800)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_1_024V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_1_024V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_1_024V\~ (0x0600)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_2_048V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_2_048V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_2_048V\~ (0x0400)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_4_096V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_4_096V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_4_096V\~ (0x0200)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_6_144V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_6_144V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_6_144V\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_MASK\~ (0x0E00)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_CONFIG\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_CONFIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_CONFIG\~ (0x01)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_CONVERT\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_CONVERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_CONVERT\~ (0x00)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_HITHRESH\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_HITHRESH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_HITHRESH\~ (0x03)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_LOWTHRESH\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_LOWTHRESH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_LOWTHRESH\~ (0x02)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_MASK\~ (0x03)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1115_CONVERSIONDELAY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1115_CONVERSIONDELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1115_CONVERSIONDELAY\~ (8)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v adsGain_t\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:adsGain_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b adsGain_t}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v GAIN_TWOTHIRDS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_TWOTHIRDS}
{\qr GAIN_TWOTHIRDS{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\cell }{\cell }{\row }
{\xe \v GAIN_ONE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_ONE}
{\qr GAIN_ONE{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\cell }{\cell }{\row }
{\xe \v GAIN_TWO\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_TWO}
{\qr GAIN_TWO{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{\cell }{\row }
{\xe \v GAIN_FOUR\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_FOUR}
{\qr GAIN_FOUR{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{\cell }{\row }
{\xe \v GAIN_EIGHT\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_EIGHT}
{\qr GAIN_EIGHT{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
{\xe \v GAIN_SIXTEEN\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_SIXTEEN}
{\qr GAIN_SIXTEEN{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\cell }{\cell }{\row }
}
\par
{
Definition at line 109 of file CoolAdafruit_ADS1015.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   110 \{\par
  111   GAIN_TWOTHIRDS    = ADS1015_REG_CONFIG_PGA_6_144V,\par
  112   GAIN_ONE          = ADS1015_REG_CONFIG_PGA_4_096V,\par
  113   GAIN_TWO          = ADS1015_REG_CONFIG_PGA_2_048V,\par
  114   GAIN_FOUR         = ADS1015_REG_CONFIG_PGA_1_024V,\par
  115   GAIN_EIGHT        = ADS1015_REG_CONFIG_PGA_0_512V,\par
  116   GAIN_SIXTEEN      = ADS1015_REG_CONFIG_PGA_0_256V\par
  117 \} adsGain_t;\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.cpp}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Wire.h>}\par
{\f2 #include "CoolNDIR_I2C.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolNDIR_I2C.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d4e/_cool_n_d_i_r___i2_c_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RHR}\~ (0x00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THR}\~ (0X00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IER}\~ (0X01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FCR}\~ (0X02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IIR}\~ (0X02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LCR}\~ (0X03)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MCR}\~ (0X04)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LSR}\~ (0X05)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MSR}\~ (0X06)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPR}\~ (0X07)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR}\~ (0X06)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TLR}\~ (0X07)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TXLVL}\~ (0X08)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RXLVL}\~ (0X09)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IODIR}\~ (0X0A)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IOSTATE}\~ (0X0B)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IOINTENA}\~ (0X0C)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IOCONTROL}\~ (0X0E)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EFCR}\~ (0X0F)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DLL}\~ (0x00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DLH}\~ (0X01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EFR}\~ (0X02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XON1}\~ (0X04)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XON2}\~ (0X05)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XOFF1}\~ (0X06)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XOFF2}\~ (0X07)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SC16IS750_CRYSTCAL_FREQ}\~ (14745600UL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RECEIVE_TIMEOUT}\~ (100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WIRE}\~ Wire\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DLH\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:DLH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DLH\~ (0X01)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v DLL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:DLL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DLL\~ (0x00)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v EFCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:EFCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EFCR\~ (0X0F)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v EFR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:EFR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EFR\~ (0X02)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v FCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:FCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FCR\~ (0X02)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IER\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IER\~ (0X01)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IIR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IIR\~ (0X02)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IOCONTROL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IOCONTROL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IOCONTROL\~ (0X0E)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IODIR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IODIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IODIR\~ (0X0A)}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IOINTENA\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IOINTENA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IOINTENA\~ (0X0C)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IOSTATE\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IOSTATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IOSTATE\~ (0X0B)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v LCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:LCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LCR\~ (0X03)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v LSR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:LSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LSR\~ (0X05)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v MCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:MCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MCR\~ (0X04)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v MSR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:MSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSR\~ (0X06)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v RECEIVE_TIMEOUT\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:RECEIVE_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RECEIVE_TIMEOUT\~ (100)}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v RHR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:RHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RHR\~ (0x00)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v RXLVL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:RXLVL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RXLVL\~ (0X09)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v SC16IS750_CRYSTCAL_FREQ\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:SC16IS750_CRYSTCAL_FREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SC16IS750_CRYSTCAL_FREQ\~ (14745600UL)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v SPR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:SPR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPR\~ (0X07)}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v TCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:TCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR\~ (0X06)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v THR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:THR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THR\~ (0X00)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v TLR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:TLR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TLR\~ (0X07)}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v TXLVL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:TXLVL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TXLVL\~ (0X08)}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v WIRE\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:WIRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WIRE\~ Wire}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XOFF1\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XOFF1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XOFF1\~ (0X06)}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XOFF2\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XOFF2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XOFF2\~ (0X07)}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XON1\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XON1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XON1\~ (0X04)}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XON2\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XON2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XON2\~ (0X05)}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolNDIR_I2C.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.h}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d5f/_cool_n_d_i_r___i2_c_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NDIR_I2C}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.cpp}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolPubSubClient.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolPubSubClient.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d86/_cool_pub_sub_client_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_HEADER_VERSION_LENGTH}\~ 7\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MQTT_HEADER_VERSION_LENGTH\:CoolPubSubClient.cpp}
{\xe \v CoolPubSubClient.cpp\:MQTT_HEADER_VERSION_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_HEADER_VERSION_LENGTH\~ 7}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.h}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "IPAddress.h"}\par
{\f2 #include "Client.h"}\par
{\f2 #include "Stream.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolPubSubClient.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d35/_cool_pub_sub_client_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d9e/_cool_pub_sub_client_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolPubSubClient}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_VERSION_3_1}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_VERSION_3_1_1}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_VERSION}\~ {\b MQTT_VERSION_3_1_1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_MAX_PACKET_SIZE}\~ 128\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_KEEPALIVE}\~ 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_SOCKET_TIMEOUT}\~ 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECTION_TIMEOUT}\~ -4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECTION_LOST}\~ -3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_FAILED}\~ -2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_DISCONNECTED}\~ -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECTED}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_BAD_PROTOCOL}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_BAD_CLIENT_ID}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_UNAVAILABLE}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_BAD_CREDENTIALS}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_UNAUTHORIZED}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTCONNECT}\~ 1 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTCONNACK}\~ 2 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBLISH}\~ 3 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBACK}\~ 4 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBREC}\~ 5 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBREL}\~ 6 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBCOMP}\~ 7 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTSUBSCRIBE}\~ 8 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTSUBACK}\~ 9 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTUNSUBSCRIBE}\~ 10 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTUNSUBACK}\~ 11 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPINGREQ}\~ 12 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPINGRESP}\~ 13 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTDISCONNECT}\~ 14 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTReserved}\~ 15 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS0}\~ (0 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS1}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS2}\~ (2 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CALLBACK_SIGNATURE}\~ void (*callback)(char*, uint8_t*, unsigned int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MQTT_CALLBACK_SIGNATURE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CALLBACK_SIGNATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CALLBACK_SIGNATURE\~ void (*callback)(char*, uint8_t*, unsigned int)}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_BAD_CLIENT_ID\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_BAD_CLIENT_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_BAD_CLIENT_ID\~ 2}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_BAD_CREDENTIALS\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_BAD_CREDENTIALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_BAD_CREDENTIALS\~ 4}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_BAD_PROTOCOL\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_BAD_PROTOCOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_BAD_PROTOCOL\~ 1}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_FAILED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_FAILED\~ -2}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_UNAUTHORIZED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_UNAUTHORIZED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_UNAUTHORIZED\~ 5}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_UNAVAILABLE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_UNAVAILABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_UNAVAILABLE\~ 3}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECTED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECTED\~ 0}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECTION_LOST\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECTION_LOST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECTION_LOST\~ -3}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECTION_TIMEOUT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECTION_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECTION_TIMEOUT\~ -4}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_DISCONNECTED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_DISCONNECTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_DISCONNECTED\~ -1}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_KEEPALIVE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_KEEPALIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_KEEPALIVE\~ 15}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_MAX_PACKET_SIZE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_MAX_PACKET_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_MAX_PACKET_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_SOCKET_TIMEOUT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_SOCKET_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_SOCKET_TIMEOUT\~ 15}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_VERSION\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_VERSION\~ {\b MQTT_VERSION_3_1_1}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_VERSION_3_1\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_VERSION_3_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_VERSION_3_1\~ 3}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_VERSION_3_1_1\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_VERSION_3_1_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_VERSION_3_1_1\~ 4}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTCONNACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTCONNACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTCONNACK\~ 2 << 4}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTCONNECT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTCONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTCONNECT\~ 1 << 4}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTDISCONNECT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTDISCONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTDISCONNECT\~ 14 << 4}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPINGREQ\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPINGREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPINGREQ\~ 12 << 4}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPINGRESP\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPINGRESP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPINGRESP\~ 13 << 4}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBACK\~ 4 << 4}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBCOMP\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBCOMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBCOMP\~ 7 << 4}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBLISH\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBLISH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBLISH\~ 3 << 4}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBREC\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBREC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBREC\~ 5 << 4}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBREL\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBREL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBREL\~ 6 << 4}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTQOS0\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTQOS0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS0\~ (0 << 1)}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTQOS1\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTQOS1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS1\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTQOS2\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTQOS2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS2\~ (2 << 1)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTReserved\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTReserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTReserved\~ 15 << 4}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTSUBACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTSUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTSUBACK\~ 9 << 4}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTSUBSCRIBE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTSUBSCRIBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTSUBSCRIBE\~ 8 << 4}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTUNSUBACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTUNSUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTUNSUBACK\~ 11 << 4}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTUNSUBSCRIBE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTUNSUBSCRIBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTUNSUBSCRIBE\~ 10 << 4}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolPubSubClient.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.cpp}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolSI114X.h"}\par
{\f2 #include "Wire.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSI114X.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d51/_cool_s_i114_x_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.h}
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSI114X.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d0d/_cool_s_i114_x_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d23/_cool_s_i114_x_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolSI114X}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_QUERY}\~ 0X80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_SET}\~ 0XA0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_NOP}\~ 0X0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_RESET}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_BUSADDR}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_FORCE}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_GET_CAL}\~ 0X12\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_FORCE}\~ 0X06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSALS_FORCE}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_PAUSE}\~ 0X09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_PAUSE}\~ 0X0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSALS_PAUSE}\~ 0XB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_AUTO}\~ 0X0D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_AUTO}\~ 0X0E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSALS_AUTO}\~ 0X0F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PART_ID}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_REV_ID}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_SEQ_ID}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_INT_CFG}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_ENABLE}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_MODE1}\~ 0x05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_MODE2}\~ 0x06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_HW_KEY}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_MEAS_RATE0}\~ 0X08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_MEAS_RATE1}\~ 0X09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_RATE}\~ 0X0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_LED21}\~ 0X0F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_LED3}\~ 0X10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF0}\~ 0X13\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF1}\~ 0X14\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF2}\~ 0X15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF3}\~ 0X16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_WR}\~ 0X17\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_COMMAND}\~ 0X18\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_RESPONSE}\~ 0X20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_STATUS}\~ 0X21\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_DATA0}\~ 0X22\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_DATA1}\~ 0X23\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_DATA0}\~ 0X24\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_DATA1}\~ 0X25\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS1_DATA0}\~ 0X26\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS1_DATA1}\~ 0X27\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS2_DATA0}\~ 0X28\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS2_DATA1}\~ 0X29\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS3_DATA0}\~ 0X2A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS3_DATA1}\~ 0X2B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_AUX_DATA0_UVINDEX0}\~ 0X2C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_AUX_DATA1_UVINDEX1}\~ 0X2D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_RD}\~ 0X2E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHIP_STAT}\~ 0X30\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_I2C_ADDR}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENUV}\~ 0x80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENAUX}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENALSIR}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENALSVIS}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENPS1}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENPS2}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENPS3}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ENCODE}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_ENCODE}\~ 0X06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS1_ADCMUX}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS2_ADCMUX}\~ 0X08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS3_ADCMUX}\~ 0X09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ADC_COUNTER}\~ 0X0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ADC_GAIN}\~ 0X0B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ADC_MISC}\~ 0X0C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_MUX}\~ 0X0E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_AUX_ADC_MUX}\~ 0X0F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_ADC_COUNTER}\~ 0X10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_ADC_GAIN}\~ 0X11\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_ADC_MISC}\~ 0X12\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_REC}\~ 0X1C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_COUNTER}\~ 0X1D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_GAIN}\~ 0X1E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_MISC}\~ 0X1F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_SMALL_IR}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_VISIABLE}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_LARGE_IR}\~ 0x03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_NO}\~ 0x06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_GND}\~ 0x25\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_TEMPERATURE}\~ 0x65\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_VDD}\~ 0x75\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_NONE}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_LED1}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_LED2}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_LED3}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_NONE}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_LED1}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_LED2}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_LED3}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_NONE}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_LED1}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_LED2}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_LED3}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV1}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV2}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV4}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV8}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV16}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV32}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_5MA}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_11MA}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_22MA}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_45MA}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_1ADCCLK}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_7ADCCLK}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_15ADCCLK}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_31ADCCLK}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_63ADCCLK}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_127ADCCLK}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_255ADCCLK}\~ 0X06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_511ADCCLK}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_LOWRANGE}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_HIGHRANGE}\~ 0X20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_ADC_RAWADC}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_INT_CFG_INTOE}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_ALS}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_PS1}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_PS2}\~ 0x08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_PS3}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADDR}\~ 0x60\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CoolSI114X_ADC_COUNTER_127ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_127ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_127ADCCLK\~ 0X05}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_15ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_15ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_15ADCCLK\~ 0X02}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_1ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_1ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_1ADCCLK\~ 0X00}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_255ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_255ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_255ADCCLK\~ 0X06}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_31ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_31ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_31ADCCLK\~ 0X03}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_511ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_511ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_511ADCCLK\~ 0X07}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_63ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_63ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_63ADCCLK\~ 0X04}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_7ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_7ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_7ADCCLK\~ 0X01}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV1\~ 0X00}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV16\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV16\~ 0X04}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV2\~ 0X01}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV32\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV32\~ 0X05}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV4\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV4\~ 0X02}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV8\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV8\~ 0X03}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY\~ 0X00}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_ADC_RAWADC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_ADC_RAWADC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_ADC_RAWADC\~ 0X04}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_HIGHRANGE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_HIGHRANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_HIGHRANGE\~ 0X20}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_LOWRANGE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_LOWRANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_LOWRANGE\~ 0X00}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_GND\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_GND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_GND\~ 0x25}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_LARGE_IR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_LARGE_IR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_LARGE_IR\~ 0x03}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_NO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_NO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_NO\~ 0x06}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_SMALL_IR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_SMALL_IR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_SMALL_IR\~ 0x00}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_TEMPERATURE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_TEMPERATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_TEMPERATURE\~ 0x65}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_VDD\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_VDD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_VDD\~ 0x75}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_VISIABLE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_VISIABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_VISIABLE\~ 0x02}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADDR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADDR\~ 0x60}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 162 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_AUTO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_AUTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_AUTO\~ 0X0E}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_ENCODE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_ENCODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_ENCODE\~ 0X06}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_FORCE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_FORCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_FORCE\~ 0X06}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_COUNTER\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_COUNTER\~ 0X1D}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_GAIN\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_GAIN\~ 0X1E}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_MISC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_MISC\~ 0X1F}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_MUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_MUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_MUX\~ 0X0E}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_DATA0\~ 0X24}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_DATA1\~ 0X25}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_PAUSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_PAUSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_PAUSE\~ 0X0A}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_ADC_COUNTER\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_ADC_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_ADC_COUNTER\~ 0X10}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_ADC_GAIN\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_ADC_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_ADC_GAIN\~ 0X11}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_ADC_MISC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_ADC_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_ADC_MISC\~ 0X12}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_DATA0\~ 0X22}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_DATA1\~ 0X23}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_AUX_ADC_MUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_AUX_ADC_MUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_AUX_ADC_MUX\~ 0X0F}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_AUX_DATA0_UVINDEX0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_AUX_DATA0_UVINDEX0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_AUX_DATA0_UVINDEX0\~ 0X2C}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_AUX_DATA1_UVINDEX1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_AUX_DATA1_UVINDEX1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_AUX_DATA1_UVINDEX1\~ 0X2D}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_BUSADDR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_BUSADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_BUSADDR\~ 0X02}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHIP_STAT\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHIP_STAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHIP_STAT\~ 0X30}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST\~ 0X01}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENALSIR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENALSIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENALSIR\~ 0x20}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENALSVIS\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENALSVIS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENALSVIS\~ 0x10}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENAUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENAUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENAUX\~ 0x40}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENPS1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENPS1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENPS1\~ 0x01}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENPS2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENPS2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENPS2\~ 0x02}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENPS3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENPS3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENPS3\~ 0x04}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENUV\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENUV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENUV\~ 0x80}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_COMMAND\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_COMMAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_COMMAND\~ 0X18}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_GET_CAL\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_GET_CAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_GET_CAL\~ 0X12}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_HW_KEY\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_HW_KEY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_HW_KEY\~ 0X07}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_I2C_ADDR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_I2C_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_I2C_ADDR\~ 0X00}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_INT_CFG\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_INT_CFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_INT_CFG\~ 0X03}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_INT_CFG_INTOE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_INT_CFG_INTOE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_INT_CFG_INTOE\~ 0X01}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_ENABLE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_ENABLE\~ 0X04}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_MODE1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_MODE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_MODE1\~ 0x05}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_MODE2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_MODE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_MODE2\~ 0x06}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_STATUS\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_STATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_STATUS\~ 0X21}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_ALS\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_ALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_ALS\~ 0x01}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_PS1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_PS1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_PS1\~ 0x04}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 158 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_PS2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_PS2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_PS2\~ 0x08}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 159 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_PS3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_PS3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_PS3\~ 0x10}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_11MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_11MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_11MA\~ 0X02}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_22MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_22MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_22MA\~ 0X03}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_45MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_45MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_45MA\~ 0X04}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_5MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_5MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_5MA\~ 0X01}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_REC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_REC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_REC\~ 0X1C}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_MEAS_RATE0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_MEAS_RATE0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_MEAS_RATE0\~ 0X08}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_MEAS_RATE1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_MEAS_RATE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_MEAS_RATE1\~ 0X09}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_NOP\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_NOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_NOP\~ 0X0}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PART_ID\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PART_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PART_ID\~ 0X00}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS1_ADCMUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS1_ADCMUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS1_ADCMUX\~ 0X07}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS1_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS1_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS1_DATA0\~ 0X26}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS1_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS1_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS1_DATA1\~ 0X27}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS2_ADCMUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS2_ADCMUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS2_ADCMUX\~ 0X08}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS2_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS2_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS2_DATA0\~ 0X28}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS2_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS2_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS2_DATA1\~ 0X29}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS3_ADCMUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS3_ADCMUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS3_ADCMUX\~ 0X09}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS3_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS3_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS3_DATA0\~ 0X2A}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS3_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS3_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS3_DATA1\~ 0X2B}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ADC_COUNTER\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ADC_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ADC_COUNTER\~ 0X0A}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ADC_GAIN\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ADC_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ADC_GAIN\~ 0X0B}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ADC_MISC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ADC_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ADC_MISC\~ 0X0C}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_AUTO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_AUTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_AUTO\~ 0X0D}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ENCODE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ENCODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ENCODE\~ 0X05}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_FORCE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_FORCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_FORCE\~ 0X05}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_LED21\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_LED21}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_LED21\~ 0X0F}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_LED3\~ 0X10}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_PAUSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_PAUSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_PAUSE\~ 0X09}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_RATE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_RATE\~ 0X0A}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSALS_AUTO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSALS_AUTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSALS_AUTO\~ 0X0F}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSALS_FORCE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSALS_FORCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSALS_FORCE\~ 0X07}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSALS_PAUSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSALS_PAUSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSALS_PAUSE\~ 0XB}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT\~ 0X02}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_LED1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_LED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_LED1\~ 0x01}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_LED2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_LED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_LED2\~ 0x02}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_LED3\~ 0x04}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_NONE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_NONE\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_LED1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_LED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_LED1\~ 0x10}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_LED2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_LED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_LED2\~ 0x20}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_LED3\~ 0x40}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_NONE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_NONE\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT\~ 0X03}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_LED1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_LED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_LED1\~ 0x10}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_LED2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_LED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_LED2\~ 0x20}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_LED3\~ 0x40}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_NONE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_NONE\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_QUERY\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_QUERY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_QUERY\~ 0X80}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_RD\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_RD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_RD\~ 0X2E}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_RESET\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_RESET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_RESET\~ 0X01}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_RESPONSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_RESPONSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_RESPONSE\~ 0X20}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_REV_ID\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_REV_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_REV_ID\~ 0X01}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_SEQ_ID\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_SEQ_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_SEQ_ID\~ 0X02}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_SET\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_SET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_SET\~ 0XA0}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF0\~ 0X13}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF1\~ 0X14}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF2\~ 0X15}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF3\~ 0X16}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_WR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_WR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_WR\~ 0X17}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolSI114X.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.cpp}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolSparkFunBME280.h"}\par
{\f2 #include "stdint.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include "Wire.h"}\par
{\f2 #include "SPI.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSparkFunBME280.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/dcb/_cool_spark_fun_b_m_e280_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.h}
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "stdint.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSparkFunBME280.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d3f/_cool_spark_fun_b_m_e280_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d44/_cool_spark_fun_b_m_e280_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SensorSettings}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SensorCalibration}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BME280}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b I2C_MODE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPI_MODE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T1_LSB_REG}\~ 0x88\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T1_MSB_REG}\~ 0x89\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T2_LSB_REG}\~ 0x8A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T2_MSB_REG}\~ 0x8B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T3_LSB_REG}\~ 0x8C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T3_MSB_REG}\~ 0x8D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P1_LSB_REG}\~ 0x8E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P1_MSB_REG}\~ 0x8F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P2_LSB_REG}\~ 0x90\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P2_MSB_REG}\~ 0x91\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P3_LSB_REG}\~ 0x92\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P3_MSB_REG}\~ 0x93\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P4_LSB_REG}\~ 0x94\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P4_MSB_REG}\~ 0x95\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P5_LSB_REG}\~ 0x96\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P5_MSB_REG}\~ 0x97\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P6_LSB_REG}\~ 0x98\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P6_MSB_REG}\~ 0x99\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P7_LSB_REG}\~ 0x9A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P7_MSB_REG}\~ 0x9B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P8_LSB_REG}\~ 0x9C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P8_MSB_REG}\~ 0x9D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P9_LSB_REG}\~ 0x9E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P9_MSB_REG}\~ 0x9F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H1_REG}\~ 0xA1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CHIP_ID_REG}\~ 0xD0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_RST_REG}\~ 0xE0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H2_LSB_REG}\~ 0xE1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H2_MSB_REG}\~ 0xE2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H3_REG}\~ 0xE3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H4_MSB_REG}\~ 0xE4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H4_LSB_REG}\~ 0xE5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H5_MSB_REG}\~ 0xE6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H6_REG}\~ 0xE7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_HUMIDITY_REG}\~ 0xF2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STAT_REG}\~ 0xF3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_MEAS_REG}\~ 0xF4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CONFIG_REG}\~ 0xF5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESSURE_MSB_REG}\~ 0xF7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESSURE_LSB_REG}\~ 0xF8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESSURE_XLSB_REG}\~ 0xF9\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMPERATURE_MSB_REG}\~ 0xFA\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMPERATURE_LSB_REG}\~ 0xFB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMPERATURE_XLSB_REG}\~ 0xFC\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_HUMIDITY_MSB_REG}\~ 0xFD\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_HUMIDITY_LSB_REG}\~ 0xFE\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BME280_CHIP_ID_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CHIP_ID_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CHIP_ID_REG\~ 0xD0}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_CONFIG_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CONFIG_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CONFIG_REG\~ 0xF5}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_CTRL_HUMIDITY_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CTRL_HUMIDITY_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_HUMIDITY_REG\~ 0xF2}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_CTRL_MEAS_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CTRL_MEAS_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_MEAS_REG\~ 0xF4}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H1_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H1_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H1_REG\~ 0xA1}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H2_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H2_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H2_LSB_REG\~ 0xE1}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H2_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H2_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H2_MSB_REG\~ 0xE2}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H3_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H3_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H3_REG\~ 0xE3}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H4_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H4_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H4_LSB_REG\~ 0xE5}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H4_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H4_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H4_MSB_REG\~ 0xE4}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H5_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H5_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H5_MSB_REG\~ 0xE6}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H6_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H6_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H6_REG\~ 0xE7}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P1_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P1_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P1_LSB_REG\~ 0x8E}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P1_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P1_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P1_MSB_REG\~ 0x8F}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P2_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P2_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P2_LSB_REG\~ 0x90}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P2_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P2_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P2_MSB_REG\~ 0x91}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P3_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P3_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P3_LSB_REG\~ 0x92}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P3_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P3_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P3_MSB_REG\~ 0x93}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P4_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P4_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P4_LSB_REG\~ 0x94}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P4_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P4_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P4_MSB_REG\~ 0x95}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P5_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P5_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P5_LSB_REG\~ 0x96}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P5_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P5_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P5_MSB_REG\~ 0x97}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P6_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P6_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P6_LSB_REG\~ 0x98}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P6_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P6_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P6_MSB_REG\~ 0x99}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P7_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P7_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P7_LSB_REG\~ 0x9A}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P7_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P7_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P7_MSB_REG\~ 0x9B}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P8_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P8_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P8_LSB_REG\~ 0x9C}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P8_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P8_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P8_MSB_REG\~ 0x9D}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P9_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P9_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P9_LSB_REG\~ 0x9E}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P9_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P9_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P9_MSB_REG\~ 0x9F}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T1_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T1_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T1_LSB_REG\~ 0x88}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T1_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T1_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T1_MSB_REG\~ 0x89}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T2_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T2_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T2_LSB_REG\~ 0x8A}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T2_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T2_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T2_MSB_REG\~ 0x8B}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T3_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T3_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T3_LSB_REG\~ 0x8C}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T3_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T3_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T3_MSB_REG\~ 0x8D}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_HUMIDITY_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_HUMIDITY_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_HUMIDITY_LSB_REG\~ 0xFE}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_HUMIDITY_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_HUMIDITY_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_HUMIDITY_MSB_REG\~ 0xFD}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_PRESSURE_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_PRESSURE_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESSURE_LSB_REG\~ 0xF8}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_PRESSURE_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_PRESSURE_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESSURE_MSB_REG\~ 0xF7}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_PRESSURE_XLSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_PRESSURE_XLSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESSURE_XLSB_REG\~ 0xF9}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_RST_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_RST_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_RST_REG\~ 0xE0}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_STAT_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_STAT_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STAT_REG\~ 0xF3}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_TEMPERATURE_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_TEMPERATURE_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMPERATURE_LSB_REG\~ 0xFB}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_TEMPERATURE_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_TEMPERATURE_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMPERATURE_MSB_REG\~ 0xFA}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_TEMPERATURE_XLSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_TEMPERATURE_XLSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMPERATURE_XLSB_REG\~ 0xFC}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file CoolSparkFunBME280.h.}\par
}
{\xe \v I2C_MODE\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:I2C_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define I2C_MODE\~ 0}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file CoolSparkFunBME280.h.}\par
}
{\xe \v SPI_MODE\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:SPI_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPI_MODE\~ 1}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file CoolSparkFunBME280.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/parse.js File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/parse.js}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/parse.js}
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/template.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/template.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/template.h}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char HTTP_HEAD [] {\b PROGMEM} = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\"content=\\"width=device-width,initial-scale=1,user-scalable=no\\"/><title>\{v\}</title>"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PROGMEM\:template.h}
{\xe \v template.h\:PROGMEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char HTTP_END [] PROGMEM = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\"content=\\"width=device-width,initial-scale=1,user-scalable=no\\"/><title>\{v\}</title>"}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1 of file template.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.cpp}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "WiFiManagerReadFileButton.h"}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for WiFiManagerReadFileButton.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d2c/_wi_fi_manager_read_file_button_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.h}
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include <ESP8266WebServer.h>}\par
{\f2 #include <DNSServer.h>}\par
{\f2 #include <memory>}\par
{\f2 #include "user_interface.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for WiFiManagerReadFileButton.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d99/_wi_fi_manager_read_file_button_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d5b/_wi_fi_manager_read_file_button_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WiFiManagerParameter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WiFiManager}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WIFI_MANAGER_MAX_PARAMS}\~ 10\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char HTTP_HEAD [] {\b PROGMEM} = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, user-scalable=no\\"/><title>\{v\}</title>"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v WIFI_MANAGER_MAX_PARAMS\:WiFiManagerReadFileButton.h}
{\xe \v WiFiManagerReadFileButton.h\:WIFI_MANAGER_MAX_PARAMS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WIFI_MANAGER_MAX_PARAMS\~ 10}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PROGMEM\:WiFiManagerReadFileButton.h}
{\xe \v WiFiManagerReadFileButton.h\:PROGMEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char HTTP_END [] PROGMEM = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, user-scalable=no\\"/><title>\{v\}</title>"}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file WiFiManagerReadFileButton.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.cpp}
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include <Arduino.h>}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <Irene3000.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Irene3000.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/df3/_irene3000_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:Irene3000.cpp}
{\xe \v Irene3000.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file Irene3000.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.h}
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "internals/CoolAdafruit_ADS1015.h"}\par
{\f2 #include <Arduino.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Irene3000.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d34/_irene3000_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d86/_irene3000_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Irene3000}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::parameters_T}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADC_MAXIMUM_VALUE}\~ 32767\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REFERENCE_VOLTAGE_GAIN_4}\~ 1.024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b V_GAIN_2}\~ 0.0625\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b V_GAIN_4}\~ 0.03125\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b V_GAIN_8}\~ 0.015625\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Write_Check}\~ 0x1234\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b button}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b temp}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b freeAdc}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ph}\~ 3\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ADC_MAXIMUM_VALUE\:Irene3000.h}
{\xe \v Irene3000.h\:ADC_MAXIMUM_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADC_MAXIMUM_VALUE\~ 32767}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file Irene3000.h.}\par
}
{\xe \v button\:Irene3000.h}
{\xe \v Irene3000.h\:button}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define button\~ 0}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file Irene3000.h.}\par
}
{\xe \v freeAdc\:Irene3000.h}
{\xe \v Irene3000.h\:freeAdc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define freeAdc\~ 2}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file Irene3000.h.}\par
}
{\xe \v ph\:Irene3000.h}
{\xe \v Irene3000.h\:ph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ph\~ 3}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file Irene3000.h.}\par
}
{\xe \v REFERENCE_VOLTAGE_GAIN_4\:Irene3000.h}
{\xe \v Irene3000.h\:REFERENCE_VOLTAGE_GAIN_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REFERENCE_VOLTAGE_GAIN_4\~ 1.024}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file Irene3000.h.}\par
}
{\xe \v temp\:Irene3000.h}
{\xe \v Irene3000.h\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define temp\~ 1}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file Irene3000.h.}\par
}
{\xe \v V_GAIN_2\:Irene3000.h}
{\xe \v Irene3000.h\:V_GAIN_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define V_GAIN_2\~ 0.0625}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file Irene3000.h.}\par
}
{\xe \v V_GAIN_4\:Irene3000.h}
{\xe \v Irene3000.h\:V_GAIN_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define V_GAIN_4\~ 0.03125}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file Irene3000.h.}\par
}
{\xe \v V_GAIN_8\:Irene3000.h}
{\xe \v Irene3000.h\:V_GAIN_8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define V_GAIN_8\~ 0.015625}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file Irene3000.h.}\par
}
{\xe \v Write_Check\:Irene3000.h}
{\xe \v Irene3000.h\:Write_Check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Write_Check\~ 0x1234}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file Irene3000.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.cpp}
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "Jetpack.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Jetpack.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d45/_jetpack_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:Jetpack.cpp}
{\xe \v Jetpack.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file Jetpack.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.h}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Jetpack.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d77/_jetpack_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d4b/_jetpack_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Jetpack}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Jetpack::state}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Simon Juif \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}