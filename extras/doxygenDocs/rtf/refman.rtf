{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment CoolBoardAPI }CoolBoardAPI}
{\comment Generated byDoxgyen. }
{\creatim \yr2017\mo8\dy24\hr16\min4\sec48}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt CoolBoardAPI}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Thu Aug 24 2017 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
README{\tc \v README}\par \pard\plain 
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 What is this repository for?} \par}
Quick summary :\par
{\b CoolBoard} API is a set of libraries and wrappers to simplify the access and usage of all the capabilites of the {\b CoolBoard}.\par
Version : 1.0\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 How do I get set up?} \par}
Configuration :\par
1/Download and Install the Arduino IDE ({\f2 https://www.arduino.cc/en/Main/Software} )\par
2/Download and Add the ESP8266 Hardware extension to Arduino ({\f2 https://github.com/esp8266/Arduino} )\par
3/Download and Add the {\b CoolBoard} Library set to the Arduino IDE :\par
a)First Method :\par
-Open the Arduino IDE\par
-Go to the "Sketch" Menu\par
-Include Library > Manage Libraries.\par
-Search for {\b CoolBoard}\par
-Install\par
-Restart Arduino IDE\par
b)Second Method (if you have a CoolBoard.zip file ):\par
-Open the Arduino IDE\par
-Go to the "Sketch" Menu\par
-Include Library > "Add .ZIP Library".\par
-Search for CoolBoard.zip\par
-Click Open\par
-Restart Arduino IDE\par
c)Third Method (if you have the bitbucket/github link):\par
-Open Arduino IDE > File > Preferences\par
-Check the "SketchBook Location" path\par
-Go to the Arduino/libraries folder (if it doesn't exist, create one )\par
-Clone the repo there ( git clone "bitbucket/github link" )\par
-Restart Arduino IDE\par
4/Download ESP8266FS Tool ({\f2 https://arduino-esp8266.readthedocs.io/en/latest/filesystem.html#uploading-files-to-file-system})\par
5/Optional but Heavily Recommended : Download the ESP8266 Exception Decoder ( download link :{\f2 https://github.com/me-no-dev/EspExceptionDecoder/releases/tag/1.0.6}) Install guide : {\f2 https://github.com/me-no-dev/EspExceptionDecoder}\par
Dependencies :\par
You need the following libraries to be able to use the {\b CoolBoard} API:\par
-ArduinoJson({\f2 https://github.com/bblanchon/ArduinoJson})\par
-NeoPixelBus({\f2 https://github.com/Makuna/NeoPixelBus})\par
-TimeLib({\f2 https://github.com/PaulStoffregen/Time})\par
-DS1337RTC({\f2 https://github.com/etrombly/DS1337RTC})\par
-DallasTemperature({\f2 https://github.com/milesburton/Arduino-Temperature-Control-Library})\par
Configuration Files :\par
-The {\b CoolBoard} API heavily uses the SPIFFS for storing and retreiving configuration and data files\par
This is a description of the configuration files and what are they used for :\par
1/coolBoardConfig.json :\par
logInterval: The time Interval to wait,in seconds, between two logs\par
ireneActive: Put this flag to 1(true) if you are using the {\b Irene3000} module\par
jetpackActive:Put this flag to 1(true) if you are using the {\b Jetpack} modue\par
externalSensorsActive: Put this flag to 1(true) if you are using a supported external Sensor\par
sleepActive: Put this flag to 1(true) if you want your {\b CoolBoard} to enable Sleep mode In Sleep Mode : your {\b CoolBoard} will do the following : -readSensors -activate Actors(if any) -log the data -check for updates -go to sleep for logInterval period of time\par
userActive:Put this flag to 1(true) if you want your {\b CoolBoard} to collect userData : userName {\b CoolBoard} MAC Address TimeStamp\par
manual /!\\ : Put this flag to 1(true) to control to turn on/off your actors and bypass your initial actors configuration {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid          Be Careful with this mode!!.\par
\par
         When this mode is actif , the CoolBoard will not restart automatically to apply any new configuration sent via\par
         the update method.\par
\par
         Restarting the coolBoard when in manual mode will deactivate all the actors!\par
\par
         Never forget to reset this to 0(false) to go back to normal mode!\par
}
\par
2/coolBoardLedConfig.json:\par
ledActive: Put this flag to 1(true) if you want to have Light Effects from the on Board LED\par
3/coolBoardSensorsConfig.json:\par
temperature : Put this flag to 1(true) if you want to collect the Temperature using the {\b BME280} Sensor\par
humidity : Put this flag to 1(true) if you want to collect the humidity using the {\b BME280} Sensor\par
pressure : Put this flag to 1(true) if you want to collect the pressure using the {\b BME280} Sensor\par
visible : Put this flag to 1(true) if you want to collect the visible light index using the SI114X Sensor\par
ir : Put this flag to 1(true) if you want to collect the infrared light index using the SI114X Sensor\par
uv : Put this flag to 1(true) if you want to collect the ultraviolet light index using the SI114X Sensor\par
vbat : Put this flag to 1(true) if you want to collect the battery voltage\par
soilMoisture : Put this flag to 1(true) if you want to collect the soil Moisture\par
4/externalSensorsConfig.json:\par
sensorsNumber: the number of supported external sensors you connect to the coolBoard\par
reference: the reference of a supported external sensor(e.g {\b NDIR_I2C} , DallasTemperature )\par
type: the type of the measurments you are making (e.g : co2, temperature,voltage ... )\par
address : the sensor's address , if it has one (e.g : {\b NDIR_I2C} CO2 sensor's address is 77 )\par
5/irene3000Config.json:\par
waterTemp.active: Put this flag to 1(true) in order to use the temperature sensor connected to the {\b Irene3000}\par
phProbe.active: Put this flag to 1(true) in order to use the ph sensor connected to the {\b Irene3000}\par
adc2.active: Put this flag to 1(true) in order to use the extra ADC input of the {\b Irene3000}\par
adc2.gain: this is the value of the gain applied to the extra ADC input of the {\b Irene3000}\par
adc2.type: the type of the measurments you are making (e.g : co2, temperature,voltage ... )\par
6/jetPackConfig.json and coolBoardActorConfig.json:\par
Act[i].actif: Put this flag to 1(true) in order to use the jetpack output N\'EF\'BF\'BDi (0..7)\par
Act[i].inverted:Put this flag to 1(true) if the actor is inverted (e.g : a cooler is activated when Temp>TempMax) Put this flag to 0(false) if the actor is notInverted(e.g : a heater is activated when Temp<TempMin)\par
Act[i].temporal:Put this flag to 1(true) if you want the actor to be actif of a period of time , then inactif for another period of time.\par
Act[i].type:["primaryType","secondaryType"] : this array contains the priamryType and the secondaryType of the actor -The primaryType is the type associated to the sensors. (e.g : primaryType : "Temperature" is associated to the sensor of type "Temperature"). -It can also be empty , in case of PURE temporal actors\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                              -The secondaryType is only used in temporal mode.\par
                                             it can be : -"" (empty):the actor will be on for a period of timeHigh ms\par
                                                                     the actor will be off for a period of timeLow ms\par
\par
                                                         -"hour" :the actor will be on when the Hour is equal or greater then hourHigh\par
                                                                  the actor will be off when the Hour is equal or greater then hourLow\par
\par
                                                         -"minute":the actor will be on when the Minute is equal or greater then minuteHigh\par
                                                                  :the actor will be off when the Minute is equal or greater then minuteLow\par
\par
                                                         -"hourMinute":the actor will be on when : Hour == hourHigh AND Minute >= minuteHigh\par
                                                                                                   Hour > hourHigh\par
                                                                       the actor will be off when : Hour == hourLow AND Minute >= minuteLow\par
                                                                                                    Hour>hourLow\par
\par
                                              /!\\ NOTE  that if both primaryType and secondaryType are valid : the actor will be in\par
                                                 mixed mode : it will need to valid both Time and measurment conditions to go on or off\par
\par
Act[i].low:[rangeLow,timeLow,hourLow,minuteLow] : this array contains the values previously described:\par
                                                  -rangeLow is the minimum of the range at which \par
                                                  to activate(deactivate in inverted mode) the actor\par
\par
                                                  -timeLow is the time spent off in temporal mode\par
\par
                                                  -hourLow is the hour to turn off the actor when secondaryType is hour or hourMinute\par
\par
                                                  -minuteLow is the minute to turn off the actor when secondaryType is minute or hourMinute\par
\par
\par
Act[i].high:[rangeHigh,timeHigh,hourHigh,minuteHigh]: this array contains the values previously described:\par
                                                  -rangeHigh is the maximum of the range at which \par
                                                  to deactivate(activate in inverted mode) the actor\par
\par
                                                  -timeHigh is the time spent on in temporal mode\par
\par
                                                  -hourHigh is the hour to turn on the actor when secondaryType is hour or hourMinute\par
\par
                                                  -minuteHigh is the minute to turn on the actor when secondaryType is minute or hourMinute\par
\par
\par
   Note that the coolBoardActorConfig.json contains only one Actor.\par
}
\par
7/mqttConfig.json:\par
mqttServer: This is the mqttServer (ip/url) address\par
user: This is the userId\par
bufferSize: This is the memory allocated to the mqtt buffer in bytes\par
inTopic : this is the topic that the coolBoard subscribes to (receives updates from )\par
outTopic : this is the topic that the coolBoard will publish to.\par
8/rtcConfig.json:\par
timeServer: NTP server ip address\par
localPort: port used to make the NTP request to update the time\par
9/wifiConfig.json:\par
wifiCount: the number of wifis saved in this configuration file\par
timeOut:access point timeout in seconds.\par
nomad: put this flag to 1(true) to activate nomad mode. in nomad mode : the coolBoard will only try to connect to known WiFis. if it fails it will NOT lunch the access point.\par
How to run the exemples : {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid -Open Arduino IDE \par
\par
-File > Exemples > CoolBoard\par
\par
-Select the Exemple you want\par
\par
-Flash it\par
\par
-Flash the SPIFFS ( this is only required for the CoolBoardExemple, CoolBoardFarmExemple and CoolBoardStationExemple)\par
\par
-Open The Serial Monitor\par
\par
-Sit back and Enjoy!\par
}
\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Contribution guidelines} \par}
For minor fixes of code and documentation, please go ahead and submit a pull request.\par
Larger changes (rewriting parts of existing code from scratch, adding new functions to the core, adding new libraries) should generally be discussed by opening an issue first.\par
Feature branches with lots of small commits (especially titled "oops", "fix typo", "forgot to add file", etc.) should be squashed before opening a pull request. At the same time, please refrain from putting multiple unrelated changes into a single pull request.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 License and credits} \par}
All files under src/internal are modified versions of existing libraries. All Credit of the original work goes to their respective authors.\par
All Other files are provided as is under {\i insert License here}  . We can only gurantee that we did our best to have everything working on our side.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Who do I talk to?} \par}
If you encounter a problem , have a good idea or just want to talk\par
Please open an issue, a pull request or send us an email :\par
La Cool Co {\f2 team@lacool.co} \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Adafruit_ADS1015\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Adafruit_ADS1115\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
CoolBoardSensors::airActive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
BaseExternalSensor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ExternalSensor< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensor< DallasTemperature >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensor< NDIR_I2C >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
BME280\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoard\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardActor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardLed\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardSensors\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolFileSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolMQTT\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolPubSubClient\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolSI114X\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolTime\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolWifi\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensors\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Irene3000\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Jetpack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardSensors::lightActive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NDIR_I2C\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Irene3000::parameters_T\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ExternalSensors::sensor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SensorCalibration\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SensorSettings\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Irene3000::state\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Jetpack::state\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoolBoardActor::state\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
WiFiManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
WiFiManagerParameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Adafruit_ADS1015} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Adafruit_ADS1115} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardSensors::airActive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BaseExternalSensor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BME280} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoard} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardActor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardLed} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardSensors} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolFileSystem} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolMQTT} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolPubSubClient} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolSI114X} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolTime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolWifi} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensor< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensor< DallasTemperature >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensor< NDIR_I2C >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensors} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Irene3000} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Jetpack} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardSensors::lightActive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NDIR_I2C} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Irene3000::parameters_T} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExternalSensors::sensor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SensorCalibration} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SensorSettings} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Irene3000::state} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Jetpack::state} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoolBoardActor::state} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b WiFiManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b WiFiManagerParameter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Source file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b irene3000.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Source File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Header File })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/{\b parse.js} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/{\b template.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Adafruit_ADS1015 Class Reference\par \pard\plain 
{\tc\tcl2 \v Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\par
{
{\f2 #include <CoolAdafruit_ADS1015.h>}}\par
Inheritance diagram for Adafruit_ADS1015:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d7a/class_adafruit___a_d_s1015__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Adafruit_ADS1015:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d64/class_adafruit___a_d_s1015__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_ADS1015} (uint8_t i2cAddress={\b ADS1015_ADDRESS})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1015 class w/appropriate properties. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the HW (reads coefficients values, etc.) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b readADC_SingleEnded} (uint8_t channel)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a single-ended ADC reading from the specified channel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b readADC_Differential_0_1} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN0) and N (AIN1) input. Generates a signed value since the difference can be either positive or negative. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b readADC_Differential_2_3} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN2) and N (AIN3) input. Generates a signed value since the difference can be either positive or negative. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startComparator_SingleEnded} (uint8_t channel, int16_t threshold)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the comparator to operate in basic mode, causing the ALERT/RDY pin to assert (go from high to low) when the ADC value exceeds the specified threshold. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b getLastConversionResults} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In order to clear the comparator, we need to read the conversion results. This function reads the last conversion results without changing the config value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGain} ({\b adsGain_t} gain)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gain and input voltage range. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b getGain} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a gain and input voltage range. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b m_i2cAddress}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b m_conversionDelay}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b m_bitShift}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b m_gain}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 119 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Adafruit_ADS1015\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:Adafruit_ADS1015}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Adafruit_ADS1015::Adafruit_ADS1015 (uint8_t  {\i i2cAddress} = {\f2 {\b ADS1015_ADDRESS}})}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1015 class w/appropriate properties. }}\par
{
Definition at line 88 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    89 \{\par
   90    m_i2cAddress = i2cAddress;\par
   91    m_conversionDelay = ADS1015_CONVERSIONDELAY;\par
   92    m_bitShift = 4;\par
   93    m_gain = GAIN_TWOTHIRDS; /* +/- 6.144V range (limited to VDD +0.3V max!) */\par
   94 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_ADS1015::begin (void )}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the HW (reads coefficients values, etc.) }}\par
{
Definition at line 114 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114                              \{\par
  115   Wire.begin(2,14);\par
  116 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a6eba7c3cd854927f60883bb371e5faa6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getGain\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:getGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Adafruit_ADS1015::getGain (void )}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a gain and input voltage range. }}\par
{
Definition at line 133 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134 \{\par
  135   return m_gain;\par
  136 \}\par
}
}
{\xe \v getLastConversionResults\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:getLastConversionResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Adafruit_ADS1015::getLastConversionResults ()}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In order to clear the comparator, we need to read the conversion results. This function reads the last conversion results without changing the config value. }}\par
{
Definition at line 348 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   349 \{\par
  350   // Wait for the conversion to complete\par
  351   delay(m_conversionDelay);\par
  352 \par
  353   // Read the conversion results\par
  354   uint16_t res = readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;\par
  355   if (m_bitShift == 0)\par
  356   \{\par
  357     return (int16_t)res;\par
  358   \}\par
  359   else\par
  360   \{\par
  361     // Shift 12-bit results right 4 bits for the ADS1015,\par
  362     // making sure we keep the sign bit intact\par
  363     if (res > 0x07FF)\par
  364     \{\par
  365       // negative number - extend the sign to 16th bit\par
  366       res |= 0xF000;\par
  367     \}\par
  368     return (int16_t)res;\par
  369   \}\par
  370 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_ad8f36d80847020778425107f6451a8c2_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADC_Differential_0_1\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:readADC_Differential_0_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Adafruit_ADS1015::readADC_Differential_0_1 (void )}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN0) and N (AIN1) input. Generates a signed value since the difference can be either positive or negative. }}\par
{
Definition at line 199 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   199                                                    \{\par
  200   // Start with default values\par
  201   uint16_t config = ADS1015_REG_CONFIG_CQUE_NONE    | // Disable the comparator (default val)\par
  202                     ADS1015_REG_CONFIG_CLAT_NONLAT  | // Non-latching (default val)\par
  203                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  204                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  205                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  206                     ADS1015_REG_CONFIG_MODE_SINGLE;   // Single-shot mode (default)\par
  207 \par
  208   // Set PGA/voltage range\par
  209   config |= m_gain;\par
  210                     \par
  211   // Set channels\par
  212   config |= ADS1015_REG_CONFIG_MUX_DIFF_0_1;          // AIN0 = P, AIN1 = N\par
  213 \par
  214   // Set 'start single-conversion' bit\par
  215   config |= ADS1015_REG_CONFIG_OS_SINGLE;\par
  216 \par
  217   // Write config register to the ADC\par
  218   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  219 \par
  220   // Wait for the conversion to complete\par
  221   delay(m_conversionDelay);\par
  222 \par
  223   // Read the conversion results\par
  224   uint16_t res = readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;\par
  225   if (m_bitShift == 0)\par
  226   \{\par
  227     return (int16_t)res;\par
  228   \}\par
  229   else\par
  230   \{\par
  231     // Shift 12-bit results right 4 bits for the ADS1015,\par
  232     // making sure we keep the sign bit intact\par
  233     if (res > 0x07FF)\par
  234     \{\par
  235       // negative number - extend the sign to 16th bit\par
  236       res |= 0xF000;\par
  237     \}\par
  238     return (int16_t)res;\par
  239   \}\par
  240 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a56582333958e66efaccd3d4a8a47e3ff_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADC_Differential_2_3\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:readADC_Differential_2_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Adafruit_ADS1015::readADC_Differential_2_3 (void )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the conversion results, measuring the voltage difference between the P (AIN2) and N (AIN3) input. Generates a signed value since the difference can be either positive or negative. }}\par
{
Definition at line 250 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   250                                                    \{\par
  251   // Start with default values\par
  252   uint16_t config = ADS1015_REG_CONFIG_CQUE_NONE    | // Disable the comparator (default val)\par
  253                     ADS1015_REG_CONFIG_CLAT_NONLAT  | // Non-latching (default val)\par
  254                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  255                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  256                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  257                     ADS1015_REG_CONFIG_MODE_SINGLE;   // Single-shot mode (default)\par
  258 \par
  259   // Set PGA/voltage range\par
  260   config |= m_gain;\par
  261 \par
  262   // Set channels\par
  263   config |= ADS1015_REG_CONFIG_MUX_DIFF_2_3;          // AIN2 = P, AIN3 = N\par
  264 \par
  265   // Set 'start single-conversion' bit\par
  266   config |= ADS1015_REG_CONFIG_OS_SINGLE;\par
  267 \par
  268   // Write config register to the ADC\par
  269   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  270 \par
  271   // Wait for the conversion to complete\par
  272   delay(m_conversionDelay);\par
  273 \par
  274   // Read the conversion results\par
  275   uint16_t res = readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;\par
  276   if (m_bitShift == 0)\par
  277   \{\par
  278     return (int16_t)res;\par
  279   \}\par
  280   else\par
  281   \{\par
  282     // Shift 12-bit results right 4 bits for the ADS1015,\par
  283     // making sure we keep the sign bit intact\par
  284     if (res > 0x07FF)\par
  285     \{\par
  286       // negative number - extend the sign to 16th bit\par
  287       res |= 0xF000;\par
  288     \}\par
  289     return (int16_t)res;\par
  290   \}\par
  291 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a38311881bcab46f7496c4bb6e4cad576_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADC_SingleEnded\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:readADC_SingleEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Adafruit_ADS1015::readADC_SingleEnded (uint8_t  {\i channel})}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a single-ended ADC reading from the specified channel. }}\par
{
Definition at line 143 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   143                                                               \{\par
  144   if (channel > 3)\par
  145   \{\par
  146     return 0;\par
  147   \}\par
  148   \par
  149   // Start with default values\par
  150   uint16_t config = ADS1015_REG_CONFIG_CQUE_NONE    | // Disable the comparator (default val)\par
  151                     ADS1015_REG_CONFIG_CLAT_NONLAT  | // Non-latching (default val)\par
  152                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  153                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  154                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  155                     ADS1015_REG_CONFIG_MODE_SINGLE;   // Single-shot mode (default)\par
  156 \par
  157   // Set PGA/voltage range\par
  158   config |= m_gain;\par
  159 \par
  160   // Set single-ended input channel\par
  161   switch (channel)\par
  162   \{\par
  163     case (0):\par
  164       config |= ADS1015_REG_CONFIG_MUX_SINGLE_0;\par
  165       break;\par
  166     case (1):\par
  167       config |= ADS1015_REG_CONFIG_MUX_SINGLE_1;\par
  168       break;\par
  169     case (2):\par
  170       config |= ADS1015_REG_CONFIG_MUX_SINGLE_2;\par
  171       break;\par
  172     case (3):\par
  173       config |= ADS1015_REG_CONFIG_MUX_SINGLE_3;\par
  174       break;\par
  175   \}\par
  176 \par
  177   // Set 'start single-conversion' bit\par
  178   config |= ADS1015_REG_CONFIG_OS_SINGLE;\par
  179 \par
  180   // Write config register to the ADC\par
  181   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  182 \par
  183   // Wait for the conversion to complete\par
  184   delay(m_conversionDelay);\par
  185 \par
  186   // Read the conversion results\par
  187   // Shift 12-bit results right 4 bits for the ADS1015\par
  188   return readRegister(m_i2cAddress, ADS1015_REG_POINTER_CONVERT) >> m_bitShift;  \par
  189 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a40f38b9e1f3ec397c0670dd632510235_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a40f38b9e1f3ec397c0670dd632510235_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setGain\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:setGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_ADS1015::setGain ({\b adsGain_t}  {\i gain})}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gain and input voltage range. }}\par
{
Definition at line 123 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   124 \{\par
  125   m_gain = gain;\par
  126 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_a399441eace686975ff22937cbe45cc50_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startComparator_SingleEnded\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:startComparator_SingleEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_ADS1015::startComparator_SingleEnded (uint8_t  {\i channel}, int16_t  {\i threshold})}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets up the comparator to operate in basic mode, causing the ALERT/RDY pin to assert (go from high to low) when the ADC value exceeds the specified threshold. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will also set the ADC in continuous conversion mode. \par
}{
Definition at line 302 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   303 \{\par
  304   // Start with default values\par
  305   uint16_t config = ADS1015_REG_CONFIG_CQUE_1CONV   | // Comparator enabled and asserts on 1 match\par
  306                     ADS1015_REG_CONFIG_CLAT_LATCH   | // Latching mode\par
  307                     ADS1015_REG_CONFIG_CPOL_ACTVLOW | // Alert/Rdy active low   (default val)\par
  308                     ADS1015_REG_CONFIG_CMODE_TRAD   | // Traditional comparator (default val)\par
  309                     ADS1015_REG_CONFIG_DR_1600SPS   | // 1600 samples per second (default)\par
  310                     ADS1015_REG_CONFIG_MODE_CONTIN  | // Continuous conversion mode\par
  311                     ADS1015_REG_CONFIG_MODE_CONTIN;   // Continuous conversion mode\par
  312 \par
  313   // Set PGA/voltage range\par
  314   config |= m_gain;\par
  315                     \par
  316   // Set single-ended input channel\par
  317   switch (channel)\par
  318   \{\par
  319     case (0):\par
  320       config |= ADS1015_REG_CONFIG_MUX_SINGLE_0;\par
  321       break;\par
  322     case (1):\par
  323       config |= ADS1015_REG_CONFIG_MUX_SINGLE_1;\par
  324       break;\par
  325     case (2):\par
  326       config |= ADS1015_REG_CONFIG_MUX_SINGLE_2;\par
  327       break;\par
  328     case (3):\par
  329       config |= ADS1015_REG_CONFIG_MUX_SINGLE_3;\par
  330       break;\par
  331   \}\par
  332 \par
  333   // Set the high threshold register\par
  334   // Shift 12-bit results left 4 bits for the ADS1015\par
  335   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_HITHRESH, threshold << m_bitShift);\par
  336 \par
  337   // Write config register to the ADC\par
  338   writeRegister(m_i2cAddress, ADS1015_REG_POINTER_CONFIG, config);\par
  339 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/df6/class_adafruit___a_d_s1015_aecd30775d943ea9d9cff0e3485926596_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_bitShift\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_bitShift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Adafruit_ADS1015::m_bitShift{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v m_conversionDelay\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_conversionDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Adafruit_ADS1015::m_conversionDelay{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v m_gain\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_gain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Adafruit_ADS1015::m_gain{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v m_i2cAddress\:Adafruit_ADS1015}
{\xe \v Adafruit_ADS1015\:m_i2cAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Adafruit_ADS1015::m_i2cAddress{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Adafruit_ADS1115 Class Reference\par \pard\plain 
{\tc\tcl2 \v Adafruit_ADS1115}
{\xe \v Adafruit_ADS1115}
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
{
{\f2 #include <CoolAdafruit_ADS1015.h>}}\par
Inheritance diagram for Adafruit_ADS1115:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/de8/class_adafruit___a_d_s1115__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Adafruit_ADS1115:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/ddc/class_adafruit___a_d_s1115__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_ADS1115} (uint8_t i2cAddress={\b ADS1015_ADDRESS})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1115 class w/appropriate properties. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 143 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Adafruit_ADS1115\:Adafruit_ADS1115}
{\xe \v Adafruit_ADS1115\:Adafruit_ADS1115}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Adafruit_ADS1115::Adafruit_ADS1115 (uint8_t  {\i i2cAddress} = {\f2 {\b ADS1015_ADDRESS}})}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiates a new ADS1115 class w/appropriate properties. }}\par
{
Definition at line 101 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   102 \{\par
  103    m_i2cAddress = i2cAddress;\par
  104    m_conversionDelay = ADS1115_CONVERSIONDELAY;\par
  105    m_bitShift = 0;\par
  106    m_gain = GAIN_TWOTHIRDS; /* +/- 6.144V range (limited to VDD +0.3V max!) */\par
  107 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolAdafruit_ADS1015.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardSensors::airActive Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive}
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
Collaboration diagram for CoolBoardSensors::airActive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d30/struct_cool_board_sensors_1_1air_active__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b temperature} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b humidity} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pressure} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 98 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v humidity\:CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive\:humidity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::airActive::humidity =0}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolBoardSensors.h.}\par
}
{\xe \v pressure\:CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive\:pressure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::airActive::pressure =0}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolBoardSensors.h.}\par
}
{\xe \v temperature\:CoolBoardSensors::airActive}
{\xe \v CoolBoardSensors::airActive\:temperature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::airActive::temperature =0}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BaseExternalSensor Class Reference\par \pard\plain 
{\tc\tcl2 \v BaseExternalSensor}
{\xe \v BaseExternalSensor}
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for BaseExternalSensor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d26/class_base_external_sensor__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for BaseExternalSensor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc4/class_base_external_sensor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BaseExternalSensor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism. \par
}{
Definition at line 48 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BaseExternalSensor\:BaseExternalSensor}
{\xe \v BaseExternalSensor\:BaseExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BaseExternalSensor::BaseExternalSensor (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b BaseExternalSensor()}: Base class generic Constructor \par
}{
Definition at line 56 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    57     \{\par
   58 \par
   59     #if DEBUGExternal == 1 \par
   60 \par
   61         Serial.println( "BaseExternalSensor Constructor" );\par
   62         Serial.println();\par
   63     \par
   64     #endif\par
   65 \par
   66     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:BaseExternalSensor}
{\xe \v BaseExternalSensor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t BaseExternalSensor::begin (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b begin()}: Base class virtual generic begin method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid generic value as it's not supposed to be used \par
}}{
Reimplemented in {\b ExternalSensor< DallasTemperature >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b ExternalSensor< NDIR_I2C >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b ExternalSensor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 76 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    77     \{\par
   78     \par
   79     #if DEBUGExternal == 1 \par
   80     \par
   81         Serial.println( "BaseExternalSensor.begin()" );\par
   82         Serial.println();\par
   83     \par
   84     #endif\par
   85 \par
   86         return(-2);\par
   87     \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d68/class_base_external_sensor_a87d132803d4f4fdd4e66332809f0c9a0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:BaseExternalSensor}
{\xe \v BaseExternalSensor\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float BaseExternalSensor::read (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b read()}: Base class virtual generic read method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid generic value as it is not supposed to be used \par
}}{
Reimplemented in {\b ExternalSensor< DallasTemperature >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b ExternalSensor< NDIR_I2C >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b ExternalSensor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 98 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    99     \{\par
  100     \par
  101     #if DEBUGExternal == 1 \par
  102 \par
  103         Serial.println( "BaseExternalSensor.read()" );\par
  104         Serial.println();\par
  105     \par
  106     #endif      \par
  107         \par
  108         return(-2);\par
  109     \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d68/class_base_external_sensor_a1564f16deacf57b51b9948ac29db4291_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BME280 Class Reference\par \pard\plain 
{\tc\tcl2 \v BME280}
{\xe \v BME280}
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
\par
{
{\f2 #include <CoolSparkFunBME280.h>}}\par
Collaboration diagram for BME280:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d82/class_b_m_e280__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BME280} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b begin} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatPressure} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatAltitudeMeters} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatAltitudeFeet} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readFloatHumidity} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readTempC} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readTempF} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readRegisterRegion} (uint8_t *, uint8_t, uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b readRegister} (uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b readRegisterInt16} (uint8_t offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeRegister} (uint8_t, uint8_t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SensorSettings} {\b settings}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SensorCalibration} {\b calibration}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b t_fine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 143 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BME280\:BME280}
{\xe \v BME280\:BME280}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BME280::BME280 (void )}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     //Construct with these default settings if nothing is specified\par
   46 \par
   47     //Select interface mode\par
   48     settings.commInterface = I2C_MODE; //Can be I2C_MODE, SPI_MODE\par
   49     //Select address for I2C.  Does nothing for SPI\par
   50     settings.I2CAddress = 0x77; //Ignored for SPI_MODE\par
   51     //Select CS pin for SPI.  Does nothing for I2C\par
   52     settings.chipSelectPin = 10;\par
   53     settings.runMode = 0;\par
   54     settings.tempOverSample = 0;\par
   55     settings.pressOverSample = 0;\par
   56     settings.humidOverSample = 0;\par
   57 \par
   58 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:BME280}
{\xe \v BME280\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BME280::begin (void )}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     //Check the settings structure values to determine how to setup the device\par
   73     uint8_t dataToWrite = 0;  //Temporary variable\par
   74 \par
   75     switch (settings.commInterface)\par
   76     \{\par
   77 \par
   78     case I2C_MODE:\par
   79         Wire.begin(2,14);\par
   80         break;\par
   81 \par
   82     case SPI_MODE:\par
   83         // start the SPI library:\par
   84         SPI.begin();\par
   85         // Maximum SPI frequency is 10MHz, could divide by 2 here:\par
   86         SPI.setClockDivider(SPI_CLOCK_DIV32);\par
   87         // Data is read and written MSb first.\par
   88         SPI.setBitOrder(MSBFIRST);\par
   89         // Data is captured on rising edge of clock (CPHA = 0)\par
   90         // Base value of the clock is HIGH (CPOL = 1)\par
   91         // This was SPI_MODE3 for RedBoard, but I had to change to\par
   92         // MODE0 for Teensy 3.1 operation\par
   93         SPI.setDataMode(SPI_MODE3);\par
   94         // initalize the  data ready and chip select pins:\par
   95         pinMode(settings.chipSelectPin, OUTPUT);\par
   96         digitalWrite(settings.chipSelectPin, HIGH);\par
   97         break;\par
   98 \par
   99     default:\par
  100         break;\par
  101     \}\par
  102 \par
  103     //Reading all compensation data, range 0x88:A1, 0xE1:E7\par
  104     \par
  105     calibration.dig_T1 = ((uint16_t)((readRegister(BME280_DIG_T1_MSB_REG) << 8) + readRegister(BME280_DIG_T1_LSB_REG)));\par
  106     calibration.dig_T2 = ((int16_t)((readRegister(BME280_DIG_T2_MSB_REG) << 8) + readRegister(BME280_DIG_T2_LSB_REG)));\par
  107     calibration.dig_T3 = ((int16_t)((readRegister(BME280_DIG_T3_MSB_REG) << 8) + readRegister(BME280_DIG_T3_LSB_REG)));\par
  108 \par
  109     calibration.dig_P1 = ((uint16_t)((readRegister(BME280_DIG_P1_MSB_REG) << 8) + readRegister(BME280_DIG_P1_LSB_REG)));\par
  110     calibration.dig_P2 = ((int16_t)((readRegister(BME280_DIG_P2_MSB_REG) << 8) + readRegister(BME280_DIG_P2_LSB_REG)));\par
  111     calibration.dig_P3 = ((int16_t)((readRegister(BME280_DIG_P3_MSB_REG) << 8) + readRegister(BME280_DIG_P3_LSB_REG)));\par
  112     calibration.dig_P4 = ((int16_t)((readRegister(BME280_DIG_P4_MSB_REG) << 8) + readRegister(BME280_DIG_P4_LSB_REG)));\par
  113     calibration.dig_P5 = ((int16_t)((readRegister(BME280_DIG_P5_MSB_REG) << 8) + readRegister(BME280_DIG_P5_LSB_REG)));\par
  114     calibration.dig_P6 = ((int16_t)((readRegister(BME280_DIG_P6_MSB_REG) << 8) + readRegister(BME280_DIG_P6_LSB_REG)));\par
  115     calibration.dig_P7 = ((int16_t)((readRegister(BME280_DIG_P7_MSB_REG) << 8) + readRegister(BME280_DIG_P7_LSB_REG)));\par
  116     calibration.dig_P8 = ((int16_t)((readRegister(BME280_DIG_P8_MSB_REG) << 8) + readRegister(BME280_DIG_P8_LSB_REG)));\par
  117     calibration.dig_P9 = ((int16_t)((readRegister(BME280_DIG_P9_MSB_REG) << 8) + readRegister(BME280_DIG_P9_LSB_REG)));\par
  118 \par
  119     calibration.dig_H1 = ((uint8_t)(readRegister(BME280_DIG_H1_REG)));\par
  120     calibration.dig_H2 = ((int16_t)((readRegister(BME280_DIG_H2_MSB_REG) << 8) + readRegister(BME280_DIG_H2_LSB_REG)));\par
  121     calibration.dig_H3 = ((uint8_t)(readRegister(BME280_DIG_H3_REG)));\par
  122     calibration.dig_H4 = ((int16_t)((readRegister(BME280_DIG_H4_MSB_REG) << 4) + (readRegister(BME280_DIG_H4_LSB_REG) & 0x0F)));\par
  123     calibration.dig_H5 = ((int16_t)((readRegister(BME280_DIG_H5_MSB_REG) << 4) + ((readRegister(BME280_DIG_H4_LSB_REG) >> 4) & 0x0F)));\par
  124     calibration.dig_H6 = ((uint8_t)readRegister(BME280_DIG_H6_REG));\par
  125 \par
  126     //Set the oversampling control words.\par
  127     //config will only be writeable in sleep mode, so first insure that.\par
  128     writeRegister(BME280_CTRL_MEAS_REG, 0x00);\par
  129     \par
  130     //Set the config word\par
  131     dataToWrite = (settings.tStandby << 0x5) & 0xE0;\par
  132     dataToWrite |= (settings.filter << 0x02) & 0x1C;\par
  133     writeRegister(BME280_CONFIG_REG, dataToWrite);\par
  134     \par
  135     //Set ctrl_hum first, then ctrl_meas to activate ctrl_hum\par
  136     dataToWrite = settings.humidOverSample & 0x07; //all other bits can be ignored\par
  137     writeRegister(BME280_CTRL_HUMIDITY_REG, dataToWrite);\par
  138     \par
  139     //set ctrl_meas\par
  140     //First, set temp oversampling\par
  141     dataToWrite = (settings.tempOverSample << 0x5) & 0xE0;\par
  142     //Next, pressure oversampling\par
  143     dataToWrite |= (settings.pressOverSample << 0x02) & 0x1C;\par
  144     //Last, set mode\par
  145     dataToWrite |= (settings.runMode) & 0x03;\par
  146     //Load the byte\par
  147     writeRegister(BME280_CTRL_MEAS_REG, dataToWrite);\par
  148     \par
  149     return readRegister(0xD0);\par
  150 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a994c102f010547f9c740a338ef9905c7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a994c102f010547f9c740a338ef9905c7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatAltitudeFeet\:BME280}
{\xe \v BME280\:readFloatAltitudeFeet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatAltitudeFeet (void )}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 201 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   202 \{\par
  203     float heightOutput = 0;\par
  204     \par
  205     heightOutput = readFloatAltitudeMeters() * 3.28084;\par
  206     return heightOutput;\par
  207     \par
  208 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a6525c8a26f887b52596c86bed99343cb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatAltitudeMeters\:BME280}
{\xe \v BME280\:readFloatAltitudeMeters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatAltitudeMeters (void )}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194     float heightOutput = 0;\par
  195     \par
  196     heightOutput = ((float)-45846.2)*(pow(((float)readFloatPressure()/(float)101325), 0.190263) - (float)1);\par
  197     return heightOutput;\par
  198     \par
  199 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_af67b56ba50760ee1d116acc6c5010221_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_af67b56ba50760ee1d116acc6c5010221_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatHumidity\:BME280}
{\xe \v BME280\:readFloatHumidity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatHumidity (void )}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 215 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   216 \{\par
  217     \par
  218     // Returns humidity in %RH as unsigned 32 bit integer in Q22. 10 format (22 integer and 10 fractional bits).\par
  219     // Output value of \'9347445\'94 represents 47445/1024 = 46. 333 %RH\par
  220     int32_t adc_H = ((uint32_t)readRegister(BME280_HUMIDITY_MSB_REG) << 8) | ((uint32_t)readRegister(BME280_HUMIDITY_LSB_REG));\par
  221     \par
  222     int32_t var1;\par
  223     var1 = (t_fine - ((int32_t)76800));\par
  224     var1 = (((((adc_H << 14) - (((int32_t)calibration.dig_H4) << 20) - (((int32_t)calibration.dig_H5) * var1)) +\par
  225     ((int32_t)16384)) >> 15) * (((((((var1 * ((int32_t)calibration.dig_H6)) >> 10) * (((var1 * ((int32_t)calibration.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) + ((int32_t)2097152)) *\par
  226     ((int32_t)calibration.dig_H2) + 8192) >> 14));\par
  227     var1 = (var1 - (((((var1 >> 15) * (var1 >> 15)) >> 7) * ((int32_t)calibration.dig_H1)) >> 4));\par
  228     var1 = (var1 < 0 ? 0 : var1);\par
  229     var1 = (var1 > 419430400 ? 419430400 : var1);\par
  230 \par
  231     return (float)(var1>>12) / 1024.0;\par
  232 \par
  233 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a42ea7232039eebf5aadb391ef6132c35_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a42ea7232039eebf5aadb391ef6132c35_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readFloatPressure\:BME280}
{\xe \v BME280\:readFloatPressure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readFloatPressure (void )}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 164 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166 \par
  167     // Returns pressure in Pa as unsigned 32 bit integer in Q24.8 format (24 integer bits and 8 fractional bits).\par
  168     // Output value of \'9324674867\'94 represents 24674867/256 = 96386.2 Pa = 963.862 hPa\par
  169     int32_t adc_P = ((uint32_t)readRegister(BME280_PRESSURE_MSB_REG) << 12) | ((uint32_t)readRegister(BME280_PRESSURE_LSB_REG) << 4) | ((readRegister(BME280_PRESSURE_XLSB_REG) >> 4) & 0x0F);\par
  170     \par
  171     int64_t var1, var2, p_acc;\par
  172     var1 = ((int64_t)t_fine) - 128000;\par
  173     var2 = var1 * var1 * (int64_t)calibration.dig_P6;\par
  174     var2 = var2 + ((var1 * (int64_t)calibration.dig_P5)<<17);\par
  175     var2 = var2 + (((int64_t)calibration.dig_P4)<<35);\par
  176     var1 = ((var1 * var1 * (int64_t)calibration.dig_P3)>>8) + ((var1 * (int64_t)calibration.dig_P2)<<12);\par
  177     var1 = (((((int64_t)1)<<47)+var1))*((int64_t)calibration.dig_P1)>>33;\par
  178     if (var1 == 0)\par
  179     \{\par
  180         return 0; // avoid exception caused by division by zero\par
  181     \}\par
  182     p_acc = 1048576 - adc_P;\par
  183     p_acc = (((p_acc<<31) - var2)*3125)/var1;\par
  184     var1 = (((int64_t)calibration.dig_P9) * (p_acc>>13) * (p_acc>>13)) >> 25;\par
  185     var2 = (((int64_t)calibration.dig_P8) * p_acc) >> 19;\par
  186     p_acc = ((p_acc + var1 + var2) >> 8) + (((int64_t)calibration.dig_P7)<<4);\par
  187     \par
  188     return (float)p_acc / 256.0;\par
  189     \par
  190 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_ada6e799917afb4f228e6253bc56ffe75_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_ada6e799917afb4f228e6253bc56ffe75_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegister\:BME280}
{\xe \v BME280\:readRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BME280::readRegister (uint8_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 325 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   326 \{\par
  327     //Return value\par
  328     uint8_t result;\par
  329     uint8_t numBytes = 1;\par
  330     switch (settings.commInterface) \{\par
  331 \par
  332     case I2C_MODE:\par
  333         Wire.beginTransmission(settings.I2CAddress);\par
  334         Wire.write(offset);\par
  335         Wire.endTransmission();\par
  336 \par
  337         Wire.requestFrom(settings.I2CAddress, numBytes);\par
  338         while ( Wire.available() ) // slave may send less than requested\par
  339         \{\par
  340             result = Wire.read(); // receive a byte as a proper uint8_t\par
  341         \}\par
  342         break;\par
  343 \par
  344     case SPI_MODE:\par
  345         // take the chip select low to select the device:\par
  346         digitalWrite(settings.chipSelectPin, LOW);\par
  347         // send the device the register you want to read:\par
  348         SPI.transfer(offset | 0x80);  //Ored with "read request" bit\par
  349         // send a value of 0 to read the first byte returned:\par
  350         result = SPI.transfer(0x00);\par
  351         // take the chip select high to de-select:\par
  352         digitalWrite(settings.chipSelectPin, HIGH);\par
  353         break;\par
  354 \par
  355     default:\par
  356         break;\par
  357     \}\par
  358     return result;\par
  359 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a1bbd14c8591966df531e40085342ff71_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegisterInt16\:BME280}
{\xe \v BME280\:readRegisterInt16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t BME280::readRegisterInt16 (uint8_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 361 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   362 \{\par
  363     uint8_t myBuffer[2];\par
  364     readRegisterRegion(myBuffer, offset, 2);  //Does memory transfer\par
  365     int16_t output = (int16_t)myBuffer[0] | int16_t(myBuffer[1] << 8);\par
  366     \par
  367     return output;\par
  368 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_ac43c30f9b321d301694094d6b4bebe7e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegisterRegion\:BME280}
{\xe \v BME280\:readRegisterRegion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BME280::readRegisterRegion (uint8_t *  {\i outputPointer}, uint8_t  {\i offset}, uint8_t  {\i length})}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 278 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279 \{\par
  280     //define pointer that will point to the external space\par
  281     uint8_t i = 0;\par
  282     char c = 0;\par
  283 \par
  284     switch (settings.commInterface)\par
  285     \{\par
  286 \par
  287     case I2C_MODE:\par
  288         Wire.beginTransmission(settings.I2CAddress);\par
  289         Wire.write(offset);\par
  290         Wire.endTransmission();\par
  291 \par
  292         // request bytes from slave device\par
  293         Wire.requestFrom(settings.I2CAddress, length);\par
  294         while ( (Wire.available()) && (i < length))  // slave may send less than requested\par
  295         \{\par
  296             c = Wire.read(); // receive a byte as character\par
  297             *outputPointer = c;\par
  298             outputPointer++;\par
  299             i++;\par
  300         \}\par
  301         break;\par
  302 \par
  303     case SPI_MODE:\par
  304         // take the chip select low to select the device:\par
  305         digitalWrite(settings.chipSelectPin, LOW);\par
  306         // send the device the register you want to read:\par
  307         SPI.transfer(offset | 0x80);  //Ored with "read request" bit\par
  308         while ( i < length ) // slave may send less than requested\par
  309         \{\par
  310             c = SPI.transfer(0x00); // receive a byte as character\par
  311             *outputPointer = c;\par
  312             outputPointer++;\par
  313             i++;\par
  314         \}\par
  315         // take the chip select high to de-select:\par
  316         digitalWrite(settings.chipSelectPin, HIGH);\par
  317         break;\par
  318 \par
  319     default:\par
  320         break;\par
  321     \}\par
  322 \par
  323 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_aecca87c2c40a7f2bcabcea921bdc6124_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTempC\:BME280}
{\xe \v BME280\:readTempC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readTempC (void )}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 243 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   244 \{\par
  245     // Returns temperature in DegC, resolution is 0.01 DegC. Output value of \'935123\'94 equals 51.23 DegC.\par
  246     // t_fine carries fine temperature as global value\par
  247 \par
  248     //get the reading (adc_T);\par
  249     int32_t adc_T = ((uint32_t)readRegister(BME280_TEMPERATURE_MSB_REG) << 12) | ((uint32_t)readRegister(BME280_TEMPERATURE_LSB_REG) << 4) | ((readRegister(BME280_TEMPERATURE_XLSB_REG) >> 4) & 0x0F);\par
  250 \par
  251     //By datasheet, calibrate\par
  252     int64_t var1, var2;\par
  253 \par
  254     var1 = ((((adc_T>>3) - ((int32_t)calibration.dig_T1<<1))) * ((int32_t)calibration.dig_T2)) >> 11;\par
  255     var2 = (((((adc_T>>4) - ((int32_t)calibration.dig_T1)) * ((adc_T>>4) - ((int32_t)calibration.dig_T1))) >> 12) *\par
  256     ((int32_t)calibration.dig_T3)) >> 14;\par
  257     t_fine = var1 + var2;\par
  258     float output = (t_fine * 5 + 128) >> 8;\par
  259 \par
  260     output = output / 100;\par
  261     \par
  262     return output;\par
  263 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_afffdd1d7ded9e1f92200e70669019d97_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_afffdd1d7ded9e1f92200e70669019d97_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTempF\:BME280}
{\xe \v BME280\:readTempF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float BME280::readTempF (void )}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   266 \{\par
  267     float output = readTempC();\par
  268     output = (output * 9) / 5 + 32;\par
  269 \par
  270     return output;\par
  271 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_a9648b496f6b4700550782a715a98b3c7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reset\:BME280}
{\xe \v BME280\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BME280::reset (void )}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   154 \{\par
  155     writeRegister(BME280_RST_REG, 0xB6);\par
  156     \par
  157 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_aeec5deb6daace6ae390108b4210e9df7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeRegister\:BME280}
{\xe \v BME280\:writeRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BME280::writeRegister (uint8_t  {\i offset}, uint8_t  {\i dataToWrite})}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 370 of file CoolSparkFunBME280.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   371 \{\par
  372     switch (settings.commInterface)\par
  373     \{\par
  374     case I2C_MODE:\par
  375         //Write the byte\par
  376         Wire.beginTransmission(settings.I2CAddress);\par
  377         Wire.write(offset);\par
  378         Wire.write(dataToWrite);\par
  379         Wire.endTransmission();\par
  380         break;\par
  381 \par
  382     case SPI_MODE:\par
  383         // take the chip select low to select the device:\par
  384         digitalWrite(settings.chipSelectPin, LOW);\par
  385         // send the device the register you want to read:\par
  386         SPI.transfer(offset & 0x7F);\par
  387         // send a value of 0 to read the first byte returned:\par
  388         SPI.transfer(dataToWrite);\par
  389         // decrement the number of bytes left to read:\par
  390         // take the chip select high to de-select:\par
  391         digitalWrite(settings.chipSelectPin, HIGH);\par
  392         break;\par
  393 \par
  394     default:\par
  395         break;\par
  396     \}\par
  397 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/dcf/class_b_m_e280_afcff21c342725246bf415d7f0e4d04f0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v calibration\:BME280}
{\xe \v BME280\:calibration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SensorCalibration} BME280::calibration}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file CoolSparkFunBME280.h.}\par
}
{\xe \v settings\:BME280}
{\xe \v BME280\:settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SensorSettings} BME280::settings}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file CoolSparkFunBME280.h.}\par
}
{\xe \v t_fine\:BME280}
{\xe \v BME280\:t_fine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t BME280::t_fine}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoard Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoard}
{\xe \v CoolBoard}
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions. }}\par
{
{\f2 #include <CoolBoard.h>}}\par
Collaboration diagram for CoolBoard:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d3a/class_cool_board__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoard} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (const char *{\b answer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b offLineMode} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b onLineMode} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b connect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isConnected} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getLogInterval} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sleep} (unsigned long interval)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b readSensors} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initReadI2C} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b userData} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolFileSystem} {\b fileSystem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardSensors} {\b coolBoardSensors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardLed} {\b coolBoardLed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolTime} {\b rtc}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolWifi} {\b wifiManager}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolMQTT} {\b mqtt}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Jetpack} {\b jetPack}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Irene3000} {\b irene3000}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensors} {\b externalSensors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardActor} {\b onBoardActor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b userActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ireneActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b jetpackActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b externalSensorsActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sleepActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b manual} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b logInterval} =1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b data} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b answer} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b EnI2C} = 5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions. \par
}{
Definition at line 54 of file CoolBoard.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoolBoard\:CoolBoard}
{\xe \v CoolBoard\:CoolBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolBoard::CoolBoard ()}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::CoolBoard()}: This Constructor is provided to start the I2C interface and Init the different used pins \par
}{
Definition at line 48 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49 \{\par
   50 \par
   51 #if DEBUG == 1\par
   52 \par
   53     Serial.println( F("Entering CoolBoard Constructor") );\par
   54     Serial.println();\par
   55 \par
   56 #endif\par
   57     \par
   58     Wire.begin(2, 14);                       //I2C init \par
   59 \par
   60     pinMode(EnI2C, OUTPUT);        //Declare I2C Enable pin \par
   61 \par
   62 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolBoard}
{\xe \v CoolBoard\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::begin ()}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::begin()}: This method is provided to configure and start the used CoolKit Parts. It also starts the first connection try If Serial is enabled,it prints the configuration of the used parts. \par
}{
Definition at line 73 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    74 \{\par
   75 \par
   76 #if DEBUG == 1\par
   77 \par
   78     Serial.println( F("Starting the CoolBoard  ")  );\par
   79     Serial.println( F("Entering CoolBoard.begin() ")  );\par
   80     Serial.println();\par
   81 #endif  \par
   82 \par
   83 #if DEBUG == 0\par
   84     Serial.println( F("Starting Coolboard..."));\par
   85 #endif\par
   86 \par
   87 \par
   88     delay(100);\par
   89     \par
   90     coolBoardLed.write(255,128,0);//orange\par
   91 \par
   92     this->initReadI2C();\par
   93     delay(50);\par
   94 \par
   95     coolBoardSensors.config();\par
   96     coolBoardSensors.begin();\par
   97     delay(100);\par
   98     \par
   99     onBoardActor.config();\par
  100     onBoardActor.begin();\par
  101     delay(100);\par
  102     \par
  103     wifiManager.config();\par
  104     wifiManager.begin();\par
  105     delay(100);\par
  106 \par
  107     mqtt.config();\par
  108     mqtt.begin();\par
  109     delay(100);\par
  110 \par
  111 #if DEBUG == 1\par
  112 \par
  113     coolBoardLed.printConf();\par
  114 \par
  115     coolBoardSensors.printConf();\par
  116 \par
  117     onBoardActor.printConf();\par
  118 \par
  119     wifiManager.printConf();\par
  120 \par
  121     mqtt.printConf();\par
  122     \par
  123 \par
  124 #endif\par
  125 \par
  126 \par
  127     if (jetpackActive)\par
  128     \{\par
  129         jetPack.config();\par
  130         jetPack.begin();\par
  131 \par
  132     #if DEBUG == 1\par
  133         \par
  134         jetPack.printConf();\par
  135 \par
  136     #endif\par
  137         delay(100);\par
  138     \}\par
  139 \par
  140     if (ireneActive)\par
  141     \{\par
  142         irene3000.config();\par
  143         irene3000.begin();\par
  144 \par
  145     #if DEBUG == 1\par
  146 \par
  147         irene3000.printConf();\par
  148 \par
  149     #endif\par
  150         delay(100);\par
  151     \}\par
  152 \par
  153     if (externalSensorsActive)\par
  154     \{\par
  155         externalSensors.config();\par
  156         externalSensors.begin();\par
  157 \par
  158     #if DEBUG == 1\par
  159 \par
  160         externalSensors.printConf();\par
  161 \par
  162     #endif\par
  163         delay(100);\par
  164     \}\par
  165     \par
  166     coolBoardLed.fadeOut(255,128,0,0.5);//orange\par
  167 \par
  168     this->connect();\par
  169     delay(100);\par
  170 \par
  171     rtc.config();\par
  172     rtc.begin();\par
  173 \par
  174 #if DEBUG == 1\par
  175 \par
  176     rtc.printConf();\par
  177 \par
  178 #endif\par
  179     delay(100);\par
  180     \par
  181     coolBoardLed.blink(0,255,0,0.5);//green\par
  182 \par
  183 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_acba7c5aef7268b2c0044bdb54d3b9d76_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoard}
{\xe \v CoolBoard\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::config ()}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::config()}: This method is provided to configure the {\b CoolBoard} : -log interval -irene3000 activated/deactivated -jetpack activated/deactivated -external Sensors activated/deactivated -mqtt server timeout\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if configuration is done, false otherwise \par
}}{
Definition at line 725 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   726 \{\par
  727     yield();\par
  728 \par
  729 #if DEBUG == 1\par
  730 \par
  731     Serial.println( F("Entering CoolBoard.config() ") );\par
  732     Serial.println();\par
  733 \par
  734 #endif\par
  735 #if DEBUG == 0\par
  736     Serial.println();\par
  737     Serial.println( F("Loading configuration for this CoolBoard..."));\par
  738 #endif \par
  739 \par
  740     //open file system\par
  741     fileSystem.begin();\par
  742     \par
  743     //start the led\par
  744     coolBoardLed.config();\par
  745     coolBoardLed.begin();\par
  746     coolBoardLed.fadeIn(243,171,46,0.5);//shade of orange       \par
  747 \par
  748     \par
  749     //open configuration file\par
  750     File configFile = SPIFFS.open("/coolBoardConfig.json", "r");\par
  751     \par
  752     if (!configFile)\par
  753 \par
  754     \{\par
  755     \par
  756         Serial.println( F("failed to read /coolBoardConfig.json  ") );\par
  757 \par
  758         coolBoardLed.blink(255,0,0,0.5);//shade of red      \par
  759         return(false);\par
  760     \}\par
  761 \par
  762     else\par
  763     \{\par
  764         size_t size = configFile.size();\par
  765 \par
  766         // Allocate a buffer to store contents of the file.\par
  767         std::unique_ptr < char[] > buf(new char[size]);\par
  768 \par
  769         configFile.readBytes(buf.get(), size);\par
  770 \par
  771         DynamicJsonBuffer jsonBuffer;\par
  772 \par
  773         JsonObject & json = jsonBuffer.parseObject(buf.get());\par
  774 \par
  775         if (!json.success())\par
  776         \{\par
  777         \par
  778             Serial.println( F("failed to parse CoolBoard Config json object ") );\par
  779     \par
  780             coolBoardLed.blink(255,0,0,0.5);//shade of red      \par
  781             return(false);\par
  782         \}\par
  783 \par
  784         else\par
  785         \{   \par
  786         \par
  787         #if DEBUG == 1\par
  788             \par
  789             Serial.println( F("configuration json : ") );\par
  790             json.printTo(Serial);\par
  791             Serial.println();\par
  792             \par
  793             Serial.print(F("jsonBuffer size : "));\par
  794             Serial.print(jsonBuffer.size());\par
  795             Serial.println();\par
  796 \par
  797         #endif\par
  798             \par
  799             //parsing userActive Key\par
  800             if (json["userActive"].success())\par
  801             \{\par
  802                 this -> userActive = json["userActive"];\par
  803             \}\par
  804 \par
  805             else\par
  806             \{\par
  807                 this -> userActive = this -> userActive;\par
  808             \}\par
  809             json["userActive"] = this -> userActive;\par
  810 \par
  811             //parsing logInterval key\par
  812             if (json["logInterval"].success())\par
  813             \{\par
  814                 this -> logInterval = json["logInterval"];\par
  815             \}\par
  816             else\par
  817             \{\par
  818                 this -> logInterval = this -> logInterval;\par
  819             \}\par
  820             json["logInterval"] = this -> logInterval;\par
  821             \par
  822             //parsing ireneActive key           \par
  823             if (json["ireneActive"].success())\par
  824             \{\par
  825                 this -> ireneActive = json["ireneActive"];\par
  826             \}\par
  827             else\par
  828             \{\par
  829                 this -> ireneActive = this -> ireneActive;\par
  830             \}\par
  831             json["ireneActive"] = this -> ireneActive;\par
  832             \par
  833             //parsing jetpackActive key\par
  834             if (json["jetpackActive"].success())\par
  835             \{\par
  836                 this -> jetpackActive = json["jetpackActive"];\par
  837             \}\par
  838             else\par
  839             \{\par
  840                 this -> jetpackActive = this -> jetpackActive;\par
  841             \}\par
  842             json["jetpackActive"] = this -> jetpackActive;\par
  843 \par
  844             //parsing externalSensorsActive key\par
  845             if (json["externalSensorsActive"].success())\par
  846             \{\par
  847                 this -> externalSensorsActive = json["externalSensorsActive"];\par
  848             \}\par
  849             else\par
  850             \{\par
  851                 this -> externalSensorsActive = this -> externalSensorsActive;\par
  852             \}\par
  853             json["externalSensorsActive"] = this -> externalSensorsActive;\par
  854 \par
  855             \par
  856             //parsing sleepActive key\par
  857             if (json["sleepActive"].success())\par
  858             \{\par
  859                 this -> sleepActive = json["sleepActive"];\par
  860             \}\par
  861             else\par
  862             \{\par
  863                 this -> sleepActive = this -> sleepActive;\par
  864             \}\par
  865             json["sleepActive"] = this -> sleepActive;\par
  866 \par
  867 \par
  868             //parsing manual key\par
  869             if (json["manual"].success())\par
  870             \{\par
  871                 this -> manual = json["manual"];\par
  872             \}\par
  873             else\par
  874             \{\par
  875                 this -> manual = this -> manual;\par
  876             \}\par
  877             json["manual"] = this -> manual;\par
  878 \par
  879 \par
  880 \par
  881             //saving the current/correct configuration\par
  882             configFile.close();\par
  883             configFile = SPIFFS.open("/coolBoardConfig.json", "w");\par
  884             if (!configFile)\par
  885             \{\par
  886             \par
  887                 Serial.println( F("failed to write to /coolBoardConfig.json") );\par
  888                 Serial.println();\par
  889 \par
  890                 coolBoardLed.blink(255,0,0,0.5);//shade of red      \par
  891                 return(false);\par
  892             \}\par
  893 \par
  894             json.printTo(configFile);\par
  895             configFile.close();\par
  896             #if DEBUG == 0\par
  897 \par
  898                 Serial.println( F("Configuration loaded : OK"));\par
  899                 Serial.println();\par
  900 \par
  901             #endif\par
  902 \par
  903             return(true);\par
  904         \}\par
  905     \}\par
  906 \par
  907     coolBoardLed.strobe(243,171,46,0.5);//shade of orange\par
  908     \par
  909     coolBoardLed.fadeOut(243,171,46,0.5);//shade of orange              \par
  910 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a583a874c09c07e70a6eb9229fc4beddb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolBoard}
{\xe \v CoolBoard\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoard::connect ()}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::connect()}: This method is provided to manage the network connection and the mqtt connection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid mqtt client state \par
}}{
Definition at line 244 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   245 \{\par
  246 \par
  247 #if DEBUG == 1  \par
  248 \par
  249     Serial.println( F("Entering CoolBoard.connect ") );\par
  250     Serial.println();\par
  251     Serial.println( F("Connecting the CoolBoard  ") );\par
  252     delay(100);\par
  253 \par
  254 #endif\par
  255     coolBoardLed.write(0,0,255);//blue\par
  256 \par
  257     \par
  258             \par
  259     \par
  260 #if DEBUG == 1      \par
  261 \par
  262     Serial.println( F("Launching CoolWifi") );\par
  263     Serial.println();\par
  264 \par
  265 #endif\par
  266     wifiManager.connect();\par
  267     delay(100);\par
  268 \par
  269 \par
  270     //only attempt MQTT connection when Wifi is Connected\par
  271     if (wifiManager.state() == WL_CONNECTED)\par
  272     \{\par
  273 \par
  274     #if DEBUG == 1  \par
  275     \par
  276         Serial.println( F("Launching mqtt.connect()") );\par
  277         Serial.println();\par
  278     \par
  279     #endif  \par
  280         //logInterval in seconds\par
  281         mqtt.connect(this -> getLogInterval()*2);\par
  282         delay(100);\par
  283     \}\par
  284     \par
  285         \par
  286     \par
  287     \par
  288 #if DEBUG == 1\par
  289 \par
  290     Serial.println( F("mqtt state is :") );\par
  291     Serial.println(mqtt.state());\par
  292     Serial.println();\par
  293     delay(100);\par
  294 \par
  295 #endif\par
  296 \par
  297     coolBoardLed.blink(0,0,255,0.5);//blue\par
  298 \par
  299     return(mqtt.state());\par
  300 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a519de78b807f8ec6463ff484eb925918_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a519de78b807f8ec6463ff484eb925918_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getLogInterval\:CoolBoard}
{\xe \v CoolBoard\:getLogInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoard::getLogInterval ()}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::getLogInterval()}: This method is provided to get the log interval\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid interval value in s \par
}}{
Definition at line 1149 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1150 \{\par
 1151 \par
 1152 #if DEBUG == 1\par
 1153 \par
 1154     Serial.println( F("Entering CoolBoard.getLogInterval() ") );\par
 1155     Serial.println();\par
 1156     Serial.println( F("log Interval is :") );\par
 1157     Serial.println(logInterval);\par
 1158     Serial.println();\par
 1159 \par
 1160 #endif\par
 1161 \par
 1162     return(this -> logInterval);\par
 1163 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a7508e029f2ee17bb747ffab599285e0d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initReadI2C\:CoolBoard}
{\xe \v CoolBoard\:initReadI2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::initReadI2C ()}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::initReadI2C()}: This method is provided to enable the I2C Interface. \par
}{
Definition at line 1244 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1245 \{\par
 1246 \par
 1247 #if DEBUG == 1\par
 1248 \par
 1249     Serial.println( F("Entering CoolBoard.initReadI2C()") );\par
 1250     Serial.println();\par
 1251 \par
 1252 #endif\par
 1253  \par
 1254     digitalWrite(EnI2C,HIGH);//HIGH= I2C Enable\par
 1255 \par
 1256 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a397b46fadab8f530a8cf4d914c561366_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isConnected\:CoolBoard}
{\xe \v CoolBoard\:isConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoard::isConnected ()}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::isConnected()}\par
This method is provided to check if the card is connected to Wifi and MQTT\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 : connected -1: Wifi Not Connected -2: MQTT Not Connected \par
}}{
Definition at line 196 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   197 \{\par
  198 \par
  199 #if DEBUG == 1  \par
  200 \par
  201     Serial.println( F("Entering CoolBoard.isConnected ") );\par
  202     Serial.println();\par
  203 \par
  204 #endif\par
  205     if (wifiManager.state() != WL_CONNECTED)\par
  206     \{\par
  207     \par
  208         Serial.println(F("Wifi Not Connected"));\par
  209 \par
  210     #if DEBUG == 1\par
  211 \par
  212         Serial.println(F("Wifi State is "));\par
  213         Serial.println(wifiManager.state());\par
  214         \par
  215     #endif\par
  216         return(-1);\par
  217     \}\par
  218     \par
  219     if(mqtt.state() != 0)\par
  220     \{\par
  221         \par
  222         Serial.println( F("MQTT not Connected"));\par
  223 \par
  224     #if DEBUG==1\par
  225         Serial.println( F("mqtt state is :") );\par
  226         Serial.println(mqtt.state());   \par
  227     \par
  228     #endif\par
  229 \par
  230     \}\par
  231     \par
  232     return(0);\par
  233 \par
  234 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ad7442cf4b62c7b0d5bd62a0f75ffc065_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v offLineMode\:CoolBoard}
{\xe \v CoolBoard\:offLineMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::offLineMode ()}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoard::offlineMode(): This method is provided to manage the offLine mode: -read sensors -do actions -save data in the file system -if there is WiFi but no Internet : make data available over AP -if there is no connection : retry to connect \par
}{
Definition at line 571 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   572 \{\par
  573     coolBoardLed.fade(51,100,50,0.5);//dark shade of green  \par
  574 #if DEBUG == 1  \par
  575     \par
  576     Serial.println( F("Entering off line mode ") ); \par
  577     \par
  578 #endif\par
  579 \par
  580 #if DEBUG == 0\par
  581 \par
  582     Serial.println( F("CoolBoard is in Offline Mode"));\par
  583 \par
  584 #endif\par
  585 \par
  586     //read user data if user is active\par
  587     if(userActive)\par
  588     \{\par
  589 \par
  590         coolBoardLed.fadeIn(245,237,27,0.5);//shade of yellow\par
  591 \par
  592     #if DEBUG == 1\par
  593         \par
  594         Serial.println( F("User is Active") );\par
  595         Serial.println( F("Collecting User's data ( mac,username,timeStamp )") );\par
  596         Serial.println();\par
  597 \par
  598     #endif\par
  599 \par
  600         coolBoardLed.blink(245,237,27,0.5);//shade of yellow    \par
  601 \par
  602         //reading user data\par
  603         data=this->userData();//\{"":"","":"","",""\}\par
  604 \par
  605         //formatting json \par
  606         data.setCharAt( data.lastIndexOf('\}') , ',');//\{"":"","":"","","",\par
  607         \par
  608                 \par
  609         //read sensors data\par
  610 \par
  611         Serial.println( F("Collecting sensors data ") );\par
  612         Serial.println();\par
  613 \par
  614         data+=this->readSensors();//\{"":"","":"","","",\{.......\}\par
  615 \par
  616         \par
  617 \par
  618         //formatting json correctly\par
  619         data.remove(data.lastIndexOf('\{'), 1);//\{"":"","":"","","",.......\}\par
  620 \par
  621         coolBoardLed.fadeOut(245,237,27,0.5);//shade of yellow\par
  622                 \par
  623     \}   \par
  624     else\par
  625     \{\par
  626         //read sensors data\par
  627     #if DEBUG == 1\par
  628 \par
  629         Serial.println( F("Collecting sensors data ") );\par
  630         Serial.println();\par
  631 \par
  632     #endif\par
  633 \par
  634         coolBoardLed.fade(190,100,150,0.5);//shade of violet        \par
  635 \par
  636         data=this->readSensors();//\{..,..,..\}\par
  637     \}\par
  638 \par
  639     coolBoardLed.fade(51,100,50,0.5);//dark shade of green  \par
  640 \par
  641     //do action\par
  642 \par
  643     if (jetpackActive)\par
  644     \{\par
  645     \par
  646 \par
  647 \par
  648     #if DEBUG == 1\par
  649 \par
  650         Serial.println( F("jetpack is Active ") );\par
  651         Serial.println( F("jetpack doing action ") );\par
  652         Serial.println();\par
  653     \par
  654     #endif\par
  655         coolBoardLed.fade(100,100,150,0.5);//dark shade of blue \par
  656     \par
  657         jetPack.doAction( data.c_str() );\par
  658     \}\par
  659     \par
  660     delay(100);\par
  661 \par
  662     onBoardActor.doAction( data.c_str() );  \par
  663 \par
  664 \par
  665     coolBoardLed.fade(51,100,50,0.5);//dark shade of green  \par
  666     \par
  667     //saving data in the file system\par
  668     \par
  669     fileSystem.saveSensorData( data.c_str() );\par
  670 \par
  671     #if DEBUG == 0\par
  672 \par
  673         Serial.println( F("saving Data in Memory : OK"));\par
  674 \par
  675     #endif\par
  676 \par
  677     coolBoardLed.fadeOut(51,100,50,0.5);//dark shade of green\par
  678 \par
  679     //case we have wifi but no internet\par
  680     if( (wifiManager.state() == WL_CONNECTED) && ( mqtt.state()!=0 ) )\par
  681     \{\par
  682         \par
  683         Serial.println(F("there is Wifi but no Internet"));\par
  684         Serial.println(F("lunching AP to check saved files"));\par
  685         Serial.println(F("and Add new WiFi if needed"));\par
  686         \par
  687         wifiManager.connectAP();\par
  688         \par
  689     \}\par
  690     \par
  691     //case we have no connection at all\par
  692     if( wifiManager.state() != WL_CONNECTED )\par
  693     \{\par
  694     \par
  695     #if DEBUG == 1\par
  696         \par
  697         Serial.println(F("there is No Wifi "));\par
  698         Serial.println(F("retrying to connect"));\par
  699     \par
  700     #endif\par
  701 \par
  702     #if DEBUG == 0\par
  703         Serial.println( F("there is no WiFi..."));\par
  704     #endif\par
  705         \par
  706         this->connect();//nomad case : just run wifiMulti\par
  707                 //normal case : run wifiMulti+AP\par
  708         \par
  709     \}   \par
  710 \par
  711 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ae6b5e1274d760462290192acea4adca8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v onLineMode\:CoolBoard}
{\xe \v CoolBoard\:onLineMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::onLineMode ()}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::onLineMode()}: This method is provided to manage the online mode: -update clock -read sensor -do actions -publish data -read answer -update config \par
}{
Definition at line 312 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   313 \{\par
  314 \par
  315     coolBoardLed.fadeIn(128,255,50,0.5);//shade of green\par
  316 \par
  317 #if DEBUG == 1\par
  318 \par
  319     Serial.println( F("Entering CoolBoard.onLineMode() ") );\par
  320     Serial.println();\par
  321 \par
  322 #endif\par
  323 #if DEBUG == 0\par
  324 \par
  325     Serial.println( F("CoolBoard is in Online Mode"));\par
  326 \par
  327 #endif\par
  328 \par
  329     data="";\par
  330     answer="";\par
  331 \par
  332     //send saved data if any\par
  333     if(fileSystem.isDataSaved())\par
  334     \{\par
  335 \par
  336         coolBoardLed.fadeIn(128,128,255,0.5);//shade of blue\par
  337 \par
  338         Serial.println( F("There is data saved on the File System") );\par
  339         Serial.println( F("Sending saved data over MQTT ") );\par
  340         Serial.println();\par
  341         coolBoardLed.strobe(128,128,255,0.5);//shade of blue \par
  342 \par
  343         mqtt.publish("sending saved data");\par
  344         mqtt.mqttLoop();\par
  345 \par
  346 \par
  347         \par
  348         int size=0;\par
  349         std::unique_ptr<String[]> savedData(std::move(fileSystem.getSensorSavedData(size)));//\{..,..,..\}\par
  350 \par
  351         int i=0;\par
  352         //loop through the array\par
  353         while(i<size)\par
  354         \{\par
  355             //formatting data:\par
  356         \par
  357             String jsonData = "\{\\"state\\":\{\\"reported\\":";\par
  358             jsonData += savedData[i]; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}\par
  359             jsonData += " \} \}"; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}  \} \}\par
  360 \par
  361         #if DEBUG == 1 \par
  362             Serial.println(F("Size is : "));\par
  363             Serial.println(size);\par
  364             Serial.print(F("sending line N\'B0"));\par
  365             Serial.println(i);\par
  366             Serial.println(jsonData);\par
  367             Serial.println();\par
  368 \par
  369         #endif\par
  370 \par
  371             coolBoardLed.strobe(128,128,255,0.5);//shade of blue\par
  372         \par
  373             mqtt.publish( jsonData.c_str() );\par
  374             mqtt.mqttLoop();\par
  375         \par
  376             coolBoardLed.fadeOut(128,128,255,0.5);//shade of blue\par
  377             \par
  378             i++;\par
  379             yield();\par
  380         \}       \par
  381 \par
  382 \par
  383     #if DEBUG == 1\par
  384 \par
  385         Serial.println( F("Saved data sent ") );\par
  386         Serial.println();\par
  387     \par
  388     #endif\par
  389 \par
  390     \}\par
  391 \par
  392     coolBoardLed.blink(128,255,50,0.5);//shade of green\par
  393 \par
  394     //clock update\par
  395     Serial.println( F("Re-checking RTC..."));\par
  396     rtc.update();\par
  397 \par
  398     //read user data if user is active\par
  399     if(userActive)\par
  400     \{\par
  401         coolBoardLed.fadeIn(245,237,27,0.5);//shade of yellow\par
  402     \par
  403     #if DEBUG == 1\par
  404 \par
  405         Serial.println( F("User is Active") );\par
  406         Serial.println( F("Collecting User's data ( mac,username,timeStamp )") );\par
  407         Serial.println();\par
  408     \par
  409     #endif  \par
  410         coolBoardLed.blink(245,237,27,0.5);//shade of yellow    \par
  411 \par
  412         //reading user data\par
  413         data=this->userData();//\{"":"","":"","",""\}\par
  414 \par
  415         //formatting json \par
  416         data.setCharAt( data.lastIndexOf('\}') , ',');//\{"":"","":"","","",\par
  417                 \par
  418         //read sensors data\par
  419     #if DEBUG == 1\par
  420 \par
  421         Serial.println( F("Collecting sensors data ") );\par
  422         Serial.println();\par
  423     \par
  424     #endif\par
  425 \par
  426         data+=this->readSensors();//\{"":"","":"","","",\{.......\}        \par
  427 \par
  428         //formatting json correctly\par
  429         data.remove(data.lastIndexOf('\{'), 1);//\{"":"","":"","","",.......\}\par
  430         \par
  431         coolBoardLed.fadeOut(245,237,27,0.5);//shade of yellow\par
  432                 \par
  433     \}   \par
  434     else\par
  435     \{\par
  436         //read sensors data\par
  437     #if DEBUG == 1\par
  438 \par
  439         Serial.println( F("Collecting sensors data ") );\par
  440         Serial.println();\par
  441     \par
  442     #endif\par
  443         coolBoardLed.fade(190,100,150,0.5);//shade of violet        \par
  444         data=this->readSensors();//\{..,..,..\}\par
  445     \}\par
  446     \par
  447 \par
  448 \par
  449 \par
  450     //do action\par
  451 \par
  452     if (jetpackActive)\par
  453     \{\par
  454 \par
  455 \par
  456     #if DEBUG ==1\par
  457 \par
  458         Serial.println( F("jetpack is Active ") );\par
  459         Serial.println();\par
  460 \par
  461     #endif\par
  462     \par
  463         if(this->manual == 0 )\par
  464         \{\par
  465 \par
  466             Serial.println( F("jetpack doing action ") );\par
  467 \par
  468             coolBoardLed.fade(100,100,150,0.5);//dark shade of blue     \par
  469 \par
  470             jetPack.doAction(data.c_str());\par
  471             \par
  472 \par
  473         \par
  474         \}\par
  475         \par
  476         else if(this->manual == 1 )\par
  477         \{\par
  478         \par
  479             Serial.println(F("we are in manual mode"));\par
  480             mqtt.mqttLoop();\par
  481             answer = mqtt.read();\par
  482             this -> update(answer.c_str());\par
  483         \}\par
  484     \}\par
  485 \par
  486     delay(100);\par
  487 \par
  488     onBoardActor.doAction( data.c_str() );  \par
  489 \par
  490 \par
  491 \par
  492     \par
  493     coolBoardLed.fadeIn(128,255,50,0.5);//shade of green\par
  494 \par
  495     //formatting data:\par
  496     String jsonData = "\{\\"state\\":\{\\"reported\\":";\par
  497     jsonData += data; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}\par
  498     jsonData += " \} \}"; // \{"state":\{"reported":\{..,..,..,..,..,..,..,..\}  \} \}\par
  499     \par
  500     //mqtt client loop to allow data handling\par
  501     mqtt.mqttLoop();\par
  502 \par
  503     coolBoardLed.blink(128,255,50,0.5);//shade of green \par
  504 \par
  505     //read mqtt answer\par
  506     answer = mqtt.read();\par
  507 \par
  508 #if DEBUG == 1 \par
  509 \par
  510     Serial.println( F("checking if there's an MQTT message ")  );\par
  511     Serial.println( F("answer is : ") );    \par
  512     Serial.println(answer); \par
  513     Serial.println();\par
  514 \par
  515 #endif  \par
  516 \par
  517     coolBoardLed.fadeOut(128,255,50,0.5);//shade of green   \par
  518 \par
  519     //check if the configuration needs update \par
  520     //and update it if needed \par
  521     this -> update(answer.c_str());\par
  522     \par
  523     coolBoardLed.fadeIn(128,255,50,0.5);//shade of green    \par
  524 \par
  525     //publishing data   \par
  526     if( this->sleepActive==0 )  \par
  527     \{   \par
  528         coolBoardLed.strobe(255,0,230,0.5);//shade of pink\par
  529         \par
  530         //logInterval in seconds\par
  531         mqtt.publish( jsonData.c_str(), this->getLogInterval() );\par
  532         mqtt.mqttLoop();\par
  533     \par
  534     \}\par
  535     else\par
  536     \{\par
  537         coolBoardLed.strobe(230,255,0,0.5);//shade of yellow    \par
  538 \par
  539         mqtt.publish(jsonData.c_str());     \par
  540         mqtt.mqttLoop();\par
  541         answer = mqtt.read();\par
  542         this ->update(answer.c_str());\par
  543 \par
  544         //logInterval in seconds\par
  545         this->sleep( this->getLogInterval() ) ;\par
  546     \}\par
  547 \par
  548     coolBoardLed.fadeOut(128,255,50,0.5);//shade of green       \par
  549 \par
  550     mqtt.mqttLoop();\par
  551 \par
  552     //read mqtt answer\par
  553     answer = mqtt.read();\par
  554     this -> update(answer.c_str()); \par
  555 \par
  556     coolBoardLed.blink(128,255,50,0.5);//shade of green \par
  557 \par
  558 \par
  559 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_aa0bbc4bc605e35618d18e68795c61363_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoard}
{\xe \v CoolBoard\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::printConf ()}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::printConf()}: This method is provided to print the configuration to the Serial Monitor. \par
}{
Definition at line 919 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   920 \{\par
  921 \par
  922 #if DEBUG == 1\par
  923     \par
  924     Serial.println( F("Entering CoolBoard.printConf() ") );\par
  925     Serial.println();\par
  926 \par
  927 #endif\par
  928 \par
  929     Serial.println( F("Printing Cool Board Configuration "));\par
  930     Serial.print( F("log interval       : "));\par
  931     Serial.println(this->logInterval);\par
  932 \par
  933     Serial.print( F("irene active       : "));\par
  934     Serial.println(this->ireneActive);\par
  935 \par
  936     Serial.print( F("jetpack active     : "));\par
  937     Serial.println(this->jetpackActive);\par
  938 \par
  939     Serial.print( F("external sensors active    : "));\par
  940     Serial.println(this->externalSensorsActive);\par
  941 \par
  942     Serial.print( F("sleep active       : "));\par
  943     Serial.println(this->sleepActive);\par
  944 \par
  945     Serial.print( F("user active        : "));\par
  946     Serial.println(this->userActive);\par
  947 \par
  948     Serial.print( F("manual active      : "));\par
  949     Serial.println(this->manual);\par
  950 \par
  951     Serial.println();\par
  952 \par
  953 \par
  954 \par
  955 \par
  956 \}\par
}
}
{\xe \v readSensors\:CoolBoard}
{\xe \v CoolBoard\:readSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::readSensors ()}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::readSensors()}: This method is provided to read and format all the sensors data in a single json.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string of all the sensors read. \par
}}{
Definition at line 1173 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1174 \{\par
 1175 \par
 1176     coolBoardLed.fadeIn(128,255,0,0.5);//light shade of green\par
 1177                 \par
 1178 #if DEBUG == 1\par
 1179 \par
 1180     Serial.println( F("Entering CoolBoard.readSensors()") );\par
 1181     Serial.println();\par
 1182 \par
 1183 #endif\par
 1184     coolBoardLed.strobe(128,255,0,0.5);//light shade of green\par
 1185 \par
 1186     String sensorsData;\par
 1187     \par
 1188     this->initReadI2C();\par
 1189 \par
 1190     sensorsData = coolBoardSensors.read(); // \{..,..,..\}\par
 1191     \par
 1192     if (externalSensorsActive)\par
 1193     \{\par
 1194         sensorsData += externalSensors.read(); // \{..,..,..\}\{..,..\}\par
 1195 \par
 1196         sensorsData.setCharAt(sensorsData.lastIndexOf('\}'), ','); // \{..,..,..\}\{..,..,\par
 1197         sensorsData.setCharAt(sensorsData.lastIndexOf('\{'), ','); // \{..,..,..\},..,..,\par
 1198         sensorsData.remove(sensorsData.lastIndexOf('\}'), 1); // \{..,..,..,..,..,\par
 1199         sensorsData.setCharAt(sensorsData.lastIndexOf(','), '\}'); // \{..,..,..,..,..\}\par
 1200 \par
 1201     \}\par
 1202     if (ireneActive)\par
 1203     \{\par
 1204         sensorsData += irene3000.read(); // \{..,..,..,..,..\}\{..,..,..\}\par
 1205 \par
 1206         sensorsData.setCharAt(sensorsData.lastIndexOf('\}'), ','); // \{..,..,..,..,..\}\{..,..,..,\par
 1207         sensorsData.setCharAt(sensorsData.lastIndexOf('\{'), ','); // \{..,..,..,..,..\},..,..,..,\par
 1208         sensorsData.remove(sensorsData.lastIndexOf('\}'), 1); // \{..,..,..,..,..,..,..,..,\par
 1209         sensorsData.setCharAt(sensorsData.lastIndexOf(','), '\}'); // \{..,..,..,..,..,..,..,..\}      \par
 1210         \par
 1211         \par
 1212     \}\par
 1213 \par
 1214     //getting Hour:\par
 1215     tmElements_t tm;\par
 1216     tm=rtc.getTimeDate();\par
 1217     \par
 1218     //adding Hour\par
 1219     sensorsData.remove(sensorsData.lastIndexOf('\}'), 1); // \{..,..,..,..,..,..,..,..,   \par
 1220     sensorsData+=",\\"hour\\":";  \par
 1221     sensorsData+=tm.Hour;\par
 1222     sensorsData+=",\\"minute\\":";\par
 1223     sensorsData+=tm.Minute;\par
 1224     sensorsData+="\}";\par
 1225     \par
 1226 #if DEBUG == 1\par
 1227     Serial.println();\par
 1228     Serial.println( F("sensors data is ") );\par
 1229     Serial.println(sensorsData);\par
 1230     Serial.println();\par
 1231 \par
 1232 #endif\par
 1233     coolBoardLed.fadeOut(128,255,0,0.5);//light shade of green\par
 1234 \par
 1235     return(sensorsData);\par
 1236 \par
 1237 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ad03abdce2e65f520bbf2cff0f2d083cf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ad03abdce2e65f520bbf2cff0f2d083cf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sleep\:CoolBoard}
{\xe \v CoolBoard\:sleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::sleep (unsigned long  {\i interval})}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoard::sleep(int interval): This method is provided to allow the board to enter deepSleep mode for a period of time equal to interval in s \par
}{
Definition at line 1313 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1314 \{\par
 1315 \par
 1316     Serial.println( F("Entering CoolBoard.sleep() ") );\par
 1317     Serial.print( F("going to sleep for ") );\par
 1318     Serial.print(interval);\par
 1319     Serial.println(F("s") );\par
 1320     Serial.println();\par
 1321     \par
 1322     //interval is in seconds , interval*1000*1000 in \'B5S\par
 1323     ESP.deepSleep ( ( interval * 1000 * 1000 ), WAKE_RF_DEFAULT) ;\par
 1324 \par
 1325 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a069952cdcb2e7f68518aa429eceadb6e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v update\:CoolBoard}
{\xe \v CoolBoard\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoard::update (const char *  {\i answer})}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoard::update(mqtt answer): This method is provided to handle the configuration update of the different parts \par
}{
Definition at line 963 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   964 \{\par
  965     coolBoardLed.fadeIn(153,76,0,0.5);//shade of brown      \par
  966 \par
  967 #if DEBUG == 1\par
  968 \par
  969     Serial.println( F("Entering CoolBoard.update() ") );\par
  970     Serial.println();\par
  971     Serial.println( F("message is : ") );\par
  972     Serial.println(answer);\par
  973     Serial.println();\par
  974 \par
  975 #endif\par
  976 \par
  977     DynamicJsonBuffer jsonBuffer;\par
  978     JsonObject & root = jsonBuffer.parseObject(answer);\par
  979     JsonObject & stateDesired = root["state"];\par
  980 \par
  981 #if DEBUG == 1\par
  982 \par
  983     Serial.println( F("root json : ") );\par
  984     root.printTo(Serial);\par
  985     Serial.println();\par
  986 \par
  987     Serial.println( F("stateDesired json : "));\par
  988     stateDesired.printTo(Serial);\par
  989     Serial.println();\par
  990     \par
  991     Serial.print( F("jsonBuffer size : "));\par
  992     Serial.println(jsonBuffer.size());\par
  993 \par
  994 #endif\par
  995 \par
  996     if (stateDesired.success())\par
  997     \{\par
  998     \par
  999     #if DEBUG == 1\par
 1000 \par
 1001         Serial.println( F("update message parsing : success") );\par
 1002         Serial.println();\par
 1003     \par
 1004     #endif\par
 1005 \par
 1006             String answerDesired;\par
 1007         \par
 1008             stateDesired.printTo(answerDesired);\par
 1009             \par
 1010         #if DEBUG == 1      \par
 1011         \par
 1012             Serial.println( F("update is ok ") );\par
 1013             Serial.println( F("desired update is : ") );            \par
 1014             Serial.println(answerDesired);\par
 1015             Serial.println("json size is : ");\par
 1016             Serial.println(jsonBuffer.size() ) ;                \par
 1017             Serial.println();\par
 1018 \par
 1019         \par
 1020         #endif\par
 1021             //manual mode check\par
 1022             if(this->manual == 1 )\par
 1023             \{ \par
 1024                 JsonObject & manualMode=stateDesired["manual"];\par
 1025                 //json parse\par
 1026                 for(auto kv : manualMode)\par
 1027                 \{\par
 1028                 #if DEBUG == 1\par
 1029 \par
 1030                     Serial.print(F("writing to "));\par
 1031                     Serial.println(kv.key);\par
 1032                     Serial.print(F("state : "));\par
 1033                     Serial.println(kv.value.as<bool>());        \par
 1034                     \par
 1035                 #endif              \par
 1036 \par
 1037                     if( strcmp(kv.key,"Act0") == 0 )\par
 1038                     \{\par
 1039                     \par
 1040                         jetPack.writeBit(0,kv.value.as<bool>() ); \par
 1041                         \par
 1042                     \}\par
 1043                     else if(strcmp(kv.key,"Act1") == 0)\par
 1044                     \{\par
 1045                         jetPack.writeBit(1,kv.value.as<bool>() ); \par
 1046 \par
 1047                     \}\par
 1048                     else if(strcmp(kv.key,"Act2") == 0)\par
 1049                     \{\par
 1050                         jetPack.writeBit(2,kv.value.as<bool>() ); \par
 1051 \par
 1052                     \}\par
 1053                     else if(strcmp(kv.key,"Act3") == 0)\par
 1054                     \{\par
 1055                         jetPack.writeBit(3,kv.value.as<bool>() ); \par
 1056 \par
 1057                     \}\par
 1058                     else if(strcmp(kv.key,"Act4") == 0)\par
 1059                     \{\par
 1060                         jetPack.writeBit(4,kv.value.as<bool>() ); \par
 1061 \par
 1062                     \}\par
 1063                     else if(strcmp(kv.key,"Act5") == 0)\par
 1064                     \{\par
 1065                         jetPack.writeBit(5,kv.value.as<bool>() ); \par
 1066 \par
 1067                     \}\par
 1068                     else if(strcmp(kv.key,"Act6") == 0)\par
 1069                     \{\par
 1070                         jetPack.writeBit(6,kv.value.as<bool>() ); \par
 1071 \par
 1072                     \}\par
 1073                     else if (strcmp(kv.key,"Act7") == 0)\par
 1074                     \{\par
 1075                         jetPack.writeBit(7,kv.value.as<bool>() ); \par
 1076 \par
 1077                     \}\par
 1078                     else if (strcmp(kv.key,"ActB") == 0)\par
 1079                     \{\par
 1080                         onBoardActor.write(kv.value.as<bool>() ); \par
 1081 \par
 1082                     \}\par
 1083                                 \par
 1084                 \par
 1085                 \}\par
 1086 \par
 1087                 \par
 1088             \}\par
 1089 \par
 1090             //saving the new configuration\par
 1091             fileSystem.updateConfigFiles(answerDesired);\par
 1092 \par
 1093                 //answering the update msg:\par
 1094             //reported = received configuration\par
 1095             //desired=null\par
 1096         \par
 1097             String updateAnswer;\par
 1098             String tempString;\par
 1099             \par
 1100             stateDesired.printTo(tempString);\par
 1101             updateAnswer="\{\\"state\\":\{\\"reported\\":";\par
 1102             updateAnswer+=tempString;\par
 1103             updateAnswer+=",\\"desired\\":null\}\}";\par
 1104 \par
 1105         #if DEBUG == 1\par
 1106 \par
 1107             Serial.println( F("preparing answer message ") );\par
 1108             Serial.println();\par
 1109             Serial.println( F("updateAnswer : ") );\par
 1110             Serial.println(updateAnswer);\par
 1111         \par
 1112         #endif  \par
 1113 \par
 1114             mqtt.publish(updateAnswer.c_str());\par
 1115             \par
 1116             mqtt.mqttLoop();\par
 1117 \par
 1118             delay(10);\par
 1119         \par
 1120             if(manual == 0 )\par
 1121             \{\par
 1122                 //restart the esp to apply the config\par
 1123                 ESP.restart();\par
 1124             \}\par
 1125     \}\par
 1126     else\par
 1127     \{\par
 1128     \par
 1129     #if DEBUG == 1\par
 1130 \par
 1131         Serial.println( F("Failed to parse update message( OR no message received )") );\par
 1132         Serial.println();\par
 1133     \par
 1134     #endif\par
 1135     \par
 1136     \}\par
 1137 \par
 1138     coolBoardLed.strobe(153,76,0,0.5);//shade of brown\par
 1139     coolBoardLed.fadeOut(153,76,0,0.5);//shade of brown                             \par
 1140 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a8612756d3f73198cdde857a66f0fe690_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_a8612756d3f73198cdde857a66f0fe690_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v userData\:CoolBoard}
{\xe \v CoolBoard\:userData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::userData ()}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard::userData()}: This method is provided to return the user's data.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string of the user's data \par
}}{
Definition at line 1266 of file CoolBoard.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1267 \{\par
 1268 \par
 1269 #if DEBUG == 1\par
 1270 \par
 1271     Serial.println( F("Entering CoolBoard.userData() ") );\par
 1272     Serial.println();\par
 1273 \par
 1274 #endif\par
 1275 \par
 1276     String tempMAC = WiFi.macAddress();\par
 1277 \par
 1278     tempMAC.replace(":", "");\par
 1279 \par
 1280     String userJson = "\{\\"user\\":\\"";\par
 1281 \par
 1282     userJson += mqtt.getUser();\par
 1283 \par
 1284     userJson += "\\",\\"timestamp\\":\\"";\par
 1285 \par
 1286     userJson += rtc.getESDate(); // "timestamp":"20yy-mm-ddThh:mm:ssZ"\par
 1287 \par
 1288     userJson += "\\",\\"mac\\":\\"";\par
 1289 \par
 1290     userJson += tempMAC;\par
 1291 \par
 1292     userJson += "\\"\}";\par
 1293 \par
 1294 #if DEBUG == 1\par
 1295 \par
 1296     Serial.println( F("userData is : ") );\par
 1297     Serial.println(userJson);\par
 1298     Serial.println();\par
 1299 \par
 1300 #endif  \par
 1301     \par
 1302     return(userJson);\par
 1303     \par
 1304 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ae7358fb6e623cfc81b775f5f1734909b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/df9/class_cool_board_ae7358fb6e623cfc81b775f5f1734909b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v answer\:CoolBoard}
{\xe \v CoolBoard\:answer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::answer =""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolBoard.h.}\par
}
{\xe \v coolBoardLed\:CoolBoard}
{\xe \v CoolBoard\:coolBoardLed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolBoardLed} CoolBoard::coolBoardLed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file CoolBoard.h.}\par
}
{\xe \v coolBoardSensors\:CoolBoard}
{\xe \v CoolBoard\:coolBoardSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolBoardSensors} CoolBoard::coolBoardSensors{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolBoard.h.}\par
}
{\xe \v data\:CoolBoard}
{\xe \v CoolBoard\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoard::data =""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolBoard.h.}\par
}
{\xe \v EnI2C\:CoolBoard}
{\xe \v CoolBoard\:EnI2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoard::EnI2C = 5{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file CoolBoard.h.}\par
}
{\xe \v externalSensors\:CoolBoard}
{\xe \v CoolBoard\:externalSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExternalSensors} CoolBoard::externalSensors{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolBoard.h.}\par
}
{\xe \v externalSensorsActive\:CoolBoard}
{\xe \v CoolBoard\:externalSensorsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::externalSensorsActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file CoolBoard.h.}\par
}
{\xe \v fileSystem\:CoolBoard}
{\xe \v CoolBoard\:fileSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolFileSystem} CoolBoard::fileSystem{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolBoard.h.}\par
}
{\xe \v irene3000\:CoolBoard}
{\xe \v CoolBoard\:irene3000}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Irene3000} CoolBoard::irene3000{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolBoard.h.}\par
}
{\xe \v ireneActive\:CoolBoard}
{\xe \v CoolBoard\:ireneActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::ireneActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file CoolBoard.h.}\par
}
{\xe \v jetPack\:CoolBoard}
{\xe \v CoolBoard\:jetPack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Jetpack} CoolBoard::jetPack{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolBoard.h.}\par
}
{\xe \v jetpackActive\:CoolBoard}
{\xe \v CoolBoard\:jetpackActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::jetpackActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file CoolBoard.h.}\par
}
{\xe \v logInterval\:CoolBoard}
{\xe \v CoolBoard\:logInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoard::logInterval =1{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file CoolBoard.h.}\par
}
{\xe \v manual\:CoolBoard}
{\xe \v CoolBoard\:manual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::manual =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file CoolBoard.h.}\par
}
{\xe \v mqtt\:CoolBoard}
{\xe \v CoolBoard\:mqtt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolMQTT} CoolBoard::mqtt{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolBoard.h.}\par
}
{\xe \v onBoardActor\:CoolBoard}
{\xe \v CoolBoard\:onBoardActor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolBoardActor} CoolBoard::onBoardActor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolBoard.h.}\par
}
{\xe \v rtc\:CoolBoard}
{\xe \v CoolBoard\:rtc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolTime} CoolBoard::rtc{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolBoard.h.}\par
}
{\xe \v sleepActive\:CoolBoard}
{\xe \v CoolBoard\:sleepActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::sleepActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file CoolBoard.h.}\par
}
{\xe \v userActive\:CoolBoard}
{\xe \v CoolBoard\:userActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoard::userActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file CoolBoard.h.}\par
}
{\xe \v wifiManager\:CoolBoard}
{\xe \v CoolBoard\:wifiManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolWifi} CoolBoard::wifiManager{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file CoolBoard.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoard.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardActor Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardActor}
{\xe \v CoolBoardActor}
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor}. }}\par
{
{\f2 #include <CoolBoardActor.h>}}\par
Collaboration diagram for CoolBoardActor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d3e/class_cool_board_actor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (bool action)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doAction} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalAction} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invertedAction} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOff} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOn} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOff} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOn} (float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourAction} (int hour)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourAction} (int hour, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b minuteAction} (int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedMinuteAction} (int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourMinuteAction} (int hour, int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourMinuteAction} (int hour, int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardActor::state} {\b actor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b pin} = 15\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor}. \par
}{
Definition at line 42 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolBoardActor}
{\xe \v CoolBoardActor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::begin ()}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::begin()}: This method is provided to initialise the {\b CoolBoardActor} pin \par
}{
Definition at line 46 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    47 \{\par
   48 \par
   49 #if DEBUG == 1 \par
   50  \par
   51     Serial.println( F("Entering CoolBoardActor.begin() ") );\par
   52     Serial.println();\par
   53 \par
   54 #endif\par
   55 \par
   56     pinMode(this->pin,OUTPUT);\par
   57     \par
   58     \par
   59 \par
   60 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a7f4422fd85a5510bc2cdfd68e109be5e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoardActor}
{\xe \v CoolBoardActor\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::config ()}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::config()}: This method is provided to configure the {\b CoolBoardActor} with a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 256 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   257 \{\par
  258 \par
  259 #if DEBUG == 1 \par
  260 \par
  261     Serial.println( F("Entering CoolBoardActor.config() ") );\par
  262     Serial.println();\par
  263 \par
  264 #endif\par
  265 \par
  266     File coolBoardActorConfig = SPIFFS.open("/coolBoardActorConfig.json", "r");\par
  267 \par
  268     if (!coolBoardActorConfig) \par
  269     \{\par
  270 \par
  271     #if DEBUG == 1 \par
  272 \par
  273         Serial.println( F("failed to read /coolBoardActorConfig.json ") );\par
  274         Serial.println();\par
  275 \par
  276     #endif\par
  277 \par
  278         return(false);\par
  279     \}\par
  280     else\par
  281     \{\par
  282         size_t size = coolBoardActorConfig.size();\par
  283         // Allocate a buffer to store contents of the file.\par
  284         std::unique_ptr<char[]> buf(new char[size]);\par
  285 \par
  286         coolBoardActorConfig.readBytes(buf.get(), size);\par
  287         DynamicJsonBuffer jsonBuffer;\par
  288         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  289         if (!json.success()) \par
  290         \{\par
  291         \par
  292         #if DEBUG == 1 \par
  293 \par
  294             Serial.println( F("failed to parse coolBoardActor Config  json from file ") );\par
  295             Serial.println();\par
  296 \par
  297         #endif\par
  298 \par
  299             return(false);\par
  300         \} \par
  301         else\par
  302         \{ \par
  303         \par
  304         #if DEBUG == 1 \par
  305 \par
  306             Serial.println( F("read configuration file : ") );\par
  307             json.printTo(Serial);\par
  308             Serial.println();\par
  309 \par
  310             Serial.print(F("jsonBuffer size: "));\par
  311             Serial.println(jsonBuffer.size());\par
  312             Serial.println();\par
  313 \par
  314         \par
  315         #endif\par
  316   \par
  317             //parsing actif key\par
  318             if(json["actif"].success() )\par
  319             \{\par
  320                 this->actor.actif=json["actif"];\par
  321             \}\par
  322             else\par
  323             \{\par
  324                 this->actor.actif=this->actor.actif;\par
  325             \}\par
  326             json["actif"]=this->actor.actif;\par
  327             \par
  328             //parsing temporal key\par
  329             if(json["temporal"].success() )\par
  330             \{\par
  331                 this->actor.temporal=json["temporal"];\par
  332             \}\par
  333             else\par
  334             \{\par
  335                 this->actor.temporal=this->actor.temporal;\par
  336             \}\par
  337             json["temporal"]=this->actor.temporal;\par
  338             \par
  339             //parsing inverted key\par
  340             if(json["inverted"].success() )\par
  341             \{\par
  342                 this->actor.inverted=json["inverted"];\par
  343             \}\par
  344             else\par
  345             \{\par
  346                 this->actor.inverted=this->actor.inverted;\par
  347             \}\par
  348             json["inverted"]=this->actor.inverted;\par
  349 \par
  350             //parsing inverted key\par
  351             if(json["inverted"].success() )\par
  352             \{\par
  353                 this->actor.inverted=json["inverted"];\par
  354             \}\par
  355             else\par
  356             \{\par
  357                 this->actor.inverted=this->actor.inverted;\par
  358             \}\par
  359             json["inverted"]=this->actor.inverted;\par
  360             \par
  361             //parsing low key\par
  362             if(json["low"].success() )\par
  363             \{\par
  364                 this->actor.rangeLow=json["low"][0];\par
  365                 this->actor.timeLow=json["low"][1];\par
  366                 this->actor.hourLow=json["low"][2];                     \par
  367                 this->actor.minuteLow=json["low"][3];                       \par
  368             \}\par
  369             else\par
  370             \{\par
  371                 this->actor.rangeLow=this->actor.rangeLow;\par
  372                 this->actor.timeLow=this->actor.timeLow;\par
  373                 this->actor.hourLow=this->actor.hourLow;\par
  374                 this->actor.minuteLow=this->actor.minuteLow;                        \par
  375             \}\par
  376             json["low"][0]=this->actor.rangeLow;\par
  377             json["low"][1]=this->actor.timeLow;\par
  378             json["low"][2]=this->actor.hourLow;\par
  379             json["low"][3]=this->actor.minuteLow;\par
  380 \par
  381             //parsing high key\par
  382             if(json["high"].success() )\par
  383             \{\par
  384                 this->actor.rangeHigh=json["high"][0];\par
  385                 this->actor.timeHigh=json["high"][1];\par
  386                 this->actor.hourHigh=json["high"][2];                       \par
  387                 this->actor.minuteHigh=json["high"][3];                     \par
  388             \}\par
  389             else\par
  390             \{\par
  391                 this->actor.rangeHigh=this->actor.rangeHigh;\par
  392                 this->actor.timeHigh=this->actor.timeHigh;\par
  393                 this->actor.hourHigh=this->actor.hourHigh;\par
  394                 this->actor.minuteHigh=this->actor.minuteHigh;\par
  395             \}\par
  396             json["high"][0]=this->actor.rangeHigh;\par
  397             json["high"][1]=this->actor.timeHigh;\par
  398             json["high"][2]=this->actor.hourHigh;\par
  399             json["high"][3]=this->actor.minuteHigh;\par
  400 \par
  401             //parsing type key\par
  402             if(json["type"].success() )\par
  403             \{\par
  404                 this->actor.primaryType=json["type"][0].as<String>();\par
  405                 this->actor.secondaryType=json["type"][1].as<String>();                     \par
  406                 \par
  407             \}\par
  408             else\par
  409             \{\par
  410                 this->actor.primaryType=this->actor.primaryType;\par
  411                 this->actor.secondaryType=this->actor.secondaryType;\par
  412             \}\par
  413             json["type"][0]=this->actor.primaryType;\par
  414             json["type"][1]=this->actor.secondaryType;\par
  415             \par
  416 \par
  417             coolBoardActorConfig.close();           \par
  418             coolBoardActorConfig = SPIFFS.open("/coolBoardActorConfig.json", "w");          \par
  419             if(!coolBoardActorConfig)\par
  420             \{\par
  421             \par
  422             #if DEBUG == 1 \par
  423 \par
  424                 Serial.println( F("failed to write to /coolBoardActorConfig.json ") );\par
  425                 Serial.println();\par
  426             \par
  427             #endif\par
  428                 \par
  429                 return(false);          \par
  430             \}  \par
  431 \par
  432             json.printTo(coolBoardActorConfig);\par
  433             coolBoardActorConfig.close();\par
  434 \par
  435         #if DEBUG == 1 \par
  436             \par
  437             Serial.println(F("saved configuration : "));\par
  438             json.printTo(Serial );\par
  439             Serial.println();       \par
  440         \par
  441         #endif\par
  442 \par
  443             return(true); \par
  444         \}\par
  445     \}   \par
  446     \par
  447 \par
  448 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a5af5538fc7d169f63127e06d5219bcd4_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v doAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:doAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::doAction (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::doAction(sensor data ): This method is provided to automate the {\b CoolBoardActor}.\par
The result action is the result of checking the different flags of the actor (actif , temporal ,inverted, primaryType and secondaryType ) and the corresponding call to the appropriate helping method \par
}{
Definition at line 99 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   100 \{\par
  101 \par
  102 #if DEBUG == 1 \par
  103 \par
  104     Serial.println( F("Entering CoolBoardActor.doAction()") );\par
  105     Serial.println();\par
  106 \par
  107     Serial.println( F("input data is :") );\par
  108     Serial.println(data);\par
  109     Serial.println();\par
  110 \par
  111 #endif \par
  112 \par
  113     DynamicJsonBuffer jsonBuffer;\par
  114     JsonObject& root = jsonBuffer.parseObject(data);\par
  115     \par
  116     if (!root.success()) \par
  117     \{\par
  118     \par
  119     #if DEBUG == 1 \par
  120 \par
  121         Serial.println( F("failed to parse json object ") );\par
  122         Serial.println();\par
  123     \par
  124     #endif \par
  125 \par
  126     \}\par
  127     else\par
  128     \{\par
  129     \par
  130     #if DEBUG == 1 \par
  131 \par
  132         Serial.println( F("created Json object :") );\par
  133         root.printTo(Serial);\par
  134         Serial.println();\par
  135 \par
  136         Serial.print(F("jsonBuffer size: "));\par
  137         Serial.println(jsonBuffer.size());\par
  138         Serial.println();\par
  139 \par
  140     \par
  141     #endif \par
  142 \par
  143         //invert the current action state for the actor\par
  144         //if the value is outside the limits\par
  145         \par
  146         //check if actor is actif\par
  147         if(this->actor.actif==1)\par
  148         \{\par
  149             //normal actor\par
  150             if(this->actor.temporal == 0)\par
  151             \{\par
  152                 //not inverted actor\par
  153                 if(this->actor.inverted==0)\par
  154                 \{\par
  155                     this->normalAction(root[this->actor.primaryType].as<float>());              \par
  156                 \}\par
  157                 //inverted actor\par
  158                 else if(this->actor.inverted==1)\par
  159                 \{\par
  160                     this->invertedAction(root[this->actor.primaryType].as<float>());                \par
  161                 \}\par
  162             \}\par
  163             //temporal actor\par
  164             else if(this->actor.temporal == 1 )\par
  165             \{\par
  166                 //hour actor\par
  167                 if(this->actor.secondaryType=="hour")\par
  168                 \{\par
  169                     //mixed hour actor\par
  170                     if(root[this->actor.primaryType].success() )\par
  171                     \{\par
  172                         this->mixedHourAction(root[this->actor.secondaryType].as<int>(),root[this->actor.primaryType].as<float>());\par
  173                     \}\par
  174                     //normal hour actor\par
  175                     else\par
  176                     \{\par
  177                         this->hourAction(root[this->actor.secondaryType].as<int>());\par
  178                     \}\par
  179                 \par
  180                 \}\par
  181                 //minute actor\par
  182                 else if(this->actor.secondaryType=="minute")\par
  183                 \{\par
  184                     //mixed minute actor\par
  185                     if(root[this->actor.primaryType].success() )\par
  186                     \{\par
  187                         this->mixedMinuteAction(root[this->actor.secondaryType].as<int>(),root[this->actor.primaryType].as<float>());\par
  188                     \}\par
  189                     //normal minute actor\par
  190                     else\par
  191                     \{\par
  192                         this->minuteAction(root[this->actor.secondaryType].as<int>());\par
  193                     \}\par
  194                 \}\par
  195                 //hourMinute actor\par
  196                 else if(this->actor.secondaryType=="hourMinute")\par
  197                 \{\par
  198                     //mixed hourMinute actor\par
  199                     if(root[this->actor.primaryType].success() )\par
  200                     \{\par
  201                         this->mixedHourMinuteAction(root["hour"].as<int>(),root["minute"].as<int>(),root[this->actor.primaryType].as<float>());\par
  202                     \}\par
  203                     //normal hourMinute actor\par
  204                     else\par
  205                     \{\par
  206                         this->hourMinuteAction(root["hour"].as<int>(),root["minute"].as<int>());\par
  207                     \}\par
  208                 \}\par
  209                 //normal temporal actor\par
  210                 else if(this->actor.secondaryType=="")\par
  211                 \{\par
  212                     //mixed temporal actor\par
  213                     if(root[this->actor.primaryType].success() )\par
  214                     \{\par
  215                         this->mixedTemporalActionOn(root[this->actor.primaryType].as<float>());\par
  216                     \}\par
  217                     //normal temporal actor\par
  218                     else\par
  219                     \{\par
  220                         this->temporalActionOn();\par
  221                     \}\par
  222                                         \par
  223                 \}\par
  224 \par
  225             \}\par
  226         \}\par
  227         //inactif actor\par
  228         else if(this->actor.actif == 0 )\par
  229         \{\par
  230             //temporal actor\par
  231             if(this->actor.temporal==1)\par
  232             \{\par
  233                 //mixed temporal actor\par
  234                 if(root[this->actor.primaryType].success() )\par
  235                 \{\par
  236                     this->mixedTemporalActionOff(root[this->actor.primaryType].as<float>());\par
  237                 \}\par
  238                 //normal temporal actor\par
  239                 else\par
  240                 \{\par
  241                     this->temporalActionOff();\par
  242                 \}\par
  243             \}           \par
  244         \}\par
  245 \par
  246     \} \par
  247 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a96a45658d32c6b95caa2f385c7da32cd_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a96a45658d32c6b95caa2f385c7da32cd_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:hourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::hourAction (int  {\i hour})}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::hourAction( current hour ): This method is provided to handle hour actors. it changes the action according to:\par
hour >= hourLow : deactivate the actor hour >= hourHigh : activate the actor \par
}{
Definition at line 920 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   921 \{\par
  922 \par
  923 #if DEBUG == 1\par
  924     \par
  925     Serial.print(F("hour Actor "));\par
  926     Serial.println();\par
  927 \par
  928     Serial.print(F(" hour : "));\par
  929     Serial.println(hour);\par
  930 \par
  931     Serial.print(F("high hour : "));\par
  932     Serial.println(this->actor.hourHigh);\par
  933 \par
  934     Serial.print(F("low hour : "));\par
  935     Serial.println(this->actor.hourLow);\par
  936 \par
  937 #endif\par
  938 \par
  939     //stop the actor    \par
  940     if(hour >= this->actor.hourLow)\par
  941     \{\par
  942         this->write( 0) ;\par
  943 \par
  944     #if DEBUG == 1 \par
  945 \par
  946         Serial.println(F("actor OFF "));\par
  947 \par
  948     #endif  \par
  949 \par
  950     \}\par
  951     //starting the actor\par
  952     else if(hour >= this->actor.hourHigh)\par
  953     \{\par
  954         this->write( 1) ;\par
  955 \par
  956     #if DEBUG == 1 \par
  957 \par
  958         Serial.println(F("actor ON "));\par
  959 \par
  960     #endif  \par
  961     \par
  962     \}\par
  963 \par
  964 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_adf3b4e15b9d73681082112adf8ef95cb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_adf3b4e15b9d73681082112adf8ef95cb_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourMinuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:hourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::hourMinuteAction (int  {\i hour}, int  {\i minute})}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::minteAction( current hour,current minute ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : deactivate the actor\par
hour > hourLow : deactivate the actor\par
hour == hourHigh : minute >= minteHigh : activate the actor\par
hour > hourHigh : activate the actor \par
}{
Definition at line 1264 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1265 \{\par
 1266 \par
 1267 #if DEBUG == 1\par
 1268 \par
 1269     Serial.print(F("hourMinute Actor "));\par
 1270     Serial.println();\par
 1271 \par
 1272     Serial.print(F(" hour : "));\par
 1273     Serial.println(hour);\par
 1274     Serial.print(F(" minute : "));\par
 1275     Serial.println(minute);\par
 1276 \par
 1277     Serial.print(F("high hour : "));\par
 1278     Serial.println(this->actor.hourHigh);\par
 1279 \par
 1280     Serial.print(F("high minute : "));\par
 1281     Serial.println(this->actor.minuteHigh);\par
 1282 \par
 1283     Serial.print(F("low hour : "));\par
 1284     Serial.println(this->actor.hourLow);\par
 1285 \par
 1286     Serial.print(F("low minute : "));\par
 1287     Serial.println(this->actor.minuteLow);\par
 1288 \par
 1289 #endif\par
 1290     //stop the actor\par
 1291     if(hour==this->actor.hourLow)\par
 1292     \{\par
 1293         if(minute>= this->actor.minuteLow)\par
 1294         \{\par
 1295             this->write( 0) ;\par
 1296         #if DEBUG == 1 \par
 1297 \par
 1298             Serial.println(F("actor OFF "));\par
 1299 \par
 1300         #endif  \par
 1301         \}\par
 1302     \}\par
 1303     else if(hour > this->actor.hourLow)\par
 1304     \{\par
 1305 \par
 1306         this->write( 0) ;\par
 1307     #if DEBUG == 1 \par
 1308 \par
 1309         Serial.println(F("actor OFF "));\par
 1310 \par
 1311     #endif  \par
 1312     \par
 1313     \}\par
 1314     //start the actor\par
 1315     else if(hour==this->actor.hourHigh)\par
 1316     \{\par
 1317         if(minute>= this->actor.minuteHigh)\par
 1318         \{\par
 1319             this->write( 1) ;\par
 1320 \par
 1321         #if DEBUG == 1 \par
 1322 \par
 1323             Serial.println(F("actor ON "));\par
 1324 \par
 1325         #endif  \par
 1326         \}\par
 1327     \}\par
 1328     else if(hour > this->actor.hourHigh)\par
 1329     \{\par
 1330 \par
 1331         this->write( 1) ;\par
 1332 \par
 1333     #if DEBUG == 1 \par
 1334 \par
 1335         Serial.println(F("actor ON "));\par
 1336 \par
 1337     #endif      \par
 1338 \par
 1339     \}\par
 1340 \par
 1341     \par
 1342 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a1eb1fbca19bc80aad20d2686d52317f8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a1eb1fbca19bc80aad20d2686d52317f8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v invertedAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:invertedAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::invertedAction (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::invertedAction( measured value): This method is provided to handle inverted actors. it changes the action according to wether the measured value is: \par
{\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid rangeHigh (activate actor) \par
}< rangeLow ( deactivate actor ) \par
}{
Definition at line 587 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   588 \{\par
  589 #if DEBUG == 1\par
  590     \par
  591     Serial.print("inverted Actor ");\par
  592     Serial.println();\par
  593 \par
  594     Serial.print("measured value : ");\par
  595     Serial.println(measurment);\par
  596 \par
  597     Serial.print("high range : ");\par
  598     Serial.println(this->actor.rangeHigh);\par
  599 \par
  600     Serial.print("low range : ");\par
  601     Serial.println(this->actor.rangeLow);\par
  602 \par
  603 #endif\par
  604 \par
  605     //measured value lower than minimum range : deactivate actor\par
  606     if(measurment < this->actor.rangeLow)\par
  607     \{\par
  608         this->write( 0) ;\par
  609 \par
  610     #if DEBUG == 1 \par
  611 \par
  612         Serial.println(F("actor OFF "));\par
  613     \par
  614     #endif\par
  615 \par
  616     \}\par
  617     //measured value higher than maximum range : activate actor\par
  618     else if(measurment > this->actor.rangeHigh)\par
  619     \{\par
  620         this->write( 1) ;\par
  621 \par
  622     #if DEBUG == 1 \par
  623 \par
  624         Serial.println(F("actor ON "));\par
  625     \par
  626     #endif\par
  627 \par
  628     \}\par
  629 \par
  630 \par
  631 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_aae82b2e62f91be009d40f93c206f9bda_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_aae82b2e62f91be009d40f93c206f9bda_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v minuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:minuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::minuteAction (int  {\i minute})}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::minteAction( current minute ): This method is provided to handle minute actors. it changes the action according to:\par
minute >= minuteLow : deactivate the actor minute >= minuteHigh : activate the actor \par
}{
Definition at line 1088 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1089 \{\par
 1090 \par
 1091 #if DEBUG == 1\par
 1092     \par
 1093     Serial.print(F("minute Actor "));\par
 1094     Serial.println();\par
 1095 \par
 1096     Serial.print(F(" minute : "));\par
 1097     Serial.println(minute);\par
 1098 \par
 1099     Serial.print(F("high minute : "));\par
 1100     Serial.println(this->actor.minuteHigh);\par
 1101 \par
 1102     Serial.print(F("low minute : "));\par
 1103     Serial.println(this->actor.minuteLow);\par
 1104 \par
 1105 #endif\par
 1106 \par
 1107     //stop the actor    \par
 1108     if(minute >= this->actor.minuteLow)\par
 1109     \{\par
 1110         this->write( 0) ;\par
 1111 \par
 1112     #if DEBUG == 1 \par
 1113 \par
 1114         Serial.println(F("actor OFF "));\par
 1115 \par
 1116     #endif  \par
 1117 \par
 1118     \}   \par
 1119     //starting the actor\par
 1120     else if(minute >= this->actor.minuteHigh)\par
 1121     \{\par
 1122         this->write( 1) ;\par
 1123 \par
 1124     #if DEBUG == 1 \par
 1125 \par
 1126         Serial.println(F("actor ON "));\par
 1127 \par
 1128     #endif  \par
 1129 \par
 1130     \}\par
 1131 \par
 1132 \} \par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_af000944ce0b9abb9c6ee4b8fe839fb36_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_af000944ce0b9abb9c6ee4b8fe839fb36_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedHourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedHourAction (int  {\i hour}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedHourAction( current hour, measured value ): This method is provided to handle mixed hour actors. it changes the action according to :\par
hour >= hourLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
hour >= hourHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 981 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   982 \{\par
  983 \par
  984 #if DEBUG == 1\par
  985     \par
  986     Serial.print("mixed hour Actor N\'B0 : ");\par
  987     Serial.println();\par
  988 \par
  989     Serial.print(" hour : ");\par
  990     Serial.println(hour);\par
  991 \par
  992     Serial.print("high hour : ");\par
  993     Serial.println(this->actor.hourHigh);\par
  994 \par
  995     Serial.print("low hour : ");\par
  996     Serial.println(this->actor.hourLow);\par
  997 \par
  998     Serial.print("measured value : ");\par
  999     Serial.println(measurment);\par
 1000 \par
 1001     Serial.print("high range : ");\par
 1002     Serial.println(this->actor.rangeHigh);\par
 1003 \par
 1004     Serial.print("low range : ");\par
 1005     Serial.println(this->actor.rangeLow);\par
 1006 \par
 1007 #endif\par
 1008     //stop the actor    \par
 1009     if(hour >= this->actor.hourLow)\par
 1010     \{\par
 1011             if( measurment >= this->actor.rangeHigh )\par
 1012             \{\par
 1013                 this->write( 0) ;\par
 1014 \par
 1015             #if DEBUG == 1 \par
 1016 \par
 1017                 Serial.print(measurment);\par
 1018                 Serial.print(F(" > " ));\par
 1019                 Serial.println(this->actor.rangeHigh);\par
 1020 \par
 1021                 Serial.println(F("actor OFF "));\par
 1022 \par
 1023             #endif  \par
 1024 \par
 1025             \}\par
 1026             else \par
 1027             \{\par
 1028                 this->write( 1) ;\par
 1029 \par
 1030             #if DEBUG == 1 \par
 1031 \par
 1032                 Serial.print(measurment);\par
 1033                 Serial.print(F(" < " ));\par
 1034                 Serial.print(this->actor.rangeHigh);\par
 1035 \par
 1036                 Serial.println(F("actor ON "));\par
 1037 \par
 1038             #endif  \par
 1039                 \par
 1040             \}\par
 1041     \}\par
 1042     //starting the actor\par
 1043     else if(hour >= this->actor.hourHigh)\par
 1044     \{\par
 1045             if( measurment < this->actor.rangeLow )\par
 1046             \{\par
 1047                 this->write( 1) ;\par
 1048 \par
 1049             #if DEBUG == 1 \par
 1050 \par
 1051                 Serial.print(measurment);\par
 1052                 Serial.print(F(" < " ));\par
 1053                 Serial.println(this->actor.rangeLow);\par
 1054 \par
 1055                 Serial.println(F("actor ON "));\par
 1056 \par
 1057             #endif  \par
 1058             \}\par
 1059             else \par
 1060             \{\par
 1061                 this->write( 0) ;\par
 1062 \par
 1063             #if DEBUG == 1 \par
 1064 \par
 1065                 Serial.print(measurment);\par
 1066                 Serial.print(F(" > " ));\par
 1067                 Serial.println(this->actor.rangeLow);\par
 1068 \par
 1069                 Serial.println(F("actor OFF "));\par
 1070 \par
 1071             #endif                  \par
 1072             \}\par
 1073 \par
 1074     \}\par
 1075 \par
 1076 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a6d93a24502c56ced2ef7675c913a276b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a6d93a24502c56ced2ef7675c913a276b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourMinuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedHourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedHourMinuteAction (int  {\i hour}, int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::minteAction( current hour,current minute , measured Value ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour > hourLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour == hourHigh : minute >= minteHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor\par
hour > hourHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor \par
}{
Definition at line 1369 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1370 \{\par
 1371 \par
 1372 #if DEBUG == 1\par
 1373     \par
 1374     Serial.print("hourMinute Actor  ");\par
 1375     Serial.println();\par
 1376 \par
 1377     Serial.print(" hour : ");\par
 1378     Serial.println(hour);\par
 1379     Serial.print(" minute : ");\par
 1380     Serial.println(minute);\par
 1381 \par
 1382     Serial.print("high hour : ");\par
 1383     Serial.println(this->actor.hourHigh);\par
 1384 \par
 1385     Serial.print("high minute : ");\par
 1386     Serial.println(this->actor.minuteHigh);\par
 1387 \par
 1388     Serial.print("low hour : ");\par
 1389     Serial.println(this->actor.hourLow);\par
 1390 \par
 1391     Serial.print("low minute : ");\par
 1392     Serial.println(this->actor.minuteLow);\par
 1393 \par
 1394     Serial.print("measured value : ");\par
 1395     Serial.println(measurment);\par
 1396 \par
 1397     Serial.print("high range : ");\par
 1398     Serial.println(this->actor.rangeHigh);\par
 1399 \par
 1400     Serial.print("low range : ");\par
 1401     Serial.println(this->actor.rangeLow);\par
 1402 \par
 1403 #endif\par
 1404     //stop the actor\par
 1405     if(hour==this->actor.hourLow)\par
 1406     \{\par
 1407         if(minute>= this->actor.minuteLow)\par
 1408         \{\par
 1409             if( measurment >= this->actor.rangeHigh )\par
 1410             \{\par
 1411                 this->write( 0) ;\par
 1412 \par
 1413             #if DEBUG == 1 \par
 1414 \par
 1415                 Serial.print(measurment);\par
 1416                 Serial.print(F(" >= " ));\par
 1417                 Serial.println(this->actor.rangeHigh);\par
 1418 \par
 1419                 Serial.println(F("actor OFF "));\par
 1420 \par
 1421             #endif  \par
 1422 \par
 1423             \}\par
 1424             else \par
 1425             \{\par
 1426                 this->write( 1) ;\par
 1427 \par
 1428             #if DEBUG == 1 \par
 1429 \par
 1430                 Serial.print(measurment);\par
 1431                 Serial.print(F(" < " ));\par
 1432                 Serial.println(this->actor.rangeHigh);\par
 1433 \par
 1434                 Serial.println(F("actor ON "));\par
 1435 \par
 1436             #endif  \par
 1437                 \par
 1438             \}\par
 1439         \}\par
 1440     \}\par
 1441     else if(hour > this->actor.hourLow)\par
 1442     \{\par
 1443 \par
 1444         if( measurment >= this->actor.rangeHigh )\par
 1445         \{\par
 1446             this->write( 0) ;\par
 1447 \par
 1448         #if DEBUG == 1 \par
 1449 \par
 1450             Serial.print(measurment);\par
 1451             Serial.print(F(" >= " ));\par
 1452             Serial.println(this->actor.rangeHigh);\par
 1453 \par
 1454             Serial.println(F("actor OFF "));\par
 1455 \par
 1456         #endif  \par
 1457 \par
 1458         \}\par
 1459         else \par
 1460         \{\par
 1461             this->write( 1) ;\par
 1462 \par
 1463         #if DEBUG == 1 \par
 1464 \par
 1465             Serial.print(measurment);\par
 1466             Serial.print(F(" < " ));\par
 1467             Serial.println(this->actor.rangeHigh);\par
 1468 \par
 1469             Serial.println(F("actor ON "));\par
 1470 \par
 1471         #endif  \par
 1472             \par
 1473         \}\par
 1474 \par
 1475 \par
 1476     \}\par
 1477     //start the actor\par
 1478     else if(hour==this->actor.hourHigh)\par
 1479     \{\par
 1480         if(minute>= this->actor.minuteHigh)\par
 1481         \{\par
 1482             if( measurment < this->actor.rangeLow )\par
 1483             \{\par
 1484                 this->write( 1) ;\par
 1485 \par
 1486             #if DEBUG == 1 \par
 1487 \par
 1488                 Serial.print(measurment);\par
 1489                 Serial.print(F(" < " ));\par
 1490                 Serial.println(this->actor.rangeLow);\par
 1491 \par
 1492                 Serial.println(F("actor ON "));\par
 1493 \par
 1494             #endif  \par
 1495 \par
 1496             \}\par
 1497             else \par
 1498             \{\par
 1499                 this->write( 0) ;\par
 1500 \par
 1501             #if DEBUG == 1 \par
 1502 \par
 1503                 Serial.print(measurment);\par
 1504                 Serial.println(F(" > " ));\par
 1505                 Serial.print(this->actor.rangeLow);\par
 1506 \par
 1507                 Serial.println(F("actor OFF "));\par
 1508 \par
 1509             #endif  \par
 1510                 \par
 1511             \}\par
 1512         \}\par
 1513     \}\par
 1514     else if(hour > this->actor.hourHigh)\par
 1515     \{\par
 1516 \par
 1517         if( measurment < this->actor.rangeLow )\par
 1518         \{\par
 1519             this->write( 1) ;\par
 1520 \par
 1521         #if DEBUG == 1 \par
 1522 \par
 1523             Serial.print(measurment);\par
 1524             Serial.print(F(" < " ));\par
 1525             Serial.println(this->actor.rangeLow);\par
 1526 \par
 1527             Serial.println(F("actor ON "));\par
 1528 \par
 1529         #endif  \par
 1530 \par
 1531         \}\par
 1532         else \par
 1533         \{\par
 1534             this->write( 0) ;\par
 1535 \par
 1536         #if DEBUG == 1 \par
 1537 \par
 1538             Serial.print(measurment);\par
 1539             Serial.println(F(" > " ));\par
 1540             Serial.print(this->actor.rangeLow);\par
 1541 \par
 1542             Serial.println(F("actor OFF "));\par
 1543 \par
 1544         #endif  \par
 1545             \par
 1546         \}\par
 1547     \par
 1548     \}\par
 1549 \par
 1550 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ae6b2a17b0e73cfeb353ded2cc4e08109_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ae6b2a17b0e73cfeb353ded2cc4e08109_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedMinuteAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedMinuteAction (int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedMinuteAction( current minute, measured value ): This method is provided to handle mixed minute actors. it changes the action according to :\par
minute >= minuteLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
minute >= minuteHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 1148 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1149 \{\par
 1150 \par
 1151 #if DEBUG == 1\par
 1152     \par
 1153     Serial.print("mixed minute Actor ");\par
 1154     Serial.println();\par
 1155 \par
 1156     Serial.print(" minute : ");\par
 1157     Serial.println(minute);\par
 1158 \par
 1159     Serial.print("high minute : ");\par
 1160     Serial.println(this->actor.minuteHigh);\par
 1161 \par
 1162     Serial.print("low minute : ");\par
 1163     Serial.println(this->actor.minuteLow);\par
 1164 \par
 1165     Serial.print("measured value : ");\par
 1166     Serial.println(measurment);\par
 1167 \par
 1168     Serial.print("high range : ");\par
 1169     Serial.println(this->actor.rangeHigh);\par
 1170 \par
 1171     Serial.print("low range : ");\par
 1172     Serial.println(this->actor.rangeLow);\par
 1173 \par
 1174 #endif\par
 1175     //stop the actor    \par
 1176     if(minute >= this->actor.minuteLow)\par
 1177     \{\par
 1178             if( measurment > this->actor.rangeHigh )\par
 1179             \{\par
 1180                 this->write( 0) ;\par
 1181 \par
 1182             #if DEBUG == 1 \par
 1183 \par
 1184                 Serial.print(measurment);\par
 1185                 Serial.print(F(" > " ));\par
 1186                 Serial.println(this->actor.rangeHigh);\par
 1187 \par
 1188                 Serial.println(F("actor OFF "));\par
 1189 \par
 1190             #endif\par
 1191     \par
 1192             \}\par
 1193             else \par
 1194             \{\par
 1195                 this->write( 1) ;\par
 1196 \par
 1197             #if DEBUG == 1 \par
 1198 \par
 1199                 Serial.print(measurment);\par
 1200                 Serial.print(F(" < " ));\par
 1201                 Serial.println(this->actor.rangeHigh);\par
 1202 \par
 1203                 Serial.println(F("actor ON "));\par
 1204 \par
 1205             #endif  \par
 1206                 \par
 1207             \}\par
 1208     \}   \par
 1209     //starting the actor\par
 1210     else if(minute >= this->actor.minuteHigh)\par
 1211     \{\par
 1212             if( measurment < this->actor.rangeLow )\par
 1213             \{\par
 1214                 this->write( 1) ;\par
 1215 \par
 1216             #if DEBUG == 1 \par
 1217 \par
 1218                 Serial.print(measurment);\par
 1219                 Serial.print(F(" < " ));\par
 1220                 Serial.println(this->actor.rangeLow);\par
 1221 \par
 1222                 Serial.println(F("actor ON "));\par
 1223 \par
 1224             #endif  \par
 1225 \par
 1226             \}\par
 1227             else \par
 1228             \{\par
 1229                 this->write( 0) ;\par
 1230             \par
 1231             #if DEBUG == 1 \par
 1232 \par
 1233                 Serial.print(measurment);\par
 1234                 Serial.print(F(" > " ));\par
 1235                 Serial.println(this->actor.rangeLow);\par
 1236 \par
 1237                 Serial.println(F("actor OFF "));\par
 1238 \par
 1239             #endif  \par
 1240                 \par
 1241             \}\par
 1242 \par
 1243     \}\par
 1244 \par
 1245 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a2b8a79a27288d5246e3e3860ae76770d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a2b8a79a27288d5246e3e3860ae76770d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOff\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedTemporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedTemporalActionOff (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedTemporalActionOff( measured value ): This method is provided to handle mixed temporal actors. it changes the action according to:\par
currentTime - startTime >= timeHigh : measured value >= rangeHigh : deactivate actor measured value < rangeHigh : activate actor \par
}{
Definition at line 693 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   694 \{\par
  695 \par
  696 #if DEBUG == 1\par
  697     \par
  698     Serial.print("mixed Temporal Actor N\'B0 : ");\par
  699     Serial.println();\par
  700 \par
  701     Serial.print("measured value : ");\par
  702     Serial.println(measurment);\par
  703 \par
  704     Serial.print("high range : ");\par
  705     Serial.println(this->actor.rangeHigh);\par
  706 \par
  707     Serial.print("time high : ");\par
  708     Serial.println(this->actor.timeHigh);\par
  709 \par
  710     Serial.print("actif Time : ");\par
  711     Serial.println(this->actor.actifTime);\par
  712 \par
  713     Serial.print(F("millis : "));\par
  714     Serial.println(millis());\par
  715 \par
  716 #endif\par
  717     if( ( millis()- this->actor.actifTime  ) >= (  this->actor.timeHigh  ) )\par
  718     \{   \par
  719         if( measurment >= this->actor.rangeHigh )\par
  720         \{\par
  721             //stop the actor\par
  722             this->write( 0) ;\par
  723 \par
  724             //make the actor inactif:\par
  725             this->actor.actif=0;\par
  726 \par
  727             //start the low timer\par
  728             this->actor.inactifTime=millis();\par
  729 \par
  730         #if DEBUG == 1 \par
  731 \par
  732             Serial.print(F("actor was on for at least "));\par
  733             Serial.print(this->actor.timeHigh);\par
  734             Serial.println(F(" ms "));\par
  735 \par
  736             Serial.print(measurment);\par
  737             Serial.print(F(" > " ));\par
  738             Serial.println(this->actor.rangeHigh);\par
  739 \par
  740             \par
  741             Serial.println(F("actor OFF "));\par
  742 \par
  743         #endif\par
  744 \par
  745         \}\par
  746         else \par
  747         \{\par
  748             this->write( 1) ;\par
  749 \par
  750         #if DEBUG == 1 \par
  751             \par
  752             Serial.print(F("actor was on for at least "));\par
  753             Serial.print(this->actor.timeHigh);\par
  754             Serial.println(F(" ms "));\par
  755 \par
  756             Serial.print(measurment);\par
  757             Serial.print(F(" < " ));\par
  758             Serial.println(this->actor.rangeHigh);\par
  759 \par
  760             Serial.println(F("actor ON "));\par
  761 \par
  762         #endif              \par
  763 \par
  764         \}           \par
  765     \}\par
  766 \par
  767 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a00b29c4abf0388551aa6812372113cf1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a00b29c4abf0388551aa6812372113cf1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOn\:CoolBoardActor}
{\xe \v CoolBoardActor\:mixedTemporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::mixedTemporalActionOn (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::mixedTemporalActionOn( measured value ): This method is provided to handle mixed temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : measured value >= rangeLow : deactivate actor measured value < rangeLow : activate actor \par
}{
Definition at line 831 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   832 \{\par
  833 \par
  834 #if DEBUG == 1\par
  835     \par
  836     Serial.print("mixed Temporal Actor  ");\par
  837     Serial.println();\par
  838 \par
  839     Serial.print("measured value : ");\par
  840     Serial.println(measurment);\par
  841 \par
  842     Serial.print("low range : ");\par
  843     Serial.println(this->actor.rangeLow);\par
  844 \par
  845     Serial.print("time low : ");\par
  846     Serial.println(this->actor.timeLow);\par
  847 \par
  848     Serial.print("inactif Time : ");\par
  849     Serial.println(this->actor.inactifTime);\par
  850 \par
  851     Serial.print(F("millis : "));\par
  852     Serial.println(millis());\par
  853 \par
  854 #endif\par
  855 \par
  856     if( ( millis() - this->actor.inactifTime ) >= (  this->actor.timeLow  ) )\par
  857     \{\par
  858         if( measurment < this->actor.rangeLow )\par
  859         \{\par
  860             //start the actor\par
  861             this->write( 1) ;\par
  862 \par
  863             //make the actor actif:\par
  864             this->actor.actif=1;\par
  865 \par
  866             //start the low timer\par
  867             this->actor.actifTime=millis();\par
  868 \par
  869         #if DEBUG == 1 \par
  870 \par
  871             Serial.print(F("actor was off for at least "));\par
  872             Serial.print(this->actor.timeLow);\par
  873             Serial.println(F(" ms "));\par
  874 \par
  875             Serial.print(measurment);\par
  876             Serial.print(F(" < " ));\par
  877             Serial.println(this->actor.rangeLow);\par
  878     \par
  879             Serial.println(F("actor ON "));\par
  880     \par
  881         #endif  \par
  882 \par
  883         \}\par
  884         else \par
  885         \{\par
  886             this->write( 0) ;   \par
  887 \par
  888         #if DEBUG == 1 \par
  889 \par
  890             Serial.print(F("actor was off for at least "));\par
  891             Serial.print(this->actor.timeLow);\par
  892             Serial.println(F(" ms "));\par
  893 \par
  894             Serial.print(measurment);\par
  895             Serial.print(F(" > " ));\par
  896             Serial.println(this->actor.rangeLow);\par
  897 \par
  898             Serial.println(F("actor OFF "));\par
  899     \par
  900         #endif              \par
  901 \par
  902         \}\par
  903 \par
  904     \}\par
  905 \par
  906     \par
  907 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a216aa7a0cfd1f31d0025cc91c2ecd5dd_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a216aa7a0cfd1f31d0025cc91c2ecd5dd_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v normalAction\:CoolBoardActor}
{\xe \v CoolBoardActor\:normalAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::normalAction (float  {\i measurment})}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::normalAction( measured value): This method is provided to handle normal actors. it changes the action according to wether the measured value is: > rangeHigh ( deactivate actor) or < rangeLow (activate actor ) \par
}{
Definition at line 530 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   531 \{\par
  532 \par
  533 #if DEBUG == 1\par
  534     \par
  535     Serial.print(F("none inverted Actor"));\par
  536     Serial.println();\par
  537 \par
  538     Serial.print(F("measured value : "));\par
  539     Serial.println(measurment);\par
  540 \par
  541     Serial.print(F("high range : "));\par
  542     Serial.println(this->actor.rangeHigh);\par
  543 \par
  544     Serial.print(F("low range : "));\par
  545     Serial.println(this->actor.rangeLow);\par
  546 \par
  547 #endif\par
  548 \par
  549     //measured value lower than minimum range : activate actor\par
  550     if(measurment < this->actor.rangeLow)\par
  551     \{\par
  552         this->write( 1) ;\par
  553 \par
  554     #if DEBUG == 1 \par
  555 \par
  556         Serial.println(F("actor ON "));s\par
  557     \par
  558     #endif\par
  559                 \par
  560     \}\par
  561     //measured value higher than maximum range : deactivate actor\par
  562     else if(measurment > this->actor.rangeHigh)\par
  563     \{\par
  564         this->write( 0) ;\par
  565 \par
  566     #if DEBUG == 1 \par
  567 \par
  568         Serial.println(F("actor OFF "));\par
  569     \par
  570     #endif\par
  571     \par
  572     \}\par
  573 \par
  574 \par
  575 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a81229abf5895f4d3b0355050b822b438_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a81229abf5895f4d3b0355050b822b438_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoardActor}
{\xe \v CoolBoardActor\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::printConf ()}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 456 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   457 \{\par
  458 \par
  459 #if DEBUG == 1 \par
  460 \par
  461     Serial.println( F("Enter CoolBoardActor.printConf() ") );\par
  462     Serial.println();\par
  463 \par
  464 #endif \par
  465     Serial.println(F( "CoolBoardActor configuration " ) ) ;\par
  466  \par
  467     Serial.print(F(" actif :"));\par
  468     Serial.println(this->actor.actif);\par
  469     \par
  470 \par
  471     Serial.print(F(" temporal :"));\par
  472     Serial.println(this->actor.temporal);\par
  473 \par
  474 \par
  475     Serial.print(F(" inverted :"));\par
  476     Serial.println(this->actor.inverted);\par
  477 \par
  478 \par
  479 \par
  480     Serial.print(F(" primary Type :"));\par
  481     Serial.println(this->actor.primaryType);\par
  482 \par
  483     Serial.print(F(" secondary Type :"));       \par
  484     Serial.println(this->actor.secondaryType);\par
  485 \par
  486 \par
  487     Serial.print(F(" range Low :"));\par
  488     Serial.println(this->actor.rangeLow);\par
  489 \par
  490 \par
  491     Serial.print(F(" time Low :"));\par
  492     Serial.println(this->actor.timeLow);\par
  493 \par
  494 \par
  495     Serial.print(F(" hour low:"));\par
  496     Serial.println(this->actor.hourLow);\par
  497 \par
  498 \par
  499     Serial.print(F(" minute low:"));\par
  500     Serial.println(this->actor.minuteLow);\par
  501 \par
  502 \par
  503     Serial.print(F(" range High:"));\par
  504     Serial.println(this->actor.rangeHigh);\par
  505 \par
  506 \par
  507     Serial.print(F(" time High:"));\par
  508     Serial.println(this->actor.timeHigh);\par
  509 \par
  510 \par
  511     Serial.print(F(" hour high:"));\par
  512     Serial.println(this->actor.hourHigh);\par
  513 \par
  514 \par
  515     Serial.print(F(" minute high:"));\par
  516     Serial.println(this->actor.minuteHigh);\par
  517 \par
  518     Serial.println(); \par
  519 \par
  520 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_aabb10e7aebc3249ffc940530de29f84a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOff\:CoolBoardActor}
{\xe \v CoolBoardActor\:temporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::temporalActionOff ()}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::temporalActionOff( )}: This method is provided to handle temporal actors. it changes the action according to:\par
currentTime - startTime > timeHigh : deactivate actor \par
}{
Definition at line 642 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   643 \{\par
  644 \par
  645 #if DEBUG == 1\par
  646     \par
  647     Serial.print(F("temporal Actor  "));\par
  648     Serial.println();\par
  649 \par
  650     Serial.print(F("millis : "));\par
  651     Serial.println(millis());\par
  652 \par
  653     Serial.print(F("actif Time : "));\par
  654     Serial.println(this->actor.actifTime);\par
  655 \par
  656     Serial.print(F("high time : "));\par
  657     Serial.println(this->actor.timeHigh);\par
  658 \par
  659 \par
  660 #endif\par
  661     \par
  662     if( ( millis()- this->actor.actifTime  ) >= (  this->actor.timeHigh  ) )\par
  663     \{\par
  664         //stop the actor\par
  665         this->write( 0) ;\par
  666 \par
  667         //make the actor inactif:\par
  668         this->actor.actif=0;\par
  669 \par
  670         //start the low timer\par
  671         this->actor.inactifTime=millis();\par
  672 \par
  673     #if DEBUG == 1 \par
  674 \par
  675         Serial.println(F("actor OFF "));\par
  676     \par
  677     #endif\par
  678                 \par
  679     \}   \par
  680 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a02698bd647df49cabbe74513d4d88918_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a02698bd647df49cabbe74513d4d88918_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOn\:CoolBoardActor}
{\xe \v CoolBoardActor\:temporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::temporalActionOn ()}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor::temporalActionOn( )}: This method is provided to handle temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : activate actor \par
}{
Definition at line 779 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   780 \{\par
  781 \par
  782 #if DEBUG == 1\par
  783     \par
  784     Serial.print(F("temporal Actor "));\par
  785     Serial.println();\par
  786 \par
  787     Serial.print(F("millis : "));\par
  788     Serial.println(millis());\par
  789 \par
  790     Serial.print(F("inactif Time : "));\par
  791     Serial.println(this->actor.inactifTime);\par
  792 \par
  793     Serial.print(F("low time : "));\par
  794     Serial.println(this->actor.timeLow);\par
  795 \par
  796 \par
  797 #endif\par
  798     \par
  799      if( ( millis() - this->actor.inactifTime ) >= (  this->actor.timeLow  ) )\par
  800     \{\par
  801         //start the actor\par
  802         this->write( 1) ;\par
  803 \par
  804         //make the actor actif:\par
  805         this->actor.actif=1;\par
  806 \par
  807         //start the low timer\par
  808         this->actor.actifTime=millis();\par
  809 \par
  810     #if DEBUG == 1 \par
  811 \par
  812         Serial.println(F("actor ON "));\par
  813 \par
  814     #endif              \par
  815 \par
  816     \}\par
  817 \par
  818 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ada603785c203fdb0b41cc967d70bdc4d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_ada603785c203fdb0b41cc967d70bdc4d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:CoolBoardActor}
{\xe \v CoolBoardActor\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardActor::write (bool  {\i action})}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardActor::write(action): This method is provided to write the given action to the {\b CoolBoardActor}. \par
}{
Definition at line 69 of file CoolBoardActor.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71 \par
   72 #if DEBUG == 1\par
   73 \par
   74     Serial.println( F("Entering CoolBoardActor.write()") );\par
   75     Serial.println();\par
   76 \par
   77     Serial.println( F("writing this action : ") );\par
   78     Serial.println(action,BIN);\par
   79     Serial.println();\par
   80 \par
   81 #endif \par
   82     \par
   83     digitalWrite(this->pin,action);\par
   84     \par
   85 \par
   86 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d69/class_cool_board_actor_a958786ff01ea1056ee72c72d439f86da_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actor\:CoolBoardActor}
{\xe \v CoolBoardActor\:actor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoolBoardActor::state} CoolBoardActor::actor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pin\:CoolBoardActor}
{\xe \v CoolBoardActor\:pin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoardActor::pin = 15{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardLed Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardLed}
{\xe \v CoolBoardLed}
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board. }}\par
{
{\f2 #include <CoolBoardLed.h>}}\par
Collaboration diagram for CoolBoardLed:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d22/class_cool_board_led__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (int R, int G, int B)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b activate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fade} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blink} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fadeIn} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fadeOut} (int R, int G, int B, float T)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b strobe} (int R, int G, int B, float T)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NeoPixelBus< NeoGrbFeature, Neo800KbpsMethod > * {\b neoPixelLed} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ledActive} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board. \par
}{
Definition at line 42 of file CoolBoardLed.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v activate\:CoolBoardLed}
{\xe \v CoolBoardLed\:activate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::activate ()}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::activate()}: This method is provided to activate the Led Object without the configuration file \par
}{
Definition at line 437 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   438 \{\par
  439 \par
  440     this->ledActive=1;\par
  441 \par
  442 \}\par
}
}
{\xe \v begin\:CoolBoardLed}
{\xe \v CoolBoardLed\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::begin ()}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::begin()}: This method is provided to start the Led Object by setting the correct pin and creating a dynamic neoPixelBus \par
}{
Definition at line 245 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   246 \{\par
  247 \par
  248 #if DEBUG == 1\par
  249 \par
  250     Serial.println( F("Entering CoolBoardLed.begin() ") );\par
  251 \par
  252 #endif\par
  253     yield();\par
  254     if(this->ledActive == 1 )\par
  255     \{\par
  256         pinMode(5,OUTPUT);\par
  257         digitalWrite(5,HIGH);\par
  258         neoPixelLed = new NeoPixelBus<NeoGrbFeature, Neo800KbpsMethod>(1,2); \par
  259         neoPixelLed->Begin();\par
  260         neoPixelLed->Show();\par
  261 \par
  262     \}\par
  263 \par
  264 \} \par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_ae3cbde8affcc6f011cbd698c8ef911f6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v blink\:CoolBoardLed}
{\xe \v CoolBoardLed\:blink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::blink (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::blink( Red , Green , Blue , Time in seconds ): Blink animation: Led On for T seconds Led off \par
}{
Definition at line 87 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    88 \{\par
   89 \par
   90 #if DEBUG == 1\par
   91 \par
   92     Serial.println( F("Entering CoolBoardLed.blink()"));\par
   93     Serial.println();\par
   94     Serial.print( F("R : "));\par
   95     Serial.println(R);\par
   96     Serial.print( F("G : ") );\par
   97     Serial.println(G);\par
   98     Serial.print( F("B : ") );\par
   99     Serial.println(B);\par
  100     Serial.print( F("Time :") );\par
  101     Serial.println(T);\par
  102     Serial.println();\par
  103 \par
  104 #endif  \par
  105 \par
  106     if(this->ledActive == 1 )\par
  107     \{\par
  108         neoPixelLed->SetPixelColor(0, RgbColor(R, G, B));\par
  109         neoPixelLed->Show();\par
  110         delay(T);\par
  111         neoPixelLed->SetPixelColor(0, RgbColor(0, 0, 0));\par
  112         neoPixelLed->Show();\par
  113     \}\par
  114 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a96e1ea13003eee34c9dbcef340404426_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoardLed}
{\xe \v CoolBoardLed\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardLed::config ()}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::config()}: This method is provided to configure the Led Object : -ledActive=0 : deactivated -ledActive=1 : activated \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the configuration done, false otherwise \par
}}{
Definition at line 304 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   305 \{\par
  306 \par
  307 #if DEBUG == 1 \par
  308         \par
  309     Serial.println( F("Entering CoolBoardLed.config()") );\par
  310     Serial.println();\par
  311 \par
  312 #endif\par
  313     \par
  314     File coolBoardLedConfig = SPIFFS.open("/coolBoardLedConfig.json", "r");\par
  315 \par
  316     if (!coolBoardLedConfig) \par
  317     \{\par
  318     \par
  319     #if DEBUG == 1\par
  320 \par
  321         Serial.println( F("failed to read /coolBoardLedConfig.json") );\par
  322         Serial.println();\par
  323 \par
  324     #endif\par
  325 \par
  326         return(false);\par
  327     \}\par
  328     else\par
  329     \{\par
  330         size_t size = coolBoardLedConfig.size();\par
  331         // Allocate a buffer to store contents of the file.\par
  332         std::unique_ptr<char[]> buf(new char[size]);\par
  333 \par
  334         coolBoardLedConfig.readBytes(buf.get(), size);\par
  335         DynamicJsonBuffer jsonBuffer;\par
  336         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  337         if (!json.success()) \par
  338         \{\par
  339         \par
  340         #if DEBUG == 1\par
  341 \par
  342             Serial.println( F("failed to parse json") );\par
  343             Serial.println();\par
  344         \par
  345         #endif\par
  346 \par
  347             return(false);\par
  348         \} \par
  349         else\par
  350         \{\par
  351         \par
  352         #if DEBUG == 1\par
  353     \par
  354             Serial.println( F("read configuration file : ") );\par
  355             json.printTo(Serial);\par
  356             Serial.println();\par
  357             \par
  358             Serial.print(F("jsonBuffer size :"));\par
  359             Serial.println(jsonBuffer.size());\par
  360             Serial.println();\par
  361 \par
  362         #endif\par
  363   \par
  364             if(json["ledActive"].success() )\par
  365             \{\par
  366                 this->ledActive = json["ledActive"]; \par
  367             \}\par
  368             else\par
  369             \{\par
  370                 this->ledActive=this->ledActive;            \par
  371             \}\par
  372             \par
  373             json["ledActive"]=this->ledActive;\par
  374             coolBoardLedConfig.close();\par
  375             \par
  376             coolBoardLedConfig = SPIFFS.open("/coolBoardLedConfig.json", "w");\par
  377             if(!coolBoardLedConfig)\par
  378             \{\par
  379             \par
  380             #if DEBUG == 1 \par
  381 \par
  382                 Serial.println( F("failed to write to /coolBoardLedConfig.json") );\par
  383                 Serial.println();\par
  384 \par
  385             #endif\par
  386 \par
  387                 return(false);          \par
  388             \}\par
  389 \par
  390             json.printTo(coolBoardLedConfig);\par
  391             coolBoardLedConfig.close();\par
  392 \par
  393         #if DEBUG == 1\par
  394     \par
  395             Serial.println( F("saved Led Config is : ") );\par
  396             json.printTo(Serial);\par
  397             Serial.println();\par
  398 \par
  399         #endif\par
  400 \par
  401             return(true); \par
  402         \}\par
  403     \}   \par
  404 \par
  405 \}               \par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a1b60e5e30bea96c49ed62ed1bf1ffc8b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v end\:CoolBoardLed}
{\xe \v CoolBoardLed\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::end ()}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::end()} : this method is provided to delete the dynamically created neoPixelLed \par
}{
Definition at line 226 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   227 \{\par
  228 \par
  229 #if DEBUG == 1 \par
  230     \par
  231     Serial.println( F("Entering CoolBoardLed.end()") );\par
  232 \par
  233 #endif\par
  234 \par
  235     delete neoPixelLed;\par
  236 \}\par
}
}
{\xe \v fade\:CoolBoardLed}
{\xe \v CoolBoardLed\:fade}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::fade (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::fade} ( Red , Green , Blue, Time in seconds ): fade animation: Fade In over T(seconds) Fade Out over T(seconds) \par
}{
Definition at line 46 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    47 \{\par
   48 \par
   49 #if DEBUG == 1\par
   50 \par
   51     Serial.println( F("Entering CoolBoardLed.fade()") );\par
   52     Serial.println();\par
   53     Serial.print( F("R : ") );\par
   54     Serial.println(R);\par
   55     Serial.print( F("G : ") );\par
   56     Serial.println(G);\par
   57     Serial.print( F("B : ") );\par
   58     Serial.println(B);\par
   59     Serial.print( F("Time : ") );\par
   60     Serial.println(T);\par
   61     Serial.println();\par
   62 \par
   63 #endif  \par
   64     if(this->ledActive == 1 )\par
   65     \{\par
   66         for (int k = 0; k < 1000; k++) \par
   67         \{\par
   68             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
   69             neoPixelLed->Show();\par
   70             delay(T);\par
   71         \}\par
   72         \par
   73         for (int k = 1000; k >= 0; k--) \par
   74         \{\par
   75             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
   76             neoPixelLed->Show();\par
   77             delay(T);\par
   78         \}\par
   79     \}\par
   80 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_af1cacbaa88db8bcf6042c1083ba41155_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fadeIn\:CoolBoardLed}
{\xe \v CoolBoardLed\:fadeIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::fadeIn (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::fadeIn(Red , Green , Blue , Time in seconds) Fade In animation: gradual increase over T(seconds) \par
}{
Definition at line 120 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   121 \{\par
  122 \par
  123 #if DEBUG == 1\par
  124 \par
  125     Serial.println( F("Entering CoolBoardLed.fadeIn()") );\par
  126     Serial.println();\par
  127     Serial.print( F("R : ") );\par
  128     Serial.println(R);\par
  129     Serial.print( F("G : ") );\par
  130     Serial.println(G);\par
  131     Serial.print( F("B : ") );\par
  132     Serial.println(B);\par
  133     Serial.print( F("Time :") );\par
  134     Serial.println(T);\par
  135     Serial.println();\par
  136 \par
  137 #endif  \par
  138     \par
  139     if(this->ledActive == 1 )\par
  140     \{\par
  141         for (int k = 0; k < 1000; k++) \par
  142         \{\par
  143             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
  144             neoPixelLed->Show();\par
  145             delay(T);\par
  146         \}\par
  147     \}\par
  148 \par
  149 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_ab778f5e7bed0ab74e3906d82110493c3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fadeOut\:CoolBoardLed}
{\xe \v CoolBoardLed\:fadeOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::fadeOut (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::fadeOut( Red , Green , Blue , Time in seconds) Fade Out animation: gradual decrease over T(seconds) \par
}{
Definition at line 155 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157 \par
  158 #if DEBUG == 1 \par
  159 \par
  160     Serial.println( F("Entering CoolBoardLed.fadeOut()" ) );\par
  161     Serial.println();\par
  162     Serial.print( F("R : ") );\par
  163     Serial.println(R);\par
  164     Serial.print( F("G : ") );\par
  165     Serial.println(G);\par
  166     Serial.print( F("B : ") );\par
  167     Serial.println(B);\par
  168     Serial.print( F("Time :") );\par
  169     Serial.println(T);\par
  170     Serial.println();\par
  171 \par
  172 #endif  \par
  173 \par
  174     if(this->ledActive == 1 )\par
  175     \{\par
  176         for (int k = 1000; k >= 0; k--) \par
  177         \{\par
  178             neoPixelLed->SetPixelColor(0, RgbColor(k * R / 1000, k * G / 1000, k * B / 1000));\par
  179             neoPixelLed->Show();\par
  180             delay(T);\par
  181         \}\par
  182     \}\par
  183 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a93d545679237e8cc858324367149775c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoardLed}
{\xe \v CoolBoardLed\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::printConf ()}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed::printConf()}: This method is provided to print the Led Object Configuration to the Serial Monitor \par
}{
Definition at line 413 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   414 \{\par
  415 \par
  416 #if DEBUG == 1 \par
  417 \par
  418     Serial.println( F("Entering CoolBoardLed.printConf()") );\par
  419     Serial.println();\par
  420 \par
  421 #endif\par
  422 \par
  423     Serial.println("Led Configuration");\par
  424 \par
  425     Serial.print("ledActive : ");\par
  426     Serial.println(ledActive);\par
  427 \par
  428     Serial.println();   \par
  429 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a8ed3053a36f0ed4a131f43b5b17efb61_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v strobe\:CoolBoardLed}
{\xe \v CoolBoardLed\:strobe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::strobe (int  {\i R}, int  {\i G}, int  {\i B}, float  {\i T})}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::strobe(Red , Green , Blue , Time in seconds) Strobe animation: blinks over T(seconds) \par
}{
Definition at line 189 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   190 \{\par
  191 \par
  192 #if DEBUG == 1\par
  193 \par
  194     Serial.println( F("Entering CoolBoardLed.strobe()") );\par
  195     Serial.println();\par
  196     Serial.print( F("R : ") );\par
  197     Serial.println(R);\par
  198     Serial.print( F("G: ") );\par
  199     Serial.println(G);\par
  200     Serial.print( F("B : ") );\par
  201     Serial.println(B);\par
  202     Serial.print( F("Time :") );\par
  203     Serial.println(T);\par
  204     Serial.println();\par
  205 \par
  206 #endif  \par
  207 \par
  208     if(this->ledActive == 1 )\par
  209     \{   \par
  210         for (int k = 1000; k >= 0; k--) \par
  211         \{\par
  212             neoPixelLed->SetPixelColor(0, RgbColor(R, G, B));\par
  213             neoPixelLed->Show();\par
  214             delay(T);\par
  215             neoPixelLed->SetPixelColor(0, RgbColor(0, 0, 0));\par
  216             neoPixelLed->Show();\par
  217             delay(T);\par
  218         \}\par
  219     \}\par
  220 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_ad5f0de4c628cbfbf49896042831c64ad_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:CoolBoardLed}
{\xe \v CoolBoardLed\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardLed::write (int  {\i R}, int  {\i G}, int  {\i B})}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardLed::write(Red,Green,Blue): This method is provided to set the Color of the Led \par
}{
Definition at line 271 of file CoolBoardLed.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   272 \{\par
  273 \par
  274 #if DEBUG == 1\par
  275 \par
  276     Serial.println( F("Entering CoolBoardLed.write()") );\par
  277     Serial.println();\par
  278     Serial.print( F("R : ") );\par
  279     Serial.println(R);\par
  280     Serial.print( F("G : ") );\par
  281     Serial.println(G);\par
  282     Serial.print( F("B : ") );\par
  283     Serial.println(B);\par
  284     Serial.println();   \par
  285 \par
  286 #endif\par
  287 \par
  288     if(this->ledActive == 1 )\par
  289     \{\par
  290         neoPixelLed->SetPixelColor(0, RgbColor(R, G, B));\par
  291         neoPixelLed->Show();\par
  292     \}\par
  293 \par
  294 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc0/class_cool_board_led_a30fadd4cbec17ceea428bf7a32207e87_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ledActive\:CoolBoardLed}
{\xe \v CoolBoardLed\:ledActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardLed::ledActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file CoolBoardLed.h.}\par
}
{\xe \v neoPixelLed\:CoolBoardLed}
{\xe \v CoolBoardLed\:neoPixelLed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NeoPixelBus<NeoGrbFeature, Neo800KbpsMethod>* CoolBoardLed::neoPixelLed = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolBoardLed.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardLed.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardSensors Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardSensors}
{\xe \v CoolBoardSensors}
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors. }}\par
{
{\f2 #include <CoolBoardSensors.h>}}\par
Collaboration diagram for CoolBoardSensors:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/db9/class_cool_board_sensors__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b airActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b lightActive}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolBoardSensors} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b allActive} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEnvSensorSettings} (uint8_t commInterface={\b I2C_MODE}, uint8_t I2CAddress=0x76, uint8_t runMode=3, uint8_t tStandby=0, uint8_t filter=0, uint8_t tempOverSample=1, uint8_t pressOverSample=1, uint8_t humidOverSample=1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readVBat} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readMoisture} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolSI114X} {\b lightSensor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BME280} {\b envSensor}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::lightActive} {\b lightDataActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::airActive} {\b airDataActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b EnMoisture} = 13\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b AnMplex} = 12\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vbatActive} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b soilMoistureActive} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors. \par
}{
Definition at line 45 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoolBoardSensors\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:CoolBoardSensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolBoardSensors::CoolBoardSensors ()}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::CoolBoardSensors()}: This Constructor is provided to init the different used pins \par
}{
Definition at line 47 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    48 \{\par
   49 \par
   50 #if DEBUG == 1\par
   51 \par
   52     Serial.println( F("Entering CoolBoardSensors Constructor") );\par
   53     Serial.println();\par
   54 \par
   55 #endif\par
   56     \par
   57     pinMode(AnMplex, OUTPUT);                //Declare Analog Multiplexer OUTPUT\par
   58     pinMode(EnMoisture, OUTPUT);             //Declare Moisture enable Pin\par
   59     digitalWrite(EnMoisture, HIGH);          //Prevent Wearing on the soil moisture fork\par
   60 \par
   61 \par
   62 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v allActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:allActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::allActive ()}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::allActive()}: This method is provided to allow activation of all the sensor board sensors without passing by the configuration file/method \par
}{
Definition at line 71 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    72 \{\par
   73 \par
   74 #if DEBUG == 1 \par
   75 \par
   76     Serial.println( F("Entering CoolBoardSensors.allActive()") );\par
   77     Serial.println();\par
   78 \par
   79 #endif\par
   80     \par
   81     this->lightDataActive.visible=1;\par
   82     this->lightDataActive.ir=1;\par
   83     this->lightDataActive.uv=1; \par
   84 \par
   85     this->airDataActive.temperature=1;\par
   86     this->airDataActive.humidity=1;\par
   87     this->airDataActive.pressure=1;\par
   88 \par
   89 \par
   90     this->vbatActive=1;\par
   91 \par
   92     this->soilMoistureActive=1;\par
   93     \par
   94 \par
   95 \par
   96 \}\par
}
}
{\xe \v begin\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::begin ()}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::begin()}: This method is provided to start the sensors that are on the sensor board \par
}{
Definition at line 104 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   105 \{  \par
  106 \par
  107 #if DEBUG == 1 \par
  108      \par
  109     Serial.println( F("Entering CoolBoardSensors.begin()") );\par
  110     Serial.println();\par
  111 \par
  112 #endif\par
  113 \par
  114     while (!lightSensor.Begin()) \par
  115     \{\par
  116     \par
  117     #if DEBUG == 1\par
  118 \par
  119         Serial.println( F("Si1145 is not ready!  1 second") );\par
  120 \par
  121     #endif\par
  122 \par
  123         delay(1000);\par
  124     \}\par
  125      \par
  126     this->setEnvSensorSettings();\par
  127     delay(10);  //Make sure sensor had enough time to turn on. BME280 requires 2ms to start up.\par
  128     this->envSensor.begin();\par
  129     delay(10);  //Make sure sensor had enough time to turn on. BME280 requires 2ms to start up.\par
  130 \par
  131 #if DEBUG == 1 \par
  132     \par
  133     Serial.print( F("BME280 begin answer is :") );\par
  134     Serial.println(envSensor.begin(), HEX);\par
  135     Serial.println();\par
  136 \par
  137 #endif\par
  138 \par
  139 #if DEBUG == 0\par
  140 \par
  141     Serial.println( F("Onboard Sensors : OK"));\par
  142     Serial.println();\par
  143 \par
  144 #endif\par
  145 \par
  146 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a97095823ef7c8f5290812f1405b966b3_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a97095823ef7c8f5290812f1405b966b3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::config ()}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::config()}: This method is provided to configure the sensor board : -activate 1 -deactivate 0\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if configuration is successful, false otherwise \par
}}{
Definition at line 270 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271 \{\par
  272 \par
  273 #if DEBUG == 1\par
  274 \par
  275     Serial.println( F("Entering CoolBoardSensors.config()") );\par
  276     Serial.println();\par
  277 \par
  278 #endif\par
  279 \par
  280 #if DEBUG == 0\par
  281 \par
  282     Serial.println( F("Reading Sensor Configuration..."));\par
  283 \par
  284 #endif\par
  285     //read config file\par
  286     //update data\par
  287     File coolBoardSensorsConfig = SPIFFS.open("/coolBoardSensorsConfig.json", "r");\par
  288 \par
  289     if (!coolBoardSensorsConfig) \par
  290     \{\par
  291     \par
  292         Serial.println( F("failed to read /coolBoardSensorsConfig.json") );\par
  293         Serial.println();\par
  294 \par
  295         return(false);\par
  296     \}\par
  297     else\par
  298     \{\par
  299         size_t size = coolBoardSensorsConfig.size();\par
  300         // Allocate a buffer to store contents of the file.\par
  301         std::unique_ptr<char[]> buf(new char[size]);\par
  302 \par
  303         coolBoardSensorsConfig.readBytes(buf.get(), size);\par
  304         DynamicJsonBuffer jsonBuffer;\par
  305         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  306         if (!json.success()) \par
  307         \{\par
  308 \par
  309             Serial.println( F("failed to parse coolBoardSensorsConfig json") );\par
  310             Serial.println();\par
  311     \par
  312             return(false);\par
  313         \} \par
  314         else\par
  315         \{\par
  316 \par
  317         #if DEBUG == 1\par
  318 \par
  319             Serial.println( F("Configuration Json is :") );\par
  320             json.printTo(Serial);\par
  321             Serial.println();\par
  322 \par
  323             Serial.print(F("jsonBuffer size: "));\par
  324             Serial.println(jsonBuffer.size());\par
  325             Serial.println();\par
  326         \par
  327         #endif\par
  328             \par
  329             if(json["BME280"]["temperature"].success() )\par
  330             \{           \par
  331                 this->airDataActive.temperature=json["BME280"]["temperature"];\par
  332             \}\par
  333             else\par
  334             \{\par
  335                 this->airDataActive.temperature=this->airDataActive.temperature;            \par
  336             \}\par
  337             json["BME280"]["temperature"]=this->airDataActive.temperature;\par
  338             \par
  339             \par
  340             if(json["BME280"]["humidity"].success() )\par
  341             \{           \par
  342             \par
  343                 this->airDataActive.humidity=json["BME280"]["humidity"];\par
  344             \}\par
  345             else\par
  346             \{\par
  347                 this->airDataActive.humidity=this->airDataActive.humidity;\par
  348             \}\par
  349             json["BME280"]["humidity"]=this->airDataActive.humidity;\par
  350             \par
  351             \par
  352             if(json["BME280"]["pressure"].success() )\par
  353             \{\par
  354                 this->airDataActive.pressure=json["BME280"]["pressure"];\par
  355             \}\par
  356             else\par
  357             \{\par
  358                 this->airDataActive.pressure=this->airDataActive.pressure;\par
  359             \}\par
  360             json["BME280"]["pressure"]=this->airDataActive.pressure;\par
  361 \par
  362             \par
  363             if(json["SI114X"]["visible"].success() )\par
  364             \{\par
  365                 this->lightDataActive.visible=json["SI114X"]["visible"];\par
  366             \}\par
  367             else\par
  368             \{\par
  369                 this->lightDataActive.visible=this->lightDataActive.visible;\par
  370             \}\par
  371             json["SI114X"]["visible"]=this->lightDataActive.visible;\par
  372             \par
  373             \par
  374             if(json["SI114X"]["ir"].success() )\par
  375             \{           \par
  376                 this->lightDataActive.ir=json["SI114X"]["ir"];\par
  377             \}\par
  378             else\par
  379             \{\par
  380                 this->lightDataActive.ir=this->lightDataActive.ir;\par
  381             \}\par
  382             json["SI114X"]["ir"]=this->lightDataActive.ir;\par
  383 \par
  384             \par
  385             if(json["SI114X"]["uv"].success() )         \par
  386             \{           \par
  387                 this->lightDataActive.uv=json["SI114X"]["uv"];\par
  388             \}\par
  389             else\par
  390             \{\par
  391                 this->lightDataActive.uv=this->lightDataActive.uv;\par
  392             \}\par
  393             json["SI114X"]["uv"]=this->lightDataActive.uv;\par
  394 \par
  395 \par
  396             if(json["vbat"].success() )\par
  397             \{\par
  398                 this->vbatActive=json["vbat"];\par
  399             \}\par
  400             else\par
  401             \{\par
  402                 this->vbatActive=this->vbatActive;\par
  403             \}\par
  404             json["vbat"]=this->vbatActive;\par
  405 \par
  406             \par
  407             if(json["soilMoisture"].success() )\par
  408             \{           \par
  409                 this->soilMoistureActive= json["soilMoisture"];\par
  410             \}\par
  411             else\par
  412             \{\par
  413                 this->soilMoistureActive=this->soilMoistureActive;\par
  414             \}\par
  415             json["soilMoisture"]=this->soilMoistureActive;\par
  416 \par
  417             coolBoardSensorsConfig.close();         \par
  418             coolBoardSensorsConfig = SPIFFS.open("/coolBoardSensorsConfig.json", "w");          \par
  419             if(!coolBoardSensorsConfig)\par
  420             \{\par
  421 \par
  422                 Serial.println( F("failed to write to /coolBoardSensorsConfig.json") );\par
  423                 Serial.println();\par
  424 \par
  425                 return(false);          \par
  426             \}  \par
  427 \par
  428             json.printTo(coolBoardSensorsConfig);\par
  429             coolBoardSensorsConfig.close();         \par
  430             \par
  431         #if DEBUG == 1\par
  432 \par
  433             Serial.println( F("Saved Configuration Json is : ") );\par
  434             json.printTo(Serial);\par
  435             Serial.println();\par
  436         \par
  437         #endif\par
  438 \par
  439         #if DEBUG == 0\par
  440             Serial.println( F("Configuration loaded : OK"));\par
  441         #endif\par
  442 \par
  443             return(true); \par
  444         \}\par
  445     \}   \par
  446 \par
  447 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a9a218895c5423375c33c08f2c56fb23a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v end\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::end ()}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::end()}: This method is provided to end the sensors on the sensor board \par
}{
Definition at line 153 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   154 \{\par
  155 \par
  156 #if DEBUG == 1  \par
  157     Serial.println( F("Entering CoolBoardSensors.end()") );\par
  158     Serial.println();\par
  159 \par
  160 #endif\par
  161 \par
  162     lightSensor.DeInit();\par
  163 \par
  164 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a4902b69f6e628bd6557193758fdd2bae_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::printConf ()}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 455 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   456 \{\par
  457 \par
  458 #if DEBUG == 1\par
  459 \par
  460     Serial.println( F("Entering CoolBoardSensors.printConf()") );\par
  461     Serial.println();\par
  462 \par
  463 #endif\par
  464 \par
  465     Serial.println( F("Sensors Configuration : "));\par
  466     \par
  467     Serial.print( F("airDataActive.temperature : "));\par
  468     Serial.println(this->airDataActive.temperature);\par
  469 \par
  470     Serial.print( F("airDataActive.humidity : "));\par
  471     Serial.println(airDataActive.humidity);\par
  472 \par
  473     Serial.print( F("airDataActive.pressure : "));\par
  474     Serial.println(airDataActive.pressure);\par
  475 \par
  476     Serial.print( F("lightDataActive.visible : "));\par
  477     Serial.println(lightDataActive.visible);\par
  478 \par
  479     Serial.print( F("lightDataActive.ir : "));\par
  480     Serial.println(lightDataActive.ir);\par
  481 \par
  482     Serial.print( F("lightDataActive.uv : "));\par
  483     Serial.println(lightDataActive.uv);\par
  484     \par
  485     Serial.print( F("vbatActive : "));\par
  486     Serial.println(vbatActive);\par
  487 \par
  488     Serial.print( F("soilMoitureActive : "));\par
  489     Serial.println(soilMoistureActive);\par
  490 \par
  491     Serial.println();\par
  492 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_af6fd79505815b204c178617ecf54c873_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoardSensors::read ()}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::read()}: This method is provided to return the data read by the sensor board\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a json string containing the sensors data \par
}}{
Definition at line 174 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   175 \{\par
  176 \par
  177 #if DEBUG == 1 \par
  178     \par
  179     Serial.println( F("Entering CoolBoardSensors.read()") );\par
  180     Serial.println();\par
  181 \par
  182 #endif\par
  183 \par
  184 #if DEBUG == 0\par
  185 \par
  186     Serial.println( F("Reading Sensors..."));\par
  187 \par
  188 #endif\par
  189 \par
  190     String data;\par
  191     DynamicJsonBuffer  jsonBuffer ;\par
  192     JsonObject& root = jsonBuffer.createObject();\par
  193 \par
  194     delay(100);\par
  195     //light data\par
  196     if(lightDataActive.visible)\par
  197     \{\par
  198         root["visibleLight"] =lightSensor.ReadVisible() ;\par
  199     \}\par
  200     \par
  201     if(lightDataActive.ir)\par
  202     \{\par
  203         root["infraRed"] = lightSensor.ReadIR();\par
  204     \}\par
  205 \par
  206     if(lightDataActive.uv)\par
  207     \{\par
  208         float tempUV = (float)lightSensor.ReadUV()/100 ;\par
  209         root["ultraViolet"] = tempUV;\par
  210     \}\par
  211     \par
  212     //BME280 data\par
  213     if(airDataActive.pressure)  \par
  214     \{\par
  215         root["Pressure"] =envSensor.readFloatPressure();\par
  216     \}\par
  217     \par
  218         \par
  219     if(airDataActive.humidity)  \par
  220     \{   \par
  221         root["Humidity"] =envSensor.readFloatHumidity() ;\par
  222     \}   \par
  223     \par
  224     if(airDataActive.temperature)\par
  225     \{\par
  226         root["Temperature"]=envSensor.readTempC();\par
  227     \}\par
  228     \par
  229     //Vbat\par
  230     if(vbatActive)  \par
  231     \{   \par
  232         root["Vbat"]=this->readVBat();\par
  233     \}\par
  234     \par
  235     //earth Moisture\par
  236     if(soilMoistureActive)\par
  237     \{   \par
  238         root["soilMoisture"]=this->readMoisture();\par
  239     \}\par
  240     \par
  241     \par
  242     root.printTo(data);\par
  243 \par
  244     Serial.println( F("CoolBoardSensors data is :") );\par
  245     root.printTo(Serial);\par
  246     Serial.println();\par
  247     Serial.println();\par
  248 \par
  249 #if DEBUG == 1\par
  250     Serial.print(F("jsonBuffer size: "));\par
  251     Serial.println(jsonBuffer.size());\par
  252     Serial.println();\par
  253 \par
  254 #endif\par
  255 \par
  256     return(data);   \par
  257     \par
  258 \par
  259 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a91badb2539d91fda8679f2a597874c48_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a91badb2539d91fda8679f2a597874c48_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readMoisture\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:readMoisture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CoolBoardSensors::readMoisture ()}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::readMoisture()}: This method is provided to red the Soil Moisture\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a float represnting the soil moisture \par
}}{
Definition at line 578 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   579 \{\par
  580 \par
  581 #if DEBUG == 1\par
  582     \par
  583     Serial.println( F("Entering CoolBoardSensors.readMoisture()") );\par
  584     Serial.println();\par
  585     \par
  586 #endif\par
  587 \par
  588     digitalWrite(EnMoisture, LOW);                 //enable moisture sensor and waith a bit\par
  589 \par
  590     digitalWrite(AnMplex, HIGH);            //enable analog Switch to get the moisture\par
  591 \par
  592     delay(2000);\par
  593 \par
  594     int val = analogRead(A0);                       //read the value form the moisture sensor\par
  595 \par
  596     if (val >= 891)\{\par
  597         val = 890;\par
  598     \}\par
  599     float result = (float)map(val, 0, 890, 0, 100); \par
  600 \par
  601     digitalWrite(EnMoisture, HIGH);                  //disable moisture sensor for minimum wear\par
  602     \par
  603 #if DEBUG == 1 \par
  604 \par
  605     Serial.println( F("RAW Moisture  is : "));\par
  606     Serial.println(val);\par
  607     Serial.println( F("Soil Moisture is : ") );\par
  608     Serial.println(result);\par
  609     Serial.println();\par
  610 \par
  611 #endif \par
  612 \par
  613     return (result);\par
  614 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a8761bff50373c485f4465c8db47d0633_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readVBat\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:readVBat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CoolBoardSensors::readVBat ()}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors::readVBat()}: This method is provided to read the Battery Voltage.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a float representing the battery voltage \par
}}{
Definition at line 541 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   542 \{\par
  543 \par
  544 #if DEBUG == 1\par
  545 \par
  546     Serial.println( F("Entering CoolBoardSensors.readVBat()") );\par
  547     Serial.println();\par
  548 \par
  549 #endif\par
  550 \par
  551     digitalWrite(this->AnMplex, LOW);                            //Enable Analog Switch to get the batterie tension\par
  552     \par
  553     delay(200);\par
  554     \par
  555     int raw = analogRead(A0);                                    //read in batterie tension\par
  556     \par
  557     float val = 6.04 / 1024 * raw;                               //convert it apprimatly right tension in volts\par
  558     \par
  559 #if DEBUG == 1\par
  560 \par
  561     Serial.println( F("Vbat is : ") );\par
  562     Serial.println(val);\par
  563     Serial.println();\par
  564 \par
  565 #endif\par
  566 \par
  567     return (val);   \par
  568 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a6944b6ea7bce8e2fce1b434acfd9d5f3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setEnvSensorSettings\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:setEnvSensorSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolBoardSensors::setEnvSensorSettings (uint8_t  {\i commInterface} = {\f2 {\b I2C_MODE}}, uint8_t  {\i I2CAddress} = {\f2 0x76}, uint8_t  {\i runMode} = {\f2 3}, uint8_t  {\i tStandby} = {\f2 0}, uint8_t  {\i filter} = {\f2 0}, uint8_t  {\i tempOverSample} = {\f2 1}, uint8_t  {\i pressOverSample} = {\f2 1}, uint8_t  {\i humidOverSample} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolBoardSensors::setEnvSensorSetting(): This method is provided to set the enviornment sensor settings , if argument is ommitted , default value will be assigned \par
}{
Definition at line 501 of file CoolBoardSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   506 \{\par
  507 \par
  508 #if DEBUG == 1\par
  509     \par
  510     Serial.println( F("Entering CoolBoardSensors.setEnvSensorSettings()") );\par
  511     Serial.println();\par
  512 \par
  513 #endif\par
  514   \par
  515     this->envSensor.settings.commInterface = commInterface;      \par
  516 \par
  517     this->envSensor.settings.I2CAddress = I2CAddress;\par
  518 \par
  519     this->envSensor.settings.runMode = runMode; \par
  520 \par
  521     this->envSensor.settings.tStandby = tStandby; \par
  522 \par
  523     this->envSensor.settings.filter = filter; \par
  524 \par
  525     this->envSensor.settings.tempOverSample = tempOverSample;\par
  526 \par
  527     this->envSensor.settings.pressOverSample = pressOverSample;\par
  528 \par
  529     this->envSensor.settings.humidOverSample = humidOverSample;\par
  530 \par
  531 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d46/class_cool_board_sensors_a406307ffd70272282d91479c7ed8d66f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v airDataActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:airDataActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoolBoardSensors::airActive} CoolBoardSensors::airDataActive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AnMplex\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:AnMplex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoardSensors::AnMplex = 12{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file CoolBoardSensors.h.}\par
}
{\xe \v EnMoisture\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:EnMoisture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int CoolBoardSensors::EnMoisture = 13{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolBoardSensors.h.}\par
}
{\xe \v envSensor\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:envSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BME280} CoolBoardSensors::envSensor}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolBoardSensors.h.}\par
}
{\xe \v lightDataActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:lightDataActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoolBoardSensors::lightActive} CoolBoardSensors::lightDataActive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lightSensor\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:lightSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolSI114X} CoolBoardSensors::lightSensor}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file CoolBoardSensors.h.}\par
}
{\xe \v soilMoistureActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:soilMoistureActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::soilMoistureActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file CoolBoardSensors.h.}\par
}
{\xe \v vbatActive\:CoolBoardSensors}
{\xe \v CoolBoardSensors\:vbatActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::vbatActive =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolFileSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolFileSystem}
{\xe \v CoolFileSystem}
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system. }}\par
{
{\f2 #include <CoolFileSystem.h>}}\par
Collaboration diagram for CoolFileSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d8f/class_cool_file_system__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b updateConfigFiles} (String answer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fileUpdate} (String update, const char *path)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveSensorData} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveSensorDataCSV} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isDataSaved} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String * {\b getSensorSavedData} (int &size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b incrementsavedData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getsavedData} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b savedData} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b linesToSkip} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system. \par
}{
Definition at line 44 of file CoolFileSystem.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolFileSystem}
{\xe \v CoolFileSystem\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::begin ()}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::begin()}: This method is provided to start the SPIFFS object.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if SPIFFS was initialized correctly, false otherwise \par
}}{
Definition at line 48 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49 \{\par
   50     bool sResult=SPIFFS.begin();\par
   51     \par
   52 \par
   53 #if DEBUG == 1\par
   54 \par
   55     Serial.println( F("Entering CoolFileSystem.begin()") );\par
   56     Serial.println();   \par
   57     Serial.print( F("SPIFFS success ? ") );\par
   58     Serial.println(sResult);\par
   59     Serial.println(  );\par
   60 \par
   61 #endif\par
   62     //get the data from the files\par
   63     this->getsavedData();\par
   64 \par
   65     return( sResult  );                                   //Initialize Filesystem\par
   66 \par
   67 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a6ba6f666ed4c530174f8569d2c636748_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a6ba6f666ed4c530174f8569d2c636748_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fileUpdate\:CoolFileSystem}
{\xe \v CoolFileSystem\:fileUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::fileUpdate (String  {\i update}, const char *  {\i path})}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::fileUpdate( update msg, file path): This method is provided to ensure the correct update for each configuration file in the File system\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful , false otherwise \par
}}{
Definition at line 1001 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1002 \{\par
 1003 \par
 1004 #if DEBUG == 1\par
 1005 \par
 1006     Serial.println( F("Entering CoolFileSystem.fileUpdate()") );\par
 1007     Serial.println();\par
 1008     \par
 1009     Serial.println(F("update msg is :"));\par
 1010     Serial.println(update);\par
 1011     \par
 1012     Serial.println(F("file path is : "));\par
 1013     Serial.println(path);   \par
 1014 \par
 1015 #endif\par
 1016     //transfer update String to json\par
 1017     DynamicJsonBuffer updateBuffer;\par
 1018     JsonObject& updateJson = updateBuffer.parseObject(update.c_str() );\par
 1019     \par
 1020     if(updateJson.success())\par
 1021     \{\par
 1022     \par
 1023     #if DEBUG ==1\par
 1024         \par
 1025         Serial.println(F("root parsing success :"));\par
 1026         updateJson.printTo(Serial);\par
 1027     \par
 1028     #endif\par
 1029 \par
 1030     \}\par
 1031     else\par
 1032     \{\par
 1033     \par
 1034     #if DEBUG == 1 \par
 1035     \par
 1036         Serial.println(F("root parsing failure "));\par
 1037     \par
 1038     #endif\par
 1039         \par
 1040         return(false);  \par
 1041 \par
 1042     \}\par
 1043     \par
 1044     //open file in read mode\par
 1045     File configFile = SPIFFS.open( path , "r");\par
 1046     \par
 1047     if(!configFile)\par
 1048     \{   \par
 1049     #if DEBUG == 1\par
 1050         \par
 1051         Serial.print( F("failed to read ") );\par
 1052         Serial.println(path);\par
 1053 \par
 1054     #endif\par
 1055         return(false);\par
 1056     \}\par
 1057 \par
 1058     //copy file to a json\par
 1059     size_t size = configFile.size();\par
 1060 \par
 1061     // Allocate a buffer to store contents of the file.\par
 1062     std::unique_ptr < char[] > buf(new char[size]);\par
 1063 \par
 1064     configFile.readBytes(buf.get(), size);\par
 1065 \par
 1066     DynamicJsonBuffer fileBuffer;\par
 1067 \par
 1068     JsonObject & fileJson = fileBuffer.parseObject(buf.get());\par
 1069 \par
 1070     if (!fileJson.success())\par
 1071     \{\par
 1072 \par
 1073     #if DEBUG == 1\par
 1074 \par
 1075         Serial.println( F("failed to parse json") );\par
 1076 \par
 1077     #endif\par
 1078 \par
 1079         return(false);\par
 1080     \}\par
 1081     \par
 1082     //modify root to contain all the json keys: updated ones and non updated ones\par
 1083     for (auto kv : fileJson) \par
 1084     \{\par
 1085         if( updateJson[kv.key].success() )\par
 1086         \{\par
 1087             fileJson[kv.key]=updateJson[kv.key];            \par
 1088         \}\par
 1089         else\par
 1090         \{\par
 1091             fileJson[kv.key]=fileJson[kv.key];\par
 1092         \}\par
 1093 \par
 1094                 \par
 1095     \}\par
 1096 \par
 1097 #if DEBUG == 1\par
 1098 \par
 1099     Serial.println(F("fileJson is now : "));\par
 1100     fileJson.printTo(Serial);\par
 1101 \par
 1102 #endif\par
 1103 \par
 1104     //close the file\par
 1105     configFile.close();\par
 1106 \par
 1107     //open file in w mode\par
 1108     configFile = SPIFFS.open( path , "w");\par
 1109     \par
 1110     if(!configFile)\par
 1111     \{   \par
 1112     #if DEBUG == 1\par
 1113         \par
 1114         Serial.print( F("failed to open ") );\par
 1115         Serial.println(path);\par
 1116 \par
 1117     #endif\par
 1118         return(false);\par
 1119     \}\par
 1120     //print json to file    \par
 1121     \par
 1122     fileJson.printTo(configFile);\par
 1123     \par
 1124     //close file\par
 1125     configFile.close();\par
 1126 \par
 1127 \par
 1128 #if DEBUG == 1\par
 1129 \par
 1130     Serial.println( F("config is") );\par
 1131     fileJson.printTo(Serial);\par
 1132     Serial.println();\par
 1133 \par
 1134 #endif\par
 1135     \par
 1136     return(true);\par
 1137     \par
 1138 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a13f2958f5b87757c31fc53797a30d23a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getsavedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:getsavedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolFileSystem::getsavedData ()}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::getsavedData()}: This method is provided to get the savedData flag from the file system \par
}{
Definition at line 1200 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1201 \{\par
 1202 \par
 1203 \par
 1204 #if DEBUG == 1\par
 1205     \par
 1206     Serial.println(F("Entering CoolFileSystem.getsavedData()"));    \par
 1207     \par
 1208 #endif\par
 1209     //open file\par
 1210     File file=SPIFFS.open("/savedDataFlag.txt","r");    \par
 1211     //read file\par
 1212     if( !file)  \par
 1213     \{\par
 1214         Serial.println( F("failed to read savedDataFlag.txt") );\par
 1215         \par
 1216     \}\par
 1217     else\par
 1218     \{       \par
 1219         //read from file    \par
 1220         String temp=file.readStringUntil(' ');\par
 1221         \par
 1222         this->savedData=temp.toInt();\par
 1223 \par
 1224         \par
 1225         temp=file.readStringUntil('\\n');\par
 1226         this-> linesToSkip=temp.toInt();;   \par
 1227         \par
 1228         file.close();   \par
 1229     \}\par
 1230     \par
 1231 #if DEBUG == 1\par
 1232 \par
 1233     Serial.print(F("number of lines to read :"));\par
 1234     Serial.println(this->savedData);\par
 1235     \par
 1236     Serial.print(F("number of lines to skip :"));\par
 1237     Serial.println(this->linesToSkip);\par
 1238 \par
 1239 #endif\par
 1240     \par
 1241 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a70701d05e811604af1b531f4f6dc69ed_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getSensorSavedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:getSensorSavedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String * CoolFileSystem::getSensorSavedData (int &  {\i lines})}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::getSensorData(int &lines): This method is provided to return the sensor data saved in the File System 10 lines at a time\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid String array containing 50 first lines from the file modifies tge lines argument to reflect the number of lines left \par
}}{
Definition at line 840 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   841 \{\par
  842     int maxString=50;\par
  843     String *sensorsDataArray=new String[maxString];\par
  844     lines=0;\par
  845 \par
  846 #if DEBUG == 1 \par
  847 \par
  848     Serial.println( F("Entering CoolFileSystem.getSensorSavedData()") );\par
  849     Serial.println();\par
  850 \par
  851 #endif\par
  852 \par
  853     //open sensors data file\par
  854     File sensorsData=SPIFFS.open("/sensorsData.json","r");\par
  855     \par
  856     if (!sensorsData)\par
  857     \{\par
  858 \par
  859     #if DEBUG == 1 \par
  860 \par
  861         Serial.println( F("Failed to read /sensorsData.json") );\par
  862 \par
  863     #endif\par
  864          \par
  865         sensorsDataArray[0]="Failed to read /sensorsData.json";\par
  866         lines++;\par
  867 \par
  868         //result=sensorsDataArray;\par
  869         return(sensorsDataArray);\par
  870 \par
  871     \}\par
  872 \par
  873     else\par
  874     \{\par
  875         //read the file line by line and put it in the String array(aka String*)        \par
  876 \par
  877         //while loop until EOF is reached\par
  878         String temp;\par
  879         while(sensorsData.available())\par
  880         \{\par
  881             yield();\par
  882             \par
  883             temp=sensorsData.readStringUntil('\\r');\par
  884 \par
  885             if(linesToSkip>0)\par
  886             \{\par
  887 \par
  888                 linesToSkip--;\par
  889         \par
  890             \}\par
  891             else\par
  892             \{\par
  893 \par
  894             #if DEBUG == 1\par
  895 \par
  896                 Serial.println(F("temp String : "));\par
  897                 Serial.println(temp);\par
  898                 Serial.println();\par
  899             \par
  900             #endif\par
  901             \par
  902                 sensorsDataArray[lines]=temp;\par
  903                 sensorsData.read();\par
  904             \par
  905             \par
  906         \par
  907             #if DEBUG== 1\par
  908      \par
  909                 Serial.print(F("read String N\'B0"));\par
  910                 Serial.print(lines);\par
  911                 Serial.println(F(" is : "));\par
  912                 Serial.println( sensorsDataArray[lines] );\par
  913                 Serial.println();\par
  914                 Serial.println(F("next char is : "));\par
  915                 Serial.println((char)sensorsData.peek());\par
  916                 Serial.println();           \par
  917             \par
  918             #endif\par
  919                 lines++;\par
  920             \par
  921                 //maximum size is maxString(index : 0..maxString-1)\par
  922                 if(lines>=maxString)\par
  923                 \{\par
  924                     break;\par
  925                 \}\par
  926             \par
  927                 yield();\par
  928             \par
  929             \}\par
  930 \par
  931         \}\par
  932         \par
  933                     \par
  934         //close the file\par
  935         sensorsData.close();\par
  936 \par
  937         //position the saved data flag to the number of unread lines\par
  938         this->savedData=savedData-lines;\par
  939         \par
  940         //position the number of lines to skip to the number of read lines  \par
  941         this->linesToSkip=lines;\par
  942 \par
  943         //delete data in the file only if savedData<=0\par
  944         if(this->savedData<=0)\par
  945         \{\par
  946             File sensorsData=SPIFFS.open("/sensorsData.json","w");\par
  947             File sensorsDataCSV=SPIFFS.open("/sensorsData.csv","w");\par
  948             if( (!sensorsData)||(!sensorsDataCSV) ) \par
  949             \{\par
  950             #if DEBUG == 1\par
  951     \par
  952                 Serial.println( F("failed to delete data in the file") );\par
  953     \par
  954             #endif\par
  955                 lines++;\par
  956                 sensorsDataArray[lines]="failed to delete data in the file";\par
  957 \par
  958                 return(sensorsDataArray);\par
  959 \par
  960             \}\par
  961 \par
  962             sensorsData.close();\par
  963             sensorsDataCSV.close();\par
  964             \par
  965             this->linesToSkip=0;\par
  966         \par
  967         \}\par
  968 \par
  969         //save the changes to linesToSkip and savedData in the file system\par
  970         this->incrementsavedData();\par
  971 \par
  972         //return the string\par
  973         #if DEBUG == 1\par
  974         \par
  975             for(int i=0;i<lines;i++)\par
  976             \{\par
  977                 Serial.print(F("String N\'B0"));\par
  978                 Serial.println(i);\par
  979                 Serial.println(sensorsDataArray[i]);\par
  980                 Serial.println();           \par
  981             \}\par
  982     \par
  983         #endif\par
  984         return(sensorsDataArray);\par
  985         \par
  986         \par
  987         \par
  988     \}\par
  989 \par
  990 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a3223ffff4266a6300988fab956d6b4b2_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_a3223ffff4266a6300988fab956d6b4b2_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v incrementsavedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:incrementsavedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::incrementsavedData ()}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::incrementsavedData()}: This method is provided to increment the savedData flag\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful , false otherwise \par
}}{
Definition at line 1150 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1151 \{\par
 1152 \par
 1153 \par
 1154 #if DEBUG == 1\par
 1155     \par
 1156     Serial.println(F("Entering CoolFileSystem.incrementsavedData()"));  \par
 1157     \par
 1158 #endif\par
 1159     //open file\par
 1160     File file=SPIFFS.open("/savedDataFlag.txt","w");    \par
 1161     //read file\par
 1162     if( !file)  \par
 1163     \{\par
 1164         Serial.println( F("failed to open savedDataFlag.txt") );\par
 1165         \par
 1166         return(false);      \par
 1167     \}\par
 1168     else\par
 1169     \{       \par
 1170         //write to file \par
 1171         file.print(this->savedData);\par
 1172         \par
 1173         file.print(" ");\par
 1174         \par
 1175         file.println(this->linesToSkip);\par
 1176     \par
 1177         file.close();\par
 1178 \par
 1179     #if DEBUG == 1\par
 1180 \par
 1181         Serial.print(F("number of lines to read :"));\par
 1182         Serial.println(this->savedData);\par
 1183     \par
 1184         Serial.print(F("number of lines to skip :"));\par
 1185         Serial.println(this->linesToSkip);\par
 1186 \par
 1187     #endif\par
 1188         \par
 1189         return(true);\par
 1190     \}\par
 1191     \par
 1192 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_aae045125288f255f3e258073dcada2a6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isDataSaved\:CoolFileSystem}
{\xe \v CoolFileSystem\:isDataSaved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolFileSystem::isDataSaved ()}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem::isDataSaved()}: This method is provided to report wether there is sensor data saved in the File System.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if there is data saved, false otherwise \par
}}{
Definition at line 780 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   781 \{\par
  782 \par
  783 #if DEBUG == 1 \par
  784 \par
  785     Serial.println( F("Entering CoolFileSystem.isDataSaved()") );\par
  786     Serial.println();\par
  787 \par
  788     FSInfo fs_info;\par
  789 \par
  790     if(SPIFFS.info(fs_info)==true)\par
  791     \{\par
  792         Serial.print(F("used bytes/total bytes : "));   \par
  793         Serial.print(fs_info.usedBytes);\par
  794         Serial.print(F("/"));\par
  795         Serial.print(fs_info.totalBytes);\par
  796         Serial.println();\par
  797 \par
  798     \}\par
  799 \par
  800     File sensorsData=SPIFFS.open("/sensorsData.json","r");\par
  801     File sensorsDataCSV=SPIFFS.open("/sensorsData.csv","r");\par
  802     \par
  803     if( (!sensorsData)||(!sensorsDataCSV) ) \par
  804     \{\par
  805         Serial.println( F("failed to open files") );        \par
  806     \}\par
  807     else\par
  808     \{       \par
  809             Serial.print(F("sensors Data file size in bytes : "));\par
  810             Serial.println(sensorsData.size());\par
  811             Serial.println();\par
  812             \par
  813             Serial.print(F("sensors Data CSV file size in bytes : "));              \par
  814             Serial.println(sensorsDataCSV.size());\par
  815             Serial.println();\par
  816     \}\par
  817 \par
  818 \par
  819 \par
  820     Serial.print( F("savedData : ") );\par
  821     Serial.println(this->savedData);\par
  822 \par
  823 #endif\par
  824 \par
  825     return( this->savedData );\par
  826 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_ac86a40e7c3a1842f7342f698d34324f9_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v saveSensorData\:CoolFileSystem}
{\xe \v CoolFileSystem\:saveSensorData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::saveSensorData (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::saveSensorData( data ): This method is provided to save the data on the local memory when there is no internet available\par
increments the saved data flag when successful\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the data was saved, false otherwise \par
}}{
Definition at line 79 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80 \{\par
   81 \par
   82 #if DEBUG == 1\par
   83 \par
   84     Serial.println( F("Entering CoolFileSystem.saveSensorData()") );\par
   85     Serial.println();\par
   86 \par
   87 #endif\par
   88     \par
   89     File sensorsData=SPIFFS.open("/sensorsData.json","a");\par
   90 \par
   91     if(!sensorsData)\par
   92     \{\par
   93     \par
   94     #if DEBUG == 1\par
   95     \par
   96         Serial.println( F("failed to append to /sensorsData.json") );\par
   97         Serial.println();\par
   98     \par
   99     #endif\par
  100         //keep the old data\par
  101         this->savedData=savedData;\par
  102 \par
  103         return (false); \par
  104     \}   \par
  105 \par
  106     DynamicJsonBuffer jsonBuffer;\par
  107     JsonObject& root = jsonBuffer.parseObject(data);\par
  108 \par
  109     if( root.success() )\par
  110     \{\par
  111         root.printTo(sensorsData);\par
  112         sensorsData.println();\par
  113         sensorsData.close();\par
  114 \par
  115 \par
  116     #if DEBUG == 1\par
  117         \par
  118         Serial.print(F("jsonBuffer size: "));\par
  119         Serial.println(jsonBuffer.size());\par
  120         Serial.println();\par
  121 \par
  122         sensorsData=SPIFFS.open("/sensorsData.json","r");\par
  123         \par
  124         if(!sensorsData)\par
  125         \{\par
  126             \par
  127             Serial.println(F("failed to reopen /sensorsData.json"));\par
  128             return(true);\par
  129                         \par
  130         \}\par
  131     \par
  132         Serial.println( F("saved data is : ") );\par
  133         root.printTo(Serial);\par
  134         Serial.println();\par
  135 \par
  136         Serial.println(F("/sensorsData.json") );\par
  137         while (sensorsData.available()) \par
  138         \{\par
  139             Serial.println(sensorsData.readString()) ;\par
  140         \}\par
  141         \par
  142         Serial.println();\par
  143         \par
  144         sensorsData.close();\par
  145     \par
  146     #endif\par
  147 \par
  148         this->saveSensorDataCSV(data);      \par
  149 \par
  150         //new data\par
  151         this->savedData++;\par
  152 \par
  153         this->incrementsavedData();\par
  154         \par
  155         return (true);      \par
  156     \}\par
  157     else\par
  158     \{\par
  159     \par
  160     #if DEBUG == 1\par
  161 \par
  162         Serial.println( F("failed to parse json") );\par
  163     \par
  164     #endif\par
  165         //old data\par
  166         this->savedData=savedData;\par
  167 \par
  168         return(false);\par
  169     \}\par
  170     \par
  171 \par
  172 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_afa3a4feae94871d4d3b6bebb701c2e67_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_afa3a4feae94871d4d3b6bebb701c2e67_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v saveSensorDataCSV\:CoolFileSystem}
{\xe \v CoolFileSystem\:saveSensorDataCSV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::saveSensorDataCSV (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::saveSensorDataCSV( data ): This method is provided to save the data on the local memory in CSV format.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the data was saved, false otherwise \par
}}{
Definition at line 183 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   184 \{\par
  185 #if DEBUG == 1\par
  186 \par
  187     Serial.println( F("Entering CoolFileSystem.saveSensorDataCSV()") );\par
  188     Serial.println();\par
  189 \par
  190 #endif\par
  191     //parsing json\par
  192     DynamicJsonBuffer jsonBuffer;\par
  193     JsonObject& root = jsonBuffer.parseObject(data);\par
  194     String header="",values="";\par
  195     \par
  196     //if json parse success\par
  197     if( root.success() )\par
  198     \{       \par
  199         for (auto kv : root) \par
  200         \{\par
  201             //print the header(json keys ) to header string\par
  202             header+=kv.key;\par
  203             header+=',';\par
  204             \par
  205             //print the values to header string\par
  206             values+=( kv.value.as<char*>() );\par
  207             values+=',';\par
  208         \}\par
  209 \par
  210         header.remove(header.lastIndexOf(','), 1);\par
  211         values.remove(values.lastIndexOf(','), 1);      \par
  212     \par
  213     #if DEBUG == 1\par
  214     \par
  215         Serial.println( F(" data is : ") );\par
  216         root.printTo(Serial);\par
  217         Serial.println();\par
  218         \par
  219         Serial.println(F(" header is :" ) ) ;\par
  220         Serial.println(header);\par
  221         Serial.println(F(" values are : "));\par
  222         Serial.println(values);\par
  223         \par
  224         Serial.print(F("jsonBuffer size: "));\par
  225         Serial.println(jsonBuffer.size());\par
  226         Serial.println();\par
  227 \par
  228     \par
  229     #endif\par
  230     \par
  231     \}\par
  232     //failed to parse json\par
  233     else\par
  234     \{\par
  235     \par
  236     #if DEBUG == 1\par
  237 \par
  238         Serial.println( F("failed to parse json") );\par
  239     \par
  240     #endif\par
  241 \par
  242         return(false);\par
  243     \}\par
  244 \par
  245     //check if file exists\par
  246     File sensorsData=SPIFFS.open("/sensorsData.csv","r");\par
  247     \par
  248     //file doesn't exist\par
  249     if( (!sensorsData) || (sensorsData.size()==0 ) )\par
  250     \{\par
  251     \par
  252     #if DEBUG == 1\par
  253     \par
  254         Serial.println( F("/sensorsData.csv not found") );\par
  255         Serial.println( F("creating /sensorsData.csv") );\par
  256         Serial.println();\par
  257     \par
  258     #endif\par
  259         //create file\par
  260         sensorsData=SPIFFS.open("/sensorsData.csv","w");\par
  261         \par
  262         if(!sensorsData)\par
  263         \{\par
  264 \par
  265         #if DEBUG == 1\par
  266         \par
  267             Serial.println( F("failed to create /sensorsData.csv") );\par
  268             Serial.println();\par
  269         \par
  270         #endif\par
  271         \par
  272             return(false);\par
  273 \par
  274         \}\par
  275         \par
  276         //print the header(json keys ) to the CSV file\par
  277         sensorsData.println(header);\par
  278 \par
  279         //print the values to the CSV file\par
  280         sensorsData.println(values);\par
  281         \par
  282         sensorsData.close();\par
  283     \par
  284     #if DEBUG == 1\par
  285 \par
  286         sensorsData=SPIFFS.open("/sensorsData.csv","r");\par
  287         \par
  288         if(!sensorsData)\par
  289         \{\par
  290             Serial.println(F("failed to reopen /sensorsData.csv "));\par
  291             return(false);      \par
  292         \}\par
  293 \par
  294         Serial.println( F("/sensorsData.csv : ") );\par
  295 \par
  296         while (sensorsData.available()) \par
  297         \{\par
  298             Serial.print(sensorsData.readString()) ;\par
  299         \}\par
  300         Serial.println();\par
  301 \par
  302         //close the file\par
  303         sensorsData.close();\par
  304 \par
  305     #endif\par
  306         \par
  307 \par
  308         \par
  309         return(true);\par
  310         \par
  311     \}\par
  312 \par
  313     //file exist\par
  314     else\par
  315     \{\par
  316 \par
  317     #if DEBUG == 1\par
  318     \par
  319         Serial.println( F("/sensorsData.csv  found") );\par
  320         Serial.println( F("appending to /sensorsData.csv") );\par
  321         Serial.println();\par
  322     \par
  323     #endif\par
  324 \par
  325         //append to file\par
  326         sensorsData=SPIFFS.open("/sensorsData.csv","a");\par
  327         \par
  328         if(!sensorsData)\par
  329         \{\par
  330         \par
  331         #if DEBUG == 1\par
  332             \par
  333             Serial.println( F("failed to open /sensorsData.csv") );\par
  334             Serial.println();\par
  335 \par
  336         #endif\par
  337             \par
  338             return(false);\par
  339         \par
  340         \}\par
  341 \par
  342         //print the values to the CSV file\par
  343         sensorsData.println(values);\par
  344         \par
  345         sensorsData.close();\par
  346 \par
  347     #if DEBUG == 1\par
  348 \par
  349         sensorsData=SPIFFS.open("/sensorsData.csv","r");\par
  350         \par
  351         if(!sensorsData)\par
  352         \{\par
  353             Serial.println(F("failed to reopen /sensorsData.csv "));\par
  354             return(false);      \par
  355         \}\par
  356 \par
  357         \par
  358         Serial.println( F("/sensorsData.csv : ") );\par
  359 \par
  360         while (sensorsData.available()) \par
  361         \{\par
  362             Serial.println(sensorsData.readString()) ;\par
  363         \}\par
  364         \par
  365         Serial.println();\par
  366         \par
  367         sensorsData.close();\par
  368         \par
  369     #endif      \par
  370         \par
  371         return(true);\par
  372     \par
  373     \}   \par
  374 \par
  375 \par
  376 \par
  377 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_ab78704d5d21ce10fc6f1138ab5ab46c8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v updateConfigFiles\:CoolFileSystem}
{\xe \v CoolFileSystem\:updateConfigFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolFileSystem::updateConfigFiles (String  {\i answer})}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolFileSystem::updateConfigFiles( mqtt answer ): This method is provided to update the configuration files when the appropriate mqtt answer is received\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the files are updated correctly, false otherwise \par
}}{
Definition at line 388 of file CoolFileSystem.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   389 \{\par
  390 \par
  391 #if DEBUG == 1\par
  392 \par
  393     Serial.println( F("Entering CoolFileSystem.updateConfigFiles") );\par
  394     Serial.println();\par
  395     \par
  396     Serial.println( F("input answer : ") );\par
  397     Serial.println(answer);\par
  398 #endif\par
  399 \par
  400     //total json object \par
  401     DynamicJsonBuffer jsonBuffer;\par
  402     JsonObject& root = jsonBuffer.parseObject( answer.c_str() );\par
  403 \par
  404 #if DEBUG == 1\par
  405     \par
  406     Serial.println( F("json object : ") );  \par
  407     root.printTo(Serial);\par
  408     Serial.println();\par
  409     \par
  410     Serial.print(F("jsonBuffer size: "));\par
  411     Serial.println(jsonBuffer.size());\par
  412     Serial.println();\par
  413 \par
  414 \par
  415 #endif\par
  416 \par
  417     if(! ( root.success() ))\par
  418     \{\par
  419     \par
  420     #if DEBUG == 1\par
  421 \par
  422         Serial.println( F("failed to parse root ") );\par
  423         Serial.println();\par
  424     \par
  425     #endif\par
  426 \par
  427         return(false);\par
  428     \}\par
  429     else\par
  430     \{\par
  431     #if DEBUG == 1\par
  432         \par
  433         Serial.println( F("success to parse root ") );\par
  434         Serial.println();\par
  435         \par
  436     #endif  \par
  437     \}\par
  438     \par
  439 #if DEBUG == 1\par
  440 \par
  441     Serial.println( F("input message is : ") );\par
  442     root.printTo(Serial);\par
  443     Serial.println();\par
  444 \par
  445 #endif\par
  446     //temp string\par
  447     String temp;\par
  448 \par
  449     //CoolBoard Configuration File\par
  450 \par
  451         JsonObject& jsonCoolBoard=root["CoolBoard"];\par
  452 \par
  453 #if DEBUG == 1\par
  454 \par
  455     Serial.println( F("before config CoolBoard json") );\par
  456     jsonCoolBoard.printTo(Serial);\par
  457 \par
  458 #endif\par
  459 \par
  460     if(jsonCoolBoard.success())\par
  461     \{\par
  462         String update;\par
  463     \par
  464         jsonCoolBoard.printTo(update);\par
  465 \par
  466         this->fileUpdate(update,"/coolBoardConfig.json");       \par
  467         \par
  468     \}\par
  469     else\par
  470     \{\par
  471     \par
  472     #if DEBUG == 1 \par
  473 \par
  474         Serial.println( F("failed to parse CoolBoard ") );\par
  475     \par
  476     #endif\par
  477 \par
  478     \}       \par
  479 \par
  480     \par
  481     //Cool Board Sensors Configuration File\par
  482         JsonObject& jsonSensorsBoard=root["CoolSensorsBoard"];\par
  483 \par
  484 #if DEBUG == 1 \par
  485 \par
  486     Serial.println( F("before config CoolSensorsBoard json") );\par
  487     jsonSensorsBoard.printTo(Serial);\par
  488 \par
  489 #endif \par
  490     \par
  491     if(jsonSensorsBoard.success())\par
  492     \{   \par
  493         String update;\par
  494     \par
  495         jsonSensorsBoard.printTo(update);\par
  496 \par
  497         this->fileUpdate(update,"/coolBoardSensorsConfig.json");        \par
  498 \par
  499     \}\par
  500     else\par
  501     \{\par
  502 \par
  503     #if DEBUG == 1\par
  504 \par
  505         Serial.println( F("failed to parse CoolSensorsBoard sensors ") );   \par
  506     \par
  507     #endif\par
  508 \par
  509     \}\par
  510 \par
  511     //Cool Board Actor Configuration File\par
  512         JsonObject& jsonCoolBoardActor=root["CoolBoardActor"];\par
  513 \par
  514 #if DEBUG == 1 \par
  515 \par
  516     Serial.println( F("before config CoolBoardActor json") );\par
  517     jsonCoolBoardActor.printTo(Serial);\par
  518 \par
  519 #endif \par
  520     \par
  521     if(jsonCoolBoardActor.success())\par
  522     \{   \par
  523         String update;\par
  524     \par
  525         jsonCoolBoardActor.printTo(update);\par
  526 \par
  527         this->fileUpdate(update,"/coolBoardActorConfig.json");      \par
  528 \par
  529     \}\par
  530     else\par
  531     \{\par
  532 \par
  533     #if DEBUG == 1\par
  534 \par
  535         Serial.println( F("failed to parse CoolBoardActor json ") );    \par
  536     \par
  537     #endif\par
  538 \par
  539     \}\par
  540 \par
  541     \par
  542     //rtc configuration file\par
  543         JsonObject& jsonRTC=root["rtc"];\par
  544 \par
  545 #if DEBUG == 1 \par
  546     \par
  547     Serial.println( F("before config rtc json") );\par
  548     jsonRTC.printTo(Serial);\par
  549 \par
  550 #endif\par
  551     if(jsonRTC.success() )\par
  552     \{\par
  553         String update;\par
  554 \par
  555         jsonRTC.printTo(update);\par
  556 \par
  557         this->fileUpdate(update,"/rtcConfig.json");         \par
  558     \}\par
  559     else\par
  560     \{\par
  561     \par
  562     #if DEBUG == 1 \par
  563 \par
  564         Serial.println( F("failed to parse rtc ") );\par
  565     \par
  566     #endif\par
  567 \par
  568     \}\par
  569     \par
  570     \par
  571         //cool board led configuration\par
  572         JsonObject& jsonLedBoard=root["led"];\par
  573     \par
  574 #if DEBUG == 1 \par
  575 \par
  576     Serial.println( F("before config Led json") );\par
  577     jsonLedBoard.printTo(Serial);\par
  578 \par
  579 #endif\par
  580 \par
  581     if(jsonLedBoard.success())\par
  582     \{   \par
  583         String update;\par
  584     \par
  585         jsonLedBoard.printTo(update);\par
  586 \par
  587         this->fileUpdate(update,"/coolBoardLedConfig.json");        \par
  588 \par
  589     \par
  590     \}\par
  591     else\par
  592     \{\par
  593     \par
  594     #if DEBUG == 1 \par
  595 \par
  596         Serial.println( F("failed to parse led") );\par
  597     \par
  598     #endif \par
  599 \par
  600     \}\par
  601         \par
  602 \par
  603     \par
  604 \par
  605     //jetpack configuration\par
  606         JsonObject& jsonJetpack=root["jetPack"];\par
  607 \par
  608 #if DEBUG == 1 \par
  609 \par
  610     Serial.println( F("before config jetpack json") );\par
  611     jsonJetpack.printTo(Serial);\par
  612 \par
  613 #endif\par
  614 \par
  615     if(jsonJetpack.success())\par
  616     \{\par
  617     \par
  618         String update;\par
  619     \par
  620         jsonJetpack.printTo(update);\par
  621 \par
  622         this->fileUpdate(update,"/jetPackConfig.json");     \par
  623 \par
  624     \}\par
  625 \par
  626     else\par
  627     \{\par
  628     \par
  629     #if DEBUG == 1 \par
  630 \par
  631         Serial.println( F("failed to parse jetpack") ); \par
  632     \par
  633     #endif\par
  634 \par
  635     \}\par
  636     \par
  637     //irene configuration   \par
  638         JsonObject& jsonIrene=root["irene3000"];\par
  639     \par
  640 #if DEBUG == 1 \par
  641 \par
  642     Serial.println( F("before config irene json") );    \par
  643     jsonIrene.printTo(Serial);\par
  644 \par
  645 #endif \par
  646 \par
  647     if(jsonIrene.success())\par
  648     \{\par
  649 \par
  650         String update;\par
  651     \par
  652         jsonIrene.printTo(update);\par
  653 \par
  654         this->fileUpdate(update,"/irene3000Config.json");       \par
  655     \par
  656     \}\par
  657     else\par
  658     \{\par
  659     \par
  660     #if DEBUG == 1 \par
  661 \par
  662         Serial.println( F("failed to parse irene") );   \par
  663     \par
  664     #endif \par
  665 \par
  666 \par
  667     \}\par
  668     \par
  669     //external sensors\par
  670         JsonObject& jsonExternalSensors=root["externalSensors"];\par
  671 \par
  672 #if DEBUG == 1 \par
  673 \par
  674     Serial.println( F("before config external Sensors json") );\par
  675     jsonExternalSensors.printTo(Serial);\par
  676 \par
  677 #endif\par
  678 \par
  679     if(jsonExternalSensors.success())\par
  680     \{\par
  681 \par
  682         String update;\par
  683     \par
  684         jsonExternalSensors.printTo(update);\par
  685 \par
  686         this->fileUpdate(update,"/externalSensorsConfig.json");     \par
  687 \par
  688     \}\par
  689 \par
  690     else\par
  691     \{   \par
  692 \par
  693     #if DEBUG == 1\par
  694         \par
  695         Serial.println( F("failed to parse external sensors") );\par
  696 \par
  697     #endif\par
  698 \par
  699 \par
  700     \}\par
  701 \par
  702     \par
  703     //mqtt config\par
  704         JsonObject& jsonMQTT=root["mqtt"];\par
  705     \par
  706 #if DEBUG == 1 \par
  707 \par
  708     Serial.println( F("before config mqtt json") );\par
  709     jsonMQTT.printTo(Serial);\par
  710 \par
  711 #endif\par
  712 \par
  713     if(jsonMQTT.success())\par
  714     \{\par
  715 \par
  716         String update;\par
  717     \par
  718         jsonMQTT.printTo(update);\par
  719 \par
  720         this->fileUpdate(update,"/mqttConfig.json");        \par
  721 \par
  722     \}\par
  723     else\par
  724     \{\par
  725 \par
  726     #if DEBUG == 1 \par
  727 \par
  728         Serial.println( F("failed to parse mqtt") );\par
  729     \par
  730     #endif\par
  731 \par
  732     \par
  733     \}   \par
  734 \par
  735     //wifi config\par
  736         JsonObject& jsonWifi=root["wifi"];\par
  737     \par
  738 #if DEBUG == 1 \par
  739 \par
  740     Serial.println( F("before config wifi json") );\par
  741     jsonWifi.printTo(Serial);\par
  742 \par
  743 #endif\par
  744 \par
  745     if(jsonWifi.success())\par
  746     \{\par
  747 \par
  748         String update;\par
  749     \par
  750         jsonWifi.printTo(update);\par
  751 \par
  752         this->fileUpdate(update,"/wifiConfig.json");        \par
  753 \par
  754     \}\par
  755     else\par
  756     \{\par
  757 \par
  758     #if DEBUG == 1 \par
  759 \par
  760         Serial.println( F("failed to parse wifi") );\par
  761     \par
  762     #endif\par
  763 \par
  764     \par
  765     \}   \par
  766         \par
  767     return true;\par
  768 \par
  769 \}   \par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_adfa8e2e80641ae6f0cceabd348a9b841_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d0c/class_cool_file_system_adfa8e2e80641ae6f0cceabd348a9b841_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v linesToSkip\:CoolFileSystem}
{\xe \v CoolFileSystem\:linesToSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolFileSystem::linesToSkip =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolFileSystem.h.}\par
}
{\xe \v savedData\:CoolFileSystem}
{\xe \v CoolFileSystem\:savedData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolFileSystem::savedData =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file CoolFileSystem.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolFileSystem.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolMQTT Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolMQTT}
{\xe \v CoolMQTT}
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client. }}\par
{
{\f2 #include <CoolMQTT.h>}}\par
Collaboration diagram for CoolMQTT:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/def/class_cool_m_q_t_t__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b connect} (unsigned long keepAlive)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *data, unsigned long logInterval)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b config} (const char {\b mqttServer}[], const char {\b inTopic}[], const char {\b outTopic}[], const char {\b user}[], int {\b bufferSize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b callback} (char *topic, byte *payload, unsigned int length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b state} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mqttLoop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getUser} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b mqttServer} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b msg} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b inTopic} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b outTopic} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b user} [50] =\{'0'\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufferSize} =3000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WiFiClient {\b espClient}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} {\b client}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b newMsg} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b previousLogTime} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client. \par
}{
Definition at line 43 of file CoolMQTT.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolMQTT}
{\xe \v CoolMQTT\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::begin ()}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::begin()}: This method is provided to set the mqtt client's parameters: -client -server -callback method -buffer size \par
}{
Definition at line 51 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52 \{ \par
   53 \par
   54 #if DEBUG == 1 \par
   55 \par
   56     Serial.println( F("Entering CoolMQTT.begin()") );\par
   57     Serial.println();\par
   58 \par
   59 #endif\par
   60 \par
   61     client.setClient(espClient);\par
   62     client.setServer(mqttServer, 1883); \par
   63     client.setCallback([this] (char* topic, byte* payload, unsigned int length) \{ this->callback(topic, payload, length); \});\par
   64     client.setBufferSize((unsigned short)bufferSize);\par
   65 \par
   66 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ac9248808641ebf3054ed0620ea9d0100_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ac9248808641ebf3054ed0620ea9d0100_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v callback\:CoolMQTT}
{\xe \v CoolMQTT\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::callback (char *  {\i topic}, byte *  {\i payload}, unsigned int  {\i length})}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::callback(in topic, incoming message , message length): This method is provided to handle incoming messages from the subscribed inTopic.\par
Arguments are automatically assigned in client.setCallback() \par
}{
Definition at line 307 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309 \par
  310 #if DEBUG == 1\par
  311 \par
  312     Serial.println( F("Entering CoolMQTT.callback() ") );\par
  313     Serial.println();\par
  314 \par
  315 #endif \par
  316 \par
  317     if(this->newMsg==false)\par
  318     \{\par
  319         char temp[length+1];\par
  320 \par
  321     #if DEBUG == 1\par
  322 \par
  323         Serial.println( F("received temp msg : ") );\par
  324         \par
  325     #endif\par
  326         \par
  327         for (unsigned int i = 0; i < length; i++) \par
  328         \{\par
  329             temp[i]=(char)payload[i];\par
  330         \par
  331         #if DEBUG == 1 \par
  332 \par
  333             Serial.print( (char)payload[i] );\par
  334         \par
  335         #endif\par
  336 \par
  337         \}\par
  338     \par
  339     #if DEBUG == 1 \par
  340 \par
  341         Serial.println();\par
  342         Serial.println( F("storing new message : ") );\par
  343 \par
  344         Serial.print(F("length : "));\par
  345         Serial.println(length);\par
  346         \par
  347         Serial.print(F("size : "));\par
  348         Serial.print(sizeof(payload));\par
  349         Serial.println();\par
  350     \par
  351     #endif\par
  352 \par
  353         this->newMsg=true;\par
  354 \par
  355         temp[length+1]='\\0';\par
  356 \par
  357         this->msg=String(temp);\par
  358         this->msg.remove(length,1);\par
  359     \par
  360     #if DEBUG == 1 \par
  361 \par
  362         Serial.println( F("stored message : ") );\par
  363         Serial.println(this->msg);\par
  364     \par
  365     #endif\par
  366 \par
  367     \}\par
  368     else\par
  369     \{\par
  370     \par
  371     #if DEBUG == 1\par
  372 \par
  373         Serial.println( F("did not read last message") );\par
  374     \par
  375     #endif \par
  376         \par
  377     \}\par
  378 \par
  379 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a30d82ad665bfb603f46ecdbc290775df_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolMQTT}
{\xe \v CoolMQTT\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::config (const char  {\i mqttServer}[], const char  {\i inTopic}[], const char  {\i outTopic}[], const char  {\i user}[], int  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::config(server,in topic, out topic , user Id, buffer size): This method is provided to manually configure the mqtt client \par
}{
Definition at line 624 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   625 \{\par
  626 \par
  627 #if DEBUG == 1\par
  628 \par
  629     Serial.println( F("Entering CoolMQTT.config() , no SPIFFS variant") );\par
  630     Serial.println();\par
  631 \par
  632 #endif\par
  633 \par
  634     for(int i =0;i< 50 ;i++)\par
  635     \{\par
  636         this->mqttServer[i]=mqttServer[i];\par
  637         this->inTopic[i]=inTopic[i];\par
  638         this->outTopic[i]=outTopic[i];\par
  639         this->user[i]=user[i];\par
  640     \}\par
  641     this->bufferSize=bufferSize;\par
  642     \par
  643 \par
  644 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a9b703de4f1358f0ee7a5e8c44979c648_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolMQTT}
{\xe \v CoolMQTT\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::config ()}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::config()}: This method is provided to configure the mqttClient : -server -inTopic -outTopic -client Id -buffer size\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 427 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   428 \{\par
  429 \par
  430 #if DEBUG == 1 \par
  431 \par
  432     Serial.println( F("Entering CoolMQTT.config()") );\par
  433     Serial.println();\par
  434 \par
  435 #endif\par
  436 \par
  437     //read config file\par
  438     //update data\par
  439     File configFile = SPIFFS.open("/mqttConfig.json", "r");\par
  440 \par
  441     if (!configFile) \par
  442     \{\par
  443     \par
  444     #if DEBUG == 1 \par
  445 \par
  446         Serial.println( F("failed to read /mqttConfig.json") );\par
  447         Serial.println();\par
  448 \par
  449     #endif\par
  450 \par
  451         return(false);\par
  452     \}\par
  453     else\par
  454     \{\par
  455         size_t size = configFile.size();\par
  456         // Allocate a buffer to store contents of the file.\par
  457         std::unique_ptr<char[]> buf(new char[size]);\par
  458 \par
  459         configFile.readBytes(buf.get(), size);\par
  460         DynamicJsonBuffer jsonBuffer;\par
  461         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  462         if (!json.success()) \par
  463         \{\par
  464         \par
  465         #if DEBUG == 1 \par
  466 \par
  467             Serial.println( F("failed to parse json ") );\par
  468             Serial.println();\par
  469         \par
  470         #endif\par
  471             \par
  472             return(false);\par
  473         \} \par
  474         else\par
  475         \{\par
  476         \par
  477         #if DEBUG == 1 \par
  478         \par
  479             Serial.println( F("configuration json is ") );\par
  480             json.printTo(Serial);\par
  481             Serial.println();\par
  482 \par
  483             Serial.print(F("jsonBuffer size: "));\par
  484             Serial.println(jsonBuffer.size());\par
  485             Serial.println();\par
  486 \par
  487 \par
  488         #endif\par
  489 \par
  490             if(json["mqttServer"].success() )\par
  491             \{           \par
  492                 const char* tempmqttServer = json["mqttServer"]; \par
  493                 for(int i =0;i< 50 ;i++)\par
  494                 \{\par
  495                     mqttServer[i]=tempmqttServer[i];\par
  496                 \}\par
  497             \}\par
  498             else\par
  499             \{\par
  500                 for(int i =0;i< 50 ;i++)\par
  501                 \{\par
  502                     this->mqttServer[i]=this->mqttServer[i];\par
  503                 \}\par
  504 \par
  505             \}\par
  506             json["mqttServer"]=this->mqttServer;\par
  507 \par
  508             \par
  509             if(json["inTopic"].success() )\par
  510             \{\par
  511                 const char* tempInTopic = json["inTopic"]; \par
  512                 for(int i =0;i< 50;i++)\par
  513                 \{\par
  514                     inTopic[i]=tempInTopic[i];\par
  515                 \}\par
  516             \}\par
  517             else\par
  518             \{\par
  519                 String tempMAC = WiFi.macAddress();\par
  520                 tempMAC.replace(":","");\par
  521                 snprintf(inTopic, 50, "$aws/things/%s/shadow/update/delta", tempMAC.c_str());   \par
  522             \par
  523             #if DEBUG == 1              \par
  524                 \par
  525                 Serial.print( F("Set Incomming MQTT Channel to : ") );\par
  526                 Serial.println(inTopic);\par
  527             \par
  528             #endif  \par
  529 \par
  530             \}\par
  531             json["inTopic"]=this->inTopic;\par
  532             \par
  533             \par
  534             if(json["outTopic"].success() )\par
  535             \{\par
  536                 const char* tempOutTopic = json["outTopic"]; \par
  537                 for(int i =0;i<50;i++)\par
  538                 \{\par
  539                     outTopic[i]=tempOutTopic[i];\par
  540                 \}\par
  541             \}\par
  542             else\par
  543             \{\par
  544                 String tempMAC = WiFi.macAddress();\par
  545                 tempMAC.replace(":","");\par
  546                 snprintf(outTopic, 50, "$aws/things/%s/shadow/update", tempMAC.c_str());\par
  547             \par
  548             #if DEBUG == 1 \par
  549 \par
  550                 Serial.print( F("Set Outgoing MQTT Channel to : ") );\par
  551                 Serial.println(outTopic);\par
  552             \par
  553             #endif\par
  554 \par
  555             \}\par
  556             json["outTopic"]=this->outTopic;\par
  557         \par
  558             \par
  559             if(json["user"].success() )\par
  560             \{               \par
  561                 const char* tempUser = json["user"]; \par
  562                 for(int i =0;i<50;i++)\par
  563                 \{\par
  564                     user[i]=tempUser[i];\par
  565                 \}\par
  566             \}\par
  567             else\par
  568             \{\par
  569                 for(int i=0;i<50;i++)\par
  570                 \{\par
  571                     this->user[i]=this->user[i];\par
  572                 \}               \par
  573             \}\par
  574             json["user"]=this->user;\par
  575             \par
  576             if(json["bufferSize"].success() )\par
  577             \{\par
  578                 int tempBufferSize = json["bufferSize"]; \par
  579                 bufferSize=tempBufferSize;\par
  580             \}\par
  581             else\par
  582             \{\par
  583                 this->bufferSize=this->bufferSize;\par
  584             \}\par
  585             json["bufferSize"]=this->bufferSize;\par
  586 \par
  587             configFile.close();\par
  588             configFile = SPIFFS.open("/mqttConfig.json", "w");\par
  589             if(!configFile)\par
  590             \{\par
  591             \par
  592             #if DEBUG == 1 \par
  593 \par
  594                 Serial.println( F("failed to write to /mqttConfig.json") );\par
  595             \par
  596             #endif\par
  597 \par
  598                 return(false);              \par
  599             \}\par
  600             \par
  601             json.printTo(configFile);\par
  602             configFile.close();\par
  603 \par
  604         #if DEBUG == 1 \par
  605 \par
  606             Serial.println( F("saved configuration is :") );\par
  607             json.printTo(Serial);\par
  608             Serial.println();\par
  609         \par
  610         #endif\par
  611 \par
  612             return(true); \par
  613         \}\par
  614     \}   \par
  615     \par
  616 \par
  617 \}\par
}
}
{\xe \v connect\:CoolMQTT}
{\xe \v CoolMQTT\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolMQTT::connect (unsigned long  {\i keepAlive})}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::connect( time to keep the connection alive in seconds ): This method is provided to connect the client to the server, publish to the out topic , subscribe to the in topic and set the keepAlive time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid mqtt client state \par
}}{
Definition at line 107 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   108 \{       \par
  109 \par
  110     int i=0;\par
  111 \par
  112 #if DEBUG == 1 \par
  113 \par
  114     Serial.println( F("Entering CoolMQTT.connect()") );\par
  115 \par
  116 #endif\par
  117     Serial.println( F("MQTT connecting...") );\par
  118     \par
  119     while( ( !this->client.connected() ) && ( i<100 ) ) \par
  120     \{\par
  121         // Attempt to connect\par
  122         if( this->client.connect( this-> user,keepAlive*10  ) )\par
  123         \{\par
  124             client.subscribe( this->inTopic );\par
  125 \par
  126         #if DEBUG == 1 \par
  127 \par
  128             Serial.println( F(" subscribed , leavin ") ) ;\par
  129         \par
  130         #endif\par
  131 \par
  132             return( this->state() );\par
  133         \}\par
  134 \par
  135         else\par
  136         \{\par
  137         \par
  138         #if DEBUG == 1 \par
  139 \par
  140             Serial.println( F("not connected , retrying") );\par
  141         \par
  142         #endif\par
  143 \par
  144             \par
  145         \}\par
  146 \par
  147     delay(5);\par
  148     i++;\par
  149     \}\par
  150     if (state() == 0)\par
  151     \{\par
  152         Serial.println( F("MQTT connected : OK") );\par
  153         Serial.println();\par
  154     \}\par
  155     else Serial.println( F("MQTT not jet connected..."));\par
  156     return( this->state() );\par
  157 \par
  158 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a50075d0ab23a327ab897fd6adad20eda_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a50075d0ab23a327ab897fd6adad20eda_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getUser\:CoolMQTT}
{\xe \v CoolMQTT\:getUser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolMQTT::getUser ()}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::getUser()}: This method is provided to get the user name \par
}{
Definition at line 687 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   688 \{\par
  689 \par
  690 #if DEBUG == 1 \par
  691     Serial.println( F("Entering CoolMQTT.getUser()") );\par
  692     Serial.println();\par
  693     \par
  694     Serial.print( F("user : ") );\par
  695     Serial.println(this->user);\par
  696 \par
  697 #endif\par
  698 \par
  699     return String(this->user);\par
  700 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a373cc92fca7760d886f02d8a6e5b3f63_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mqttLoop\:CoolMQTT}
{\xe \v CoolMQTT\:mqttLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::mqttLoop ()}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::mqttLoop()}: This method is provided to allow the client to process the data\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 271 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   272 \{\par
  273 \par
  274     unsigned long lastTime=millis();\par
  275 \par
  276 #if DEBUG == 1\par
  277 \par
  278     Serial.println( F("Entering CoolMQTT.mqttLoop()") );\par
  279     Serial.println();\par
  280 \par
  281 #endif  \par
  282 \par
  283     while( ( millis() - lastTime ) < 1000)\par
  284     \{\par
  285         this->client.loop();\par
  286         yield();\par
  287     \}\par
  288 \par
  289 #if DEBUG == 1 \par
  290     \par
  291     Serial.print( F("loop result : ") );\par
  292     Serial.println( this->client.loop() );\par
  293     Serial.println();\par
  294 \par
  295 #endif\par
  296 \par
  297     return( this->client.loop() );\par
  298 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_aa5eaae967b562b62cbcf2b8d81f6e5d5_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_aa5eaae967b562b62cbcf2b8d81f6e5d5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolMQTT}
{\xe \v CoolMQTT\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolMQTT::printConf ()}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 651 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   652 \{\par
  653 \par
  654 #if DEBUG == 1 \par
  655 \par
  656     Serial.println( F("Entering CoolMQTT.printConf()") );\par
  657     Serial.println();   \par
  658 \par
  659 #endif\par
  660     \par
  661     Serial.println("MQTT configuration ");\par
  662 \par
  663     Serial.print("mqttServer : ");\par
  664     Serial.println(this->mqttServer);\par
  665 \par
  666     Serial.print("inTopic : ");\par
  667     Serial.println(this->inTopic);\par
  668 \par
  669     Serial.print("outTopic : ");\par
  670     Serial.println(this->outTopic);\par
  671 \par
  672     Serial.print("user : ");\par
  673     Serial.println(this->user);\par
  674 \par
  675     Serial.print("bufferSize : ");\par
  676     Serial.println(this->bufferSize);\par
  677 \par
  678     Serial.println();\par
  679 \par
  680 \par
  681 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a40553a0ad4b5ecf1cb4411ab54ca85fb_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolMQTT}
{\xe \v CoolMQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::publish (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::publish(data): This method is provided to publish data to the out topic\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if publish successful, false otherwise \par
}}{
Definition at line 168 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   169 \{\par
  170 \par
  171 #if DEBUG == 1 \par
  172 \par
  173     Serial.println( F("Entering CoolMQTT.publish()") );\par
  174     Serial.println();\par
  175     //data is in JSON, publish it directly\par
  176 \par
  177     Serial.println( F("data to publish : ") );\par
  178     Serial.println(data);\par
  179     Serial.print( F("data size : ") );\par
  180     Serial.println(strlen(data));\par
  181 \par
  182     Serial.println();\par
  183 \par
  184 #endif\par
  185 #if DEBUG == 0\par
  186     Serial.println( F("Publishing Message : "));\par
  187     Serial.println(data);\par
  188     Serial.println();\par
  189 #endif\par
  190 \par
  191     bool pub=client.publish( this->outTopic,(byte*) data,strlen(data),false  );\par
  192 \par
  193 #if DEBUG == 1 \par
  194 \par
  195     Serial.print( F("success : ") );\par
  196     Serial.println(pub);    \par
  197 \par
  198 #endif\par
  199 #if DEBUG == 0\par
  200     if (pub == 1)\par
  201     \{\par
  202         Serial.println( F("Publish : OK"));\par
  203     \}\par
  204     else Serial.println( F("Publish : FAIL!!!"));\par
  205 #endif\par
  206 \par
  207     return(pub);\par
  208 \par
  209 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ace977b3e90ab14b1199fe5c4fb0a13ec_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ace977b3e90ab14b1199fe5c4fb0a13ec_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolMQTT}
{\xe \v CoolMQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::publish (const char *  {\i data}, unsigned long  {\i logInterval})}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolMQTT::publish(data): This method is provided to publish data to the out topic every logInterval in seconds\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if publish successful, false otherwise \par
}}{
Definition at line 219 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   220 \{\par
  221 \par
  222 #if DEBUG == 1 \par
  223 \par
  224     Serial.println( F("Entering CoolMQTT.publish() every logInterval ") );\par
  225     Serial.println();\par
  226 \par
  227 #endif \par
  228     //log interval is passed in seconds, logInteral*1000 = logInterval in ms\par
  229     if( ( millis() - ( this->previousLogTime)  ) >= ( logInterval*1000 ) )\par
  230     \{\par
  231     \par
  232     #if DEBUG == 1\par
  233 \par
  234         Serial.println( F("log Interval has passed ") );\par
  235         Serial.println();\par
  236     \par
  237     #endif\par
  238 \par
  239         this->publish(data);\par
  240 \par
  241         this->previousLogTime=millis();\par
  242     \par
  243     #if DEBUG == 1 \par
  244 \par
  245         Serial.print( F("last log time : ") );\par
  246         Serial.println(this->previousLogTime);\par
  247 \par
  248     #endif\par
  249 \par
  250         return(true);\par
  251     \}\par
  252 \par
  253 #if DEBUG == 1 \par
  254 \par
  255     Serial.println( F("log Interval still didn't pass ") ); \par
  256     Serial.println();\par
  257 \par
  258 #endif\par
  259 \par
  260     return(false);\par
  261 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a613c5e3927ae85bb94fbf648d84d8780_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:CoolMQTT}
{\xe \v CoolMQTT\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolMQTT::read ()}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::read()}: This method is provided to return the last read message. \par
}{
Definition at line 386 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   387 \{   \par
  388 \par
  389 #if DEBUG == 1 \par
  390 \par
  391     Serial.println( F("Entering CoolMQTT.read()") );\par
  392     Serial.println();\par
  393 \par
  394 #endif \par
  395 \par
  396     if(this->newMsg==true)\par
  397     \{\par
  398         \par
  399         this->newMsg=false;\par
  400 \par
  401 #if DEBUG == 1 \par
  402         Serial.println( F("received new message") );\par
  403         Serial.println( F("message : ") );\par
  404         Serial.println(this->msg);\par
  405         Serial.println();\par
  406 \par
  407 #endif\par
  408 \par
  409         return(this->msg);\par
  410         \par
  411     \}\par
  412     return("");\par
  413 \par
  414 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_ae3c18f6ae9723746d32765f1c8f176ca_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v state\:CoolMQTT}
{\xe \v CoolMQTT\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolMQTT::state ()}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT::state()}: This method is provided to return the mqtt client's state. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid mqtt client state: -4 : MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3 : MQTT_CONNECTION_LOST - the network connection was broken -2 : MQTT_CONNECT_FAILED - the network connection failed -1 : MQTT_DISCONNECTED - the client is disconnected cleanly 0 : MQTT_CONNECTED - the cient is connected 1 : MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2 : MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3 : MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4 : MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5 : MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect \par
}}{
Definition at line 84 of file CoolMQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    85 \{\par
   86 \par
   87 #if DEBUG == 1 \par
   88 \par
   89     Serial.println( F("Entering CoolMQTT.state()") );\par
   90     Serial.println();   \par
   91     Serial.print( F("state : ") );\par
   92     Serial.println( this->client.state() );\par
   93 \par
   94 #endif\par
   95     \par
   96     return( this->client.state() );\par
   97 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a5d003307eff78efbd585e42b43b72b6d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd0/class_cool_m_q_t_t_a5d003307eff78efbd585e42b43b72b6d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bufferSize\:CoolMQTT}
{\xe \v CoolMQTT\:bufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolMQTT::bufferSize =3000{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolMQTT.h.}\par
}
{\xe \v client\:CoolMQTT}
{\xe \v CoolMQTT\:client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} CoolMQTT::client{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolMQTT.h.}\par
}
{\xe \v espClient\:CoolMQTT}
{\xe \v CoolMQTT\:espClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiClient CoolMQTT::espClient{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolMQTT.h.}\par
}
{\xe \v inTopic\:CoolMQTT}
{\xe \v CoolMQTT\:inTopic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::inTopic[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolMQTT.h.}\par
}
{\xe \v mqttServer\:CoolMQTT}
{\xe \v CoolMQTT\:mqttServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::mqttServer[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolMQTT.h.}\par
}
{\xe \v msg\:CoolMQTT}
{\xe \v CoolMQTT\:msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolMQTT::msg =""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file CoolMQTT.h.}\par
}
{\xe \v newMsg\:CoolMQTT}
{\xe \v CoolMQTT\:newMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolMQTT::newMsg =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolMQTT.h.}\par
}
{\xe \v outTopic\:CoolMQTT}
{\xe \v CoolMQTT\:outTopic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::outTopic[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file CoolMQTT.h.}\par
}
{\xe \v previousLogTime\:CoolMQTT}
{\xe \v CoolMQTT\:previousLogTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolMQTT::previousLogTime =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolMQTT.h.}\par
}
{\xe \v user\:CoolMQTT}
{\xe \v CoolMQTT\:user}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CoolMQTT::user[50] =\{'0'\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolMQTT.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolMQTT.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolPubSubClient Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolPubSubClient}
{\xe \v CoolPubSubClient}
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
\par
{
{\f2 #include <CoolPubSubClient.h>}}\par
Collaboration diagram for CoolPubSubClient:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d7b/class_cool_pub_sub_client__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (IPAddress, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (uint8_t *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} (const char *, uint16_t, {\b MQTT_CALLBACK_SIGNATURE}, Client &client, Stream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CoolPubSubClient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setServer} (IPAddress {\b ip}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setServer} (uint8_t *{\b ip}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setServer} (const char *{\b domain}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setCallback} ({\b MQTT_CALLBACK_SIGNATURE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setClient} (Client &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setStream} (Stream &{\b stream})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoolPubSubClient} & {\b setTimeout} (uint16_t {\b socketTimeout})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, const char *user, const char *pass, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, const char *willTopic, uint8_t willQos, boolean willRetain, const char *willMessage, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect} (const char *id, const char *user, const char *pass, const char *willTopic, uint8_t willQos, boolean willRetain, const char *willMessage, uint16_t {\b keepAlive}={\b MQTT_KEEPALIVE}, uint16_t {\b socketTimeout}={\b MQTT_SOCKET_TIMEOUT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disconnect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const char *payload)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const char *payload, boolean retained)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, boolean retained)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b publish_P} (const char *topic, const uint8_t *payload, unsigned int plength, boolean retained)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b subscribe} (const char *topic)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b subscribe} (const char *topic, uint8_t qos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b unsubscribe} (const char *topic)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b loop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connected} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b state} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b setBufferSize} (uint16_t size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getBufferSize} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b readPacket} (uint8_t *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b readByte} (uint8_t *result)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b readByte} (uint8_t *result, uint16_t *index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b write} (uint8_t header, uint8_t *buf, uint16_t length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b writeString} (const char *string, uint8_t *buf, uint16_t pos)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client * {\b _client}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t * {\b buffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b buffer_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b nextMsgId}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastOutActivity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastInActivity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pingOutstanding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT_CALLBACK_SIGNATURE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b ip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b domain}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Stream * {\b stream}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _state}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b keepAlive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b socketTimeout}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 88 of file CoolPubSubClient.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient ()}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    14                                    \{\par
   15     this->_state = MQTT_DISCONNECTED;\par
   16     this->_client = NULL;\par
   17     this->stream = NULL;\par
   18     setCallback(NULL);\par
   19     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   20     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   21 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a2e54e36217bb0969b91b5dee9a27410f_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23                                                  \{\par
   24     this->_state = MQTT_DISCONNECTED;\par
   25     setClient(client);\par
   26     this->stream = NULL;\par
   27     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   28     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   29 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0563a12cb4e9339bf2605cfc655e717d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    31                                                                                 \{\par
   32     this->_state = MQTT_DISCONNECTED;\par
   33     setServer(addr, port);\par
   34     setClient(client);\par
   35     this->stream = NULL;\par
   36     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   37     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   38 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a4548ad6f306f6181e337a86c0b21a89a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    39                                                                                                 \{\par
   40     this->_state = MQTT_DISCONNECTED;\par
   41     setServer(addr,port);\par
   42     setClient(client);\par
   43     setStream(stream);\par
   44     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   45     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   46 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_af8b1aeb169366da52e3289bb6c238b6b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    47                                                                                                          \{\par
   48     this->_state = MQTT_DISCONNECTED;\par
   49     setServer(addr, port);\par
   50     setCallback(callback);\par
   51     setClient(client);\par
   52     this->stream = NULL;\par
   53     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   54     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   55 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a1743a9eeef19b3b6ff1db5be8df55a9c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (IPAddress  {\i addr}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    56                                                                                                                          \{\par
   57     this->_state = MQTT_DISCONNECTED;\par
   58     setServer(addr,port);\par
   59     setCallback(callback);\par
   60     setClient(client);\par
   61     setStream(stream);\par
   62     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   63     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   64 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0797679d710bf2b1aa802107bdb1a2fe_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    66                                                                              \{\par
   67     this->_state = MQTT_DISCONNECTED;\par
   68     setServer(ip, port);\par
   69     setClient(client);\par
   70     this->stream = NULL;\par
   71     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   72     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   73 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a15e4dd41ebda943c377539086f70469d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    74                                                                                              \{\par
   75     this->_state = MQTT_DISCONNECTED;\par
   76     setServer(ip,port);\par
   77     setClient(client);\par
   78     setStream(stream);\par
   79     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   80     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   81 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a3e7d7fa4b55e36f0ac8912335993d650_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82                                                                                                       \{\par
   83     this->_state = MQTT_DISCONNECTED;\par
   84     setServer(ip, port);\par
   85     setCallback(callback);\par
   86     setClient(client);\par
   87     this->stream = NULL;\par
   88     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   89     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   90 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_afc703702b40ba925377d0b9cd401319e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (uint8_t *  {\i ip}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    91                                                                                                                       \{\par
   92     this->_state = MQTT_DISCONNECTED;\par
   93     setServer(ip,port);\par
   94     setCallback(callback);\par
   95     setClient(client);\par
   96     setStream(stream);\par
   97     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
   98     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
   99 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a08309a2cf058099fa5c96c198f777647_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101                                                                                     \{\par
  102     this->_state = MQTT_DISCONNECTED;\par
  103     setServer(domain,port);\par
  104     setClient(client);\par
  105     this->stream = NULL;\par
  106     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  107     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  108 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a469eefe7429f0cbb6d7d443b52488411_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   109                                                                                                     \{\par
  110     this->_state = MQTT_DISCONNECTED;\par
  111     setServer(domain,port);\par
  112     setClient(client);\par
  113     setStream(stream);\par
  114     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  115     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  116 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a103e7286407babde84d63bb735c4e4b6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   117                                                                                                              \{\par
  118     this->_state = MQTT_DISCONNECTED;\par
  119     setServer(domain,port);\par
  120     setCallback(callback);\par
  121     setClient(client);\par
  122     this->stream = NULL;\par
  123     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  124     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  125 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a2aea0a9487dc15b9db1caf0f069eb877_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::CoolPubSubClient (const char *  {\i domain}, uint16_t  {\i port}, {\b MQTT_CALLBACK_SIGNATURE} , Client &  {\i client}, Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   126                                                                                                                              \{\par
  127     this->_state = MQTT_DISCONNECTED;\par
  128     setServer(domain,port);\par
  129     setCallback(callback);\par
  130     setClient(client);\par
  131     setStream(stream);\par
  132     this->buffer_size = MQTT_MAX_PACKET_SIZE;\par
  133     this->buffer = (uint8_t*)malloc(MQTT_MAX_PACKET_SIZE);\par
  134 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a6466f55abe5820d410b1c9cf7a70ec7e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ~CoolPubSubClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:~CoolPubSubClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::~CoolPubSubClient ()}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   136                                     \{\par
  137   free(this->buffer);\par
  138 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   140                                                                                             \{\par
  141     return connect(id,NULL,NULL,0,0,0,0,keepAlive,socketTimeout);\par
  142  \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a2664c2ebc302b2fa49f493a339ecc891_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, const char *  {\i user}, const char *  {\i pass}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144                                                                                                                                 \{\par
  145     return connect(id,user,pass,0,0,0,0,keepAlive,socketTimeout);\par
  146  \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7f30e39bf4ca5ea5fb9747c403639a03_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, const char *  {\i willTopic}, uint8_t  {\i willQos}, boolean  {\i willRetain}, const char *  {\i willMessage}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   148                                                                                                                                                                                  \{\par
  149     return connect(id,NULL,NULL,willTopic,willQos,willRetain,willMessage,keepAlive,socketTimeout);\par
  150  \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_af461a5a08fda1c3237e706965704ddb6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connect (const char *  {\i id}, const char *  {\i user}, const char *  {\i pass}, const char *  {\i willTopic}, uint8_t  {\i willQos}, boolean  {\i willRetain}, const char *  {\i willMessage}, uint16_t  {\i keepAlive} = {\f2 {\b MQTT_KEEPALIVE}}, uint16_t  {\i socketTimeout} = {\f2 {\b MQTT_SOCKET_TIMEOUT}})}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   152                                                                                                                                                                                                                      \{  \par
  153     if (!connected()) \{\par
  154         int result = 0;\par
  155 \par
  156         if (domain != NULL) \{\par
  157             result = _client->connect(this->domain, this->port);\par
  158         \} else \{\par
  159             result = _client->connect(this->ip, this->port);\par
  160         \}\par
  161         if (result == 1) \{\par
  162             nextMsgId = 1;\par
  163             // Leave room in the buffer for header and variable length field\par
  164             uint16_t length = 5;\par
  165             unsigned int j;\par
  166 \par
  167 #if MQTT_VERSION == MQTT_VERSION_3_1\par
  168             uint8_t d[9] = \{0x00,0x06,'M','Q','I','s','d','p', MQTT_VERSION\};\par
  169 #define MQTT_HEADER_VERSION_LENGTH 9\par
  170 #elif MQTT_VERSION == MQTT_VERSION_3_1_1\par
  171             uint8_t d[7] = \{0x00,0x04,'M','Q','T','T',MQTT_VERSION\};\par
  172 #define MQTT_HEADER_VERSION_LENGTH 7\par
  173 #endif\par
  174             for (j = 0;j<MQTT_HEADER_VERSION_LENGTH;j++) \{\par
  175                 buffer[length++] = d[j];\par
  176             \}\par
  177 \par
  178             uint8_t v;\par
  179             if (willTopic) \{\par
  180                 v = 0x06|(willQos<<3)|(willRetain<<5);\par
  181             \} else \{\par
  182                 v = 0x02;\par
  183             \}\par
  184 \par
  185             if(user != NULL) \{\par
  186                 v = v|0x80;\par
  187 \par
  188                 if(pass != NULL) \{\par
  189                     v = v|(0x80>>1);\par
  190                 \}\par
  191             \}\par
  192 \par
  193             buffer[length++] = v;\par
  194 \par
  195             if (keepAlive > 0) \{\par
  196                 this->keepAlive = keepAlive;\par
  197             \} else \{\par
  198                 this->keepAlive = MQTT_KEEPALIVE;\par
  199             \}\par
  200 \par
  201             buffer[length++] = ((this->keepAlive) >> 8);\par
  202             buffer[length++] = ((this->keepAlive) & 0xFF);\par
  203 \par
  204             length = writeString(id,buffer,length);\par
  205             if (willTopic) \{\par
  206                 length = writeString(willTopic,buffer,length);\par
  207                 length = writeString(willMessage,buffer,length);\par
  208             \}\par
  209 \par
  210             if(user != NULL) \{\par
  211                 length = writeString(user,buffer,length);\par
  212                 if(pass != NULL) \{\par
  213                     length = writeString(pass,buffer,length);\par
  214                 \}\par
  215             \}\par
  216 \par
  217             write(MQTTCONNECT,buffer,length-5);\par
  218 \par
  219             lastInActivity = lastOutActivity = millis();\par
  220         \par
  221         if (socketTimeout > 0) \{\par
  222                 this->socketTimeout = socketTimeout;\par
  223             \} else \{\par
  224                 this->socketTimeout = MQTT_SOCKET_TIMEOUT;\par
  225             \}\par
  226 \par
  227 \par
  228             while (!_client->available()) \{\par
  229                 unsigned long t = millis();\par
  230                 if (t-lastInActivity >= ((int32_t) this->socketTimeout*1000UL)) \{\par
  231                     _state = MQTT_CONNECTION_TIMEOUT;\par
  232                     _client->stop();\par
  233                     return false;\par
  234                 \}\par
  235             \}\par
  236             uint8_t llen;\par
  237             uint16_t len = readPacket(&llen);\par
  238 \par
  239             if (len == 4) \{\par
  240                 if (buffer[3] == 0) \{\par
  241                     lastInActivity = millis();\par
  242                     pingOutstanding = false;\par
  243                     _state = MQTT_CONNECTED;\par
  244                     return true;\par
  245                 \} else \{\par
  246                     _state = buffer[3];\par
  247                 \}\par
  248             \}\par
  249             _client->stop();\par
  250         \} else \{\par
  251             _state = MQTT_CONNECT_FAILED;\par
  252         \}\par
  253         return false;\par
  254     \}\par
  255     return true;\par
  256 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7e5a85731dd25d90a41f6d859e61da77_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connected\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:connected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::connected ()}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 588 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   588                                     \{\par
  589     boolean rc;\par
  590     if (_client == NULL ) \{\par
  591         rc = false;\par
  592     \} else \{\par
  593         rc = (int)_client->connected();\par
  594         if (!rc) \{\par
  595             if (this->_state == MQTT_CONNECTED) \{\par
  596                 this->_state = MQTT_CONNECTION_LOST;\par
  597                 _client->flush();\par
  598                 _client->stop();\par
  599             \}\par
  600         \}\par
  601     \}\par
  602     return rc;\par
  603 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a3d5a5da4ddb1e5c1bea64d80c665d148_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v disconnect\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:disconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolPubSubClient::disconnect ()}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 565 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   565                                   \{\par
  566     buffer[0] = MQTTDISCONNECT;\par
  567     buffer[1] = 0;\par
  568     _client->write(buffer,2);\par
  569     _state = MQTT_DISCONNECTED;\par
  570     _client->stop();\par
  571     lastInActivity = lastOutActivity = millis();\par
  572 \}\par
}
}
{\xe \v getBufferSize\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:getBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::getBufferSize ()}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 648 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   648                                          \{\par
  649   return this->buffer_size;\par
  650 \}\par
}
}
{\xe \v loop\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::loop ()}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 334 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   334                                \{\par
  335     if (connected()) \{\par
  336         unsigned long t = millis();\par
  337         if ((t - lastInActivity > this->keepAlive*1000UL) || (t - lastOutActivity > this->keepAlive*1000UL)) \{ \par
  338             if (pingOutstanding) \{\par
  339                 this->_state = MQTT_CONNECTION_TIMEOUT;\par
  340                 _client->stop();\par
  341                 return false;\par
  342             \} else \{\par
  343                 buffer[0] = MQTTPINGREQ;\par
  344                 buffer[1] = 0;\par
  345                 _client->write(buffer,2);\par
  346                 lastOutActivity = t;\par
  347                 lastInActivity = t;\par
  348                 pingOutstanding = true;\par
  349             \}\par
  350         \}\par
  351         if (_client->available()) \{\par
  352             uint8_t llen;\par
  353             uint16_t len = readPacket(&llen);\par
  354             uint16_t msgId = 0;\par
  355             uint8_t *payload;\par
  356             if (len > 0) \{\par
  357                 lastInActivity = t;\par
  358                 uint8_t type = buffer[0]&0xF0;\par
  359                 if (type == MQTTPUBLISH) \{\par
  360                     if (callback) \{\par
  361                         uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; /* topic length in bytes */\par
  362                         memmove(buffer+llen+2,buffer+llen+3,tl); /* move topic inside buffer 1 byte to front */\par
  363                         buffer[llen+2+tl] = 0; /* end the topic as a 'C' string with \\x00 */\par
  364                         char *topic = (char*) buffer+llen+2;\par
  365                         // msgId only present for QOS>0\par
  366                         if ((buffer[0]&0x06) == MQTTQOS1) \{\par
  367                             msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];\par
  368                             payload = buffer+llen+3+tl+2;\par
  369                             callback(topic,payload,len-llen-3-tl-2);\par
  370 \par
  371                             buffer[0] = MQTTPUBACK;\par
  372                             buffer[1] = 2;\par
  373                             buffer[2] = (msgId >> 8);\par
  374                             buffer[3] = (msgId & 0xFF);\par
  375                             _client->write(buffer,4);\par
  376                             lastOutActivity = t;\par
  377 \par
  378                         \} else \{\par
  379                             payload = buffer+llen+3+tl;\par
  380                             callback(topic,payload,len-llen-3-tl);\par
  381                         \}\par
  382                     \}\par
  383                 \} else if (type == MQTTPINGREQ) \{\par
  384                     buffer[0] = MQTTPINGRESP;\par
  385                     buffer[1] = 0;\par
  386                     _client->write(buffer,2);\par
  387                 \} else if (type == MQTTPINGRESP) \{\par
  388                     pingOutstanding = false;\par
  389                 \}\par
  390             \}\par
  391         \}\par
  392         return true;\par
  393     \}\par
  394     return false;\par
  395 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_afc15900f0fc4886a19394508e61793b8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_afc15900f0fc4886a19394508e61793b8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const char *  {\i payload})}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 397 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   397                                                                         \{\par
  398     return publish(topic,(const uint8_t*)payload,strlen(payload),false);\par
  399 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ab6ad5fa2d3db8f91454027257f225a89_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const char *  {\i payload}, boolean  {\i retained})}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 401 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   401                                                                                           \{\par
  402     return publish(topic,(const uint8_t*)payload,strlen(payload),retained);\par
  403 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0b01cef98af0b57d8da4df373e196448_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength})}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 405 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   405                                                                                                  \{\par
  406     return publish(topic, payload, plength, false);\par
  407 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_abf184c0968a6655b68b5fdfbbc0c87d1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, boolean  {\i retained})}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 409 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   409                                                                                                                    \{\par
  410     if (connected()) \{\par
  411         if (this->buffer_size < 5 + 2+strlen(topic) + plength) \{\par
  412             // Too long\par
  413             return false;\par
  414         \}\par
  415         // Leave room in the buffer for header and variable length field\par
  416         uint16_t length = 5;\par
  417         length = writeString(topic,buffer,length);\par
  418         uint16_t i;\par
  419         for (i=0;i<plength;i++) \{\par
  420             buffer[length++] = payload[i];\par
  421         \}\par
  422         uint8_t header = MQTTPUBLISH;\par
  423         if (retained) \{\par
  424             header |= 1;\par
  425         \}\par
  426         return write(header,buffer,length-5);\par
  427     \}\par
  428     return false;\par
  429 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_adef968760eb87b70e3fed03e60da76f7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publish_P\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:publish_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::publish_P (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, boolean  {\i retained})}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 431 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   431                                                                                                                      \{\par
  432     uint8_t llen = 0;\par
  433     uint8_t digit;\par
  434     unsigned int rc = 0;\par
  435     uint16_t tlen;\par
  436     unsigned int pos = 0;\par
  437     unsigned int i;\par
  438     uint8_t header;\par
  439     unsigned int len;\par
  440 \par
  441     if (!connected()) \{\par
  442         return false;\par
  443     \}\par
  444 \par
  445     tlen = strlen(topic);\par
  446 \par
  447     header = MQTTPUBLISH;\par
  448     if (retained) \{\par
  449         header |= 1;\par
  450     \}\par
  451     buffer[pos++] = header;\par
  452     len = plength + 2 + tlen;\par
  453     do \{\par
  454         digit = len % 128;\par
  455         len = len / 128;\par
  456         if (len > 0) \{\par
  457             digit |= 0x80;\par
  458         \}\par
  459         buffer[pos++] = digit;\par
  460         llen++;\par
  461     \} while(len>0);\par
  462 \par
  463     pos = writeString(topic,buffer,pos);\par
  464 \par
  465     rc += _client->write(buffer,pos);\par
  466 \par
  467     for (i=0;i<plength;i++) \{\par
  468         rc += _client->write((char)pgm_read_byte_near(payload + i));\par
  469     \}\par
  470 \par
  471     lastOutActivity = millis();\par
  472 \par
  473     return rc == tlen + 4 + plength;\par
  474 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a55458d47cf01f590e9b6647d5a418ab6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readByte\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:readByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::readByte (uint8_t *  {\i result}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 259 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   259                                                    \{\par
  260    uint32_t previousMillis = millis();\par
  261    while(!_client->available()) \par
  262    \{\par
  263      uint32_t currentMillis = millis();\par
  264      if(currentMillis - previousMillis >= ((int32_t) this->socketTimeout * 1000))\par
  265      \{ \par
  266        return false;\par
  267      \}\par
  268    \}\par
  269    *result = _client->read();\par
  270    return true;\par
  271 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ad409bbd287d5894f0cf082f62446c002_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readByte\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:readByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::readByte (uint8_t *  {\i result}, uint16_t *  {\i index}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 274 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   274                                                                     \{\par
  275   uint16_t current_index = *index;\par
  276   uint8_t * write_address = &(result[current_index]);\par
  277   if(readByte(write_address))\{\par
  278     *index = current_index + 1;\par
  279     return true;\par
  280   \}\par
  281   return false;\par
  282 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_abef3735bb9a2a8c87b3da659dc4ade03_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readPacket\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:readPacket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::readPacket (uint8_t *  {\i lengthLength}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 284 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   284                                                            \{\par
  285     uint16_t len = 0;\par
  286     if(!readByte(buffer, &len)) return 0;\par
  287     bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;\par
  288     uint32_t multiplier = 1;\par
  289     uint16_t length = 0;\par
  290     uint8_t digit = 0;\par
  291     uint16_t skip = 0;\par
  292     uint8_t start = 0;\par
  293 \par
  294     do \{\par
  295         if(!readByte(&digit)) return 0;\par
  296         buffer[len++] = digit;\par
  297         length += (digit & 127) * multiplier;\par
  298         multiplier *= 128;\par
  299     \} while ((digit & 128) != 0);\par
  300     *lengthLength = len-1;\par
  301 \par
  302     if (isPublish) \{\par
  303         // Read in topic length to calculate bytes to skip over for Stream writing\par
  304         if(!readByte(buffer, &len)) return 0;\par
  305         if(!readByte(buffer, &len)) return 0;\par
  306         skip = (buffer[*lengthLength+1]<<8)+buffer[*lengthLength+2];\par
  307         start = 2;\par
  308         if (buffer[0]&MQTTQOS1) \{\par
  309             // skip message id\par
  310             skip += 2;\par
  311         \}\par
  312     \}\par
  313 \par
  314     for (uint16_t i = start;i<length;i++) \{\par
  315         if(!readByte(&digit)) return 0;\par
  316         if (this->stream) \{\par
  317             if (isPublish && len-*lengthLength-2>skip) \{\par
  318                 this->stream->write(digit);\par
  319             \}\par
  320         \}\par
  321         if (len < this->buffer_size) \{\par
  322             buffer[len] = digit;\par
  323         \}\par
  324         len++;\par
  325     \}\par
  326 \par
  327     if (!this->stream && len > this->buffer_size) \{\par
  328         len = 0; // This will cause the packet to be ignored.\par
  329     \}\par
  330 \par
  331     return len;\par
  332 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a25a8779149cfa809b7c06f63568b25cf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a25a8779149cfa809b7c06f63568b25cf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBufferSize\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::setBufferSize (uint16_t  {\i size})}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 642 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   642                                                      \{\par
  643   this->buffer = (uint8_t*)realloc(this->buffer, size);\par
  644   this->buffer_size = size;\par
  645   return (this->buffer == NULL);\par
  646 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a4f83e54f1ba96e32f725d93cdec283b7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setCallback\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setCallback ({\b MQTT_CALLBACK_SIGNATURE} )}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 623 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   623                                                                        \{\par
  624     this->callback = callback;\par
  625     return *this;\par
  626 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ac5cab7658f1bdded32131241e468e661_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setClient\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setClient (Client &  {\i client})}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 628 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   628                                                            \{\par
  629     this->_client = &client;\par
  630     return *this;\par
  631 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7ee119b786010561ab6a9afa0798e91d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setServer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setServer (IPAddress  {\i ip}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 610 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   610                                                                          \{\par
  611     this->ip = ip;\par
  612     this->port = port;\par
  613     this->domain = NULL;\par
  614     return *this;\par
  615 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a947e70c394c66c7d08d0c53caf8425e3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setServer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setServer (uint8_t *  {\i ip}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 605 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   605                                                                          \{\par
  606     IPAddress addr(ip[0],ip[1],ip[2],ip[3]);\par
  607     return setServer(addr,port);\par
  608 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ad589f977fc2799b9341dc5f4fcdb483a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setServer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setServer (const char *  {\i domain}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 617 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   617                                                                                 \{\par
  618     this->domain = domain;\par
  619     this->port = port;\par
  620     return *this;\par
  621 \}\par
}
}
{\xe \v setStream\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setStream (Stream &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 633 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   633                                                            \{\par
  634     this->stream = &stream;\par
  635     return *this;\par
  636 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ae97e40823ea689ff9e36d5bdd71bb933_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setTimeout\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoolPubSubClient} & CoolPubSubClient::setTimeout (uint16_t  {\i socketTimeout})}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 652 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   652                                                                     \{\par
  653     this->socketTimeout = socketTimeout;\par
  654     return *this;\par
  655 \}\par
}
}
{\xe \v state\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolPubSubClient::state ()}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 638 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   638                             \{\par
  639     return this->_state;\par
  640 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a3245a5afc6d22e61270dcfe392ccb866_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subscribe\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::subscribe (const char *  {\i topic})}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 518 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   518                                                      \{\par
  519     return subscribe(topic, 0);\par
  520 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_ac1ebc9ad874128aefa985d78496d2e8f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subscribe\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::subscribe (const char *  {\i topic}, uint8_t  {\i qos})}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 522 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   522                                                                   \{\par
  523     if (qos < 0 || qos > 1) \{\par
  524         return false;\par
  525     \}\par
  526     if (this->buffer_size < 9 + strlen(topic)) \{\par
  527         // Too long\par
  528         return false;\par
  529     \}\par
  530     if (connected()) \{\par
  531         // Leave room in the buffer for header and variable length field\par
  532         uint16_t length = 5;\par
  533         nextMsgId++;\par
  534         if (nextMsgId == 0) \{\par
  535             nextMsgId = 1;\par
  536         \}\par
  537         buffer[length++] = (nextMsgId >> 8);\par
  538         buffer[length++] = (nextMsgId & 0xFF);\par
  539         length = writeString((char*)topic, buffer,length);\par
  540         buffer[length++] = qos;\par
  541         return write(MQTTSUBSCRIBE|MQTTQOS1,buffer,length-5);\par
  542     \}\par
  543     return false;\par
  544 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_aebf684e98588c52a72af1014f7957bee_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v unsubscribe\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:unsubscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::unsubscribe (const char *  {\i topic})}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 546 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   546                                                        \{\par
  547     if (this->buffer_size < 9 + strlen(topic)) \{\par
  548         // Too long\par
  549         return false;\par
  550     \}\par
  551     if (connected()) \{\par
  552         uint16_t length = 5;\par
  553         nextMsgId++;\par
  554         if (nextMsgId == 0) \{\par
  555             nextMsgId = 1;\par
  556         \}\par
  557         buffer[length++] = (nextMsgId >> 8);\par
  558         buffer[length++] = (nextMsgId & 0xFF);\par
  559         length = writeString(topic, buffer,length);\par
  560         return write(MQTTUNSUBSCRIBE|MQTTQOS1,buffer,length-5);\par
  561     \}\par
  562     return false;\par
  563 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a850554280e314d6b5c33c73fd9e809fc_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean CoolPubSubClient::write (uint8_t  {\i header}, uint8_t *  {\i buf}, uint16_t  {\i length}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 476 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   476                                                                              \{\par
  477     uint8_t lenBuf[4];\par
  478     uint8_t llen = 0;\par
  479     uint8_t digit;\par
  480     uint8_t pos = 0;\par
  481     uint16_t rc;\par
  482     uint16_t len = length;\par
  483     do \{\par
  484         digit = len % 128;\par
  485         len = len / 128;\par
  486         if (len > 0) \{\par
  487             digit |= 0x80;\par
  488         \}\par
  489         lenBuf[pos++] = digit;\par
  490         llen++;\par
  491     \} while(len>0);\par
  492 \par
  493     buf[4-llen] = header;\par
  494     for (int i=0;i<llen;i++) \{\par
  495         buf[5-llen+i] = lenBuf[i];\par
  496     \}\par
  497 \par
  498 #ifdef MQTT_MAX_TRANSFER_SIZE\par
  499     uint8_t* writeBuf = buf+(4-llen);\par
  500     uint16_t bytesRemaining = length+1+llen;  //Match the length type\par
  501     uint8_t bytesToWrite;\par
  502     boolean result = true;\par
  503     while((bytesRemaining > 0) && result) \{\par
  504         bytesToWrite = (bytesRemaining > MQTT_MAX_TRANSFER_SIZE)?MQTT_MAX_TRANSFER_SIZE:bytesRemaining;\par
  505         rc = _client->write(writeBuf,bytesToWrite);\par
  506         result = (rc == bytesToWrite);\par
  507         bytesRemaining -= rc;\par
  508         writeBuf += rc;\par
  509     \}\par
  510     return result;\par
  511 #else\par
  512     rc = _client->write(buf+(4-llen),length+1+llen);\par
  513     lastOutActivity = millis();\par
  514     return (rc == 1+llen+length);\par
  515 #endif\par
  516 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a7a8e4854a1846eaa668046d3854d47ad_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeString\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:writeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::writeString (const char *  {\i string}, uint8_t *  {\i buf}, uint16_t  {\i pos}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 574 of file CoolPubSubClient.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   574                                                                                      \{\par
  575     const char* idp = string;\par
  576     uint16_t i = 0;\par
  577     pos += 2;\par
  578     while (*idp) \{\par
  579         buf[pos++] = *idp++;\par
  580         i++;\par
  581     \}\par
  582     buf[pos-i-2] = (i >> 8);\par
  583     buf[pos-i-1] = (i & 0xFF);\par
  584     return pos;\par
  585 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d4b/class_cool_pub_sub_client_a0e3d7e776d4cf4427f9569b28868905a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _client\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:_client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Client* CoolPubSubClient::_client{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolPubSubClient.h.}\par
}
{\xe \v _state\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolPubSubClient::_state{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file CoolPubSubClient.h.}\par
}
{\xe \v buffer\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t* CoolPubSubClient::buffer{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolPubSubClient.h.}\par
}
{\xe \v buffer_size\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:buffer_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::buffer_size{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolPubSubClient.h.}\par
}
{\xe \v domain\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:domain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CoolPubSubClient::domain{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolPubSubClient.h.}\par
}
{\xe \v ip\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress CoolPubSubClient::ip{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file CoolPubSubClient.h.}\par
}
{\xe \v keepAlive\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:keepAlive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::keepAlive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolPubSubClient.h.}\par
}
{\xe \v lastInActivity\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:lastInActivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolPubSubClient::lastInActivity{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file CoolPubSubClient.h.}\par
}
{\xe \v lastOutActivity\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:lastOutActivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolPubSubClient::lastOutActivity{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CALLBACK_SIGNATURE\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:MQTT_CALLBACK_SIGNATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoolPubSubClient::MQTT_CALLBACK_SIGNATURE{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file CoolPubSubClient.h.}\par
}
{\xe \v nextMsgId\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:nextMsgId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::nextMsgId{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file CoolPubSubClient.h.}\par
}
{\xe \v pingOutstanding\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:pingOutstanding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolPubSubClient::pingOutstanding{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolPubSubClient.h.}\par
}
{\xe \v port\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::port{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file CoolPubSubClient.h.}\par
}
{\xe \v socketTimeout\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:socketTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolPubSubClient::socketTimeout{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolPubSubClient.h.}\par
}
{\xe \v stream\:CoolPubSubClient}
{\xe \v CoolPubSubClient\:stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Stream* CoolPubSubClient::stream{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolPubSubClient.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolPubSubClient.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolSI114X Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolSI114X}
{\xe \v CoolSI114X}
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\par
{
{\f2 #include <CoolSI114X.h>}}\par
Collaboration diagram for CoolSI114X:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d2d/class_cool_s_i114_x__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Begin} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Reset} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeInit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ReadParamData} (uint8_t Reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b WriteParamData} (uint8_t Reg, uint8_t Value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadVisible} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadIR} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadProximity} (uint8_t PSn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadUV} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteByte} (uint8_t Reg, uint8_t Value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ReadByte} (uint8_t Reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b ReadHalfWord} (uint8_t Reg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 165 of file CoolSI114X.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Begin\:CoolSI114X}
{\xe \v CoolSI114X\:Begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolSI114X::Begin (void )}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    92 \{\par
   93   Wire.begin(2,14);\par
   94   //\par
   95   //Init IIC  and reset si1145\par
   96   //\par
   97   if(ReadByte(CoolSI114X_PART_ID)!=0X45)\par
   98   \{\par
   99     return false;\par
  100   \}\par
  101   Reset();\par
  102   //\par
  103   //INIT \par
  104   //\par
  105   DeInit();\par
  106   return true;\par
  107 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a206b36aca7049f63be1d11088c30a09f_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a206b36aca7049f63be1d11088c30a09f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DeInit\:CoolSI114X}
{\xe \v CoolSI114X\:DeInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolSI114X::DeInit (void )}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    42 \{  \par
   43   //ENABLE UV reading  \par
   44   //these reg must be set to the fixed value\par
   45   WriteByte(CoolSI114X_UCOEFF0, 0x29);\par
   46   WriteByte(CoolSI114X_UCOEFF1, 0x89);\par
   47   WriteByte(CoolSI114X_UCOEFF2, 0x02);\par
   48   WriteByte(CoolSI114X_UCOEFF3, 0x00);\par
   49   WriteParamData(CoolSI114X_CHLIST, CoolSI114X_CHLIST_ENUV |CoolSI114X_CHLIST_ENALSIR | CoolSI114X_CHLIST_ENALSVIS |CoolSI114X_CHLIST_ENPS1);\par
   50   //\par
   51   //set LED1 CURRENT(22.4mA)(It is a normal value for many LED)\par
   52   //\par
   53   WriteParamData(CoolSI114X_PS1_ADCMUX, CoolSI114X_ADCMUX_LARGE_IR);\par
   54   WriteByte(CoolSI114X_PS_LED21, CoolSI114X_LED_CURRENT_22MA);\par
   55   WriteParamData(CoolSI114X_PSLED12_SELECT, CoolSI114X_PSLED12_SELECT_PS1_LED1); //\par
   56   //\par
   57   //PS ADC SETTING\par
   58   //\par
   59   WriteParamData(CoolSI114X_PS_ADC_GAIN, CoolSI114X_ADC_GAIN_DIV1);\par
   60   WriteParamData(CoolSI114X_PS_ADC_COUNTER, CoolSI114X_ADC_COUNTER_511ADCCLK);\par
   61   WriteParamData(CoolSI114X_PS_ADC_MISC, CoolSI114X_ADC_MISC_HIGHRANGE|CoolSI114X_ADC_MISC_ADC_RAWADC); \par
   62   //\par
   63   //VIS ADC SETTING\par
   64   //\par
   65   WriteParamData(CoolSI114X_ALS_VIS_ADC_GAIN, CoolSI114X_ADC_GAIN_DIV1);\par
   66   WriteParamData(CoolSI114X_ALS_VIS_ADC_COUNTER, CoolSI114X_ADC_COUNTER_511ADCCLK);\par
   67   WriteParamData(CoolSI114X_ALS_VIS_ADC_MISC, CoolSI114X_ADC_MISC_HIGHRANGE);\par
   68   //\par
   69   //IR ADC SETTING\par
   70   //\par
   71   WriteParamData(CoolSI114X_ALS_IR_ADC_GAIN, CoolSI114X_ADC_GAIN_DIV1);\par
   72   WriteParamData(CoolSI114X_ALS_IR_ADC_COUNTER, CoolSI114X_ADC_COUNTER_511ADCCLK);\par
   73   WriteParamData(CoolSI114X_ALS_IR_ADC_MISC, CoolSI114X_ADC_MISC_HIGHRANGE);\par
   74   //\par
   75   //interrupt enable\par
   76   //\par
   77   WriteByte(CoolSI114X_INT_CFG, CoolSI114X_INT_CFG_INTOE);  \par
   78   WriteByte(CoolSI114X_IRQ_ENABLE, CoolSI114X_IRQEN_ALS);  \par
   79   //\par
   80   //AUTO RUN\par
   81   //\par
   82   WriteByte(CoolSI114X_MEAS_RATE0, 0xFF);\par
   83   WriteByte(CoolSI114X_COMMAND, CoolSI114X_PSALS_AUTO);\par
   84 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a6840abd53a2e3d71a6bb918077c6d6e6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a6840abd53a2e3d71a6bb918077c6d6e6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadByte\:CoolSI114X}
{\xe \v CoolSI114X\:ReadByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CoolSI114X::ReadByte (uint8_t  {\i Reg}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144 \{\par
  145     Wire.beginTransmission(CoolSI114X_ADDR);\par
  146     Wire.write(Reg);\par
  147     Wire.endTransmission();\par
  148     Wire.requestFrom(CoolSI114X_ADDR, 1);  \par
  149     return Wire.read();\par
  150 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_acc20f8037e156ec4aadcbe90780b1e8b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadHalfWord\:CoolSI114X}
{\xe \v CoolSI114X\:ReadHalfWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadHalfWord (uint8_t  {\i Reg}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157   uint16_t Value;\par
  158   Wire.beginTransmission(CoolSI114X_ADDR);\par
  159   Wire.write(Reg); \par
  160   Wire.endTransmission(); \par
  161   Wire.requestFrom(CoolSI114X_ADDR, 2);\par
  162   Value = Wire.read();\par
  163   Value |= (uint16_t)Wire.read() << 8; \par
  164   return Value;\par
  165 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a1d25c9e137874af529804c2ec796a6b9_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadIR\:CoolSI114X}
{\xe \v CoolSI114X\:ReadIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadIR (void )}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 200 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   201 \{\par
  202   return ReadHalfWord(CoolSI114X_ALS_IR_DATA0);     \par
  203 \} \par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abc536ee7ae8e3ba9d1069acc3889a2cf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abc536ee7ae8e3ba9d1069acc3889a2cf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadParamData\:CoolSI114X}
{\xe \v CoolSI114X\:ReadParamData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CoolSI114X::ReadParamData (uint8_t  {\i Reg})}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 170 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   171 \{\par
  172     WriteByte(CoolSI114X_COMMAND, Reg | CoolSI114X_QUERY);\par
  173     return ReadByte(CoolSI114X_RD);\par
  174 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a33cf431103c722442f6a0cc93848d640_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadProximity\:CoolSI114X}
{\xe \v CoolSI114X\:ReadProximity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadProximity (uint8_t  {\i PSn})}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 208 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   209 \{\par
  210   return ReadHalfWord(PSn);     \par
  211 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a194fede1105508c7803dbb567cbdcc67_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadUV\:CoolSI114X}
{\xe \v CoolSI114X\:ReadUV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadUV (void )}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218 \{\par
  219   return (ReadHalfWord(CoolSI114X_AUX_DATA0_UVINDEX0));     \par
  220 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a14ced664d74e93438440b0274109c111_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a14ced664d74e93438440b0274109c111_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReadVisible\:CoolSI114X}
{\xe \v CoolSI114X\:ReadVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t CoolSI114X::ReadVisible (void )}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194   return ReadHalfWord(CoolSI114X_ALS_VIS_DATA0);    \par
  195 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a42e0e574256341443c647a4c0eda87d5_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a42e0e574256341443c647a4c0eda87d5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Reset\:CoolSI114X}
{\xe \v CoolSI114X\:Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolSI114X::Reset (void )}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114 \{\par
  115   WriteByte(CoolSI114X_MEAS_RATE0, 0);\par
  116   WriteByte(CoolSI114X_MEAS_RATE1, 0);\par
  117   WriteByte(CoolSI114X_IRQ_ENABLE, 0);\par
  118   WriteByte(CoolSI114X_IRQ_MODE1, 0);\par
  119   WriteByte(CoolSI114X_IRQ_MODE2, 0);\par
  120   WriteByte(CoolSI114X_INT_CFG, 0);\par
  121   WriteByte(CoolSI114X_IRQ_STATUS, 0xFF);\par
  122 \par
  123   WriteByte(CoolSI114X_COMMAND, CoolSI114X_RESET);\par
  124   delay(10);\par
  125   WriteByte(CoolSI114X_HW_KEY, 0x17);\par
  126   delay(10);\par
  127 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a9d9f9c9129c0c29ed497f8563f3dd823_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_a9d9f9c9129c0c29ed497f8563f3dd823_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WriteByte\:CoolSI114X}
{\xe \v CoolSI114X\:WriteByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolSI114X::WriteByte (uint8_t  {\i Reg}, uint8_t  {\i Value}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   133 \{\par
  134   Wire.beginTransmission(CoolSI114X_ADDR); \par
  135   Wire.write(Reg); \par
  136   Wire.write(Value); \par
  137   Wire.endTransmission(); \par
  138 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_ac5c8dc5ade604da7a1c8cd1586feefc2_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WriteParamData\:CoolSI114X}
{\xe \v CoolSI114X\:WriteParamData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CoolSI114X::WriteParamData (uint8_t  {\i Reg}, uint8_t  {\i Value})}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 179 of file CoolSI114X.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   180 \{\par
  181     //write Value into PARAMWR reg first\par
  182    WriteByte(CoolSI114X_WR, Value);\par
  183    WriteByte(CoolSI114X_COMMAND, Reg | CoolSI114X_SET);\par
  184    //CoolSI114X writes value out to PARAM_RD,read and confirm its right\par
  185    return ReadByte(CoolSI114X_RD);\par
  186 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abf45eb10a6de1be16e68a51624fa2608_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d67/class_cool_s_i114_x_abf45eb10a6de1be16e68a51624fa2608_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSI114X.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolTime Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolTime}
{\xe \v CoolTime}
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC . }}\par
{
{\f2 #include <CoolTime.h>}}\par
Collaboration diagram for CoolTime:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d40/class_cool_time__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b config} (IPAddress {\b timeServer}, unsigned int {\b localPort})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDateTime} (int year, int month, int day, int hour, int minutes, int seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tmElements_t {\b getTimeDate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getESDate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getLastSyncTime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTimeSync} (unsigned long seconds=604800)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b getNtpTime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendNTPpacket} (IPAddress &address)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b formatDigits} (int digits)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveTimeSync} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeSync} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b timeServer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WiFiUDP {\b Udp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b localPort} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b packetBuffer} [{\b NTP_PACKET_SIZE}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tmElements_t {\b tmSet}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DS1337RTC {\b rtc}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC . \par
}{
Definition at line 52 of file CoolTime.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CoolTime}
{\xe \v CoolTime\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::begin ()}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::begin()}: This method is provided to init the udp connection \par
}{
Definition at line 52 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    53 \{\par
   54 \par
   55 #if DEBUG == 1 \par
   56 \par
   57     Serial.println( F("Entering CoolTime.begin()") );\par
   58     Serial.println();\par
   59 \par
   60 #endif \par
   61 \par
   62 \par
   63     Udp.begin(localPort);\par
   64     \par
   65     this->update();\par
   66     \par
   67 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ab1976cf718b950bc31e003c3323b8adb_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ab1976cf718b950bc31e003c3323b8adb_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolTime}
{\xe \v CoolTime\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolTime::config ()}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::config()}: This method is provided to configure the {\b CoolTime} object through a configuration file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 425 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   426 \{\par
  427 \par
  428 #if DEBUG == 1 \par
  429 \par
  430     Serial.println( F("Enter CoolTime.config()") );\par
  431     Serial.println();\par
  432 \par
  433 #endif \par
  434 \par
  435     File rtcConfig = SPIFFS.open("/rtcConfig.json", "r");\par
  436 \par
  437     if (!rtcConfig) \par
  438     \{\par
  439     \par
  440         Serial.println( F("failed to read /rtcConfig.json") );\par
  441         Serial.println();\par
  442 \par
  443         return(false);\par
  444     \}\par
  445     else\par
  446     \{\par
  447         size_t size = rtcConfig.size();\par
  448         // Allocate a buffer to store contents of the file.\par
  449         std::unique_ptr<char[]> buf(new char[size]);\par
  450 \par
  451         rtcConfig.readBytes(buf.get(), size);\par
  452         DynamicJsonBuffer jsonBuffer;\par
  453         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  454         if (!json.success()) \par
  455         \{\par
  456 \par
  457             Serial.println( F("failed to parse rtcConfig json") );\par
  458             Serial.println();\par
  459 \par
  460             return(false);\par
  461         \} \par
  462         else\par
  463         \{  \par
  464         \par
  465         #if DEBUG == 1 \par
  466 \par
  467             Serial.println( F("configuration json is :") );\par
  468             json.printTo(Serial);\par
  469             Serial.println();\par
  470 \par
  471             Serial.print(F("jsonBuffer size: "));\par
  472             Serial.println(jsonBuffer.size());\par
  473             Serial.println();\par
  474 \par
  475 \par
  476         #endif\par
  477 \par
  478             String ip;\par
  479             \par
  480             if(json["timeServer"].success() )\par
  481             \{           \par
  482                  ip=json["timeServer"].as<String>();\par
  483                 this->timeServer.fromString(ip);\par
  484                 \par
  485             \}\par
  486             else\par
  487             \{\par
  488                 this->timeServer=this->timeServer;\par
  489             \}\par
  490             json["timeServer"]=ip;\par
  491             \par
  492             if(json["localPort"].success() )\par
  493             \{                       \par
  494                 this->localPort=json["localPort"];\par
  495             \}\par
  496             else\par
  497             \{\par
  498                 this->localPort=this->localPort;\par
  499             \}\par
  500             json["localPort"]=this->localPort;\par
  501 \par
  502 \par
  503             if( json["timeSync"].success() )\par
  504             \{\par
  505 \par
  506                 this->timeSync=json["timeSync"];\par
  507             \}\par
  508             else\par
  509             \{\par
  510                 this->timeSync=this->timeSync;\par
  511             \}\par
  512             json["timeSync"]=this->timeSync;\par
  513 \par
  514             rtcConfig.close();\par
  515             rtcConfig= SPIFFS.open("/rtcConfig.json", "w");\par
  516             \par
  517             if(!rtcConfig)\par
  518             \{\par
  519             \par
  520             #if DEBUG == 1\par
  521 \par
  522                 Serial.println( F("failed to write to /rtcConfig.json") );\par
  523                 Serial.println();\par
  524             \par
  525             #endif\par
  526 \par
  527                 return(false);\par
  528             \}\par
  529             \par
  530             json.printTo(rtcConfig);\par
  531             rtcConfig.close();\par
  532 \par
  533         #if DEBUG == 1 \par
  534 \par
  535             Serial.println( F("configuration is :") );\par
  536             json.printTo(Serial);\par
  537             Serial.println();\par
  538         \par
  539         #endif\par
  540         \par
  541             return(true); \par
  542         \}\par
  543     \}   \par
  544 \par
  545 \par
  546 \par
  547 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a87c28260c1bc77091162cbcf1ee2e129_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolTime}
{\xe \v CoolTime\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::config (IPAddress  {\i timeServer}, unsigned int  {\i localPort})}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::config(Time server IP , udp Port): This method is provided to do manual configuration. \par
}{
Definition at line 402 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   403 \{\par
  404 \par
  405 #if DEBUG == 1 \par
  406 \par
  407     Serial.println( F("Enter CoomTime.config() , no SPIFFS variant ") );\par
  408     Serial.println();\par
  409 \par
  410 #endif \par
  411 \par
  412     this->timeServer=timeServer;\par
  413     this->localPort=localPort;\par
  414     \par
  415 \} \par
}
}
{\xe \v formatDigits\:CoolTime}
{\xe \v CoolTime\:formatDigits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolTime::formatDigits (int  {\i digits})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::printDigits(digit)\par
utility method for digital clock display adds leading 0\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid formatted string of the input digit \par
}}{
Definition at line 706 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{\par
  708 \par
  709 #if DEBUG == 1 \par
  710 \par
  711     Serial.println( F("Entering CoolTime.formatDigits()") );\par
  712     Serial.println();\par
  713 \par
  714 #endif \par
  715 \par
  716     if(digits < 10)\par
  717     \{\par
  718     \par
  719     #if DEBUG == 1\par
  720 \par
  721         Serial.println( F("output digit : ") );\par
  722         Serial.println( String("0") + String(digits) );\par
  723 \par
  724     #endif\par
  725 \par
  726         return( String("0") + String(digits) );\par
  727     \}\par
  728     \par
  729 #if DEBUG == 1 \par
  730 \par
  731     Serial.println( F("output digit : ") );\par
  732     Serial.println(digits);\par
  733 \par
  734 #endif\par
  735 \par
  736     return( String(digits) );\par
  737 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_acd537cd4210d7bde4e1f5c47d2ac0456_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getESDate\:CoolTime}
{\xe \v CoolTime\:getESDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolTime::getESDate ()}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::getESD(): This method is provided to return an Elastic Search compatible date Format\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid date String in Elastic Search format \par
}}{
Definition at line 204 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   205 \{\par
  206 \par
  207 #if DEBUG == 1 \par
  208 \par
  209     Serial.println( F("Entering CoolTime.getESDate()") );\par
  210     Serial.println();\par
  211 \par
  212 #endif \par
  213 \par
  214     tmElements_t tm=this->getTimeDate();\par
  215 \par
  216     //"20yy-mm-ddT00:00:00Z"\par
  217     String elasticSearchString =String(tm.Year+1970)+"-"+this->formatDigits(tm.Month)+"-";\par
  218 \par
  219     elasticSearchString +=this->formatDigits(tm.Day)+"T"+this->formatDigits(tm.Hour)+":";\par
  220     \par
  221     elasticSearchString +=this->formatDigits(tm.Minute)+":"+this->formatDigits(tm.Second)+"Z";\par
  222 \par
  223 #if DEBUG == 1 \par
  224 \par
  225     Serial.print( F("elastic Search date : ") );\par
  226     Serial.println(elasticSearchString);\par
  227     Serial.println();\par
  228 \par
  229 #endif\par
  230 \par
  231     return (elasticSearchString);\par
  232 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ac4f32ee513c1328d984306645e8785a4_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ac4f32ee513c1328d984306645e8785a4_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getLastSyncTime\:CoolTime}
{\xe \v CoolTime\:getLastSyncTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolTime::getLastSyncTime ()}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::getLastSyncTime()}: This method is provided to get the last time we syncronised the time\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid unsigned long representation of last syncronisation time in seconds \par
}}{
Definition at line 242 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   243 \{\par
  244 \par
  245 #if DEBUG == 1 \par
  246 \par
  247     Serial.println( F("Entering CoolTime.getLastSyncTime()") );\par
  248     Serial.println();\par
  249     \par
  250     Serial.print( F("last sync time : ") );\par
  251     Serial.println(this->timeSync);\par
  252 \par
  253 #endif \par
  254 \par
  255     return(this->timeSync);\par
  256 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a5d17f707a9d337720493b2bce9d41c21_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getNtpTime\:CoolTime}
{\xe \v CoolTime\:getNtpTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t CoolTime::getNtpTime ()}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::getNtopTime(): This method is provided to get the Time through an NTP request to a Time Server\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a time_t (unsigned long ) timestamp in seconds \par
}}{
Definition at line 308 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   309 \{\par
  310 \par
  311 #if DEBUG == 1 \par
  312 \par
  313     Serial.println( F("Entering CoolTime.getNtpTime()") );\par
  314     Serial.println();\par
  315 \par
  316 #endif \par
  317 \par
  318     while (Udp.parsePacket() > 0) ; // discard any previously received packets\par
  319 \par
  320     Serial.println( F("Transmit NTP Request") );\par
  321 \par
  322     sendNTPpacket(timeServer);\par
  323 \par
  324     uint32_t beginWait = millis();\par
  325 \par
  326     while (millis() - beginWait < 1500) \par
  327     \{\par
  328         int size = Udp.parsePacket();\par
  329         if (size >= NTP_PACKET_SIZE) \par
  330         \{\par
  331         \par
  332         #if DEBUG == 1\par
  333 \par
  334             Serial.println( F("Receive NTP Response") );\par
  335         \par
  336         #endif\par
  337 \par
  338             Udp.read(packetBuffer, NTP_PACKET_SIZE);  // read packet into the buffer\par
  339             unsigned long secsSince1900;\par
  340             // convert four bytes starting at location 40 to a long integer\par
  341             secsSince1900 =  (unsigned long)packetBuffer[40] << 24;\par
  342             secsSince1900 |= (unsigned long)packetBuffer[41] << 16;\par
  343             secsSince1900 |= (unsigned long)packetBuffer[42] << 8;\par
  344             secsSince1900 |= (unsigned long)packetBuffer[43];\par
  345         \par
  346         #if DEBUG == 1 \par
  347     \par
  348             Serial.print( F("received unix time : ") );\par
  349             Serial.println(secsSince1900 - 2208988800UL);\par
  350             Serial.println();\par
  351 \par
  352         #endif \par
  353 \par
  354             return secsSince1900 - 2208988800UL ;\par
  355         \}\par
  356     \}\par
  357     \par
  358     Serial.println( F("No NTP Response :-(") );\par
  359 \par
  360     return 0; // return 0 if unable to get the time\par
  361 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a41fbbbfd651c2079f54d4b2911e4c705_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a41fbbbfd651c2079f54d4b2911e4c705_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTimeDate\:CoolTime}
{\xe \v CoolTime\:getTimeDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tmElements_t CoolTime::getTimeDate ()}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::getTimeDate()}: This method is provided to get the RTC Time\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a tmElements_t structre that has the time in it \par
}}{
Definition at line 161 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162 \{\par
  163 \par
  164 #if DEBUG == 1 \par
  165     \par
  166     Serial.println( F("Entering CoolTime.getTimeDate()") );\par
  167     Serial.println();\par
  168 \par
  169 #endif\par
  170 \par
  171     tmElements_t tm;\par
  172     time_t timeDate = this->rtc.get(CLOCK_ADDRESS);\par
  173     breakTime(timeDate,tm);\par
  174 \par
  175 #if DEBUG == 1\par
  176     \par
  177     Serial.print( F("time is : ") );\par
  178     Serial.print(tm.Year+ 1970 );\par
  179     Serial.print( F("-") );\par
  180     Serial.print( this->formatDigits( tm.Month ) );\par
  181     Serial.print( F("-") );\par
  182     Serial.print( this->formatDigits( tm.Day ) );\par
  183     Serial.print( F("T") );\par
  184     Serial.print( this->formatDigits( tm.Hour ) );\par
  185     Serial.print( F(":") );\par
  186     Serial.print( this->formatDigits( tm.Minute ) );\par
  187     Serial.print( F(":") );\par
  188     Serial.print( this->formatDigits( tm.Second ) );\par
  189     Serial.print( F("Z") );\par
  190 \par
  191 #endif\par
  192     \par
  193     return(tm);\par
  194 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a7a7501c5ca77dd1248bea704c44f986c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a7a7501c5ca77dd1248bea704c44f986c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isTimeSync\:CoolTime}
{\xe \v CoolTime\:isTimeSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolTime::isTimeSync (unsigned long  {\i seconds} = {\f2 604800})}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::isTimeSync( time in seconds): This method is provided to test if the time is syncronised or not. By default we test once per week.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if time is syncronised,false otherwise \par
}}{
Definition at line 268 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   269 \{\par
  270 \par
  271 #if DEBUG == 1\par
  272 \par
  273     Serial.println( F("Entering CoolTime.isTimeSync() ") );\par
  274     Serial.println();\par
  275 \par
  276 #endif \par
  277 \par
  278 #if DEBUG == 0\par
  279 \par
  280     Serial.println( F("Check if Clock is ok and in sync..."));\par
  281 \par
  282 #endif\par
  283 \par
  284     //default is once per week we try to get a time update\par
  285     if( ( RTC.get(CLOCK_ADDRESS) - this->getLastSyncTime() ) > ( seconds ) ) \par
  286     \{\par
  287 \par
  288         Serial.println( F("time is not syncronised ") );\par
  289     \par
  290         return(false);  \par
  291     \}\par
  292     \par
  293     Serial.println( F("time is syncronised : OK") );\par
  294     Serial.println();\par
  295 \par
  296     return(true);\par
  297 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a5ae038a4498602b189f76a10bf02adf8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a5ae038a4498602b189f76a10bf02adf8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolTime}
{\xe \v CoolTime\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::printConf ()}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::printConf()}: This method is provided to print the {\b CoolTime} configuration to the Serial Monitor \par
}{
Definition at line 679 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   680 \{\par
  681 \par
  682 #if DEBUG == 1\par
  683 \par
  684     Serial.println( F("Entering CoolTime.printConf()") );\par
  685     Serial.println();\par
  686 \par
  687 #endif \par
  688 \par
  689     Serial.println("RTC Configuration") ;\par
  690 \par
  691     Serial.print("timeServer : ");\par
  692     Serial.println(timeServer);\par
  693     \par
  694     Serial.print("localPort : :");\par
  695     Serial.println(localPort);\par
  696 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_af355e7f9b3898211cd2ff25eab5933b1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v saveTimeSync\:CoolTime}
{\xe \v CoolTime\:saveTimeSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolTime::saveTimeSync ()}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::saveTimeSync()} This method is provided to save the last sync time in the SPIFFS.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 558 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   559 \{\par
  560     Serial.println( F("Enter CoolTime.saveTimeSync()") );\par
  561     Serial.println();\par
  562 \par
  563     File rtcConfig = SPIFFS.open("/rtcConfig.json", "r");\par
  564 \par
  565     if (!rtcConfig) \par
  566     \{\par
  567         Serial.println( F("failed to read /rtcConfig.json") );\par
  568         Serial.println();\par
  569 \par
  570         return(false);\par
  571     \}\par
  572     else\par
  573     \{\par
  574         size_t size = rtcConfig.size();\par
  575         // Allocate a buffer to store contents of the file.\par
  576         std::unique_ptr<char[]> buf(new char[size]);\par
  577 \par
  578         rtcConfig.readBytes(buf.get(), size);\par
  579         DynamicJsonBuffer jsonBuffer;\par
  580         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  581         if (!json.success()) \par
  582         \{\par
  583 \par
  584             Serial.println( F("failed to parse json") );\par
  585             Serial.println();\par
  586 \par
  587             return(false);\par
  588         \} \par
  589         else\par
  590         \{\par
  591 \par
  592         #if DEBUG == 1\par
  593     \par
  594             Serial.println( F("configuration json is :") );\par
  595             json.printTo(Serial);\par
  596             Serial.println();\par
  597 \par
  598             Serial.print(F("jsonBuffer size: "));\par
  599             Serial.println(jsonBuffer.size());\par
  600             Serial.println();\par
  601 \par
  602         #endif\par
  603 \par
  604             String ip;\par
  605                     \par
  606             if(json["timeServer"].success() )\par
  607             \{           \par
  608                  ip=json["timeServer"].as<String>();\par
  609                 this->timeServer.fromString(ip);\par
  610                 \par
  611             \}\par
  612             else\par
  613             \{\par
  614                 this->timeServer=this->timeServer;\par
  615             \}\par
  616             json["timeServer"]=ip;\par
  617             \par
  618             if(json["localPort"].success() )\par
  619             \{                       \par
  620                 this->localPort=json["localPort"];\par
  621             \}\par
  622             else\par
  623             \{\par
  624                 this->localPort=this->localPort;\par
  625             \}\par
  626             json["localPort"]=this->localPort;\par
  627 \par
  628 \par
  629             if( json["timeSync"].success() )\par
  630             \{\par
  631                 json["timeSync"]=this->timeSync;\par
  632             \}\par
  633             else\par
  634             \{\par
  635                 this->timeSync=this->timeSync;\par
  636             \}\par
  637             json["timeSync"]=this->timeSync;\par
  638 \par
  639 \par
  640             rtcConfig.close();\par
  641             rtcConfig= SPIFFS.open("/rtcConfig.json", "w");\par
  642             \par
  643             if(!rtcConfig)\par
  644             \{\par
  645             #if DEBUG == 1\par
  646 \par
  647                 Serial.println( F("failed to write timeSync to /rtcConfig.json") );\par
  648                 Serial.println();\par
  649             \par
  650             #endif\par
  651 \par
  652                 return(false);\par
  653             \}\par
  654             \par
  655             json.printTo(rtcConfig);\par
  656             rtcConfig.close();\par
  657     \par
  658         #if DEBUG == 1\par
  659 \par
  660             Serial.println( F("configuration is :") );\par
  661             json.printTo(Serial);\par
  662             Serial.println();\par
  663         \par
  664         #endif\par
  665             return(true); \par
  666         \}\par
  667     \}   \par
  668 \par
  669 \par
  670 \par
  671 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ae9658c9b377510d469e3b88edf33ee85_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sendNTPpacket\:CoolTime}
{\xe \v CoolTime\:sendNTPpacket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::sendNTPpacket (IPAddress &  {\i address})}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::sendNTPpacket( Time Server IP address): This method is provided to send an NTP request to the time server at the given address \par
}{
Definition at line 368 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   369 \{\par
  370 \par
  371 #if DEBUG == 1 \par
  372 \par
  373     Serial.println( F("Enter CoolTime.sendNTPpacket()") );\par
  374     Serial.println();\par
  375 \par
  376 #endif\par
  377 \par
  378     memset(packetBuffer, 0, NTP_PACKET_SIZE);\par
  379     // Initialize values needed to form NTP request\par
  380     // (see URL above for details on the packets)\par
  381     packetBuffer[0] = 0b11100011;   // LI, Version, Mode\par
  382     packetBuffer[1] = 0;     // Stratum, or type of clock\par
  383     packetBuffer[2] = 6;     // Polling Interval\par
  384     packetBuffer[3] = 0xEC;  // Peer Clock Precision\par
  385     // 8 bytes of zero for Root Delay & Root Dispersion\par
  386     packetBuffer[12]  = 49;\par
  387     packetBuffer[13]  = 0x4E;\par
  388     packetBuffer[14]  = 49;\par
  389     packetBuffer[15]  = 52;\par
  390     // all NTP fields have been given values, now\par
  391     // you can send a packet requesting a timestamp:                 \par
  392     Udp.beginPacket(address, 123); //NTP requests are to port 123\par
  393     Udp.write(packetBuffer, NTP_PACKET_SIZE);\par
  394     Udp.endPacket();    \par
  395 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_a236a38d120dc53bc67456d763838c5a1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setDateTime\:CoolTime}
{\xe \v CoolTime\:setDateTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::setDateTime (int  {\i year}, int  {\i month}, int  {\i day}, int  {\i hour}, int  {\i minutes}, int  {\i seconds})}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolTime::setDateTime(year,month,dat,hour,minutes,seconds): This method is provided to manually set the RTc Time \par
}{
Definition at line 107 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   108 \{ \par
  109 \par
  110 #if DEBUG == 1\par
  111 \par
  112     Serial.println( F("Entering CoolTime.setDateTime") );\par
  113     Serial.println();\par
  114 \par
  115 #endif\par
  116 \par
  117     tmElements_t tm;\par
  118     tm.Second=seconds; \par
  119     tm.Minute=minutes; \par
  120     tm.Hour=hour; \par
  121     tm.Day=day;\par
  122     tm.Month=month; \par
  123     tm.Year=year;\par
  124     \par
  125     this->rtc.set(makeTime(tm),CLOCK_ADDRESS);   \par
  126 \par
  127 #if DEBUG == 1\par
  128 \par
  129     Serial.print( F("setting time to : ") );//"20yy-mm-ddT00:00:00Z\par
  130 \par
  131     Serial.print(tm.Year);\par
  132     Serial.print( F("-") );\par
  133     Serial.print( this->formatDigits( tm.Month ) );\par
  134     Serial.print( F("-") );\par
  135     Serial.print( this->formatDigits( tm.Day ) );\par
  136     Serial.print( F("T") );\par
  137     Serial.print( this->formatDigits( tm.Hour ) );\par
  138     Serial.print( F(":") );\par
  139     Serial.print( this->formatDigits( tm.Minute ) );\par
  140     Serial.print( F(":") );\par
  141     Serial.print( this->formatDigits( tm.Second ) );\par
  142     Serial.print( F("Z") );\par
  143 \par
  144     Serial.println();\par
  145     \par
  146     Serial.print( F("time set to : ") );\par
  147     Serial.println(this->getESDate());\par
  148     Serial.println();\par
  149 \par
  150 #endif\par
  151 \par
  152 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_ab81ea7fdaace111aa01cc1ec84c6d297_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v update\:CoolTime}
{\xe \v CoolTime\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolTime::update ()}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime::update()}: This method is provided to correct the rtc Time when it drifts,once every week. \par
}{
Definition at line 74 of file CoolTime.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75 \{\par
   76 \par
   77 #if DEBUG == 1\par
   78 \par
   79     Serial.println( F("Entering CoolTime.update()") );\par
   80     Serial.println();\par
   81 \par
   82 #endif \par
   83 \par
   84     if( !( this->isTimeSync() ) )\par
   85     \{\par
   86     \par
   87     #if DEBUG == 1\par
   88 \par
   89         Serial.println( F("waiting for sync") );\par
   90         Serial.println();\par
   91 \par
   92     #endif \par
   93 \par
   94         this->timeSync=this->getNtpTime();\par
   95         breakTime(this->getNtpTime(), this->tmSet);\par
   96         this->rtc.set(makeTime(this->tmSet), CLOCK_ADDRESS); // set the clock\par
   97         this->saveTimeSync();\par
   98     \}\par
   99     \par
  100 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_aae601f795452cfa48d9fb337aed483a8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d49/class_cool_time_aae601f795452cfa48d9fb337aed483a8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v localPort\:CoolTime}
{\xe \v CoolTime\:localPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CoolTime::localPort =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolTime.h.}\par
}
{\xe \v packetBuffer\:CoolTime}
{\xe \v CoolTime\:packetBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte CoolTime::packetBuffer[{\b NTP_PACKET_SIZE}]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file CoolTime.h.}\par
}
{\xe \v rtc\:CoolTime}
{\xe \v CoolTime\:rtc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DS1337RTC CoolTime::rtc{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file CoolTime.h.}\par
}
{\xe \v timeServer\:CoolTime}
{\xe \v CoolTime\:timeServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress CoolTime::timeServer{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolTime.h.}\par
}
{\xe \v timeSync\:CoolTime}
{\xe \v CoolTime\:timeSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolTime::timeSync =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolTime.h.}\par
}
{\xe \v tmSet\:CoolTime}
{\xe \v CoolTime\:tmSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tmElements_t CoolTime::tmSet{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolTime.h.}\par
}
{\xe \v Udp\:CoolTime}
{\xe \v CoolTime\:Udp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiUDP CoolTime::Udp{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolTime.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolTime.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolWifi Class Reference\par \pard\plain 
{\tc\tcl2 \v CoolWifi}
{\xe \v CoolWifi}
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection . }}\par
{
{\f2 #include <CoolWifi.h>}}\par
Collaboration diagram for CoolWifi:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dff/class_cool_wifi__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} (String {\b ssid}[], String {\b pass}[], int wifiNumber, int APTimeOut, bool {\b nomad})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b connect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b connectWifiMulti} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b connectAP} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
wl_status_t {\b state} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addWifi} (String {\b ssid}, String {\b pass}="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ESP8266WiFiMulti {\b wifiMulti}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wifiCount} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b ssid} [50] =\{"0"\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b pass} [50] =\{"0"\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b timeOut} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b nomad} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection . \par
}{
Definition at line 50 of file CoolWifi.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addWifi\:CoolWifi}
{\xe \v CoolWifi\:addWifi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::addWifi (String  {\i ssid}, String  {\i pass} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolWifi::addWifi(ssid,pass) This method is provided to add new WiFi detected by the {\b WiFiManager} to the jsonConfig(if used )\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successfull , false otherwise \par
}}{
Definition at line 569 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   570 \{\par
  571 \par
  572 #if DEBUG == 1\par
  573     \par
  574     Serial.println("Entering CoolWifi.addWifi() ") ;\par
  575 \par
  576 #endif  \par
  577     \par
  578     this->wifiCount++;\par
  579     if( this->wifiCount >=50)\par
  580     \{\par
  581     \par
  582     #if DEBUG == 1\par
  583 \par
  584         Serial.println("You have reached the limit of 50");\par
  585         return(false);  \par
  586     \par
  587     #endif\par
  588 \par
  589     \}\par
  590 \par
  591     this->ssid[this->wifiCount-1]=ssid;\par
  592     this->pass[this->wifiCount-1]=pass;\par
  593     \par
  594     //read config file\par
  595     //update data\par
  596     File configFile = SPIFFS.open("/wifiConfig.json", "r");\par
  597 \par
  598     if (!configFile) \par
  599     \{\par
  600     \par
  601     #if DEBUG == 1 \par
  602 \par
  603         Serial.println( F("failed to read /wifiConfig.json") );\par
  604         Serial.println();\par
  605 \par
  606     #endif\par
  607     \}\par
  608     else\par
  609     \{\par
  610         size_t size = configFile.size();\par
  611         // Allocate a buffer to store contents of the file.\par
  612         std::unique_ptr<char[]> buf(new char[size]);\par
  613 \par
  614         configFile.readBytes(buf.get(), size);\par
  615         DynamicJsonBuffer jsonBuffer;\par
  616         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  617         if (!json.success()) \par
  618         \{\par
  619         \par
  620         #if DEBUG == 1 \par
  621 \par
  622             Serial.println( F("failed to parse json ") );\par
  623             Serial.println();\par
  624         \par
  625         #endif\par
  626         \} \par
  627         else\par
  628         \{\par
  629         \par
  630         #if DEBUG == 1 \par
  631         \par
  632             Serial.println( F("configuration json is ") );\par
  633             json.printTo(Serial);\par
  634             Serial.println();\par
  635 \par
  636             Serial.print(F("jsonBuffer size: "));\par
  637             Serial.println(jsonBuffer.size());\par
  638             Serial.println();\par
  639 \par
  640 \par
  641         #endif\par
  642             //wifiCount\par
  643             if(json["wifiCount"].success() )\par
  644             \{           \par
  645                 json["wifiCount"]=this->wifiCount;\par
  646             \}\par
  647             else\par
  648             \{\par
  649                 this->wifiCount=this->wifiCount;\par
  650             \}\par
  651             json["wifiCount"]=this->wifiCount;\par
  652 \par
  653             \par
  654             //AP timeOut\par
  655             if(json["timeOut"].success() )\par
  656             \{\par
  657                 this->timeOut=json["timeOut"];\par
  658             \}\par
  659             else\par
  660             \{\par
  661                 this->timeOut=this->timeOut;\par
  662 \par
  663             \}\par
  664             json["timeOut"]=this->timeOut;\par
  665             \par
  666             \par
  667             //new Wifi SSID and PASS\par
  668             JsonObject& newWifi = json.createNestedObject( "Wifi"+String( this->wifiCount-1 ) );\par
  669             \par
  670             newWifi["ssid"] =this->ssid[this->wifiCount-1];\par
  671             newWifi["pass"] = this->pass[this->wifiCount-1];\par
  672             \par
  673 \par
  674             configFile.close();\par
  675             configFile = SPIFFS.open("/wifiConfig.json", "w");\par
  676             if(!configFile)\par
  677             \{\par
  678             \par
  679             #if DEBUG == 1 \par
  680 \par
  681                 Serial.println( F("failed to write to /wifiConfig.json") );\par
  682             \par
  683             #endif\par
  684 \par
  685             \}\par
  686             \par
  687             json.printTo(configFile);\par
  688             configFile.close();\par
  689 \par
  690         #if DEBUG == 1 \par
  691 \par
  692             Serial.println( F("saved configuration is :") );\par
  693             json.printTo(Serial);\par
  694             Serial.println();\par
  695         \par
  696         #endif\par
  697 \par
  698             return(true); \par
  699         \}\par
  700     \}   \par
  701 \par
  702     \par
  703     return(true);\par
  704     \par
  705 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a914d7a1df14dd6b75345fb614c34e9d6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v begin\:CoolWifi}
{\xe \v CoolWifi\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolWifi::begin ()}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::begin()}: This method is provided to set the wifiMulti Access points and the wifiManager time out \par
}{
Definition at line 50 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{ \par
   52 \par
   53 #if DEBUG == 1 \par
   54 \par
   55     Serial.println( F("Entering CoolWifi.begin()") );\par
   56     Serial.println();\par
   57 \par
   58 #endif\par
   59     for(int i =0;i<this->wifiCount;i++)\par
   60     \{\par
   61          this->wifiMulti.addAP(this->ssid[i].c_str() , this->pass[i].c_str() ); \par
   62     \}\par
   63     \par
   64 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a46942fed90e475112cc10b78a32e7aaa_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolWifi}
{\xe \v CoolWifi\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::config ()}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::config()}: This method is provided to set the wifi parameters : -ssid -pass -AP timeOut -wifiCount\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 296 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   297 \{\par
  298 \par
  299 #if DEBUG == 1 \par
  300 \par
  301     Serial.println( F("Entering CoolWifi.config()") );\par
  302     Serial.println();\par
  303 \par
  304 #endif\par
  305 #if DEBUG == 0\par
  306 \par
  307     Serial.println( "Reading Wifi Configuration..");\par
  308     delay(100);\par
  309 #endif \par
  310 \par
  311     //read config file\par
  312     //update data\par
  313     File configFile = SPIFFS.open("/wifiConfig.json", "r");\par
  314 \par
  315     if (!configFile) \par
  316     \{\par
  317     \par
  318         Serial.println( F("failed to read /wifiConfig.json") );\par
  319         Serial.println();\par
  320 \par
  321         return(false);\par
  322     \}\par
  323     else\par
  324     \{\par
  325         size_t size = configFile.size();\par
  326         // Allocate a buffer to store contents of the file.\par
  327         std::unique_ptr<char[]> buf(new char[size]);\par
  328 \par
  329         configFile.readBytes(buf.get(), size);\par
  330         DynamicJsonBuffer jsonBuffer;\par
  331         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  332         if (!json.success()) \par
  333         \{\par
  334 \par
  335             Serial.println( F("failed to parse json ") );\par
  336             Serial.println();\par
  337 \par
  338             return(false);\par
  339         \} \par
  340         else\par
  341         \{\par
  342         \par
  343         #if DEBUG == 1 \par
  344         \par
  345             Serial.println( F("configuration json is ") );\par
  346             json.printTo(Serial);\par
  347             Serial.println();\par
  348 \par
  349             Serial.print(F("jsonBuffer size: "));\par
  350             Serial.println(jsonBuffer.size());\par
  351             Serial.println();\par
  352 \par
  353 \par
  354         #endif\par
  355             //wifiCount\par
  356             if(json["wifiCount"].success() )\par
  357             \{           \par
  358                 this->wifiCount=json["wifiCount"];\par
  359             \}\par
  360             else\par
  361             \{\par
  362                 this->wifiCount=this->wifiCount;\par
  363             \}\par
  364             json["wifiCount"]=this->wifiCount;\par
  365 \par
  366             \par
  367             //AP timeOut\par
  368             if(json["timeOut"].success() )\par
  369             \{\par
  370                 this->timeOut=json["timeOut"];\par
  371             \}\par
  372             else\par
  373             \{\par
  374                 this->timeOut=this->timeOut;\par
  375 \par
  376             \}\par
  377             json["timeOut"]=this->timeOut;\par
  378 \par
  379             //nomad\par
  380             if(json["nomad"].success() )\par
  381             \{\par
  382                 this->nomad=json["nomad"];\par
  383             \}\par
  384             else\par
  385             \{\par
  386                 this->nomad=this->nomad;\par
  387 \par
  388             \}\par
  389             json["nomad"]=this->nomad;\par
  390 \par
  391             \par
  392             \par
  393             //Wifis SSID and PASS\par
  394             for(int i =0; i<this->wifiCount ;i++)\par
  395             \{\par
  396                 if ( json["Wifi"+String(i)].success() )\par
  397                 \{\par
  398                     \par
  399                     if( json["Wifi"+String(i)]["ssid"].success() )\par
  400                     \{\par
  401                         const char* tempSsid=json["Wifi"+String(i)]["ssid"]; \par
  402                         this->ssid[i]=tempSsid;                 \par
  403                     \}\par
  404                     else\par
  405                     \{\par
  406                         this->ssid[i]=this->ssid[i];                    \par
  407                     \}\par
  408                     json["Wifi"+String(i)]["ssid"]=this->ssid[i].c_str();\par
  409                     \par
  410                     \par
  411                     if( json["Wifi"+String(i)]["pass"].success() )\par
  412                     \{\par
  413                         const char* tempPass =json["Wifi"+String(i)]["pass"];\par
  414                         this->pass[i]=tempPass ;                    \par
  415                     \}\par
  416                     else\par
  417                     \{\par
  418                         this->pass[i]=this->pass[i];                    \par
  419                     \}\par
  420                     json["Wifi"+String(i)]["pass"]=this->pass[i].c_str();           \par
  421                 \par
  422                 \}\par
  423                 else\par
  424                 \{\par
  425                     \par
  426                     this->ssid[i]=this->ssid[i];\par
  427                     this->pass[i]=this->pass[i];                    \par
  428                     \par
  429                 \}\par
  430                 json["Wifi"+String(i)]["ssid"]=this->ssid[i].c_str();\par
  431                 json["Wifi"+String(i)]["pass"]=this->pass[i].c_str();           \par
  432                         \par
  433             \}\par
  434 \par
  435             configFile.close();\par
  436             configFile = SPIFFS.open("/wifiConfig.json", "w");\par
  437             if(!configFile)\par
  438             \{\par
  439             \par
  440                 Serial.println( F("failed to write to /wifiConfig.json") );\par
  441             \par
  442                 return(false);              \par
  443             \}\par
  444             \par
  445             json.printTo(configFile);\par
  446             configFile.close();\par
  447 \par
  448         #if DEBUG == 1 \par
  449 \par
  450             Serial.println( F("saved configuration is :") );\par
  451             json.printTo(Serial);\par
  452             Serial.println();\par
  453         \par
  454         #endif\par
  455         #if DEBUG == 0\par
  456             Serial.println( F("Configuration loaded : OK"));\par
  457         #endif\par
  458             return(true); \par
  459         \}\par
  460     \}   \par
  461     \par
  462 \par
  463 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a4eb2f6b9b09dd588964b88b6c70122c0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:CoolWifi}
{\xe \v CoolWifi\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::config (String  {\i ssid}[], String  {\i pass}[], int  {\i wifiNumber}, int  {\i APTimeOut}, bool  {\i nomad})}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CoolWifi::config(ssid array, pass array, number of wifis, AP timeout,nomad flag ); This method is provided to configure the Wifi without SPIFFS\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successfull, false otherwise \par
}}{
Definition at line 471 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   472 \{\par
  473 \par
  474 #if DEBUG == 1 \par
  475     \par
  476     Serial.println("Entering CoolWifi.config(), no SPIFFS variant ") ;\par
  477     \par
  478 #endif\par
  479     \par
  480     if(wifiNumber>50)\par
  481     \{\par
  482     \par
  483     #if DEBUG == 1 \par
  484         \par
  485         Serial.println("the limit of WiFis is 50 " );\par
  486         \par
  487     #endif\par
  488         return(false);  \par
  489     \}\par
  490 \par
  491     this->wifiCount=wifiNumber;\par
  492 \par
  493     this->timeOut=APTimeOut;\par
  494 \par
  495     this->nomad=nomad;\par
  496     \par
  497     for(int i=0;i<wifiNumber;i++)\par
  498     \{\par
  499         this->ssid[i]=ssid[i];\par
  500         \par
  501         this->pass[i]=pass[i];\par
  502     \}\par
  503         \par
  504     return(true);\par
  505 \par
  506 \}\par
}
}
{\xe \v connect\:CoolWifi}
{\xe \v CoolWifi\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::connect ()}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::connect( )}: This method is provided to connect to the strongest WiFi in the provided list of wiFis. If none are found , it starts the AP mode.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi state \par
}}{
Definition at line 103 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   104 \{       \par
  105 \par
  106 \par
  107 \par
  108 #if DEBUG == 1 \par
  109 \par
  110     Serial.println( F("Entering CoolWifi.connect()") );\par
  111 \par
  112 #endif\par
  113 \par
  114     Serial.println( F("Wifi connecting...") );\par
  115 \par
  116 \par
  117     //if WifiCount > 0 , lunch wifiMulti\par
  118     //else no need to , skip this part\par
  119     // to wifiManager  \par
  120     if(this->wifiCount !=0)\par
  121     \{\par
  122     \par
  123         this->connectWifiMulti();\par
  124         \par
  125         //if nomad is true, only check wifi list\par
  126         if(this->nomad == true)\par
  127         \{\par
  128     \par
  129         #if DEBUG == 1\par
  130     \par
  131             Serial.print(F("nomad mode :"));\par
  132             Serial.println(this->nomad);\par
  133         \par
  134             Serial.print(F("Wifi status: "));\par
  135             Serial.println(WiFi.status());\par
  136         \par
  137         #endif  \par
  138             return(WiFi.status());  \par
  139         \}\par
  140 \par
  141     \}\par
  142 \par
  143 \par
  144     //Wifi Manager\par
  145     if( WiFi.status() != WL_CONNECTED ) \par
  146     \{\par
  147 \par
  148     #if DEBUG == 1 \par
  149     \par
  150         Serial.println(F("No matching wifi Found ") );\par
  151         Serial.println( F("Starting Access Point ") );  \par
  152         Serial.println();\par
  153 \par
  154     #endif\par
  155         \par
  156         this->connectAP();      \par
  157         \par
  158     \}\par
  159     else\par
  160     \{\par
  161 \par
  162         Serial.println(F("connected to "));\par
  163         Serial.println( WiFi.SSID() );\par
  164         Serial.println();\par
  165     \par
  166     \}\par
  167     \par
  168     return( WiFi.status() ) ;\par
  169 \par
  170 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_ad060353050f40d032a2dbf9e54a768bf_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_ad060353050f40d032a2dbf9e54a768bf_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectAP\:CoolWifi}
{\xe \v CoolWifi\:connectAP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::connectAP ()}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::connectAP()} This function is provided to run the WifiManager part of the Wifi connection process\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi state \par
}}{
Definition at line 230 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232 \par
  233 #if DEBUG == 1 \par
  234     \par
  235     Serial.println( F("Entering CoolWifi.connectAP()") );   \par
  236     Serial.println();\par
  237 \par
  238 #endif\par
  239     WiFiManager wifiManager;\par
  240     \par
  241     wifiManager.setRemoveDuplicateAPs(true);\par
  242 \par
  243     wifiManager.setTimeout(this->timeOut);\par
  244     \par
  245     String tempMAC = WiFi.macAddress();\par
  246     tempMAC.replace(":","");\par
  247 \par
  248     String name="CoolBoard-"+tempMAC;   \par
  249 \par
  250     if(!wifiManager.autoConnect(name.c_str())) \par
  251     \{\par
  252 \par
  253         Serial.println( F("failed to connect and hit timeout") );\par
  254 \par
  255         delay(30);\par
  256 \par
  257     \} \par
  258 \par
  259     //if you get here you have connected to the WiFi\par
  260 \par
  261     if(WiFi.status()==WL_CONNECTED)\par
  262     \{\par
  263 \par
  264     #if DEBUG == 1\par
  265 \par
  266         Serial.println( F("connected...yeey :)" ));\par
  267         Serial.println("connected to ");\par
  268         Serial.println( WiFi.SSID() );\par
  269         //Serial.println( WiFi.psk() ) ;\par
  270         \par
  271     #endif\par
  272 \par
  273         this->addWifi( WiFi.SSID() , WiFi.psk() );\par
  274         \par
  275     \}\par
  276     else\par
  277     \{\par
  278         Serial.println( F("Not connected...:(" ));\par
  279     \}\par
  280     \par
  281     return(WiFi.status());\par
  282 \par
  283 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a7c857f27161782f5ef1d62d552aff971_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a7c857f27161782f5ef1d62d552aff971_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectWifiMulti\:CoolWifi}
{\xe \v CoolWifi\:connectWifiMulti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::connectWifiMulti ()}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::connectWifiMulti()} This function is provided to run the WifiMulti part of the Wifi connection process\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi state \par
}}{
Definition at line 180 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   181 \{\par
  182     int i=0;\par
  183 \par
  184 #if DEBUG == 1 \par
  185 \par
  186     Serial.println(F("Entering CoolWifi.connectWifiMulti()"));\par
  187     Serial.println();\par
  188     \par
  189     Serial.println( F("entry time to multi : ") );\par
  190     Serial.println(millis() ) ;\par
  191 \par
  192 #endif\par
  193     \par
  194     //Wifi MULTI\par
  195     while( (this->wifiMulti.run() != WL_CONNECTED) && (i<500)  ) \par
  196     \{\par
  197 \par
  198     #if DEBUG == 1\par
  199 \par
  200         Serial.print(F("."));\par
  201         \par
  202     #endif\par
  203         i++;\par
  204         delay(5);\par
  205         \}   \par
  206 \par
  207 #if DEBUG == 1 \par
  208 \par
  209     Serial.println();   \par
  210     Serial.println(F("exit point from multi : "));\par
  211     Serial.println(millis() );\par
  212     \par
  213     Serial.print(F("Wifi Status :"));\par
  214     Serial.println(WiFi.status());\par
  215 #endif\par
  216 \par
  217     return(WiFi.status());\par
  218 \par
  219 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a419de92d738f14b7444cf822b3ab0070_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:CoolWifi}
{\xe \v CoolWifi\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoolWifi::printConf ()}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 514 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   515 \{\par
  516 \par
  517 #if DEBUG == 1 \par
  518 \par
  519     Serial.println( F("Entering CoolWifi.printConf()") );\par
  520     Serial.println();   \par
  521 \par
  522 #endif\par
  523     \par
  524     Serial.println(F("Wifi configuration "));\par
  525 \par
  526     \par
  527     Serial.println(F("wifiCount : "));\par
  528     Serial.println(this->wifiCount);\par
  529     \par
  530     for(int i=0;i<this->wifiCount;i++)\par
  531     \{   \par
  532         Serial.print(F("SSID"));\par
  533         Serial.print(i);\par
  534         Serial.println(F(" : "));\par
  535         Serial.println(this->ssid[i]);\par
  536                 \par
  537 \par
  538         //Serial.print("PASS");\par
  539         //Serial.print(i);\par
  540         //Serial.println(" : ");\par
  541 \par
  542         //Serial.print(F("PASS"));\par
  543         //Serial.print(i);\par
  544         //Serial.println(F(" : "));\par
  545 \par
  546         //Serial.println(this->pass[i]);\par
  547         \par
  548     \}\par
  549     \par
  550     Serial.println(F("timeOut : "));\par
  551     Serial.println(this->timeOut);\par
  552 \par
  553     Serial.println(F("nomad : "));\par
  554     Serial.println(this->nomad);\par
  555 \par
  556     Serial.println();\par
  557 \par
  558 \par
  559 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a9e6105c6d13d35ec510f6633da9e0223_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v state\:CoolWifi}
{\xe \v CoolWifi\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
wl_status_t CoolWifi::state ()}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi::state()}: This method is provided to return the Wifi client's state. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid wifi client state: WL_NO_SHIELD = 255, WL_IDLE_STATUS = 0, WL_NO_SSID_AVAIL = 1, WL_SCAN_COMPLETED = 2, WL_CONNECTED = 3, WL_CONNECT_FAILED = 4, WL_CONNECTION_LOST = 5, WL_DISCONNECTED = 6 \par
}}{
Definition at line 80 of file CoolWifi.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    81 \{\par
   82 \par
   83 #if DEBUG == 1 \par
   84 \par
   85     Serial.println( F("Entering CoolWifi.state()") );\par
   86     Serial.println();   \par
   87     Serial.print( F("state : ") );\par
   88     Serial.println( WiFi.status() );\par
   89 \par
   90 #endif\par
   91     \par
   92     return( WiFi.status() ) ;\par
   93 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d29/class_cool_wifi_a1c7b4d82a4098d346e7593dce92039fa_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v nomad\:CoolWifi}
{\xe \v CoolWifi\:nomad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolWifi::nomad =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolWifi.h.}\par
}
{\xe \v pass\:CoolWifi}
{\xe \v CoolWifi\:pass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolWifi::pass[50] =\{"0"\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file CoolWifi.h.}\par
}
{\xe \v ssid\:CoolWifi}
{\xe \v CoolWifi\:ssid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolWifi::ssid[50] =\{"0"\}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolWifi.h.}\par
}
{\xe \v timeOut\:CoolWifi}
{\xe \v CoolWifi\:timeOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolWifi::timeOut =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolWifi.h.}\par
}
{\xe \v wifiCount\:CoolWifi}
{\xe \v CoolWifi\:wifiCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolWifi::wifiCount =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file CoolWifi.h.}\par
}
{\xe \v wifiMulti\:CoolWifi}
{\xe \v CoolWifi\:wifiMulti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ESP8266WiFiMulti CoolWifi::wifiMulti{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolWifi.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolWifi.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensor< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensor< T >}
{\xe \v ExternalSensor< T >}
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor}. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for ExternalSensor< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d93/class_external_sensor__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for ExternalSensor< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d2f/class_external_sensor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b sensor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>\par
class ExternalSensor< T >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the generic Template for an external sensor This class works automatically with sensors that provide the following methods :{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constructor(void);\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t/bool {\b begin(void)};\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read(void)};\par}
If your sensor doesn't provide these methods or is not present in the specialized templates feel free to implement your own specializiation, following the provided generic template , or contact us and we will be glad to expand our list of supported external sensors \par
}{
Definition at line 135 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExternalSensor\:ExternalSensor}
{\xe \v ExternalSensor\:ExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b ExternalSensor}< T >::{\b ExternalSensor} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic Constructor \par
}{
Definition at line 141 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   142     \{\par
  143     \par
  144     #if DEBUGExternal == 1 \par
  145 \par
  146         Serial.println( "ExternalSensor <Generic> Constructor" );\par
  147         Serial.println();\par
  148     \par
  149     #endif\par
  150 \par
  151         sensor();\par
  152     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensor}
{\xe \v ExternalSensor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > virtual uint8_t {\b ExternalSensor}< T >::begin (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic begin method \par
}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 159 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   160     \{\par
  161     \par
  162     #if DEBUGExternal == 1 \par
  163 \par
  164         Serial.println( "ExternalSensor <Generic> begin()" );\par
  165         Serial.println();\par
  166     \par
  167     #endif\par
  168 \par
  169         return(sensor.begin() );    \par
  170     \}\par
}
}
{\xe \v read\:ExternalSensor}
{\xe \v ExternalSensor\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > virtual float {\b ExternalSensor}< T >::read (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic read method \par
}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 175 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176     \{\par
  177     \par
  178     #if DEBUGExternal == 1 \par
  179 \par
  180         Serial.println( "ExternalSensor <Generic> read() " );\par
  181         Serial.println();\par
  182         \par
  183     #endif\par
  184 \par
  185         return(sensor.read());\par
  186     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sensor\:ExternalSensor}
{\xe \v ExternalSensor\:sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > T {\b ExternalSensor}< T >::sensor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensor< DallasTemperature > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >}
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for ExternalSensor< DallasTemperature >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d74/class_external_sensor_3_01_dallas_temperature_01_4__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for ExternalSensor< DallasTemperature >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d86/class_external_sensor_3_01_dallas_temperature_01_4__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensor} (OneWire *{\b oneWire})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DallasTemperature {\b sensor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DeviceAddress {\b dallasAddress}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<>\par
class ExternalSensor< DallasTemperature >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor. \par
}{
Definition at line 328 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExternalSensor\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:ExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExternalSensor}< DallasTemperature >::{\b ExternalSensor} (OneWire *  {\i oneWire}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor()}: DallasTemperature specific constructor \par
}{
Definition at line 335 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   336     \{\par
  337         \par
  338     #if DEBUGExternal == 1 \par
  339 \par
  340         Serial.println( "ExternalSensor <DallasTemperature> constructor" );\par
  341         Serial.println();\par
  342     \par
  343     #endif\par
  344         sensor=DallasTemperature(oneWire);\par
  345     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t {\b ExternalSensor}< DallasTemperature >::begin (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b begin()}: DallasTemperature specific begin method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 353 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   354     \{\par
  355     \par
  356     #if DEBUGExternal == 1 \par
  357 \par
  358         Serial.println( "ExternalSensor <DallasTemperature> begin()" );\par
  359         Serial.println();\par
  360     \par
  361     #endif\par
  362 \par
  363         sensor.begin(); \par
  364         delay(5);\par
  365         sensor.getAddress(this->dallasAddress, 0);  \par
  366         return(true);\par
  367     \}\par
}
}
{\xe \v read\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float {\b ExternalSensor}< DallasTemperature >::read (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b read()}: DallasTemperature specific read method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the temperature in \'B0C \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 374 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   375     \{\par
  376 \par
  377         sensor.requestTemperatures(); // Send the command to get temperatures\par
  378         float result=(float) sensor.getTempCByIndex(0);\par
  379     #if DEBUGExternal == 1 \par
  380 \par
  381         Serial.println( "ExternalSensor <DallasTemperature> read()" );\par
  382         Serial.println();\par
  383 \par
  384         Serial.print("Requesting temperature...");\par
  385 \par
  386         Serial.print( "temperature : ");\par
  387         Serial.print( result );\par
  388         Serial.print( "\'B0C" );\par
  389         Serial.println();\par
  390     \par
  391     #endif\par
  392         \par
  393         return( result );\par
  394     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dallasAddress\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:dallasAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DeviceAddress {\b ExternalSensor}< DallasTemperature >::dallasAddress{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 400 of file ExternalSensor.h.}\par
}
{\xe \v sensor\:ExternalSensor< DallasTemperature >}
{\xe \v ExternalSensor< DallasTemperature >\:sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DallasTemperature {\b ExternalSensor}< DallasTemperature >::sensor{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 399 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensor< NDIR_I2C > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >}
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor. }}\par
{
{\f2 #include <ExternalSensor.h>}}\par
Inheritance diagram for ExternalSensor< NDIR_I2C >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d1b/class_external_sensor_3_01_n_d_i_r___i2_c_01_4__inherit__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for ExternalSensor< NDIR_I2C >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d03/class_external_sensor_3_01_n_d_i_r___i2_c_01_4__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExternalSensor} (uint8_t i2c_addr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b read} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NDIR_I2C} {\b sensor} =NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<>\par
class ExternalSensor< NDIR_I2C >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor. \par
}{
Definition at line 203 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExternalSensor\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:ExternalSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExternalSensor}< {\b NDIR_I2C} >::{\b ExternalSensor} (uint8_t  {\i i2c_addr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor(I2C address)}: {\b NDIR_I2C} specific constructor \par
}{
Definition at line 211 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   212     \{\par
  213     \par
  214     #if DEBUGExternal == 1 \par
  215 \par
  216         Serial.println( "ExternalSensor <NDIR_I2C> constructor");\par
  217         Serial.println();\par
  218     \par
  219     #endif\par
  220 \par
  221         sensor=NDIR_I2C(i2c_addr);\par
  222     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t {\b ExternalSensor}< {\b NDIR_I2C} >::begin (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b begin()}: {\b NDIR_I2C} specific begin method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful, false otherwise \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 231 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   232     \{\par
  233     \par
  234     #if DEBUGExternal == 1 \par
  235 \par
  236         Serial.println( "ExternalSensor <NDIR_I2C> begin()" );\par
  237         Serial.println();\par
  238     \par
  239     #endif \par
  240 \par
  241         if (sensor.begin()) \par
  242         \{\par
  243         \par
  244         #if DEBUGExternal == 1 \par
  245             \par
  246             Serial.println( "NDIR_I2C init : wait 10 seconds" );\par
  247             Serial.println();\par
  248         \par
  249         #endif\par
  250 \par
  251             delay(10000);\par
  252             return(true);\par
  253 \par
  254             \}\par
  255         else \par
  256         \{\par
  257         \par
  258         #if DEBUGExternal == 1 \par
  259 \par
  260             Serial.println( "NDIR_I2C init : fail " );\par
  261             Serial.println();\par
  262         \par
  263         #endif\par
  264 \par
  265             return(false);\par
  266         \}   \par
  267     \}\par
}
}
{\xe \v read\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float {\b ExternalSensor}< {\b NDIR_I2C} >::read (void ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b read()}: {\b NDIR_I2C} specific read method\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ppm value if successful, else return -42 \par
}}{
Reimplemented from {\b BaseExternalSensor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 276 of file ExternalSensor.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   277     \{\par
  278         \par
  279     #if DEBUGExternal == 1 \par
  280         \par
  281         Serial.println( "ExternalSensor <NDIR_I2C> read()" );\par
  282         Serial.println();\par
  283 \par
  284     #endif\par
  285 \par
  286         if (sensor.measure())\par
  287         \{\par
  288         \par
  289         #if DEBUGExternal == 1 \par
  290 \par
  291             Serial.print( "NDIR_I2C ppm :" );\par
  292             Serial.println( (float) sensor.ppm);\par
  293             \par
  294             Serial.println();           \par
  295 \par
  296         #endif\par
  297 \par
  298             return( (float) sensor.ppm);\par
  299             \par
  300         \}\par
  301         \par
  302         else\par
  303         \{\par
  304         \par
  305         #if DEBUGExternal == 1 \par
  306 \par
  307             Serial.println( "NDIR_I2C read fail " );\par
  308             Serial.println();\par
  309         \par
  310         #endif\par
  311 \par
  312             return(-42);\par
  313         \}\par
  314     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sensor\:ExternalSensor< NDIR_I2C >}
{\xe \v ExternalSensor< NDIR_I2C >\:sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NDIR_I2C} {\b ExternalSensor}< {\b NDIR_I2C} >::sensor =NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 318 of file ExternalSensor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensors Class Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensors}
{\xe \v ExternalSensors}
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions. }}\par
{
{\f2 #include <ExternalSensors.h>}}\par
Collaboration diagram for ExternalSensors:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/df9/class_external_sensors__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sensor}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} (String reference[], String type[], uint8_t address[], int {\b sensorsNumber})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExternalSensors::sensor} {\b sensors} [50]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sensorsNumber} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions. \par
}{
Definition at line 45 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:ExternalSensors}
{\xe \v ExternalSensors\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExternalSensors::begin (void )}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::begin()}: This method is provided to initialise the external sensors. \par
}{
Definition at line 56 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    57 \{\par
   58 \par
   59 #if DEBUG == 1\par
   60 \par
   61     Serial.println( F("Enter ExternalSensors.begin()") );\par
   62     Serial.println();\par
   63 \par
   64 #endif \par
   65 \par
   66     for(int i=0;i< this->sensorsNumber ; i++)\par
   67     \{\par
   68         if( (sensors[i].reference) == "NDIR_I2C" )\par
   69         \{   \par
   70             std::unique_ptr< ExternalSensor<NDIR_I2C> > sensorCO2(new ExternalSensor<NDIR_I2C>( this->sensors[i].address) );\par
   71 \par
   72 \par
   73             sensors[i].exSensor= sensorCO2.release();\par
   74             sensors[i].exSensor->begin();\par
   75             sensors[i].exSensor->read();\par
   76 \par
   77         \}\par
   78         if( (sensors[i].reference) == "DallasTemperature")\par
   79         \{\par
   80 \par
   81             std::unique_ptr< ExternalSensor<DallasTemperature> > dallasTemp(new ExternalSensor<DallasTemperature> (&oneWire));\par
   82              \par
   83             sensors[i].exSensor=dallasTemp.release();\par
   84             sensors[i].exSensor->begin();\par
   85             sensors[i].exSensor->read();\par
   86         \}\par
   87         \par
   88         \par
   89     \}\par
   90 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a58ede0d786a86417254708870f04a21e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a58ede0d786a86417254708870f04a21e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:ExternalSensors}
{\xe \v ExternalSensors\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExternalSensors::config ()}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::config()}: This method is provided to configure the externalSensors through a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 173 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   174 \{\par
  175     //read config file\par
  176     //update data\par
  177     File externalSensorsConfig = SPIFFS.open("/externalSensorsConfig.json", "r");\par
  178 \par
  179     if (!externalSensorsConfig) \par
  180     \{\par
  181     \par
  182     #if DEBUG == 1\par
  183         \par
  184         Serial.println( F("failed to read /externalSensorsConfig.json") );\par
  185         Serial.println();\par
  186     \par
  187     #endif\par
  188         \par
  189         return(false);\par
  190     \}\par
  191     else\par
  192     \{\par
  193         size_t size = externalSensorsConfig.size();\par
  194         // Allocate a buffer to store contents of the file.\par
  195         std::unique_ptr<char[]> buf(new char[size]);\par
  196 \par
  197         externalSensorsConfig.readBytes(buf.get(), size);\par
  198         DynamicJsonBuffer jsonBuffer;\par
  199         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  200 \par
  201         if (!json.success()) \par
  202         \{\par
  203         \par
  204         #if DEBUG == 1 \par
  205 \par
  206             Serial.println( F("failed to parse json") );\par
  207             Serial.println();\par
  208         \par
  209         #endif\par
  210 \par
  211             return(false);\par
  212         \} \par
  213         else\par
  214         \{\par
  215         \par
  216         #if DEBUG == 1 \par
  217     \par
  218             Serial.println( F("configuration json is : ") );\par
  219             json.printTo(Serial);\par
  220             Serial.println();\par
  221 \par
  222             Serial.print(F("jsonBuffer size: "));\par
  223             Serial.println(jsonBuffer.size());\par
  224             Serial.println();\par
  225 \par
  226         \par
  227         #endif          \par
  228             if(json["sensorsNumber"]!=NULL)\par
  229             \{\par
  230                 this->sensorsNumber = json["sensorsNumber"];\par
  231                 \par
  232                 \par
  233 \par
  234                 for(int i=0;i<sensorsNumber;i++)\par
  235                 \{   String name="sensor"+String(i);\par
  236                     \par
  237                     if(json[name].success())\par
  238                     \{  \par
  239                         JsonObject& sensorJson=json[name];\par
  240                         \par
  241                         if(sensorJson["reference"].success() )\par
  242                         \{  \par
  243                             this->sensors[i].reference =sensorJson["reference"].as<String>();\par
  244                         \}\par
  245                         else\par
  246                         \{\par
  247                             this->sensors[i].reference=this->sensors[i].reference;                          \par
  248                                     \par
  249                         \}\par
  250                         sensorJson["reference"]=this->sensors[i].reference;\par
  251 \par
  252                     \par
  253                         if(sensorJson["type"].success() )\par
  254                         \{                   \par
  255                             this->sensors[i].type=sensorJson["type"].as<String>();\par
  256                         \}\par
  257                         else\par
  258                         \{\par
  259                             this->sensors[i].type=this->sensors[i].type;\par
  260 \par
  261                         \}\par
  262                         sensorJson["type"]=this->sensors[i].type;\par
  263                     \par
  264                         if(sensorJson["address"].success() )\par
  265                         \{                   \par
  266                             this->sensors[i].address=sensorJson["address"];\par
  267                         \}\par
  268                         else\par
  269                         \{   \par
  270                             this->sensors[i].address=this->sensors[i].address;\par
  271 \par
  272                         \}\par
  273                         sensorJson["address"]=this->sensors[i].address;\par
  274                     \par
  275     \par
  276                     \}\par
  277                     else\par
  278                     \{\par
  279                         this->sensors[i]=this->sensors[i];                  \par
  280                     \}\par
  281                                             \par
  282                     json[name]["reference"]=this->sensors[i].reference;\par
  283                     json[name]["type"]=this->sensors[i].type;\par
  284                     json[name]["address"]=this->sensors[i].address;\par
  285                 \}\par
  286  \par
  287             \}\par
  288             else\par
  289             \{\par
  290                 this->sensorsNumber=this->sensorsNumber;\par
  291             \}\par
  292             json["sensorsNumber"]=this->sensorsNumber;\par
  293 \par
  294             externalSensorsConfig.close();\par
  295             externalSensorsConfig = SPIFFS.open("/externalSensorsConfig.json", "w");\par
  296 \par
  297             if(!externalSensorsConfig)\par
  298             \{\par
  299             \par
  300             #if DEBUG == 1 \par
  301 \par
  302                 Serial.println( F("failed to write to /externalSensorsConfig.json") );\par
  303                 Serial.println();\par
  304             \par
  305             #endif\par
  306 \par
  307                 return(false);\par
  308             \}\par
  309             \par
  310             json.printTo(externalSensorsConfig);\par
  311             externalSensorsConfig.close();\par
  312             \par
  313         #if DEBUG == 1 \par
  314 \par
  315             Serial.println( F("saved configuration is : ") );\par
  316             json.printTo(Serial);\par
  317             Serial.println();\par
  318         \par
  319         #endif\par
  320 \par
  321             return(true); \par
  322         \}\par
  323     \}   \par
  324     \par
  325 \par
  326 \par
  327 \par
  328 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a862a4bd11346b37270d0244c2adabe5a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:ExternalSensors}
{\xe \v ExternalSensors\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExternalSensors::config (String  {\i reference}[], String  {\i type}[], uint8_t  {\i address}[], int  {\i sensorsNumber})}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::config(String reference[],String type[],uint8_t address[],int sensorsNumber)}: This method is provided to configure the externalSensors without a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 338 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   339 \{\par
  340 \par
  341 #if DEBUG == 1\par
  342 \par
  343     Serial.println( F("Entering ExternalSensors.conf(reference[], type[], address[], sensorsNumber)") );\par
  344     Serial.println();\par
  345 \par
  346 #endif  \par
  347     if(sensorsNumber>50)\par
  348     \{\par
  349     \par
  350     #if DEBUG == 1\par
  351     \par
  352         Serial.println(F("you can't add more than 50 sensors"));    \par
  353     \par
  354     #endif  \par
  355     \par
  356         return(false);\par
  357     \}\par
  358 \par
  359     this->sensorsNumber=sensorsNumber;\par
  360     \par
  361     for(int i=0;i<sensorsNumber;i++)\par
  362     \{\par
  363     \par
  364         this->sensors[i].reference=reference[i];\par
  365         \par
  366         this->sensors[i].type=type[i];\par
  367 \par
  368         this->sensors[i].address=address[i];\par
  369     \par
  370     \}\par
  371     \par
  372     return(true);\par
  373 \par
  374 \}\par
}
}
{\xe \v printConf\:ExternalSensors}
{\xe \v ExternalSensors\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExternalSensors::printConf ()}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 381 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   382 \{\par
  383 \par
  384 #if DEBUG == 1\par
  385 \par
  386     Serial.println( F("Entering ExternalSensors.printConf()") );\par
  387     Serial.println();\par
  388 \par
  389 #endif \par
  390 \par
  391     Serial.println("External Sensors configuration ");\par
  392 \par
  393     Serial.print("sensorsNumber : ");\par
  394     Serial.println(sensorsNumber);\par
  395 \par
  396     for(int i=0;i<sensorsNumber;i++)\par
  397     \{\par
  398         Serial.print("sensor ");\par
  399         Serial.print(i);\par
  400         Serial.print(" reference : ");\par
  401         Serial.println(this->sensors[i].reference);\par
  402 \par
  403         Serial.print("sensor ");\par
  404         Serial.print(i);\par
  405         Serial.print(" type : ");\par
  406         Serial.println(this->sensors[i].type);\par
  407                 \par
  408         Serial.print("sensor ");\par
  409         Serial.print(i);\par
  410         Serial.print(" address : ");\par
  411         Serial.println(this->sensors[i].address);\par
  412     \par
  413     \}\par
  414 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a78c2bf55084435dd51d3c559b2d3c6f3_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:ExternalSensors}
{\xe \v ExternalSensors\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String ExternalSensors::read (void )}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors::read()}: This method is provided to read the data from the external sensors\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string that contains the sensors data \par
}}{
Definition at line 100 of file ExternalSensors.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101 \{\par
  102 \par
  103 #if DEBUG == 1\par
  104 \par
  105     Serial.println( F("Entering ExternalSensors.read()") );\par
  106     Serial.println();\par
  107 \par
  108 #endif \par
  109 \par
  110     String data;\par
  111     DynamicJsonBuffer  jsonBuffer ;\par
  112     JsonObject& root = jsonBuffer.createObject();\par
  113 \par
  114     if(!root.success() )\par
  115     \{\par
  116  \par
  117     #if DEBUG == 1\par
  118 \par
  119         Serial.println( F("failed to create json ") );\par
  120     \par
  121     #endif \par
  122 \par
  123         return("00");\par
  124     \}\par
  125     else\par
  126     \{\par
  127         if(sensorsNumber>0)\par
  128         \{\par
  129             for(int i=0;i<sensorsNumber;i++)\par
  130             \{\par
  131                 if(sensors[i].exSensor != NULL )\par
  132                 \{\par
  133                     root[sensors[i].type]=sensors[i].exSensor->read();      \par
  134                 \}\par
  135             \par
  136             #if DEBUG == 1\par
  137                 else\par
  138                 \{\par
  139                     Serial.println(F("null pointer "));\par
  140                 \}\par
  141             #endif  \par
  142             \}\par
  143         \}   \par
  144         \par
  145         root.printTo(data);\par
  146     \par
  147     #if DEBUG == 1\par
  148 \par
  149         Serial.println( F("sensors data :") );\par
  150         Serial.println(data);\par
  151         Serial.println();\par
  152 \par
  153         Serial.print(F("jsonBuffer size: "));\par
  154         Serial.println(jsonBuffer.size());\par
  155         Serial.println();\par
  156 \par
  157     \par
  158     #endif\par
  159     \par
  160         return(data);\par
  161     \}\par
  162 \par
  163 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2f/class_external_sensors_a53177b81eca3be89508b5511ddcd00fc_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sensors\:ExternalSensors}
{\xe \v ExternalSensors\:sensors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ExternalSensors::sensor} ExternalSensors::sensors[50]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sensorsNumber\:ExternalSensors}
{\xe \v ExternalSensors\:sensorsNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExternalSensors::sensorsNumber =0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Irene3000 Class Reference\par \pard\plain 
{\tc\tcl2 \v Irene3000}
{\xe \v Irene3000}
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield. }}\par
{
{\f2 #include <Irene3000.h>}}\par
Collaboration diagram for Irene3000:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d7b/class_irene3000__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b parameters_T}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readButton} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGain} ({\b adsGain_t} gain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readADSChannel2} ({\b adsGain_t} gain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readPh} (double t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readTemp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetParams} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calibratepH7} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calibratepH4} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calcpHSlope} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b gainConvert} (uint16_t tempGain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveParams} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_ADS1115} {\b ads}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::parameters_T} {\b params}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state} {\b waterTemp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state} {\b phProbe}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state} {\b adc2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b vRef} = 1.024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b opampGain} = 5.25\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield. \par
}{
Definition at line 57 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Irene3000}
{\xe \v Irene3000\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::begin (void )}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::begin()}: This method is provided to start the {\b Irene3000} \par
}{
Definition at line 50 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52     this->ads.begin();\par
   53 \par
   54     delay(2000);\par
   55 \par
   56 #if DEBUG == 1 \par
   57 \par
   58 \par
   59     Serial.println( F("Entering Irene3000.begin()") );\par
   60     Serial.println();\par
   61     \par
   62     \par
   63     \par
   64 \par
   65 #endif\par
   66     Serial.println(F("Press the button to calibrate the Ph probe "));\par
   67 \par
   68     delay(2000);\par
   69 \par
   70     int bValue=this->readButton();\par
   71     \par
   72     while(bValue<500)\par
   73     \{\par
   74         bValue=this->readButton();\par
   75         delay(10);  \par
   76     \}\par
   77 \par
   78     if(  bValue > 20000 )\par
   79     \{\par
   80     \par
   81 \par
   82         \par
   83         Serial.println(F("calibrating the Ph probe " ) );\par
   84         \par
   85         Serial.println(F("ph7 calibration for 25 seconds"));\par
   86         \par
   87         delay(10000);\par
   88         \par
   89         this->calibratepH7();\par
   90 \par
   91         delay(15000);       \par
   92     \par
   93         this->calibratepH7();\par
   94 \par
   95         delay(1000);\par
   96         Serial.println(F("ph 7 calibration ok"));\par
   97         Serial.println();\par
   98     \par
   99 \par
  100         Serial.println(F("ph 4 calibration for 25 seconds"));\par
  101     \par
  102         delay(10000);       \par
  103 \par
  104         this->calibratepH4();\par
  105 \par
  106         delay(15000);\par
  107         \par
  108         this->calibratepH4();\par
  109     \par
  110         delay(1000);        \par
  111 \par
  112         Serial.println(F("ph 4 calibration ok"));\par
  113         Serial.println();\par
  114     \par
  115 \par
  116 \par
  117         this->saveParams();\par
  118     \par
  119     \}\par
  120 \par
  121 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ad5891806c500ae1007afe52b9e304c2b_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ad5891806c500ae1007afe52b9e304c2b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calcpHSlope\:Irene3000}
{\xe \v Irene3000\:calcpHSlope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::calcpHSlope ()}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::calcpHSlop(): This method is provided to calculate th PH slope \par
}{
Definition at line 683 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   684 \{\par
  685 \par
  686 #if DEBUG == 1 \par
  687 \par
  688     Serial.println( F("Entering Irene3000.calcpHSlope()") );\par
  689     Serial.println();\par
  690 \par
  691 #endif \par
  692 \par
  693     params.pHStep = ((((vRef * (float)(params.pH7Cal - params.pH4Cal)) / 32767) * 1000) / opampGain) / 3;\par
  694 \par
  695  \par
  696 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a81f6a79e546679692053f7ac1af49613_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calibratepH4\:Irene3000}
{\xe \v Irene3000\:calibratepH4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::calibratepH4 ()}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::calibratepH4()}: This method is provided to calibrate the PH probe to 4 \par
}{
Definition at line 657 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   658 \{\par
  659 \par
  660 #if DEBUG == 1 \par
  661 \par
  662     Serial.println( F("Entering Irene3000.calibraph4()") );\par
  663     Serial.println();\par
  664 \par
  665 #endif \par
  666     delay(1000);\par
  667 \par
  668     this->setGain(GAIN_FOUR);\par
  669 \par
  670     this->params.pH4Cal =  ads.readADC_SingleEnded(ph);\par
  671 \par
  672     this->calcpHSlope();\par
  673 \par
  674 \par
  675 \par
  676 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aa140dd026922a04981edfd04d46cabbe_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aa140dd026922a04981edfd04d46cabbe_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calibratepH7\:Irene3000}
{\xe \v Irene3000\:calibratepH7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::calibratepH7 ()}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::calibratepH7()}: This method is provided to calibrate the PH probe to 7 \par
}{
Definition at line 630 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   631 \{\par
  632 \par
  633 #if DEBUG == 1 \par
  634 \par
  635     Serial.println( F("Entering Irene3000.calibratepH7() ") );\par
  636     Serial.println();\par
  637     \par
  638     \par
  639 \par
  640 #endif \par
  641     delay(1000);\par
  642 \par
  643     this->setGain(GAIN_FOUR);\par
  644         \par
  645     this->params.pH7Cal = ads.readADC_SingleEnded(ph);\par
  646  \par
  647     this->calcpHSlope();\par
  648 \par
  649 \par
  650 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a1d3299202e4cb7afcff9c9e3e95d94c1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a1d3299202e4cb7afcff9c9e3e95d94c1_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:Irene3000}
{\xe \v Irene3000\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Irene3000::config ()}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::config()}: This method is provided to configure the {\b Irene3000} shield through a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 201 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   202 \{\par
  203 \par
  204 #if DEBUG == 1 \par
  205 \par
  206     Serial.println( F("Entering Irene3000.config()") );\par
  207     Serial.println();\par
  208 \par
  209 #endif\par
  210 \par
  211     File irene3000Config = SPIFFS.open("/irene3000Config.json", "r");\par
  212 \par
  213     if (!irene3000Config) \par
  214     \{\par
  215     \par
  216     #if DEBUG == 1 \par
  217 \par
  218         Serial.println( F("failed to read /irene3000Config.json") );\par
  219         Serial.println();\par
  220     \par
  221     #endif\par
  222 \par
  223         return(false);\par
  224     \}\par
  225     else\par
  226     \{\par
  227         size_t size = irene3000Config.size();\par
  228         // Allocate a buffer to store contents of the file.\par
  229         std::unique_ptr<char[]> buf(new char[size]);\par
  230             uint16_t tempGain;\par
  231         irene3000Config.readBytes(buf.get(), size);\par
  232         DynamicJsonBuffer jsonBuffer;\par
  233         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  234         if (!json.success()) \par
  235         \{\par
  236         \par
  237         #if DEBUG == 1 \par
  238 \par
  239             Serial.println( F("failed to parse json ") );\par
  240             Serial.println();\par
  241         \par
  242         #endif\par
  243             \par
  244             return(false);\par
  245         \} \par
  246         else\par
  247         \{\par
  248         \par
  249         #if DEBUG == 1 \par
  250     \par
  251             Serial.println( F("read configuration file ") );\par
  252             json.printTo(Serial);\par
  253             Serial.println();\par
  254 \par
  255             Serial.print(F("jsonBuffer size: "));\par
  256             Serial.println(jsonBuffer.size());\par
  257             Serial.println();\par
  258 \par
  259         \par
  260 \par
  261         #endif          \par
  262             if(json["waterTemp"]["active"].success() )\par
  263             \{           \par
  264                 this->waterTemp.active = json["waterTemp"]["active"]; \par
  265             \}\par
  266             else\par
  267             \{\par
  268                 this->waterTemp.active=this->waterTemp.active;\par
  269             \}\par
  270             json["waterTemp"]["active"]=this->waterTemp.active;\par
  271 \par
  272             \par
  273             if(json["phProbe"]["active"].success())\par
  274             \{\par
  275                 this->phProbe.active=json["phProbe"]["active"];\par
  276             \}\par
  277             else\par
  278             \{\par
  279                 this->phProbe.active=this->phProbe.active;\par
  280             \}\par
  281             json["phProbe"]["active"]=this->phProbe.active;\par
  282 \par
  283             \par
  284             if(json["adc2"]["active"].success() )\par
  285             \{\par
  286                 this->adc2.active=json["adc2"]["active"];\par
  287             \}\par
  288             else\par
  289             \{\par
  290                 this->adc2.active=this->adc2.active;\par
  291             \}\par
  292             json["adc2"]["active"]=this->adc2.active;\par
  293 \par
  294             \par
  295             if(json["adc2"]["gain"].success() )\par
  296             \{           \par
  297                 tempGain=json["adc2"]["gain"];\par
  298                 this->adc2.gain=this->gainConvert(tempGain);\par
  299             \}\par
  300             else\par
  301             \{\par
  302                 this->adc2.gain=this->adc2.gain;\par
  303             \}\par
  304             json["adc2"]["gain"]=this->adc2.gain;\par
  305 \par
  306             \par
  307             if(json["adc2"]["type"].success() )\par
  308             \{\par
  309                 this->adc2.type=json["adc2"]["type"].as<String>(); \par
  310             \}\par
  311             else\par
  312             \{\par
  313                 this->adc2.type=this->adc2.type;\par
  314             \}\par
  315             json["adc2"]["type"]=this->adc2.type;\par
  316 \par
  317 \par
  318             if(json["pH7Cal"].success())\par
  319             \{\par
  320                 this->params.pH7Cal=json["pH7Cal"];         \par
  321             \}\par
  322             else\par
  323             \{\par
  324                 this->params.pH7Cal=this->params.pH7Cal;\par
  325             \}\par
  326             json["pH7Cal"]=this->params.pH7Cal;\par
  327 \par
  328             \par
  329             if(json["pH4Cal"].success())\par
  330             \{\par
  331                 this->params.pH4Cal=json["pH4Cal"];         \par
  332             \}\par
  333             else\par
  334             \{\par
  335                 this->params.pH4Cal=this->params.pH4Cal;\par
  336             \}\par
  337             json["pH4Cal"]=this->params.pH4Cal;\par
  338 \par
  339 \par
  340             if(json["pHStep"].success())\par
  341             \{\par
  342                 this->params.pHStep=json["pHStep"];         \par
  343             \}\par
  344             else\par
  345             \{\par
  346                 this->params.pHStep=this->params.pHStep;\par
  347             \}\par
  348             json["pHStep"]=this->params.pHStep;\par
  349 \par
  350 \par
  351             irene3000Config.close();\par
  352             irene3000Config = SPIFFS.open("/irene3000Config.json", "w");\par
  353 \par
  354             if(!irene3000Config)\par
  355             \{\par
  356             \par
  357             #if DEBUG == 1\par
  358 \par
  359                 Serial.println( F("failed to write to /irene3000Config.json") );\par
  360                 Serial.println();\par
  361             \par
  362             #endif \par
  363 \par
  364                 return(false);\par
  365             \}\par
  366 \par
  367             json.printTo(irene3000Config);\par
  368             irene3000Config.close();\par
  369             \par
  370         #if DEBUG == 1 \par
  371 \par
  372             Serial.println( F("saved configuration file :")  );\par
  373             json.printTo(Serial);\par
  374             Serial.println();\par
  375         \par
  376         #endif\par
  377 \par
  378             return(true); \par
  379         \}\par
  380     \}   \par
  381 \par
  382 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_afed5c35e4b23963c157847ef27c11e9c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_afed5c35e4b23963c157847ef27c11e9c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v gainConvert\:Irene3000}
{\xe \v Irene3000\:gainConvert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Irene3000::gainConvert (uint16_t  {\i tempGain})}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::gainConvert}( gain : \{ 0.67 ,1,2,4,8,16 \} ) This method is provided to convert the gain to Internal Constants\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid internal representation of the ADS gain \par
}}{
Definition at line 730 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   731 \{\par
  732 \par
  733 #if DEBUG == 1 \par
  734 \par
  735     Serial.println( F("Entering Irene3000.gainConvert()") );\par
  736     Serial.println();\par
  737 \par
  738 #endif \par
  739     \par
  740     switch(tempGain)\par
  741     \{\par
  742         case(1): return (GAIN_ONE);\par
  743         case(2) : return(GAIN_TWO);\par
  744         case(4): return(GAIN_FOUR) ;   \par
  745         case(8):return(GAIN_EIGHT)  ;  \par
  746         case(16):return(GAIN_SIXTEEN);\par
  747         default: return(GAIN_TWOTHIRDS);    \par
  748     \}\par
  749 \par
  750     return(GAIN_ONE);\par
  751 \par
  752 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_abcad62d1201a59f8dd3ba87048002728_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:Irene3000}
{\xe \v Irene3000\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::printConf ()}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 389 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   390 \{\par
  391 \par
  392 #if DEBUG == 1 \par
  393 \par
  394     Serial.println( F("Entering Irene3000.printConf()") );\par
  395     Serial.println();\par
  396 \par
  397 #endif \par
  398 \par
  399     Serial.println("Irene Configuration ");\par
  400 \par
  401     Serial.print("waterTemp.active : ");\par
  402     Serial.println(waterTemp.active);\par
  403 \par
  404     Serial.print("waterTemp.gain : ");\par
  405     Serial.println(waterTemp.gain,HEX); \par
  406 \par
  407     Serial.print("phProbe.active : ");\par
  408     Serial.println(phProbe.active);\par
  409 \par
  410     Serial.print("phProbe.gain : ");\par
  411     Serial.println(phProbe.gain,HEX);\par
  412     \par
  413     Serial.print("adc2.active : ");\par
  414     Serial.println(adc2.active);\par
  415 \par
  416     Serial.print("adc2.gain : ");\par
  417     Serial.println(adc2.gain,HEX);\par
  418 \par
  419     Serial.print("adc2.type : ");\par
  420     Serial.println(adc2.type);\par
  421 \par
  422     Serial.println();\par
  423 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a7bc2414100b5e19eacc6630fa34b2654_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read\:Irene3000}
{\xe \v Irene3000\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Irene3000::read (void )}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000}:{\b read()}: This method is provided to read the {\b Irene3000} sensors data\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid json string of the sensors data \par
}}{
Definition at line 131 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   132 \{\par
  133 \par
  134 #if DEBUG == 1 \par
  135     \par
  136     Serial.println( F("Entering Irene3000.read()") );\par
  137     Serial.println();\par
  138 \par
  139 #endif \par
  140 \par
  141     String data;\par
  142     DynamicJsonBuffer jsonBuffer;\par
  143     JsonObject& root = jsonBuffer.createObject();\par
  144     if( !( root.success()) )\par
  145     \{\par
  146     \par
  147     #if DEBUG == 1 \par
  148 \par
  149         Serial.println( F("failed to create json") );\par
  150     \par
  151     #endif \par
  152 \par
  153         return("");\par
  154     \}\par
  155 \par
  156         \par
  157     if(waterTemp.active)\par
  158     \{\par
  159         root["waterTemp"] = this->readTemp();\par
  160 \par
  161         if(phProbe.active)\par
  162         \{\par
  163             root["ph"] =this->readPh( root["waterTemp"].as<double>() ) ;\par
  164         \}\par
  165 \par
  166     \}\par
  167 \par
  168     if(adc2.active)\par
  169     \{\par
  170         root[adc2.type] =this->readADSChannel2(adc2.gain);\par
  171     \}\par
  172     \par
  173     root.printTo(data);\par
  174     \par
  175 #if DEBUG == 1 \par
  176 \par
  177     Serial.println( F("Irene data : ") );\par
  178     Serial.println(data);\par
  179     Serial.println();\par
  180 \par
  181     Serial.print(F("jsonBuffer size: "));\par
  182     Serial.println(jsonBuffer.size());\par
  183     Serial.println();\par
  184 \par
  185 \par
  186 #endif\par
  187     \par
  188     return(data);\par
  189     \par
  190     \par
  191 \par
  192 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a852a170feea994ea1df01c6b245b5d9a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a852a170feea994ea1df01c6b245b5d9a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readADSChannel2\:Irene3000}
{\xe \v Irene3000\:readADSChannel2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::readADSChannel2 ({\b adsGain_t}  {\i gain})}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::readADSChannel2(gain): This method is provided to read from the ADS channel 2 . ADS Channel 2 is free and the user can connect another analog sensor to it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ADS Channel 2 value \par
}}{
Definition at line 482 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   483 \{   \par
  484 \par
  485 #if DEBUG == 1 \par
  486     \par
  487     Serial.println( F("Entering Irene3000.readADSChannel2()") );\par
  488     Serial.println();\par
  489 \par
  490 #endif\par
  491 \par
  492     this->setGain(gain);\par
  493     int result = this->ads.readADC_SingleEnded(freeAdc);\par
  494 #if DEBUG == 1 \par
  495     \par
  496     Serial.println( F("adc2 value : ") );\par
  497     Serial.println( );\par
  498     Serial.println();\par
  499 \par
  500 #endif\par
  501 \par
  502     return( result ) ;\par
  503 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ae73bd2ed14a199a7e83f4d6458476a7c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_ae73bd2ed14a199a7e83f4d6458476a7c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readButton\:Irene3000}
{\xe \v Irene3000\:readButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::readButton ()}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::readButton()}: This method is provided to read the {\b Irene3000} button\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the button value \par
}}{
Definition at line 432 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   433 \{\par
  434 \par
  435 #if DEBUG == 1 \par
  436 \par
  437     Serial.println( F("Entering Irene3000.readButton()" ) );\par
  438     Serial.println();\par
  439 \par
  440 #endif \par
  441 \par
  442     this->setGain(GAIN_TWOTHIRDS);\par
  443     int result =this->ads.readADC_SingleEnded(button);\par
  444 #if DEBUG == 1\par
  445     \par
  446     Serial.println( F("button value : ") );\par
  447     Serial.println( result );\par
  448 \par
  449 #endif \par
  450 \par
  451     return( result );\par
  452     \par
  453 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a78a87eb7cf295b95c12b2ebd51c2bb77_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a78a87eb7cf295b95c12b2ebd51c2bb77_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readPh\:Irene3000}
{\xe \v Irene3000\:readPh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Irene3000::readPh (double  {\i t})}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::readPh(double t)}: This method is provided to read the PH probe note that for the best results, PH must be correlated to Temperature.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the PH probe value \par
}}{
Definition at line 513 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   514 \{\par
  515 \par
  516 #if DEBUG == 1 \par
  517 \par
  518     Serial.println( F("Entering Irene3000.readPh()") );\par
  519     Serial.println();\par
  520 \par
  521 #endif \par
  522 \par
  523     this->setGain(GAIN_FOUR);\par
  524     int adcR=ads.readADC_SingleEnded(ph);\par
  525     double Voltage =  REFERENCE_VOLTAGE_GAIN_4 * ( adcR ) / ADC_MAXIMUM_VALUE;\par
  526 \par
  527     float miliVolts = Voltage * 1000;\par
  528     float temporary = ((((vRef * (float)params.pH7Cal) / 32767) * 1000) - miliVolts) / opampGain;\par
  529     \par
  530     float phT=7 - (temporary / params.pHStep);\par
  531 \par
  532     float ph25= ( phT / ( 1 + 0.009*( t - 25 ) ) );\par
  533 \par
  534 #if DEBUG == 1 \par
  535 \par
  536     Serial.println( F("ph is : ") );\par
  537     Serial.println( phT ) ;\par
  538     \par
  539     Serial.println(F("corrected ph to 25\'B0C is : "));\par
  540     Serial.println(ph25);\par
  541 \par
  542 #endif \par
  543     if(isnan(ph25) )\par
  544     \{\par
  545         return(-42);    \par
  546     \}\par
  547 \par
  548     return(ph25);\par
  549 \par
  550 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a436fc0a06681cd0784aba56b9707f19a_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a436fc0a06681cd0784aba56b9707f19a_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTemp\:Irene3000}
{\xe \v Irene3000\:readTemp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Irene3000::readTemp ()}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::readTemp(gain): This method is provided to read the Temeperature probe\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the Temperature probe value \par
}}{
Definition at line 559 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   560 \{\par
  561 \par
  562 #if DEBUG == 1 \par
  563 \par
  564     Serial.println( F("Entering Irene3000.readTemp()") );\par
  565     Serial.println();\par
  566 \par
  567 #endif\par
  568 \par
  569     const double A = 3.9083E-3;\par
  570     const double B = -5.775E-7;\par
  571     double T;\par
  572 \par
  573     this->setGain(GAIN_EIGHT);\par
  574 \par
  575     double adc0 = ads.readADC_SingleEnded(temp);\par
  576 \par
  577 \par
  578     double R = ( ( adc0 * V_GAIN_8 ) / 0.095 ) / 1000 ;\par
  579 \par
  580     T = 0.0 - A;\par
  581     T += sqrt((A * A) - 4.0 * B * (1.0 - R));\par
  582     T /= (2.0 * B);\par
  583 \par
  584     if (T > 0 && T < 200) \par
  585     \{\par
  586 \par
  587     #if DEBUG == 1 \par
  588 \par
  589         Serial.print( F(" temperature : ") );\par
  590         Serial.println(T);\par
  591         Serial.println();\par
  592     \par
  593     #endif \par
  594         if(isnan(T))\par
  595         \{\par
  596             return(-300);           \par
  597         \}\par
  598 \par
  599         return T;\par
  600     \}\par
  601     else \par
  602     \{\par
  603         T = 0.0 - A;\par
  604         T -= sqrt((A * A) - 4.0 * B * (1.0 - R));\par
  605         T /= (2.0 * B);\par
  606     \par
  607     #if DEBUG == 1 \par
  608     \par
  609         Serial.println( F("temperature : ") );\par
  610         Serial.println(T);\par
  611         Serial.println();\par
  612     \par
  613     #endif\par
  614         if(isnan(T))\par
  615         \{\par
  616             return(-400);           \par
  617         \}\par
  618 \par
  619         return T;\par
  620     \}\par
  621 \par
  622 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a80bc6dfea106dc3bc54fa20204d4d5dc_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a80bc6dfea106dc3bc54fa20204d4d5dc_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetParams\:Irene3000}
{\xe \v Irene3000\:resetParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::resetParams (void )}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000::resetParams()}: This method is provided to reset the PH configuration, assuming Ideal configuration \par
}{
Definition at line 704 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   705 \{\par
  706 \par
  707 #if DEBUG == 1 \par
  708 \par
  709     Serial.println( F("Entering Irene3000.resetParams()") );\par
  710     Serial.println();\par
  711 \par
  712 #endif \par
  713 \par
  714     //Restore to default set of parameters!\par
  715     params.WriteCheck = Write_Check;\par
  716     params.pH7Cal = 16384; //assume ideal probe and amp conditions 1/2 of 4096\par
  717     params.pH4Cal = 8192; //using ideal probe slope we end up this many 12bit units away on the 4 scale\par
  718     params.pHStep = 59.16;//ideal probe slope\par
  719 \par
  720 \par
  721 \}\par
}
}
{\xe \v saveParams\:Irene3000}
{\xe \v Irene3000\:saveParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Irene3000::saveParams ()}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 755 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   756 \{\par
  757 \par
  758 #if DEBUG == 1\par
  759         \par
  760     Serial.println(F("Entering Irene3000.saveParams()"));\par
  761     Serial.println();\par
  762     \par
  763     Serial.println(F("saving new params"));\par
  764 #endif\par
  765     \par
  766     //open file\par
  767     File irene3000Config = SPIFFS.open("/irene3000Config.json", "r");\par
  768 \par
  769     if (!irene3000Config) \par
  770     \{\par
  771     \par
  772     #if DEBUG == 1 \par
  773 \par
  774         Serial.println( F("failed to read /irene3000Config.json") );\par
  775         Serial.println();\par
  776     \par
  777     #endif\par
  778 \par
  779         return(false);\par
  780     \}\par
  781     else\par
  782     \{\par
  783         //read file into json\par
  784         size_t size = irene3000Config.size();\par
  785         // Allocate a buffer to store contents of the file.\par
  786         std::unique_ptr<char[]> buf(new char[size]);\par
  787             irene3000Config.readBytes(buf.get(), size);\par
  788         DynamicJsonBuffer jsonBuffer;\par
  789         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  790         if (!json.success()) \par
  791         \{\par
  792         \par
  793         #if DEBUG == 1 \par
  794 \par
  795             Serial.println( F("failed to parse json ") );\par
  796             Serial.println();\par
  797         \par
  798         #endif\par
  799             \par
  800             return(false);\par
  801         \} \par
  802         else\par
  803         \{\par
  804         \par
  805         #if DEBUG == 1 \par
  806     \par
  807             Serial.println( F("read configuration file ") );\par
  808             json.printTo(Serial);\par
  809             Serial.println();\par
  810 \par
  811             Serial.print(F("jsonBuffer size: "));\par
  812             Serial.println(jsonBuffer.size());\par
  813             Serial.println();\par
  814 \par
  815         \par
  816 \par
  817         #endif          \par
  818     \par
  819             //add params to json\par
  820             json["pH7Cal"]=this->params.pH7Cal;\par
  821             json["pH4Cal"]=this->params.pH4Cal;\par
  822             json["pHStep"]=this->params.pHStep;         \par
  823             \par
  824             irene3000Config.close();\par
  825             \par
  826             \par
  827             //save json to file\par
  828             irene3000Config = SPIFFS.open("/irene3000Config.json", "w");\par
  829 \par
  830             if(!irene3000Config)\par
  831             \{\par
  832             \par
  833             #if DEBUG == 1\par
  834 \par
  835                 Serial.println( F("failed to write to /irene3000Config.json") );\par
  836                 Serial.println();\par
  837             \par
  838             #endif \par
  839 \par
  840                 return(false);\par
  841             \}\par
  842 \par
  843             json.printTo(irene3000Config);\par
  844             irene3000Config.close();\par
  845             \par
  846         #if DEBUG == 1 \par
  847 \par
  848             Serial.println( F("saved configuration file :")  );\par
  849             json.printTo(Serial);\par
  850             Serial.println();\par
  851         \par
  852         #endif\par
  853 \par
  854             return(true); \par
  855         \}\par
  856     \}   \par
  857 \par
  858 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_a63dbd38e79b8cd5f1fba4b245501a894_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setGain\:Irene3000}
{\xe \v Irene3000\:setGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Irene3000::setGain ({\b adsGain_t}  {\i gain})}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irene3000::setGain(gain): This method is provided to set the ADS chip gain \par
}{
Definition at line 460 of file irene3000.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   461 \{\par
  462 \par
  463 #if DEBUG == 1  \par
  464 \par
  465     Serial.println( F("Entering Irene3000.setGain()") );\par
  466     Serial.println();\par
  467 \par
  468 #endif\par
  469 \par
  470     this->ads.setGain(gain);\par
  471 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aff7c5da186b388e7272e63ff88a20c34_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d03/class_irene3000_aff7c5da186b388e7272e63ff88a20c34_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v adc2\:Irene3000}
{\xe \v Irene3000\:adc2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::state} Irene3000::adc2{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ads\:Irene3000}
{\xe \v Irene3000\:ads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Adafruit_ADS1115} Irene3000::ads{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file Irene3000.h.}\par
}
{\xe \v opampGain\:Irene3000}
{\xe \v Irene3000\:opampGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float Irene3000::opampGain = 5.25{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file Irene3000.h.}\par
}
{\xe \v params\:Irene3000}
{\xe \v Irene3000\:params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::parameters_T} Irene3000::params{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phProbe\:Irene3000}
{\xe \v Irene3000\:phProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::state}  Irene3000::phProbe{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vRef\:Irene3000}
{\xe \v Irene3000\:vRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float Irene3000::vRef = 1.024{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file Irene3000.h.}\par
}
{\xe \v waterTemp\:Irene3000}
{\xe \v Irene3000\:waterTemp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Irene3000::state}  Irene3000::waterTemp{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b irene3000.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Jetpack Class Reference\par \pard\plain 
{\tc\tcl2 \v Jetpack}
{\xe \v Jetpack}
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield. }}\par
{
{\f2 #include <Jetpack.h>}}\par
Collaboration diagram for Jetpack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/db7/class_jetpack__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (byte {\b action})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeBit} (byte pin, bool {\b state})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doAction} (const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalAction} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invertedAction} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOff} (int actorNumber)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b temporalActionOn} (int actorNumber)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOff} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedTemporalActionOn} (int actorNumber, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourAction} (int actorNumber, int hour)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourAction} (int actorNumber, int hour, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b minuteAction} (int actorNumber, int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedMinuteAction} (int actorNumber, int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hourMinuteAction} (int actorNumber, int hour, int minute)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mixedHourMinuteAction} (int actorNumber, int hour, int minute, float measurment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printConf} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b action} = B00000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Jetpack::state} {\b actors} [8]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b clockPin} = 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b dataPin} = 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b EnI2C} =5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield. \par
}{
Definition at line 42 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Jetpack}
{\xe \v Jetpack\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::begin (void )}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack::begin()}: This method is provided to initialise the pin that control the {\b Jetpack} shield \par
}{
Definition at line 47 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    48 \{\par
   49 \par
   50 #if DEBUG == 1 \par
   51  \par
   52     Serial.println( F("Entering Jetpack.begin() ") );\par
   53     Serial.println();\par
   54 \par
   55 #endif\par
   56 \par
   57     pinMode(EnI2C,OUTPUT);\par
   58     pinMode(dataPin,OUTPUT);\par
   59     pinMode(clockPin,OUTPUT);\par
   60     \par
   61     \par
   62 \par
   63 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a5a53e1ebf7aaf3bf3e0d37ea64ca09a7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v config\:Jetpack}
{\xe \v Jetpack\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::config ()}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack::config()}: This method is provided to configure the {\b Jetpack} with a configuration file\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if successful,false otherwise \par
}}{
Definition at line 304 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   305 \{\par
  306 \par
  307 #if DEBUG == 1 \par
  308 \par
  309     Serial.println( F("Entering Jetpack.config() ") );\par
  310     Serial.println();\par
  311 \par
  312 #endif\par
  313 \par
  314     File jetPackConfig = SPIFFS.open("/jetPackConfig.json", "r");\par
  315 \par
  316     if (!jetPackConfig) \par
  317     \{\par
  318 \par
  319     #if DEBUG == 1 \par
  320 \par
  321         Serial.println( F("failed to read /jetPackConfig.json ") );\par
  322         Serial.println();\par
  323 \par
  324     #endif\par
  325 \par
  326         return(false);\par
  327     \}\par
  328     else\par
  329     \{\par
  330         size_t size = jetPackConfig.size();\par
  331         // Allocate a buffer to store contents of the file.\par
  332         std::unique_ptr<char[]> buf(new char[size]);\par
  333 \par
  334         jetPackConfig.readBytes(buf.get(), size);\par
  335         DynamicJsonBuffer jsonBuffer;\par
  336         JsonObject& json = jsonBuffer.parseObject(buf.get());\par
  337         if (!json.success()) \par
  338         \{\par
  339         \par
  340         #if DEBUG == 1 \par
  341 \par
  342             Serial.println( F("failed to parse jetpack config json from file ") );\par
  343             Serial.println();\par
  344 \par
  345         #endif\par
  346 \par
  347             return(false);\par
  348         \} \par
  349         else\par
  350         \{ \par
  351         \par
  352         #if DEBUG == 1 \par
  353 \par
  354             Serial.println( F("read configuration file : ") );\par
  355             json.printTo(Serial);\par
  356             Serial.println();\par
  357 \par
  358             Serial.print(F("jsonBuffer size: "));\par
  359             Serial.println(jsonBuffer.size());\par
  360             Serial.println();\par
  361 \par
  362         \par
  363         #endif\par
  364   \par
  365             for(int i=0;i<8;i++)\par
  366             \{   \par
  367                 if(json[String("Act")+String(i)].success())\par
  368                 \{\par
  369                     //parsing actif key\par
  370                     if(json[String("Act")+String(i)]["actif"].success() )\par
  371                     \{\par
  372                         this->actors[i].actif=json[String("Act")+String(i)]["actif"];\par
  373                     \}\par
  374                     else\par
  375                     \{\par
  376                         this->actors[i].actif=this->actors[i].actif;\par
  377                     \}\par
  378                     json[String("Act")+String(i)]["actif"]=this->actors[i].actif;\par
  379                     \par
  380                     //parsing temporal key\par
  381                     if(json[String("Act")+String(i)]["temporal"].success() )\par
  382                     \{\par
  383                         this->actors[i].temporal=json[String("Act")+String(i)]["temporal"];\par
  384                     \}\par
  385                     else\par
  386                     \{\par
  387                         this->actors[i].temporal=this->actors[i].temporal;\par
  388                     \}\par
  389                     json[String("Act")+String(i)]["temporal"]=this->actors[i].temporal;\par
  390                     \par
  391                     //parsing inverted key\par
  392                     if(json[String("Act")+String(i)]["inverted"].success() )\par
  393                     \{\par
  394                         this->actors[i].inverted=json[String("Act")+String(i)]["inverted"];\par
  395                     \}\par
  396                     else\par
  397                     \{\par
  398                         this->actors[i].inverted=this->actors[i].inverted;\par
  399                     \}\par
  400                     json[String("Act")+String(i)]["inverted"]=this->actors[i].inverted;\par
  401 \par
  402                     //parsing inverted key\par
  403                     if(json[String("Act")+String(i)]["inverted"].success() )\par
  404                     \{\par
  405                         this->actors[i].inverted=json[String("Act")+String(i)]["inverted"];\par
  406                     \}\par
  407                     else\par
  408                     \{\par
  409                         this->actors[i].inverted=this->actors[i].inverted;\par
  410                     \}\par
  411                     json[String("Act")+String(i)]["inverted"]=this->actors[i].inverted;\par
  412                     \par
  413                     //parsing low key\par
  414                     if(json[String("Act")+String(i)]["low"].success() )\par
  415                     \{\par
  416                         this->actors[i].rangeLow=json[String("Act")+String(i)]["low"][0];\par
  417                         this->actors[i].timeLow=json[String("Act")+String(i)]["low"][1];\par
  418                         this->actors[i].hourLow=json[String("Act")+String(i)]["low"][2];                        \par
  419                         this->actors[i].minuteLow=json[String("Act")+String(i)]["low"][3];                      \par
  420                     \}\par
  421                     else\par
  422                     \{\par
  423                         this->actors[i].rangeLow=this->actors[i].rangeLow;\par
  424                         this->actors[i].timeLow=this->actors[i].timeLow;\par
  425                         this->actors[i].hourLow=this->actors[i].hourLow;\par
  426                         this->actors[i].minuteLow=this->actors[i].minuteLow;                        \par
  427                     \}\par
  428                     json[String("Act")+String(i)]["low"][0]=this->actors[i].rangeLow;\par
  429                     json[String("Act")+String(i)]["low"][1]=this->actors[i].timeLow;\par
  430                     json[String("Act")+String(i)]["low"][2]=this->actors[i].hourLow;\par
  431                     json[String("Act")+String(i)]["low"][3]=this->actors[i].minuteLow;\par
  432 \par
  433                     //parsing high key\par
  434                     if(json[String("Act")+String(i)]["high"].success() )\par
  435                     \{\par
  436                         this->actors[i].rangeHigh=json[String("Act")+String(i)]["high"][0];\par
  437                         this->actors[i].timeHigh=json[String("Act")+String(i)]["high"][1];\par
  438                         this->actors[i].hourHigh=json[String("Act")+String(i)]["high"][2];                      \par
  439                         this->actors[i].minuteHigh=json[String("Act")+String(i)]["high"][3];                        \par
  440                     \}\par
  441                     else\par
  442                     \{\par
  443                         this->actors[i].rangeHigh=this->actors[i].rangeHigh;\par
  444                         this->actors[i].timeHigh=this->actors[i].timeHigh;\par
  445                         this->actors[i].hourHigh=this->actors[i].hourHigh;\par
  446                         this->actors[i].minuteHigh=this->actors[i].minuteHigh;\par
  447                     \}\par
  448                     json[String("Act")+String(i)]["high"][0]=this->actors[i].rangeHigh;\par
  449                     json[String("Act")+String(i)]["high"][1]=this->actors[i].timeHigh;\par
  450                     json[String("Act")+String(i)]["high"][2]=this->actors[i].hourHigh;\par
  451                     json[String("Act")+String(i)]["high"][3]=this->actors[i].minuteHigh;\par
  452 \par
  453                     //parsing type key\par
  454                     if(json[String("Act")+String(i)]["type"].success() )\par
  455                     \{\par
  456                         this->actors[i].primaryType=json[String("Act")+String(i)]["type"][0].as<String>();\par
  457                         this->actors[i].secondaryType=json[String("Act")+String(i)]["type"][1].as<String>();                        \par
  458                         \par
  459                     \}\par
  460                     else\par
  461                     \{\par
  462                         this->actors[i].primaryType=this->actors[i].primaryType;\par
  463                         this->actors[i].secondaryType=this->actors[i].secondaryType;\par
  464                     \}\par
  465                     json[String("Act")+String(i)]["type"][0]=this->actors[i].primaryType;\par
  466                     json[String("Act")+String(i)]["type"][1]=this->actors[i].secondaryType;\par
  467                         \par
  468 \par
  469 \par
  470                     \par
  471                     \par
  472                      \par
  473                 \}\par
  474                 else\par
  475                 \{\par
  476                     this->actors[i]=this->actors[i];\par
  477                 \}\par
  478                 \par
  479                 json[String("Act")+String(i)]["actif"]=this->actors[i].actif;\par
  480                 json[String("Act")+String(i)]["temporal"]=this->actors[i].temporal;\par
  481                 json[String("Act")+String(i)]["inverted"]=this->actors[i].inverted;\par
  482 \par
  483                 json[String("Act")+String(i)]["low"][0]=this->actors[i].rangeLow;\par
  484                 json[String("Act")+String(i)]["low"][1]=this->actors[i].timeLow;\par
  485                 json[String("Act")+String(i)]["low"][2]=this->actors[i].hourLow;\par
  486                 json[String("Act")+String(i)]["low"][3]=this->actors[i].minuteLow;\par
  487 \par
  488                 json[String("Act")+String(i)]["high"][0]=this->actors[i].rangeHigh;\par
  489                 json[String("Act")+String(i)]["high"][1]=this->actors[i].timeHigh;\par
  490                 json[String("Act")+String(i)]["high"][2]=this->actors[i].hourHigh;\par
  491                 json[String("Act")+String(i)]["high"][3]=this->actors[i].minuteHigh;\par
  492 \par
  493                 json[String("Act")+String(i)]["type"][0]=this->actors[i].primaryType;\par
  494                 json[String("Act")+String(i)]["type"][1]=this->actors[i].secondaryType;\par
  495 \par
  496 \par
  497 \par
  498             \}\par
  499             \par
  500 \par
  501             jetPackConfig.close();          \par
  502             jetPackConfig = SPIFFS.open("/jetPackConfig.json", "w");            \par
  503             if(!jetPackConfig)\par
  504             \{\par
  505             \par
  506             #if DEBUG == 1 \par
  507 \par
  508                 Serial.println( F("failed to write to /jetPackConfig.json ") );\par
  509                 Serial.println();\par
  510             \par
  511             #endif\par
  512                 \par
  513                 return(false);          \par
  514             \}  \par
  515 \par
  516             json.printTo(jetPackConfig);\par
  517             jetPackConfig.close();\par
  518 \par
  519         #if DEBUG == 1 \par
  520             \par
  521             Serial.println(F("saved configuration : "));\par
  522             json.printTo(Serial );\par
  523             Serial.println();       \par
  524         \par
  525         #endif\par
  526 \par
  527             return(true); \par
  528         \}\par
  529     \}   \par
  530     \par
  531 \par
  532 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ab065ee83e244265a2223a22f3ee4a719_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v doAction\:Jetpack}
{\xe \v Jetpack\:doAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::doAction (const char *  {\i data})}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::doAction(sensor data ): This method is provided to automate the {\b Jetpack}.\par
The result action is the result of checking the different flags of an actor (actif , temporal ,inverted, primaryType and secondaryType ) and the corresponding call to the appropriate helping method \par
}{
Definition at line 141 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   142 \{\par
  143 \par
  144 #if DEBUG == 1 \par
  145 \par
  146     Serial.println( F("Entering Jetpack.doAction()") );\par
  147     Serial.println();\par
  148 \par
  149     Serial.println( F("input data is :") );\par
  150     Serial.println(data);\par
  151     Serial.println();\par
  152 \par
  153 #endif \par
  154 \par
  155     DynamicJsonBuffer jsonBuffer;\par
  156     JsonObject& root = jsonBuffer.parseObject(data);\par
  157     \par
  158     if (!root.success()) \par
  159     \{\par
  160     \par
  161     #if DEBUG == 1 \par
  162 \par
  163         Serial.println( F("failed to parse json object ") );\par
  164         Serial.println();\par
  165     \par
  166     #endif \par
  167 \par
  168     \}\par
  169     else\par
  170     \{\par
  171     \par
  172     #if DEBUG == 1 \par
  173 \par
  174         Serial.println( F("created Json object :") );\par
  175         root.printTo(Serial);\par
  176         Serial.println();\par
  177 \par
  178         Serial.print(F("jsonBuffer size: "));\par
  179         Serial.println(jsonBuffer.size());\par
  180         Serial.println();\par
  181 \par
  182     \par
  183     #endif \par
  184 \par
  185         //invert the current action state for each actor\par
  186         //if the value is outside the limits\par
  187         for(int i=0;i<8;i++)\par
  188         \{\par
  189             //check if actor is actif\par
  190             if(this->actors[i].actif==1)\par
  191             \{\par
  192                 //normal actor\par
  193                 if(this->actors[i].temporal == 0)\par
  194                 \{\par
  195                     //not inverted actor\par
  196                     if(this->actors[i].inverted==0)\par
  197                     \{\par
  198                         this->normalAction(i,root[this->actors[i].primaryType].as<float>());\par
  199             \par
  200                     \}\par
  201                     //inverted actor\par
  202                     else if(this->actors[i].inverted==1)\par
  203                     \{\par
  204                         this->invertedAction(i,root[this->actors[i].primaryType].as<float>());          \par
  205                     \}\par
  206                 \}\par
  207                 //temporal actor\par
  208                 else if(this->actors[i].temporal == 1 )\par
  209                 \{\par
  210                     //hour actor\par
  211                     if(this->actors[i].secondaryType=="hour")\par
  212                     \{\par
  213                         //mixed hour actor\par
  214                         if(root[this->actors[i].primaryType].success() )\par
  215                         \{\par
  216                             this->mixedHourAction(i,root[this->actors[i].secondaryType].as<int>(),root[this->actors[i].primaryType].as<float>());\par
  217                         \}\par
  218                         //normal hour actor\par
  219                         else\par
  220                         \{\par
  221                             this->hourAction(i,root[this->actors[i].secondaryType].as<int>());\par
  222                         \}\par
  223                     \par
  224                     \}\par
  225                     //minute actor\par
  226                     else if(this->actors[i].secondaryType=="minute")\par
  227                     \{\par
  228                         //mixed minute actor\par
  229                         if(root[this->actors[i].primaryType].success() )\par
  230                         \{\par
  231                             this->mixedMinuteAction(i,root[this->actors[i].secondaryType].as<int>(),root[this->actors[i].primaryType].as<float>());\par
  232                         \}\par
  233                         //normal minute actor\par
  234                         else\par
  235                         \{\par
  236                             this->minuteAction(i,root[this->actors[i].secondaryType].as<int>());\par
  237                         \}\par
  238                     \}\par
  239                     //hourMinute actor\par
  240                     else if(this->actors[i].secondaryType=="hourMinute")\par
  241                     \{\par
  242                         //mixed hourMinute actor\par
  243                         if(root[this->actors[i].primaryType].success() )\par
  244                         \{\par
  245                             this->mixedHourMinuteAction(i,root["hour"].as<int>(),root["minute"].as<int>(),root[this->actors[i].primaryType].as<float>());\par
  246                         \}\par
  247                         //normal hourMinute actor\par
  248                         else\par
  249                         \{\par
  250                             this->hourMinuteAction(i,root["hour"].as<int>(),root["minute"].as<int>());\par
  251                         \}\par
  252                     \}\par
  253                     //normal temporal actor\par
  254                     else if(this->actors[i].secondaryType=="")\par
  255                     \{\par
  256                         //mixed temporal actor\par
  257                         if(root[this->actors[i].primaryType].success() )\par
  258                         \{\par
  259                             this->mixedTemporalActionOn(i,root[this->actors[i].primaryType].as<float>());\par
  260                         \}\par
  261                         //normal temporal actor\par
  262                         else\par
  263                         \{\par
  264                             this->temporalActionOn(i);\par
  265                         \}\par
  266                                             \par
  267                     \}\par
  268 \par
  269                 \}\par
  270             \}\par
  271             //inactif actor\par
  272             else if(this->actors[i].actif == 0 )\par
  273             \{\par
  274                 //temporal actor\par
  275                 if(this->actors[i].temporal==1)\par
  276                 \{\par
  277                     //mixed temporal actor\par
  278                     if(root[this->actors[i].primaryType].success() )\par
  279                     \{\par
  280                         this->mixedTemporalActionOff(i,root[this->actors[i].primaryType].as<float>());\par
  281                     \}\par
  282                     //normal temporal actor\par
  283                     else\par
  284                     \{\par
  285                         this->temporalActionOff(i);\par
  286                     \}\par
  287                 \}           \par
  288             \}\par
  289 \par
  290         \}\par
  291 \par
  292         this->write(this->action);\par
  293 \par
  294     \} \par
  295 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a9e703197093094b963f9ad57817495b8_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a9e703197093094b963f9ad57817495b8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourAction\:Jetpack}
{\xe \v Jetpack\:hourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::hourAction (int  {\i actorNumber}, int  {\i hour})}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::hourAction(actorNumber, current hour ): This method is provided to handle hour actors. it changes the action according to:\par
hour >= hourLow : deactivate the actor hour >= hourHigh : activate the actor \par
}{
Definition at line 1024 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1025 \{\par
 1026 \par
 1027 #if DEBUG == 1\par
 1028     \par
 1029     Serial.print(F("hour Actor N\'B0 : "));\par
 1030     Serial.println(actorNumber);\par
 1031 \par
 1032     Serial.print(F(" hour : "));\par
 1033     Serial.println(hour);\par
 1034 \par
 1035     Serial.print(F("high hour : "));\par
 1036     Serial.println(this->actors[actorNumber].hourHigh);\par
 1037 \par
 1038     Serial.print(F("low hour : "));\par
 1039     Serial.println(this->actors[actorNumber].hourLow);\par
 1040 \par
 1041 #endif\par
 1042 \par
 1043     //stop the actor    \par
 1044     if(hour >= this->actors[actorNumber].hourLow)\par
 1045     \{\par
 1046         bitWrite( this->action , actorNumber , 0) ;\par
 1047 \par
 1048     #if DEBUG == 1 \par
 1049 \par
 1050         Serial.println(F("actor OFF "));\par
 1051 \par
 1052     #endif  \par
 1053 \par
 1054     \}\par
 1055     //starting the actor\par
 1056     else if(hour >= this->actors[actorNumber].hourHigh)\par
 1057     \{\par
 1058         bitWrite( this->action , actorNumber , 1) ;\par
 1059 \par
 1060     #if DEBUG == 1 \par
 1061 \par
 1062         Serial.println(F("actor ON "));\par
 1063 \par
 1064     #endif  \par
 1065     \par
 1066     \}\par
 1067 \par
 1068 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_acd6889af2fe5b057c6bd51b6dac827ef_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hourMinuteAction\:Jetpack}
{\xe \v Jetpack\:hourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::hourMinuteAction (int  {\i actorNumber}, int  {\i hour}, int  {\i minute})}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::minteAction(actorNumber, current hour,current minute ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : deactivate the actor\par
hour > hourLow : deactivate the actor\par
hour == hourHigh : minute >= minteHigh : activate the actor\par
hour > hourHigh : activate the actor \par
}{
Definition at line 1368 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1369 \{\par
 1370 \par
 1371 #if DEBUG == 1\par
 1372 \par
 1373     Serial.print(F("hourMinute Actor N\'B0 : "));\par
 1374     Serial.println(actorNumber);\par
 1375 \par
 1376     Serial.print(F(" hour : "));\par
 1377     Serial.println(hour);\par
 1378     Serial.print(F(" minute : "));\par
 1379     Serial.println(minute);\par
 1380 \par
 1381     Serial.print(F("high hour : "));\par
 1382     Serial.println(this->actors[actorNumber].hourHigh);\par
 1383 \par
 1384     Serial.print(F("high minute : "));\par
 1385     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1386 \par
 1387     Serial.print(F("low hour : "));\par
 1388     Serial.println(this->actors[actorNumber].hourLow);\par
 1389 \par
 1390     Serial.print(F("low minute : "));\par
 1391     Serial.println(this->actors[actorNumber].minuteLow);\par
 1392 \par
 1393 #endif\par
 1394     //stop the actor\par
 1395     if(hour==this->actors[actorNumber].hourLow)\par
 1396     \{\par
 1397         if(minute>= this->actors[actorNumber].minuteLow)\par
 1398         \{\par
 1399             bitWrite( this->action , actorNumber , 0) ;\par
 1400         #if DEBUG == 1 \par
 1401 \par
 1402             Serial.println(F("actor OFF "));\par
 1403 \par
 1404         #endif  \par
 1405         \}\par
 1406     \}\par
 1407     else if(hour > this->actors[actorNumber].hourLow)\par
 1408     \{\par
 1409 \par
 1410         bitWrite( this->action , actorNumber , 0) ;\par
 1411     #if DEBUG == 1 \par
 1412 \par
 1413         Serial.println(F("actor OFF "));\par
 1414 \par
 1415     #endif  \par
 1416     \par
 1417     \}\par
 1418     //start the actor\par
 1419     else if(hour==this->actors[actorNumber].hourHigh)\par
 1420     \{\par
 1421         if(minute>= this->actors[actorNumber].minuteHigh)\par
 1422         \{\par
 1423             bitWrite( this->action , actorNumber , 1) ;\par
 1424 \par
 1425         #if DEBUG == 1 \par
 1426 \par
 1427             Serial.println(F("actor ON "));\par
 1428 \par
 1429         #endif  \par
 1430         \}\par
 1431     \}\par
 1432     else if(hour > this->actors[actorNumber].hourHigh)\par
 1433     \{\par
 1434 \par
 1435         bitWrite( this->action , actorNumber , 1) ;\par
 1436 \par
 1437     #if DEBUG == 1 \par
 1438 \par
 1439         Serial.println(F("actor ON "));\par
 1440 \par
 1441     #endif      \par
 1442 \par
 1443     \}\par
 1444 \par
 1445     \par
 1446 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ae01c13c785ebdf1b0bb5500234aba1bd_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v invertedAction\:Jetpack}
{\xe \v Jetpack\:invertedAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::invertedAction (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::invertedAction(actorNumber , measured value): This method is provided to handle inverted actors. it changes the action according to wether the measured value is: \par
{\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid rangeHigh (activate actor) \par
}< rangeLow ( deactivate actor ) \par
}{
Definition at line 691 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   692 \{\par
  693 #if DEBUG == 1\par
  694     \par
  695     Serial.print("inverted Actor N\'B0 : ");\par
  696     Serial.println(actorNumber);\par
  697 \par
  698     Serial.print("measured value : ");\par
  699     Serial.println(measurment);\par
  700 \par
  701     Serial.print("high range : ");\par
  702     Serial.println(this->actors[actorNumber].rangeHigh);\par
  703 \par
  704     Serial.print("low range : ");\par
  705     Serial.println(this->actors[actorNumber].rangeLow);\par
  706 \par
  707 #endif\par
  708 \par
  709     //measured value lower than minimum range : deactivate actor\par
  710     if(measurment < this->actors[actorNumber].rangeLow)\par
  711     \{\par
  712         bitWrite( this->action , actorNumber , 0) ;\par
  713 \par
  714     #if DEBUG == 1 \par
  715 \par
  716         Serial.println(F("actor OFF "));\par
  717     \par
  718     #endif\par
  719 \par
  720     \}\par
  721     //measured value higher than maximum range : activate actor\par
  722     else if(measurment > this->actors[actorNumber].rangeHigh)\par
  723     \{\par
  724         bitWrite( this->action , actorNumber , 1) ;\par
  725 \par
  726     #if DEBUG == 1 \par
  727 \par
  728         Serial.println(F("actor ON "));\par
  729     \par
  730     #endif\par
  731 \par
  732     \}\par
  733 \par
  734 \par
  735 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_adacfc35fab4a621357caf98ce1c9cb54_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v minuteAction\:Jetpack}
{\xe \v Jetpack\:minuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::minuteAction (int  {\i actorNumber}, int  {\i minute})}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::minteAction(actorNumber, current minute ): This method is provided to handle minute actors. it changes the action according to:\par
minute >= minuteLow : deactivate the actor minute >= minuteHigh : activate the actor \par
}{
Definition at line 1192 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1193 \{\par
 1194 \par
 1195 #if DEBUG == 1\par
 1196     \par
 1197     Serial.print(F("minute Actor N\'B0 : "));\par
 1198     Serial.println(actorNumber);\par
 1199 \par
 1200     Serial.print(F(" minute : "));\par
 1201     Serial.println(minute);\par
 1202 \par
 1203     Serial.print(F("high minute : "));\par
 1204     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1205 \par
 1206     Serial.print(F("low minute : "));\par
 1207     Serial.println(this->actors[actorNumber].minuteLow);\par
 1208 \par
 1209 #endif\par
 1210 \par
 1211     //stop the actor    \par
 1212     if(minute >= this->actors[actorNumber].minuteLow)\par
 1213     \{\par
 1214         bitWrite( this->action , actorNumber , 0) ;\par
 1215 \par
 1216     #if DEBUG == 1 \par
 1217 \par
 1218         Serial.println(F("actor OFF "));\par
 1219 \par
 1220     #endif  \par
 1221 \par
 1222     \}   \par
 1223     //starting the actor\par
 1224     else if(minute >= this->actors[actorNumber].minuteHigh)\par
 1225     \{\par
 1226         bitWrite( this->action , actorNumber , 1) ;\par
 1227 \par
 1228     #if DEBUG == 1 \par
 1229 \par
 1230         Serial.println(F("actor ON "));\par
 1231 \par
 1232     #endif  \par
 1233 \par
 1234     \}\par
 1235 \par
 1236 \} \par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a97da41141c7b53ddee61143519c8d17d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourAction\:Jetpack}
{\xe \v Jetpack\:mixedHourAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedHourAction (int  {\i actorNumber}, int  {\i hour}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedHourAction(actorNumber, current hour, measured value ): This method is provided to handle mixed hour actors. it changes the action according to :\par
hour >= hourLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
hour >= hourHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 1085 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1086 \{\par
 1087 \par
 1088 #if DEBUG == 1\par
 1089     \par
 1090     Serial.print("mixed hour Actor N\'B0 : ");\par
 1091     Serial.println(actorNumber);\par
 1092 \par
 1093     Serial.print(" hour : ");\par
 1094     Serial.println(hour);\par
 1095 \par
 1096     Serial.print("high hour : ");\par
 1097     Serial.println(this->actors[actorNumber].hourHigh);\par
 1098 \par
 1099     Serial.print("low hour : ");\par
 1100     Serial.println(this->actors[actorNumber].hourLow);\par
 1101 \par
 1102     Serial.print("measured value : ");\par
 1103     Serial.println(measurment);\par
 1104 \par
 1105     Serial.print("high range : ");\par
 1106     Serial.println(this->actors[actorNumber].rangeHigh);\par
 1107 \par
 1108     Serial.print("low range : ");\par
 1109     Serial.println(this->actors[actorNumber].rangeLow);\par
 1110 \par
 1111 #endif\par
 1112     //stop the actor    \par
 1113     if(hour >= this->actors[actorNumber].hourLow)\par
 1114     \{\par
 1115             if( measurment >= this->actors[actorNumber].rangeHigh )\par
 1116             \{\par
 1117                 bitWrite( this->action , actorNumber , 0) ;\par
 1118 \par
 1119             #if DEBUG == 1 \par
 1120 \par
 1121                 Serial.print(measurment);\par
 1122                 Serial.print(F(" > " ));\par
 1123                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1124 \par
 1125                 Serial.println(F("actor OFF "));\par
 1126 \par
 1127             #endif  \par
 1128 \par
 1129             \}\par
 1130             else \par
 1131             \{\par
 1132                 bitWrite( this->action , actorNumber , 1) ;\par
 1133 \par
 1134             #if DEBUG == 1 \par
 1135 \par
 1136                 Serial.print(measurment);\par
 1137                 Serial.print(F(" < " ));\par
 1138                 Serial.print(this->actors[actorNumber].rangeHigh);\par
 1139 \par
 1140                 Serial.println(F("actor ON "));\par
 1141 \par
 1142             #endif  \par
 1143                 \par
 1144             \}\par
 1145     \}\par
 1146     //starting the actor\par
 1147     else if(hour >= this->actors[actorNumber].hourHigh)\par
 1148     \{\par
 1149             if( measurment < this->actors[actorNumber].rangeLow )\par
 1150             \{\par
 1151                 bitWrite( this->action , actorNumber , 1) ;\par
 1152 \par
 1153             #if DEBUG == 1 \par
 1154 \par
 1155                 Serial.print(measurment);\par
 1156                 Serial.print(F(" < " ));\par
 1157                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1158 \par
 1159                 Serial.println(F("actor ON "));\par
 1160 \par
 1161             #endif  \par
 1162             \}\par
 1163             else \par
 1164             \{\par
 1165                 bitWrite( this->action , actorNumber , 0) ;\par
 1166 \par
 1167             #if DEBUG == 1 \par
 1168 \par
 1169                 Serial.print(measurment);\par
 1170                 Serial.print(F(" > " ));\par
 1171                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1172 \par
 1173                 Serial.println(F("actor OFF "));\par
 1174 \par
 1175             #endif                  \par
 1176             \}\par
 1177 \par
 1178     \}\par
 1179 \par
 1180 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ac1a49ab4867718cdb415ad74c2066b9d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedHourMinuteAction\:Jetpack}
{\xe \v Jetpack\:mixedHourMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedHourMinuteAction (int  {\i actorNumber}, int  {\i hour}, int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::minteAction(actorNumber, current hour,current minute , measured Value ): This method is provided to handle hour minute actors. it changes the action according to:\par
hour == hourLow : minute >= minuteLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour > hourLow : measuredValue >= rangeHigh : deactivate actor measuredValue < rangeHigh : activate actor\par
hour == hourHigh : minute >= minteHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor\par
hour > hourHigh : measuredValue >= rangeLow : deactivate actor measuredValue < rangeLow : activate actor \par
}{
Definition at line 1473 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1474 \{\par
 1475 \par
 1476 #if DEBUG == 1\par
 1477     \par
 1478     Serial.print("hourMinute Actor N\'B0 : ");\par
 1479     Serial.println(actorNumber);\par
 1480 \par
 1481     Serial.print(" hour : ");\par
 1482     Serial.println(hour);\par
 1483     Serial.print(" minute : ");\par
 1484     Serial.println(minute);\par
 1485 \par
 1486     Serial.print("high hour : ");\par
 1487     Serial.println(this->actors[actorNumber].hourHigh);\par
 1488 \par
 1489     Serial.print("high minute : ");\par
 1490     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1491 \par
 1492     Serial.print("low hour : ");\par
 1493     Serial.println(this->actors[actorNumber].hourLow);\par
 1494 \par
 1495     Serial.print("low minute : ");\par
 1496     Serial.println(this->actors[actorNumber].minuteLow);\par
 1497 \par
 1498     Serial.print("measured value : ");\par
 1499     Serial.println(measurment);\par
 1500 \par
 1501     Serial.print("high range : ");\par
 1502     Serial.println(this->actors[actorNumber].rangeHigh);\par
 1503 \par
 1504     Serial.print("low range : ");\par
 1505     Serial.println(this->actors[actorNumber].rangeLow);\par
 1506 \par
 1507 #endif\par
 1508     //stop the actor\par
 1509     if(hour==this->actors[actorNumber].hourLow)\par
 1510     \{\par
 1511         if(minute>= this->actors[actorNumber].minuteLow)\par
 1512         \{\par
 1513             if( measurment >= this->actors[actorNumber].rangeHigh )\par
 1514             \{\par
 1515                 bitWrite( this->action , actorNumber , 0) ;\par
 1516 \par
 1517             #if DEBUG == 1 \par
 1518 \par
 1519                 Serial.print(measurment);\par
 1520                 Serial.print(F(" >= " ));\par
 1521                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1522 \par
 1523                 Serial.println(F("actor OFF "));\par
 1524 \par
 1525             #endif  \par
 1526 \par
 1527             \}\par
 1528             else \par
 1529             \{\par
 1530                 bitWrite( this->action , actorNumber , 1) ;\par
 1531 \par
 1532             #if DEBUG == 1 \par
 1533 \par
 1534                 Serial.print(measurment);\par
 1535                 Serial.print(F(" < " ));\par
 1536                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1537 \par
 1538                 Serial.println(F("actor ON "));\par
 1539 \par
 1540             #endif  \par
 1541                 \par
 1542             \}\par
 1543         \}\par
 1544     \}\par
 1545     else if(hour > this->actors[actorNumber].hourLow)\par
 1546     \{\par
 1547 \par
 1548         if( measurment >= this->actors[actorNumber].rangeHigh )\par
 1549         \{\par
 1550             bitWrite( this->action , actorNumber , 0) ;\par
 1551 \par
 1552         #if DEBUG == 1 \par
 1553 \par
 1554             Serial.print(measurment);\par
 1555             Serial.print(F(" >= " ));\par
 1556             Serial.println(this->actors[actorNumber].rangeHigh);\par
 1557 \par
 1558             Serial.println(F("actor OFF "));\par
 1559 \par
 1560         #endif  \par
 1561 \par
 1562         \}\par
 1563         else \par
 1564         \{\par
 1565             bitWrite( this->action , actorNumber , 1) ;\par
 1566 \par
 1567         #if DEBUG == 1 \par
 1568 \par
 1569             Serial.print(measurment);\par
 1570             Serial.print(F(" < " ));\par
 1571             Serial.println(this->actors[actorNumber].rangeHigh);\par
 1572 \par
 1573             Serial.println(F("actor ON "));\par
 1574 \par
 1575         #endif  \par
 1576             \par
 1577         \}\par
 1578 \par
 1579 \par
 1580     \}\par
 1581     //start the actor\par
 1582     else if(hour==this->actors[actorNumber].hourHigh)\par
 1583     \{\par
 1584         if(minute>= this->actors[actorNumber].minuteHigh)\par
 1585         \{\par
 1586             if( measurment < this->actors[actorNumber].rangeLow )\par
 1587             \{\par
 1588                 bitWrite( this->action , actorNumber , 1) ;\par
 1589 \par
 1590             #if DEBUG == 1 \par
 1591 \par
 1592                 Serial.print(measurment);\par
 1593                 Serial.print(F(" < " ));\par
 1594                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1595 \par
 1596                 Serial.println(F("actor ON "));\par
 1597 \par
 1598             #endif  \par
 1599 \par
 1600             \}\par
 1601             else \par
 1602             \{\par
 1603                 bitWrite( this->action , actorNumber , 0) ;\par
 1604 \par
 1605             #if DEBUG == 1 \par
 1606 \par
 1607                 Serial.print(measurment);\par
 1608                 Serial.println(F(" > " ));\par
 1609                 Serial.print(this->actors[actorNumber].rangeLow);\par
 1610 \par
 1611                 Serial.println(F("actor OFF "));\par
 1612 \par
 1613             #endif  \par
 1614                 \par
 1615             \}\par
 1616         \}\par
 1617     \}\par
 1618     else if(hour > this->actors[actorNumber].hourHigh)\par
 1619     \{\par
 1620 \par
 1621         if( measurment < this->actors[actorNumber].rangeLow )\par
 1622         \{\par
 1623             bitWrite( this->action , actorNumber , 1) ;\par
 1624 \par
 1625         #if DEBUG == 1 \par
 1626 \par
 1627             Serial.print(measurment);\par
 1628             Serial.print(F(" < " ));\par
 1629             Serial.println(this->actors[actorNumber].rangeLow);\par
 1630 \par
 1631             Serial.println(F("actor ON "));\par
 1632 \par
 1633         #endif  \par
 1634 \par
 1635         \}\par
 1636         else \par
 1637         \{\par
 1638             bitWrite( this->action , actorNumber , 0) ;\par
 1639 \par
 1640         #if DEBUG == 1 \par
 1641 \par
 1642             Serial.print(measurment);\par
 1643             Serial.println(F(" > " ));\par
 1644             Serial.print(this->actors[actorNumber].rangeLow);\par
 1645 \par
 1646             Serial.println(F("actor OFF "));\par
 1647 \par
 1648         #endif  \par
 1649             \par
 1650         \}\par
 1651     \par
 1652     \}\par
 1653 \par
 1654 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a273dae1517b56f0242e28b8944edc26b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedMinuteAction\:Jetpack}
{\xe \v Jetpack\:mixedMinuteAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedMinuteAction (int  {\i actorNumber}, int  {\i minute}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedMinuteAction(actorNumber, current minute, measured value ): This method is provided to handle mixed minute actors. it changes the action according to :\par
minute >= minuteLow : -measuredValue >= rangeHigh : deactivate actor -measured < rangeHigh : activate actor\par
minute >= minuteHigh : -measuredValue < rangeLow : activate actor -measuredValue >=rangeLow : activate actor \par
}{
Definition at line 1252 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1253 \{\par
 1254 \par
 1255 #if DEBUG == 1\par
 1256     \par
 1257     Serial.print("mixed minute Actor N\'B0 : ");\par
 1258     Serial.println(actorNumber);\par
 1259 \par
 1260     Serial.print(" minute : ");\par
 1261     Serial.println(minute);\par
 1262 \par
 1263     Serial.print("high minute : ");\par
 1264     Serial.println(this->actors[actorNumber].minuteHigh);\par
 1265 \par
 1266     Serial.print("low minute : ");\par
 1267     Serial.println(this->actors[actorNumber].minuteLow);\par
 1268 \par
 1269     Serial.print("measured value : ");\par
 1270     Serial.println(measurment);\par
 1271 \par
 1272     Serial.print("high range : ");\par
 1273     Serial.println(this->actors[actorNumber].rangeHigh);\par
 1274 \par
 1275     Serial.print("low range : ");\par
 1276     Serial.println(this->actors[actorNumber].rangeLow);\par
 1277 \par
 1278 #endif\par
 1279     //stop the actor    \par
 1280     if(minute >= this->actors[actorNumber].minuteLow)\par
 1281     \{\par
 1282             if( measurment > this->actors[actorNumber].rangeHigh )\par
 1283             \{\par
 1284                 bitWrite( this->action , actorNumber , 0) ;\par
 1285 \par
 1286             #if DEBUG == 1 \par
 1287 \par
 1288                 Serial.print(measurment);\par
 1289                 Serial.print(F(" > " ));\par
 1290                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1291 \par
 1292                 Serial.println(F("actor OFF "));\par
 1293 \par
 1294             #endif\par
 1295     \par
 1296             \}\par
 1297             else \par
 1298             \{\par
 1299                 bitWrite( this->action , actorNumber , 1) ;\par
 1300 \par
 1301             #if DEBUG == 1 \par
 1302 \par
 1303                 Serial.print(measurment);\par
 1304                 Serial.print(F(" < " ));\par
 1305                 Serial.println(this->actors[actorNumber].rangeHigh);\par
 1306 \par
 1307                 Serial.println(F("actor ON "));\par
 1308 \par
 1309             #endif  \par
 1310                 \par
 1311             \}\par
 1312     \}   \par
 1313     //starting the actor\par
 1314     else if(minute >= this->actors[actorNumber].minuteHigh)\par
 1315     \{\par
 1316             if( measurment < this->actors[actorNumber].rangeLow )\par
 1317             \{\par
 1318                 bitWrite( this->action , actorNumber , 1) ;\par
 1319 \par
 1320             #if DEBUG == 1 \par
 1321 \par
 1322                 Serial.print(measurment);\par
 1323                 Serial.print(F(" < " ));\par
 1324                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1325 \par
 1326                 Serial.println(F("actor ON "));\par
 1327 \par
 1328             #endif  \par
 1329 \par
 1330             \}\par
 1331             else \par
 1332             \{\par
 1333                 bitWrite( this->action , actorNumber , 0) ;\par
 1334             \par
 1335             #if DEBUG == 1 \par
 1336 \par
 1337                 Serial.print(measurment);\par
 1338                 Serial.print(F(" > " ));\par
 1339                 Serial.println(this->actors[actorNumber].rangeLow);\par
 1340 \par
 1341                 Serial.println(F("actor OFF "));\par
 1342 \par
 1343             #endif  \par
 1344                 \par
 1345             \}\par
 1346 \par
 1347     \}\par
 1348 \par
 1349 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_acf8ed1fb594b9e8e224f4ed872a8e093_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOff\:Jetpack}
{\xe \v Jetpack\:mixedTemporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedTemporalActionOff (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedTemporalActionOff(actorNumber, measured value ): This method is provided to handle mixed temporal actors. it changes the action according to:\par
currentTime - startTime >= timeHigh : measured value >= rangeHigh : deactivate actor measured value < rangeHigh : activate actor \par
}{
Definition at line 797 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   798 \{\par
  799 \par
  800 #if DEBUG == 1\par
  801     \par
  802     Serial.print("mixed Temporal Actor N\'B0 : ");\par
  803     Serial.println(actorNumber);\par
  804 \par
  805     Serial.print("measured value : ");\par
  806     Serial.println(measurment);\par
  807 \par
  808     Serial.print("high range : ");\par
  809     Serial.println(this->actors[actorNumber].rangeHigh);\par
  810 \par
  811     Serial.print("time high : ");\par
  812     Serial.println(this->actors[actorNumber].timeHigh);\par
  813 \par
  814     Serial.print("actif Time : ");\par
  815     Serial.println(this->actors[actorNumber].actifTime);\par
  816 \par
  817     Serial.print(F("millis : "));\par
  818     Serial.println(millis());\par
  819 \par
  820 #endif\par
  821     if( ( millis()- this->actors[actorNumber].actifTime  ) >= (  this->actors[actorNumber].timeHigh  ) )\par
  822     \{   \par
  823         if( measurment >= this->actors[actorNumber].rangeHigh )\par
  824         \{\par
  825             //stop the actor\par
  826             bitWrite( this->action , actorNumber , 0) ;\par
  827 \par
  828             //make the actor inactif:\par
  829             this->actors[actorNumber].actif=0;\par
  830 \par
  831             //start the low timer\par
  832             this->actors[actorNumber].inactifTime=millis();\par
  833 \par
  834         #if DEBUG == 1 \par
  835 \par
  836             Serial.print(F("actor was on for at least "));\par
  837             Serial.print(this->actors[actorNumber].timeHigh);\par
  838             Serial.println(F(" ms "));\par
  839 \par
  840             Serial.print(measurment);\par
  841             Serial.print(F(" > " ));\par
  842             Serial.println(this->actors[actorNumber].rangeHigh);\par
  843 \par
  844             \par
  845             Serial.println(F("actor OFF "));\par
  846 \par
  847         #endif\par
  848 \par
  849         \}\par
  850         else \par
  851         \{\par
  852             bitWrite( this->action , actorNumber , 1) ;\par
  853 \par
  854         #if DEBUG == 1 \par
  855             \par
  856             Serial.print(F("actor was on for at least "));\par
  857             Serial.print(this->actors[actorNumber].timeHigh);\par
  858             Serial.println(F(" ms "));\par
  859 \par
  860             Serial.print(measurment);\par
  861             Serial.print(F(" < " ));\par
  862             Serial.println(this->actors[actorNumber].rangeHigh);\par
  863 \par
  864             Serial.println(F("actor ON "));\par
  865 \par
  866         #endif              \par
  867 \par
  868         \}           \par
  869     \}\par
  870 \par
  871 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_af2f567ef6311a8fc2f7bb948837667b7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mixedTemporalActionOn\:Jetpack}
{\xe \v Jetpack\:mixedTemporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::mixedTemporalActionOn (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::mixedTemporalActionOn(actorNumber, measured value ): This method is provided to handle mixed temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : measured value >= rangeLow : deactivate actor measured value < rangeLow : activate actor \par
}{
Definition at line 935 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   936 \{\par
  937 \par
  938 #if DEBUG == 1\par
  939     \par
  940     Serial.print("mixed Temporal Actor N\'B0 : ");\par
  941     Serial.println(actorNumber);\par
  942 \par
  943     Serial.print("measured value : ");\par
  944     Serial.println(measurment);\par
  945 \par
  946     Serial.print("low range : ");\par
  947     Serial.println(this->actors[actorNumber].rangeLow);\par
  948 \par
  949     Serial.print("time low : ");\par
  950     Serial.println(this->actors[actorNumber].timeLow);\par
  951 \par
  952     Serial.print("inactif Time : ");\par
  953     Serial.println(this->actors[actorNumber].inactifTime);\par
  954 \par
  955     Serial.print(F("millis : "));\par
  956     Serial.println(millis());\par
  957 \par
  958 #endif\par
  959 \par
  960     if( ( millis() - this->actors[actorNumber].inactifTime ) >= (  this->actors[actorNumber].timeLow  ) )\par
  961     \{\par
  962         if( measurment < this->actors[actorNumber].rangeLow )\par
  963         \{\par
  964             //start the actor\par
  965             bitWrite( this->action , actorNumber , 1) ;\par
  966 \par
  967             //make the actor actif:\par
  968             this->actors[actorNumber].actif=1;\par
  969 \par
  970             //start the low timer\par
  971             this->actors[actorNumber].actifTime=millis();\par
  972 \par
  973         #if DEBUG == 1 \par
  974 \par
  975             Serial.print(F("actor was off for at least "));\par
  976             Serial.print(this->actors[actorNumber].timeLow);\par
  977             Serial.println(F(" ms "));\par
  978 \par
  979             Serial.print(measurment);\par
  980             Serial.print(F(" < " ));\par
  981             Serial.println(this->actors[actorNumber].rangeLow);\par
  982     \par
  983             Serial.println(F("actor ON "));\par
  984     \par
  985         #endif  \par
  986 \par
  987         \}\par
  988         else \par
  989         \{\par
  990             bitWrite( this->action , actorNumber , 0) ; \par
  991 \par
  992         #if DEBUG == 1 \par
  993 \par
  994             Serial.print(F("actor was off for at least "));\par
  995             Serial.print(this->actors[actorNumber].timeLow);\par
  996             Serial.println(F(" ms "));\par
  997 \par
  998             Serial.print(measurment);\par
  999             Serial.print(F(" > " ));\par
 1000             Serial.println(this->actors[actorNumber].rangeLow);\par
 1001 \par
 1002             Serial.println(F("actor OFF "));\par
 1003     \par
 1004         #endif              \par
 1005 \par
 1006         \}\par
 1007 \par
 1008     \}\par
 1009 \par
 1010     \par
 1011 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_af44bc8a08818e4433dfb1c7104601f12_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v normalAction\:Jetpack}
{\xe \v Jetpack\:normalAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::normalAction (int  {\i actorNumber}, float  {\i measurment})}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::normalAction(actorNumber , measured value): This method is provided to handle normal actors. it changes the action according to wether the measured value is: > rangeHigh ( deactivate actor) or < rangeLow (activate actor ) \par
}{
Definition at line 634 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   635 \{\par
  636 \par
  637 #if DEBUG == 1\par
  638     \par
  639     Serial.print(F("none inverted Actor N\'B0 : "));\par
  640     Serial.println(actorNumber);\par
  641 \par
  642     Serial.print(F("measured value : "));\par
  643     Serial.println(measurment);\par
  644 \par
  645     Serial.print(F("high range : "));\par
  646     Serial.println(this->actors[actorNumber].rangeHigh);\par
  647 \par
  648     Serial.print(F("low range : "));\par
  649     Serial.println(this->actors[actorNumber].rangeLow);\par
  650 \par
  651 #endif\par
  652 \par
  653     //measured value lower than minimum range : activate actor\par
  654     if(measurment < this->actors[actorNumber].rangeLow)\par
  655     \{\par
  656         bitWrite( this->action , actorNumber , 1) ;\par
  657 \par
  658     #if DEBUG == 1 \par
  659 \par
  660         Serial.println(F("actor ON "));\par
  661     \par
  662     #endif\par
  663                 \par
  664     \}\par
  665     //measured value higher than maximum range : deactivate actor\par
  666     else if(measurment > this->actors[actorNumber].rangeHigh)\par
  667     \{\par
  668         bitWrite( this->action , actorNumber , 0) ;\par
  669 \par
  670     #if DEBUG == 1 \par
  671 \par
  672         Serial.println(F("actor OFF "));\par
  673     \par
  674     #endif\par
  675     \par
  676     \}\par
  677 \par
  678 \par
  679 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a65ce9533c39fa71e4945b970bf14b980_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printConf\:Jetpack}
{\xe \v Jetpack\:printConf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::printConf ()}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack::printConf()}: This method is provided to print the configuration to the Serial Monitor \par
}{
Definition at line 540 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   541 \{\par
  542 \par
  543 #if DEBUG == 1 \par
  544 \par
  545     Serial.println( F("Enter Jetpack.printConf() ") );\par
  546     Serial.println();\par
  547 \par
  548 #endif \par
  549     Serial.println(F( "Jetpack configuration " ) ) ;\par
  550  \par
  551         for(int i=0;i<8;i++)\par
  552     \{   \par
  553         Serial.print(F("actor N\'B0"));\par
  554         Serial.print(i);\par
  555         Serial.print(F(" actif :"));\par
  556         Serial.println(this->actors[i].actif);\par
  557         \par
  558         Serial.print(F("actor N\'B0"));\par
  559         Serial.print(i);\par
  560         Serial.print(F(" temporal :"));\par
  561         Serial.println(this->actors[i].temporal);\par
  562 \par
  563         Serial.print(F("actor N\'B0"));\par
  564         Serial.print(i);\par
  565         Serial.print(F(" inverted :"));\par
  566         Serial.println(this->actors[i].inverted);\par
  567 \par
  568 \par
  569         Serial.print(F("actor N\'B0"));\par
  570         Serial.print(i);\par
  571         Serial.print(F(" primary Type :"));\par
  572         Serial.println(this->actors[i].primaryType);\par
  573 \par
  574         Serial.print(F("actor N\'B0"));\par
  575         Serial.print(i);\par
  576         Serial.print(F(" secondary Type :"));       \par
  577         Serial.println(this->actors[i].secondaryType);\par
  578 \par
  579         Serial.print(F("actor N\'B0"));\par
  580         Serial.print(i);\par
  581         Serial.print(F(" range Low :"));\par
  582         Serial.println(this->actors[i].rangeLow);\par
  583 \par
  584         Serial.print(F("actor N\'B0"));\par
  585         Serial.print(i);\par
  586         Serial.print(F(" time Low :"));\par
  587         Serial.println(this->actors[i].timeLow);\par
  588 \par
  589         Serial.print(F("actor N\'B0"));\par
  590         Serial.print(i);\par
  591         Serial.print(F(" hour low:"));\par
  592         Serial.println(this->actors[i].hourLow);\par
  593 \par
  594         Serial.print(F("actor N\'B0"));\par
  595         Serial.print(i);\par
  596         Serial.print(F(" minute low:"));\par
  597         Serial.println(this->actors[i].minuteLow);\par
  598 \par
  599         Serial.print(F("actor N\'B0"));\par
  600         Serial.print(i);\par
  601         Serial.print(F(" range High:"));\par
  602         Serial.println(this->actors[i].rangeHigh);\par
  603 \par
  604         Serial.print(F("actor N\'B0"));\par
  605         Serial.print(i);\par
  606         Serial.print(F(" time High:"));\par
  607         Serial.println(this->actors[i].timeHigh);\par
  608 \par
  609         Serial.print(F("actor N\'B0"));\par
  610         Serial.print(i);\par
  611         Serial.print(F(" hour high:"));\par
  612         Serial.println(this->actors[i].hourHigh);\par
  613 \par
  614         Serial.print(F("actor N\'B0"));\par
  615         Serial.print(i);\par
  616         Serial.print(F(" minute high:"));\par
  617         Serial.println(this->actors[i].minuteHigh);\par
  618 \par
  619         Serial.println(); \par
  620 \par
  621     \}\par
  622 \par
  623     Serial.println();\par
  624 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ac54a7bb4f9166bee32052253d9b1d306_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOff\:Jetpack}
{\xe \v Jetpack\:temporalActionOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::temporalActionOff (int  {\i actorNumber})}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::temporalActionOff(actorNumber ): This method is provided to handle temporal actors. it changes the action according to:\par
currentTime - startTime > timeHigh : deactivate actor \par
}{
Definition at line 746 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   747 \{\par
  748 \par
  749 #if DEBUG == 1\par
  750     \par
  751     Serial.print(F("temporal Actor N\'B0 : "));\par
  752     Serial.println(actorNumber);\par
  753 \par
  754     Serial.print(F("millis : "));\par
  755     Serial.println(millis());\par
  756 \par
  757     Serial.print(F("actif Time : "));\par
  758     Serial.println(this->actors[actorNumber].actifTime);\par
  759 \par
  760     Serial.print(F("high time : "));\par
  761     Serial.println(this->actors[actorNumber].timeHigh);\par
  762 \par
  763 \par
  764 #endif\par
  765     \par
  766     if( ( millis()- this->actors[actorNumber].actifTime  ) >= (  this->actors[actorNumber].timeHigh  ) )\par
  767     \{\par
  768         //stop the actor\par
  769         bitWrite( this->action , actorNumber , 0) ;\par
  770 \par
  771         //make the actor inactif:\par
  772         this->actors[actorNumber].actif=0;\par
  773 \par
  774         //start the low timer\par
  775         this->actors[actorNumber].inactifTime=millis();\par
  776 \par
  777     #if DEBUG == 1 \par
  778 \par
  779         Serial.println(F("actor OFF "));\par
  780     \par
  781     #endif\par
  782                 \par
  783     \}   \par
  784 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a2991b302cd99bf89325f9b66b104d575_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v temporalActionOn\:Jetpack}
{\xe \v Jetpack\:temporalActionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::temporalActionOn (int  {\i actorNumber})}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::temporalActionOn(actorNumber ): This method is provided to handle temporal actors. it changes the action according to :\par
currentTime - stopTime > timeLow : activate actor \par
}{
Definition at line 883 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   884 \{\par
  885 \par
  886 #if DEBUG == 1\par
  887     \par
  888     Serial.print(F("temporal Actor N\'B0 : "));\par
  889     Serial.println(actorNumber);\par
  890 \par
  891     Serial.print(F("millis : "));\par
  892     Serial.println(millis());\par
  893 \par
  894     Serial.print(F("inactif Time : "));\par
  895     Serial.println(this->actors[actorNumber].inactifTime);\par
  896 \par
  897     Serial.print(F("low time : "));\par
  898     Serial.println(this->actors[actorNumber].timeLow);\par
  899 \par
  900 \par
  901 #endif\par
  902     \par
  903      if( ( millis() - this->actors[actorNumber].inactifTime ) >= (  this->actors[actorNumber].timeLow  ) )\par
  904     \{\par
  905         //start the actor\par
  906         bitWrite( this->action , actorNumber , 1) ;\par
  907 \par
  908         //make the actor actif:\par
  909         this->actors[actorNumber].actif=1;\par
  910 \par
  911         //start the low timer\par
  912         this->actors[actorNumber].actifTime=millis();\par
  913 \par
  914     #if DEBUG == 1 \par
  915 \par
  916         Serial.println(F("actor ON "));\par
  917 \par
  918     #endif              \par
  919 \par
  920     \}\par
  921 \par
  922 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_ad011d904f639accb5f94ef806846ef59_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write\:Jetpack}
{\xe \v Jetpack\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::write (byte  {\i action})}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::write(action): This method is provided to write the given action to the entire {\b Jetpack} action is a Byte (8 bits ), each bit goes to an output. MSBFirst \par
}{
Definition at line 74 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75 \{\par
   76 \par
   77 #if DEBUG == 1\par
   78 \par
   79     Serial.println( F("Entering Jetpack.write()") );\par
   80     Serial.println();\par
   81 \par
   82     Serial.println( F("writing this action : ") );\par
   83     Serial.println(action,BIN);\par
   84     Serial.println();\par
   85 \par
   86 #endif \par
   87 \par
   88     this->action=action;\par
   89 \par
   90     \par
   91     digitalWrite(EnI2C, LOW);\par
   92     \par
   93     shiftOut(dataPin, clockPin, MSBFIRST, this->action);\par
   94 \par
   95     digitalWrite(EnI2C, HIGH);\par
   96 \par
   97 \par
   98 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a338f1af8cbc6504ac69b47c7328569b5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeBit\:Jetpack}
{\xe \v Jetpack\:writeBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Jetpack::writeBit (byte  {\i pin}, bool  {\i state})}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Jetpack::writeBit(pin,state): This method is provided to write the given state to the given pin \par
}{
Definition at line 105 of file Jetpack.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   106 \{\par
  107 \par
  108 #if DEBUG == 1 \par
  109 \par
  110     Serial.println( F("Entering Jetpack.writeBit() ") );\par
  111 \par
  112     Serial.print( F("Writing ") );\par
  113     Serial.print(state);\par
  114 \par
  115     Serial.print( F("to pin N\'B0") );\par
  116     Serial.print(pin);\par
  117 \par
  118     Serial.println();\par
  119 \par
  120 #endif\par
  121 \par
  122     bitWrite(this->action, pin, state);\par
  123     digitalWrite(EnI2C, LOW);\par
  124     \par
  125     shiftOut(dataPin, clockPin, MSBFIRST, this->action);\par
  126 \par
  127     digitalWrite(EnI2C, HIGH);\par
  128 \par
  129 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d1d/class_jetpack_a79ae7bc3c1828a0551a7c005c4f8bd00_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v action\:Jetpack}
{\xe \v Jetpack\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte Jetpack::action = B00000000{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file Jetpack.h.}\par
}
{\xe \v actors\:Jetpack}
{\xe \v Jetpack\:actors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Jetpack::state} Jetpack::actors[8]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clockPin\:Jetpack}
{\xe \v Jetpack\:clockPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Jetpack::clockPin = 4{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file Jetpack.h.}\par
}
{\xe \v dataPin\:Jetpack}
{\xe \v Jetpack\:dataPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Jetpack::dataPin = 15{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file Jetpack.h.}\par
}
{\xe \v EnI2C\:Jetpack}
{\xe \v Jetpack\:EnI2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Jetpack::EnI2C =5{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardSensors::lightActive Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive}
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
Collaboration diagram for CoolBoardSensors::lightActive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d9f/struct_cool_board_sensors_1_1light_active__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ir} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b uv} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 89 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ir\:CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive\:ir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::lightActive::ir =0}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolBoardSensors.h.}\par
}
{\xe \v uv\:CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive\:uv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::lightActive::uv =0}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file CoolBoardSensors.h.}\par
}
{\xe \v visible\:CoolBoardSensors::lightActive}
{\xe \v CoolBoardSensors::lightActive\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardSensors::lightActive::visible =0}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolBoardSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardSensors.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NDIR_I2C Class Reference\par \pard\plain 
{\tc\tcl2 \v NDIR_I2C}
{\xe \v NDIR_I2C}
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
\par
{
{\f2 #include <CoolNDIR_I2C.h>}}\par
Collaboration diagram for NDIR_I2C:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/dff/class_n_d_i_r___i2_c__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NDIR_I2C} (uint8_t {\b i2c_addr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b measure} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b i2c_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ppm}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b send} (uint8_t *pdata, uint8_t n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b receive} (uint8_t *pbuf, uint8_t n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b read_register} (uint8_t reg_addr, uint8_t *pval)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b write_register} (uint8_t reg_addr, uint8_t *pdata, uint8_t n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b write_register} (uint8_t reg_addr, uint8_t val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b parse} (uint8_t *pbuf)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint8_t {\b cmd_measure} [9] = \{0xFF,0x01,0x9C,0x00,0x00,0x00,0x00,0x00,0x63\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 27 of file CoolNDIR_I2C.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NDIR_I2C\:NDIR_I2C}
{\xe \v NDIR_I2C\:NDIR_I2C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NDIR_I2C::NDIR_I2C (uint8_t  {\i i2c_addr})}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    78 \{\par
   79     if (i2c_addr >= 8 && i2c_addr < 120) \{\par
   80         NDIR_I2C::i2c_addr = i2c_addr;\par
   81     \} else \{\par
   82         NDIR_I2C::i2c_addr = 0;\par
   83     \}\par
   84 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:NDIR_I2C}
{\xe \v NDIR_I2C\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::begin (void )}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    88 \{\par
   89     if (i2c_addr) \{\par
   90         WIRE.begin(2,14);\par
   91         write_register(IOCONTROL, 0x08);\par
   92 \par
   93         if (write_register(FCR, 0x07)) \{\par
   94             if (write_register(LCR, 0x83)) \{\par
   95                 if (write_register(DLL, 0x60)) \{\par
   96                     if (write_register(DLH, 0x00)) \{\par
   97                         if (write_register(LCR, 0x03)) \{\par
   98                             if (measure()) \{\par
   99                                 return true;\par
  100                             \}\par
  101                         \}\par
  102                     \}\par
  103                 \}\par
  104             \}\par
  105         \}\par
  106     \}\par
  107 \par
  108     return false;\par
  109 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_acf82f3dcb41e75709a93f8b68d087a3c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v measure\:NDIR_I2C}
{\xe \v NDIR_I2C\:measure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::measure ()}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   112 \{\par
  113     uint8_t buf[9];\par
  114 \par
  115     if (i2c_addr) \{\par
  116         if (write_register(FCR, 0x07)) \{\par
  117             delayMicroseconds(1);\par
  118 \par
  119             if (send(cmd_measure, 9)) \{\par
  120                 if (receive(buf, 9)) \{\par
  121                     if (parse(buf)) \{\par
  122                         return true;\par
  123                     \}\par
  124                 \}\par
  125             \}\par
  126         \}\par
  127     \}\par
  128 \par
  129     return false;\par
  130 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_ab8f50d38501d498b802b822bd4844ede_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_ab8f50d38501d498b802b822bd4844ede_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v parse\:NDIR_I2C}
{\xe \v NDIR_I2C\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::parse (uint8_t *  {\i pbuf}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134 \{\par
  135     uint8_t i;\par
  136     uint8_t checksum = 0;\par
  137 \par
  138     for (i=0; i<9; i++) \{\par
  139         checksum += pbuf[i];\par
  140     \}\par
  141 \par
  142     if (pbuf[0] == 0xFF && pbuf[1] == 0x9C && checksum == 0xFF) \{\par
  143         ppm = (uint32_t)pbuf[2] << 24 | (uint32_t)pbuf[3] << 16 | (uint32_t)pbuf[4] << 8 | pbuf[5];\par
  144         return true;\par
  145     \} else \{\par
  146         return false;\par
  147     \}\par
  148 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_a907b756fc9244c7398b7d187b73cde94_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read_register\:NDIR_I2C}
{\xe \v NDIR_I2C\:read_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::read_register (uint8_t  {\i reg_addr}, uint8_t *  {\i pval}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 208 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   209 \{\par
  210     uint8_t result;\par
  211 \par
  212     WIRE.beginTransmission(i2c_addr);\par
  213     WIRE.write(reg_addr << 3);\par
  214 \par
  215     if (WIRE.endTransmission() != 0) \{\par
  216         return false;\par
  217     \}\par
  218 \par
  219     if (WIRE.requestFrom(i2c_addr, (uint8_t)1) != 1) \{\par
  220         return false;\par
  221     \}\par
  222 \par
  223    *pval = WIRE.read();\par
  224     return true;\par
  225 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aa72058e6e7c6174b14466fee4b2df1e0_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v receive\:NDIR_I2C}
{\xe \v NDIR_I2C\:receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::receive (uint8_t *  {\i pbuf}, uint8_t  {\i n}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 166 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   166                                                   \{\par
  167     uint8_t  i;\par
  168     uint8_t  rx_level;\par
  169     uint32_t start = millis();\par
  170 \par
  171     while (n) \{\par
  172         if (read_register(RXLVL, &rx_level)) \{\par
  173             if (rx_level > n) \{\par
  174                 rx_level = n;\par
  175             \}\par
  176 \par
  177             if (rx_level) \{\par
  178                 WIRE.beginTransmission(i2c_addr);\par
  179                 WIRE.write(RHR << 3);\par
  180 \par
  181                 if (WIRE.endTransmission() != 0) \{\par
  182                     return false;\par
  183                 \}//delay(10);\par
  184 \par
  185                 if (rx_level == WIRE.requestFrom(i2c_addr, rx_level)) \{\par
  186                     for (i=0; i<rx_level; i++) \{\par
  187                        *pbuf = WIRE.read();\par
  188                         pbuf++;\par
  189                         n--;\par
  190                     \}\par
  191                 \} else \{\par
  192                     return false;\par
  193                 \}\par
  194             \}\par
  195         \} else \{\par
  196             return false;\par
  197         \}\par
  198 \par
  199         if (millis() - start > RECEIVE_TIMEOUT) \{\par
  200             return false;\par
  201         \}\par
  202     \}\par
  203 \par
  204     return true;\par
  205 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aa6d2b8dd287f9c9015461cebb18f9abc_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aa6d2b8dd287f9c9015461cebb18f9abc_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:NDIR_I2C}
{\xe \v NDIR_I2C\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::send (uint8_t *  {\i pdata}, uint8_t  {\i n}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   151                                                 \{\par
  152     uint8_t result;\par
  153 \par
  154     if (read_register(TXLVL, &result)) \{\par
  155         if (result >= n) \{\par
  156             if (write_register(THR, pdata, n)) \{\par
  157                 return true;\par
  158             \}\par
  159         \}\par
  160     \}\par
  161 \par
  162     return false;\par
  163 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aab0c04c2b7d08e99d12af044df179f0c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_aab0c04c2b7d08e99d12af044df179f0c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write_register\:NDIR_I2C}
{\xe \v NDIR_I2C\:write_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::write_register (uint8_t  {\i reg_addr}, uint8_t *  {\i pdata}, uint8_t  {\i n}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 228 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   229 \{\par
  230     uint8_t result;\par
  231 \par
  232     WIRE.beginTransmission(i2c_addr);\par
  233     WIRE.write(reg_addr << 3);\par
  234 \par
  235     while (n--) \{\par
  236         WIRE.write(*pdata);\par
  237         pdata++;\par
  238     \}\par
  239 \par
  240     if (WIRE.endTransmission() != 0) \{\par
  241         return false;\par
  242     \} else \{\par
  243         return true;\par
  244     \}\par
  245 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_a5de6a044b00e985f035edca07521e319_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v write_register\:NDIR_I2C}
{\xe \v NDIR_I2C\:write_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::write_register (uint8_t  {\i reg_addr}, uint8_t  {\i val}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 248 of file CoolNDIR_I2C.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     return write_register(reg_addr, &val, 1);\par
  251 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/ddb/class_n_d_i_r___i2_c_a8ad2a76f9866b0a1f34810a147b4b20d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cmd_measure\:NDIR_I2C}
{\xe \v NDIR_I2C\:cmd_measure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::cmd_measure = \{0xFF,0x01,0x9C,0x00,0x00,0x00,0x00,0x00,0x63\}{\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolNDIR_I2C.h.}\par
}
{\xe \v i2c_addr\:NDIR_I2C}
{\xe \v NDIR_I2C\:i2c_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t NDIR_I2C::i2c_addr}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolNDIR_I2C.h.}\par
}
{\xe \v ppm\:NDIR_I2C}
{\xe \v NDIR_I2C\:ppm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t NDIR_I2C::ppm}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file CoolNDIR_I2C.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolNDIR_I2C.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Irene3000::parameters_T Struct Reference\par \pard\plain 
{\tc\tcl2 \v Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T}
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
Collaboration diagram for Irene3000::parameters_T:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/df5/struct_irene3000_1_1parameters___t__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b WriteCheck} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pH7Cal}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pH4Cal} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pHStep} =1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 97 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v pH4Cal\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:pH4Cal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::parameters_T::pH4Cal =0}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file Irene3000.h.}\par
}
{\xe \v pH7Cal\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:pH7Cal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Irene3000::parameters_T::pH7Cal}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file Irene3000.h.}\par
}
{\xe \v pHStep\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:pHStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Irene3000::parameters_T::pHStep =1}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file Irene3000.h.}\par
}
{\xe \v WriteCheck\:Irene3000::parameters_T}
{\xe \v Irene3000::parameters_T\:WriteCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Irene3000::parameters_T::WriteCheck =0}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExternalSensors::sensor Struct Reference\par \pard\plain 
{\tc\tcl2 \v ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor}
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
Collaboration diagram for ExternalSensors::sensor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/db6/struct_external_sensors_1_1sensor__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b reference} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b type} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b address} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BaseExternalSensor} * {\b exSensor} =NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 60 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v address\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ExternalSensors::sensor::address =0}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file ExternalSensors.h.}\par
}
{\xe \v exSensor\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:exSensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BaseExternalSensor}* ExternalSensors::sensor::exSensor =NULL}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file ExternalSensors.h.}\par
}
{\xe \v reference\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String ExternalSensors::sensor::reference =""}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file ExternalSensors.h.}\par
}
{\xe \v type\:ExternalSensors::sensor}
{\xe \v ExternalSensors::sensor\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String ExternalSensors::sensor::type =""}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file ExternalSensors.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b ExternalSensors.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SensorCalibration Struct Reference\par \pard\plain 
{\tc\tcl2 \v SensorCalibration}
{\xe \v SensorCalibration}
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\par
{
{\f2 #include <CoolSparkFunBME280.h>}}\par
Collaboration diagram for SensorCalibration:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d4a/struct_sensor_calibration__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b dig_T1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_T2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_T3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b dig_P1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P5}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P6}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P7}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_P9}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_H1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_H2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_H3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_H4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_H5}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_H6}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 115 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dig_H1\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorCalibration::dig_H1}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H2\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_H2}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H3\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorCalibration::dig_H3}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H4\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_H4}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H5\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_H5}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_H6\:SensorCalibration}
{\xe \v SensorCalibration\:dig_H6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorCalibration::dig_H6}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P1\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SensorCalibration::dig_P1}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P2\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P2}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P3\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P3}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P4\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P4}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P5\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P5}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P6\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P6}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P7\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P7}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P8\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P8}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_P9\:SensorCalibration}
{\xe \v SensorCalibration\:dig_P9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_P9}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_T1\:SensorCalibration}
{\xe \v SensorCalibration\:dig_T1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SensorCalibration::dig_T1}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_T2\:SensorCalibration}
{\xe \v SensorCalibration\:dig_T2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_T2}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file CoolSparkFunBME280.h.}\par
}
{\xe \v dig_T3\:SensorCalibration}
{\xe \v SensorCalibration\:dig_T3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SensorCalibration::dig_T3}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SensorSettings Struct Reference\par \pard\plain 
{\tc\tcl2 \v SensorSettings}
{\xe \v SensorSettings}
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
\par
{
{\f2 #include <CoolSparkFunBME280.h>}}\par
Collaboration diagram for SensorSettings:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d99/struct_sensor_settings__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b commInterface}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b I2CAddress}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b chipSelectPin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b runMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b tStandby}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b filter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b tempOverSample}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b pressOverSample}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b humidOverSample}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 95 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v chipSelectPin\:SensorSettings}
{\xe \v SensorSettings\:chipSelectPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::chipSelectPin}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolSparkFunBME280.h.}\par
}
{\xe \v commInterface\:SensorSettings}
{\xe \v SensorSettings\:commInterface}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::commInterface}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolSparkFunBME280.h.}\par
}
{\xe \v filter\:SensorSettings}
{\xe \v SensorSettings\:filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::filter}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolSparkFunBME280.h.}\par
}
{\xe \v humidOverSample\:SensorSettings}
{\xe \v SensorSettings\:humidOverSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::humidOverSample}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolSparkFunBME280.h.}\par
}
{\xe \v I2CAddress\:SensorSettings}
{\xe \v SensorSettings\:I2CAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::I2CAddress}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolSparkFunBME280.h.}\par
}
{\xe \v pressOverSample\:SensorSettings}
{\xe \v SensorSettings\:pressOverSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::pressOverSample}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolSparkFunBME280.h.}\par
}
{\xe \v runMode\:SensorSettings}
{\xe \v SensorSettings\:runMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::runMode}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolSparkFunBME280.h.}\par
}
{\xe \v tempOverSample\:SensorSettings}
{\xe \v SensorSettings\:tempOverSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::tempOverSample}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file CoolSparkFunBME280.h.}\par
}
{\xe \v tStandby\:SensorSettings}
{\xe \v SensorSettings\:tStandby}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SensorSettings::tStandby}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file CoolSparkFunBME280.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b CoolSparkFunBME280.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Irene3000::state Struct Reference\par \pard\plain 
{\tc\tcl2 \v Irene3000::state}
{\xe \v Irene3000::state}
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
Collaboration diagram for Irene3000::state:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d72/struct_irene3000_1_1state__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b active} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b adsGain_t} {\b gain} ={\b GAIN_TWOTHIRDS}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b type} =""\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 104 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v active\:Irene3000::state}
{\xe \v Irene3000::state\:active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Irene3000::state::active =0}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file Irene3000.h.}\par
}
{\xe \v gain\:Irene3000::state}
{\xe \v Irene3000::state\:gain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b adsGain_t} Irene3000::state::gain ={\b GAIN_TWOTHIRDS}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file Irene3000.h.}\par
}
{\xe \v type\:Irene3000::state}
{\xe \v Irene3000::state\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Irene3000::state::type =""}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file Irene3000.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Irene3000.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Jetpack::state Struct Reference\par \pard\plain 
{\tc\tcl2 \v Jetpack::state}
{\xe \v Jetpack::state}
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
Collaboration diagram for Jetpack::state:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/da1/struct_jetpack_1_1state__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b actif} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b temporal} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inverted} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b primaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b secondaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b actifTime} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b inactifTime} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 86 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actif\:Jetpack::state}
{\xe \v Jetpack::state\:actif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::state::actif =0}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file Jetpack.h.}\par
}
{\xe \v actifTime\:Jetpack::state}
{\xe \v Jetpack::state\:actifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::actifTime =0}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file Jetpack.h.}\par
}
{\xe \v hourHigh\:Jetpack::state}
{\xe \v Jetpack::state\:hourHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::hourHigh =0}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file Jetpack.h.}\par
}
{\xe \v hourLow\:Jetpack::state}
{\xe \v Jetpack::state\:hourLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::hourLow =0}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file Jetpack.h.}\par
}
{\xe \v inactifTime\:Jetpack::state}
{\xe \v Jetpack::state\:inactifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::inactifTime =0}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file Jetpack.h.}\par
}
{\xe \v inverted\:Jetpack::state}
{\xe \v Jetpack::state\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::state::inverted =0}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file Jetpack.h.}\par
}
{\xe \v minuteHigh\:Jetpack::state}
{\xe \v Jetpack::state\:minuteHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::minuteHigh =0}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file Jetpack.h.}\par
}
{\xe \v minuteLow\:Jetpack::state}
{\xe \v Jetpack::state\:minuteLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::minuteLow =0}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file Jetpack.h.}\par
}
{\xe \v primaryType\:Jetpack::state}
{\xe \v Jetpack::state\:primaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Jetpack::state::primaryType =""}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file Jetpack.h.}\par
}
{\xe \v rangeHigh\:Jetpack::state}
{\xe \v Jetpack::state\:rangeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::rangeHigh =0}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file Jetpack.h.}\par
}
{\xe \v rangeLow\:Jetpack::state}
{\xe \v Jetpack::state\:rangeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Jetpack::state::rangeLow =0}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file Jetpack.h.}\par
}
{\xe \v secondaryType\:Jetpack::state}
{\xe \v Jetpack::state\:secondaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Jetpack::state::secondaryType =""}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file Jetpack.h.}\par
}
{\xe \v temporal\:Jetpack::state}
{\xe \v Jetpack::state\:temporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Jetpack::state::temporal =0}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file Jetpack.h.}\par
}
{\xe \v timeHigh\:Jetpack::state}
{\xe \v Jetpack::state\:timeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::timeHigh =0}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file Jetpack.h.}\par
}
{\xe \v timeLow\:Jetpack::state}
{\xe \v Jetpack::state\:timeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Jetpack::state::timeLow =0}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file Jetpack.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b Jetpack.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoolBoardActor::state Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoolBoardActor::state}
{\xe \v CoolBoardActor::state}
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
Collaboration diagram for CoolBoardActor::state:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d44/struct_cool_board_actor_1_1state__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b actif} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b temporal} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inverted} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b primaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b secondaryType} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteLow} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rangeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b timeHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hourHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minuteHigh} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b actifTime} =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b inactifTime} =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 82 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actif\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:actif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::state::actif =0}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolBoardActor.h.}\par
}
{\xe \v actifTime\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:actifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::actifTime =0}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file CoolBoardActor.h.}\par
}
{\xe \v hourHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:hourHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::hourHigh =0}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file CoolBoardActor.h.}\par
}
{\xe \v hourLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:hourLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::hourLow =0}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolBoardActor.h.}\par
}
{\xe \v inactifTime\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:inactifTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::inactifTime =0}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file CoolBoardActor.h.}\par
}
{\xe \v inverted\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::state::inverted =0}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolBoardActor.h.}\par
}
{\xe \v minuteHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:minuteHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::minuteHigh =0}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file CoolBoardActor.h.}\par
}
{\xe \v minuteLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:minuteLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::minuteLow =0}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolBoardActor.h.}\par
}
{\xe \v primaryType\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:primaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoardActor::state::primaryType =""}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolBoardActor.h.}\par
}
{\xe \v rangeHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:rangeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::rangeHigh =0}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolBoardActor.h.}\par
}
{\xe \v rangeLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:rangeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoolBoardActor::state::rangeLow =0}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolBoardActor.h.}\par
}
{\xe \v secondaryType\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:secondaryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String CoolBoardActor::state::secondaryType =""}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file CoolBoardActor.h.}\par
}
{\xe \v temporal\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:temporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CoolBoardActor::state::temporal =0}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolBoardActor.h.}\par
}
{\xe \v timeHigh\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:timeHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::timeHigh =0}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolBoardActor.h.}\par
}
{\xe \v timeLow\:CoolBoardActor::state}
{\xe \v CoolBoardActor::state\:timeLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long CoolBoardActor::state::timeLow =0}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file CoolBoardActor.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/{\b CoolBoardActor.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WiFiManager Class Reference\par \pard\plain 
{\tc\tcl2 \v WiFiManager}
{\xe \v WiFiManager}
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
\par
{
{\f2 #include <WiFiManagerReadFileButton.h>}}\par
Collaboration diagram for WiFiManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d8d/class_wi_fi_manager__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManager} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b autoConnect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b autoConnect} (char const *apName, char const *apPassword=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b startConfigPortal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b startConfigPortal} (char const *apName, char const *apPassword=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getConfigPortalSSID} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetSettings} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConfigPortalTimeout} (unsigned long seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTimeout} (unsigned long seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConnectTimeout} (unsigned long seconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDebugOutput} (boolean debug)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumSignalQuality} (int quality=8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAPStaticIPConfig} (IPAddress ip, IPAddress gw, IPAddress sn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSTAStaticIPConfig} (IPAddress ip, IPAddress gw, IPAddress sn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAPCallback} (void(*func)({\b WiFiManager} *))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSaveConfigCallback} (void(*func)(void))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addParameter} ({\b WiFiManagerParameter} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBreakAfterConfig} (boolean shouldBreak)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCustomHeadElement} (const char *element)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRemoveDuplicateAPs} (boolean removeDuplicates)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupConfigPortal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startWPS} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b connectWifi} (String ssid, String pass)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b waitForConnectResult} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleRoot} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleWifi} (boolean scan)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleWifiSave} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleInfo} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleReset} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleNotFound} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handle204} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b handleFileRead} (String path)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b captivePortal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b getContentType} (String filename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getRSSIasQuality} (int RSSI)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b isIp} (String str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b toStringIp} (IPAddress ip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Generic > void {\b DEBUG_WM} (Generic text)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > auto {\b optionalIPFromString} (T *obj, const char *s) -> decltype(obj->fromString(s))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b optionalIPFromString} (...) -> bool\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::unique_ptr< DNSServer > {\b dnsServer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::unique_ptr< ESP8266WebServer > {\b server}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _apName} = "no-net"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _apPassword} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b _ssid} = ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b _pass} = ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b _configPortalTimeout} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b _connectTimeout} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b _configPortalStart} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _ap_static_ip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _ap_static_gw}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _ap_static_sn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _sta_static_ip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _sta_static_gw}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IPAddress {\b _sta_static_sn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _paramsCount} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _minimumQuality} = -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _removeDuplicateAPs} = true\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _shouldBreakAfterConfig} = false\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _tryWPS} = false\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _customHeadElement} = ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b status} = WL_IDLE_STATUS\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const byte {\b DNS_PORT} = 53\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b connect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
boolean {\b _debug} = true\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b _apcallback} )({\b WiFiManager} *) = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b _savecallback} )(void) = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} * {\b _params} [{\b WIFI_MANAGER_MAX_PARAMS}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 67 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WiFiManager\:WiFiManager}
{\xe \v WiFiManager\:WiFiManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManager::WiFiManager ()}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    65                          \{\par
   66 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addParameter\:WiFiManager}
{\xe \v WiFiManager\:addParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::addParameter ({\b WiFiManagerParameter} *  {\i p})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    68                                                       \{\par
   69   _params[_paramsCount] = p;\par
   70   _paramsCount++;\par
   71   DEBUG_WM("Adding parameter");\par
   72   DEBUG_WM(p->getID());\par
   73 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a62907428e5874de097d83c33ef46c80d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v autoConnect\:WiFiManager}
{\xe \v WiFiManager\:autoConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::autoConnect ()}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   129                                  \{\par
  130   String ssid = "ESP" + String(ESP.getChipId());\par
  131   return autoConnect(ssid.c_str(), NULL);\par
  132 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae3cdfa6b02edcfe63d7da4f696b62136_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v autoConnect\:WiFiManager}
{\xe \v WiFiManager\:autoConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::autoConnect (char const *  {\i apName}, char const *  {\i apPassword} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134                                                                            \{\par
  135   DEBUG_WM(F(""));\par
  136   DEBUG_WM(F("AutoConnect"));\par
  137 \par
  138   // read eeprom for ssid and pass\par
  139   //String ssid = getSSID();\par
  140   //String pass = getPassword();\par
  141 \par
  142   // attempt to connect; should it fail, fall back to AP\par
  143   WiFi.mode(WIFI_STA);\par
  144 \par
  145   if (connectWifi("", "") == WL_CONNECTED)   \{\par
  146     DEBUG_WM(F("IP Address:"));\par
  147     DEBUG_WM(WiFi.localIP());\par
  148     //connected\par
  149     return true;\par
  150   \}\par
  151 \par
  152   return startConfigPortal(apName, apPassword);\par
  153 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ab1d094034e5e3e36e2e1b3624edad469_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v captivePortal\:WiFiManager}
{\xe \v WiFiManager\:captivePortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::captivePortal (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Redirect to captive portal if we got a request for another domain. Return true in that case so the page handler do not try to handle the request again. \par
}{
Definition at line 746 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   746                                    \{\par
  747   if (!isIp(server->hostHeader()) ) \{\par
  748     DEBUG_WM(F("Request redirected to captive portal"));\par
  749     server->sendHeader("Location", String("http://") + toStringIp(server->client().localIP()), true);\par
  750     server->send ( 302, "text/plain", ""); // Empty content inhibits Content-length header so we have to close the socket ourselves.\par
  751     server->client().stop(); // Stop is needed because we sent no content length\par
  752     return true;\par
  753   \}\par
  754   return false;\par
  755 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a4ef4298deb224212e5242c456669a973_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a4ef4298deb224212e5242c456669a973_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectWifi\:WiFiManager}
{\xe \v WiFiManager\:connectWifi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::connectWifi (String  {\i ssid}, String  {\i pass}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 222 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   222                                                      \{\par
  223   DEBUG_WM(F("Connecting as wifi client..."));\par
  224 \par
  225   // check if we've got static_ip settings, if we do, use those.\par
  226   if (_sta_static_ip) \{\par
  227     DEBUG_WM(F("Custom STA IP/GW/Subnet"));\par
  228     WiFi.config(_sta_static_ip, _sta_static_gw, _sta_static_sn);\par
  229     DEBUG_WM(WiFi.localIP());\par
  230   \}\par
  231   //fix for auto connect racing issue\par
  232   if (WiFi.status() == WL_CONNECTED) \{\par
  233     DEBUG_WM("Already connected. Bailing out.");\par
  234     return WL_CONNECTED;\par
  235   \}\par
  236   //check if we have ssid and pass and force those, if not, try with last saved values\par
  237   if (ssid != "") \{\par
  238     WiFi.begin(ssid.c_str(), pass.c_str());\par
  239   \} else \{\par
  240     if (WiFi.SSID()) \{\par
  241       DEBUG_WM("Using last saved values, should be faster");\par
  242       //trying to fix connection in progress hanging\par
  243       ETS_UART_INTR_DISABLE();\par
  244       wifi_station_disconnect();\par
  245       ETS_UART_INTR_ENABLE();\par
  246 \par
  247       WiFi.begin();\par
  248     \} else \{\par
  249       DEBUG_WM("No saved credentials");\par
  250     \}\par
  251   \}\par
  252 \par
  253   int connRes = waitForConnectResult();\par
  254   DEBUG_WM ("Connection result: ");\par
  255   DEBUG_WM ( connRes );\par
  256   //not connected, WPS enabled, no pass - first attempt\par
  257   if (_tryWPS && connRes != WL_CONNECTED && pass == "") \{\par
  258     startWPS();\par
  259     //should be connected at the end of WPS\par
  260     connRes = waitForConnectResult();\par
  261   \}\par
  262   return connRes;\par
  263 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae0ae27b5543b47585728c084c3bbdca7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae0ae27b5543b47585728c084c3bbdca7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DEBUG_WM\:WiFiManager}
{\xe \v WiFiManager\:DEBUG_WM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Generic > void WiFiManager::DEBUG_WM (Generic  {\i text}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 780 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   780                                        \{\par
  781   if (_debug) \{\par
  782     Serial.print("*WM: ");\par
  783     Serial.println(text);\par
  784   \}\par
  785 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae5f595c670ccbcf9a191baf50f5c7c26_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getConfigPortalSSID\:WiFiManager}
{\xe \v WiFiManager\:getConfigPortalSSID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::getConfigPortalSSID ()}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 314 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314                                         \{\par
  315   return _apName;\par
  316 \}\par
}
}
{\xe \v getContentType\:WiFiManager}
{\xe \v WiFiManager\:getContentType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::getContentType (String  {\i filename}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 821 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   821                                                  \{\par
  822   if(server->hasArg("download")) return "application/octet-stream";\par
  823   else if(filename.endsWith(".htm")) return "text/html";\par
  824   else if(filename.endsWith(".html")) return "text/html";\par
  825   else if(filename.endsWith(".css")) return "text/css";\par
  826   else if(filename.endsWith(".js")) return "application/javascript";\par
  827   else if(filename.endsWith(".png")) return "image/png";\par
  828   else if(filename.endsWith(".gif")) return "image/gif";\par
  829   else if(filename.endsWith(".jpg")) return "image/jpeg";\par
  830   else if(filename.endsWith(".ico")) return "image/x-icon";\par
  831   else if(filename.endsWith(".xml")) return "text/xml";\par
  832   else if(filename.endsWith(".pdf")) return "application/x-pdf";\par
  833   else if(filename.endsWith(".zip")) return "application/x-zip";\par
  834   else if(filename.endsWith(".gz")) return "application/x-gzip";\par
  835   else if (filename.endsWith(".csv")) return "text/csv";\par
  836   return "text/plain";\par
  837 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a40f123fd290c3e331c9785d19a88f3b8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getRSSIasQuality\:WiFiManager}
{\xe \v WiFiManager\:getRSSIasQuality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::getRSSIasQuality (int  {\i RSSI}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 787 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   787                                           \{\par
  788   int quality = 0;\par
  789 \par
  790   if (RSSI <= -100) \{\par
  791     quality = 0;\par
  792   \} else if (RSSI >= -50) \{\par
  793     quality = 100;\par
  794   \} else \{\par
  795     quality = 2 * (RSSI + 100);\par
  796   \}\par
  797   return quality;\par
  798 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ae71cfd6bd70ada2ca02e1d20b152d0e5_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handle204\:WiFiManager}
{\xe \v WiFiManager\:handle204}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handle204 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleFileRead\:WiFiManager}
{\xe \v WiFiManager\:handleFileRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool WiFiManager::handleFileRead (String  {\i path}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the read file button \par
}{
Definition at line 676 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   677 \{\par
  678 \par
  679     DEBUG_WM(F("handleFileRead" ));\par
  680     DEBUG_WM(F("path : "));\par
  681     DEBUG_WM(path);\par
  682 \par
  683     if(path.endsWith("/"))\par
  684     \{\par
  685         path += "index.htm";\par
  686     \}\par
  687 \par
  688     DEBUG_WM(F("path modified : "));\par
  689     DEBUG_WM(path);\par
  690     \par
  691     \par
  692     String contentType = getContentType(path);\par
  693     String pathWithGz = path + ".gz";\par
  694     if(SPIFFS.exists(pathWithGz) || SPIFFS.exists(path))\par
  695     \{\par
  696 \par
  697         if(SPIFFS.exists(pathWithGz))\par
  698         \{\par
  699             path += ".gz";\par
  700         \}\par
  701 \par
  702         File file = SPIFFS.open(path, "r");\par
  703         size_t sent = server->streamFile(file, contentType);\par
  704         file.close();\par
  705         return true;\par
  706 \par
  707     \}\par
  708 \par
  709     return false;\par
  710 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a9e802fa4ca834a622f058a7176f47806_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a9e802fa4ca834a622f058a7176f47806_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleInfo\:WiFiManager}
{\xe \v WiFiManager\:handleInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleInfo (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the info page \par
}{
Definition at line 598 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   598                              \{\par
  599   DEBUG_WM(F("Info"));\par
  600 \par
  601   String page = FPSTR(HTTP_HEAD);\par
  602   page.replace("\{v\}", "Info");\par
  603   page += FPSTR(HTTP_SCRIPT);\par
  604   page += FPSTR(HTTP_STYLE);\par
  605   page += _customHeadElement;\par
  606   page += FPSTR(HTTP_HEAD_END);\par
  607   page += F("<dl>");\par
  608   page += F("<dt>Chip ID</dt><dd>");\par
  609   page += ESP.getChipId();\par
  610   page += F("</dd>");\par
  611   page += F("<dt>Flash Chip ID</dt><dd>");\par
  612   page += ESP.getFlashChipId();\par
  613   page += F("</dd>");\par
  614   page += F("<dt>IDE Flash Size</dt><dd>");\par
  615   page += ESP.getFlashChipSize();\par
  616   page += F(" bytes</dd>");\par
  617   page += F("<dt>Real Flash Size</dt><dd>");\par
  618   page += ESP.getFlashChipRealSize();\par
  619   page += F(" bytes</dd>");\par
  620   page += F("<dt>Soft AP IP</dt><dd>");\par
  621   page += WiFi.softAPIP().toString();\par
  622   page += F("</dd>");\par
  623   page += F("<dt>Soft AP MAC</dt><dd>");\par
  624   page += WiFi.softAPmacAddress();\par
  625   page += F("</dd>");\par
  626   page += F("<dt>Station MAC</dt><dd>");\par
  627   page += WiFi.macAddress();\par
  628   page += F("</dd>");\par
  629   page += F("</dl>");\par
  630   page += FPSTR(HTTP_END);\par
  631 \par
  632   server->send(200, "text/html", page);\par
  633 \par
  634   DEBUG_WM(F("Sent info page"));\par
  635 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ac35e46661f8a209d84bba62d9aa43a35_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ac35e46661f8a209d84bba62d9aa43a35_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleNotFound\:WiFiManager}
{\xe \v WiFiManager\:handleNotFound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleNotFound (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 722 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   722                                  \{\par
  723   if (captivePortal()) \{\par
  724         return;\par
  725   \}\par
  726   String message = "File Not Found\\n\\n";\par
  727   message += "URI: ";\par
  728   message += server->uri();\par
  729   message += "\\nMethod: ";\par
  730   message += ( server->method() == HTTP_GET ) ? "GET" : "POST";\par
  731   message += "\\nArguments: ";\par
  732   message += server->args();\par
  733   message += "\\n";\par
  734 \par
  735   for ( uint8_t i = 0; i < server->args(); i++ ) \{\par
  736     message += " " + server->argName ( i ) + ": " + server->arg ( i ) + "\\n";\par
  737   \}\par
  738   server->sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");\par
  739   server->sendHeader("Pragma", "no-cache");\par
  740   server->sendHeader("Expires", "-1");\par
  741   server->send ( 404, "text/plain", message );\par
  742 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a7d01f7de3e4b76acdabffac79fa3d0ab_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a7d01f7de3e4b76acdabffac79fa3d0ab_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleReset\:WiFiManager}
{\xe \v WiFiManager\:handleReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleReset (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the reset page \par
}{
Definition at line 638 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   638                               \{\par
  639   DEBUG_WM(F("Reset"));\par
  640 \par
  641   String page = FPSTR(HTTP_HEAD);\par
  642   page.replace("\{v\}", "Info");\par
  643   page += FPSTR(HTTP_SCRIPT);\par
  644   page += FPSTR(HTTP_STYLE);\par
  645   page += _customHeadElement;\par
  646   page += FPSTR(HTTP_HEAD_END);\par
  647   page += F("Module will reset in a few seconds.");\par
  648   page += FPSTR(HTTP_END);\par
  649   server->send(200, "text/html", page);\par
  650 \par
  651   DEBUG_WM(F("Sent reset page"));\par
  652   delay(5000);\par
  653   \par
  654   DEBUG_WM(F("reset ESP and Wifi configuration file"));\par
  655 \par
  656  //create json wifi count = 0 ,timeout=300,nomad=0\par
  657  const size_t bufferSize = JSON_OBJECT_SIZE(3) + 40;\par
  658  DynamicJsonBuffer jsonBuffer(bufferSize);\par
  659 \par
  660  const char* json = "\{\\"wifiCount\\":0,\\"timeOut\\":300,\\"nomad\\":0\}";\par
  661 \par
  662  JsonObject& root = jsonBuffer.parseObject(json);\par
  663 \par
  664  //open wifi file in w : delete contents\par
  665  File configFile = SPIFFS.open("/wifiConfig.json", "w");\par
  666  //write json in file \par
  667  root.printTo(configFile);\par
  668  //close file \par
  669  configFile.close();\par
  670  delay(500);\par
  671  ESP.reset();\par
  672  delay(2000);\par
  673 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a94fb1a8fcfbd0d02714c69138bf72f9c_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a94fb1a8fcfbd0d02714c69138bf72f9c_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleRoot\:WiFiManager}
{\xe \v WiFiManager\:handleRoot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleRoot (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle root or redirect to captive portal \par
}{
Definition at line 361 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   361                              \{\par
  362   DEBUG_WM(F("Handle root"));\par
  363   if (captivePortal()) \{ // If caprive portal redirect instead of displaying the page.\par
  364     return;\par
  365   \}\par
  366 \par
  367   String page = FPSTR(HTTP_HEAD);\par
  368   page.replace("\{v\}", "Options");\par
  369   page += FPSTR(HTTP_SCRIPT);\par
  370   page += FPSTR(HTTP_STYLE);\par
  371   page += _customHeadElement;\par
  372   page += FPSTR(HTTP_HEAD_END);\par
  373   page += "<h1>";\par
  374   page += _apName;\par
  375   page += "</h1>";\par
  376   page += F("<h3>WiFiManager</h3>");\par
  377   page += FPSTR(HTTP_PORTAL_OPTIONS);\par
  378   page += FPSTR(HTTP_END);\par
  379 \par
  380   server->send(200, "text/html", page);\par
  381 \par
  382 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a47e4c7df7478f690c53ff9f5125c9760_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a47e4c7df7478f690c53ff9f5125c9760_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleWifi\:WiFiManager}
{\xe \v WiFiManager\:handleWifi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleWifi (boolean  {\i scan}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wifi config page handler \par
}{
Definition at line 385 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   385                                          \{\par
  386 \par
  387   String page = FPSTR(HTTP_HEAD);\par
  388   page.replace("\{v\}", "Config ESP");\par
  389   page += FPSTR(HTTP_SCRIPT);\par
  390   page += FPSTR(HTTP_STYLE);\par
  391   page += _customHeadElement;\par
  392   page += FPSTR(HTTP_HEAD_END);\par
  393 \par
  394   if (scan) \{\par
  395     int n = WiFi.scanNetworks();\par
  396     DEBUG_WM(F("Scan done"));\par
  397     if (n == 0) \{\par
  398       DEBUG_WM(F("No networks found"));\par
  399       page += F("No networks found. Refresh to scan again.");\par
  400     \} else \{\par
  401 \par
  402       //sort networks\par
  403       int indices[n];\par
  404       for (int i = 0; i < n; i++) \{\par
  405         indices[i] = i;\par
  406       \}\par
  407 \par
  408       // RSSI SORT\par
  409 \par
  410       // old sort\par
  411       for (int i = 0; i < n; i++) \{\par
  412         for (int j = i + 1; j < n; j++) \{\par
  413           if (WiFi.RSSI(indices[j]) > WiFi.RSSI(indices[i])) \{\par
  414             std::swap(indices[i], indices[j]);\par
  415           \}\par
  416         \}\par
  417       \}\par
  418 \par
  419       /*std::sort(indices, indices + n, [](const int & a, const int & b) -> bool\par
  420         \{\par
  421         return WiFi.RSSI(a) > WiFi.RSSI(b);\par
  422         \});*/\par
  423 \par
  424       // remove duplicates ( must be RSSI sorted )\par
  425       if (_removeDuplicateAPs) \{\par
  426         String cssid;\par
  427         for (int i = 0; i < n; i++) \{\par
  428           if (indices[i] == -1) continue;\par
  429           cssid = WiFi.SSID(indices[i]);\par
  430           for (int j = i + 1; j < n; j++) \{\par
  431             if (cssid == WiFi.SSID(indices[j])) \{\par
  432               DEBUG_WM("DUP AP: " + WiFi.SSID(indices[j]));\par
  433               indices[j] = -1; // set dup aps to index -1\par
  434             \}\par
  435           \}\par
  436         \}\par
  437       \}\par
  438 \par
  439       //display networks in page\par
  440       for (int i = 0; i < n; i++) \{\par
  441         if (indices[i] == -1) continue; // skip dups\par
  442         DEBUG_WM(WiFi.SSID(indices[i]));\par
  443         DEBUG_WM(WiFi.RSSI(indices[i]));\par
  444         int quality = getRSSIasQuality(WiFi.RSSI(indices[i]));\par
  445 \par
  446         if (_minimumQuality == -1 || _minimumQuality < quality) \{\par
  447           String item = FPSTR(HTTP_ITEM);\par
  448           String rssiQ;\par
  449           rssiQ += quality;\par
  450           item.replace("\{v\}", WiFi.SSID(indices[i]));\par
  451           item.replace("\{r\}", rssiQ);\par
  452           if (WiFi.encryptionType(indices[i]) != ENC_TYPE_NONE) \{\par
  453             item.replace("\{i\}", "l");\par
  454           \} else \{\par
  455             item.replace("\{i\}", "");\par
  456           \}\par
  457           //DEBUG_WM(item);\par
  458           page += item;\par
  459           delay(0);\par
  460         \} else \{\par
  461           DEBUG_WM(F("Skipping due to quality"));\par
  462         \}\par
  463 \par
  464       \}\par
  465       page += "<br/>";\par
  466     \}\par
  467   \}\par
  468 \par
  469   page += FPSTR(HTTP_FORM_START);\par
  470   char parLength[2];\par
  471   // add the extra parameters to the form\par
  472   for (int i = 0; i < _paramsCount; i++) \{\par
  473     if (_params[i] == NULL) \{\par
  474       break;\par
  475     \}\par
  476 \par
  477     String pitem = FPSTR(HTTP_FORM_PARAM);\par
  478     if (_params[i]->getID() != NULL) \{\par
  479       pitem.replace("\{i\}", _params[i]->getID());\par
  480       pitem.replace("\{n\}", _params[i]->getID());\par
  481       pitem.replace("\{p\}", _params[i]->getPlaceholder());\par
  482       snprintf(parLength, 2, "%d", _params[i]->getValueLength());\par
  483       pitem.replace("\{l\}", parLength);\par
  484       pitem.replace("\{v\}", _params[i]->getValue());\par
  485       pitem.replace("\{c\}", _params[i]->getCustomHTML());\par
  486     \} else \{\par
  487       pitem = _params[i]->getCustomHTML();\par
  488     \}\par
  489 \par
  490     page += pitem;\par
  491   \}\par
  492   if (_params[0] != NULL) \{\par
  493     page += "<br/>";\par
  494   \}\par
  495 \par
  496   if (_sta_static_ip) \{\par
  497 \par
  498     String item = FPSTR(HTTP_FORM_PARAM);\par
  499     item.replace("\{i\}", "ip");\par
  500     item.replace("\{n\}", "ip");\par
  501     item.replace("\{p\}", "Static IP");\par
  502     item.replace("\{l\}", "15");\par
  503     item.replace("\{v\}", _sta_static_ip.toString());\par
  504 \par
  505     page += item;\par
  506 \par
  507     item = FPSTR(HTTP_FORM_PARAM);\par
  508     item.replace("\{i\}", "gw");\par
  509     item.replace("\{n\}", "gw");\par
  510     item.replace("\{p\}", "Static Gateway");\par
  511     item.replace("\{l\}", "15");\par
  512     item.replace("\{v\}", _sta_static_gw.toString());\par
  513 \par
  514     page += item;\par
  515 \par
  516     item = FPSTR(HTTP_FORM_PARAM);\par
  517     item.replace("\{i\}", "sn");\par
  518     item.replace("\{n\}", "sn");\par
  519     item.replace("\{p\}", "Subnet");\par
  520     item.replace("\{l\}", "15");\par
  521     item.replace("\{v\}", _sta_static_sn.toString());\par
  522 \par
  523     page += item;\par
  524 \par
  525     page += "<br/>";\par
  526   \}\par
  527 \par
  528   page += FPSTR(HTTP_FORM_END);\par
  529   page += FPSTR(HTTP_SCAN_LINK);\par
  530 \par
  531   page += FPSTR(HTTP_END);\par
  532 \par
  533   server->send(200, "text/html", page);\par
  534 \par
  535 \par
  536   DEBUG_WM(F("Sent config page"));\par
  537 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a57a9048175c1918340ab9d0a2c53601f_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a57a9048175c1918340ab9d0a2c53601f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleWifiSave\:WiFiManager}
{\xe \v WiFiManager\:handleWifiSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::handleWifiSave (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the WLAN save form and redirect to WLAN config page again \par
}{
Definition at line 540 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   540                                  \{\par
  541   DEBUG_WM(F("WiFi save"));\par
  542 \par
  543   //SAVE/connect here\par
  544   _ssid = server->arg("s").c_str();\par
  545   _pass = server->arg("p").c_str();\par
  546 \par
  547   //parameters\par
  548   for (int i = 0; i < _paramsCount; i++) \{\par
  549     if (_params[i] == NULL) \{\par
  550       break;\par
  551     \}\par
  552     //read parameter\par
  553     String value = server->arg(_params[i]->getID()).c_str();\par
  554     //store it in array\par
  555     value.toCharArray(_params[i]->_value, _params[i]->_length);\par
  556     DEBUG_WM(F("Parameter"));\par
  557     DEBUG_WM(_params[i]->getID());\par
  558     DEBUG_WM(value);\par
  559   \}\par
  560 \par
  561   if (server->arg("ip") != "") \{\par
  562     DEBUG_WM(F("static ip"));\par
  563     DEBUG_WM(server->arg("ip"));\par
  564     //_sta_static_ip.fromString(server->arg("ip"));\par
  565     String ip = server->arg("ip");\par
  566     optionalIPFromString(&_sta_static_ip, ip.c_str());\par
  567   \}\par
  568   if (server->arg("gw") != "") \{\par
  569     DEBUG_WM(F("static gateway"));\par
  570     DEBUG_WM(server->arg("gw"));\par
  571     String gw = server->arg("gw");\par
  572     optionalIPFromString(&_sta_static_gw, gw.c_str());\par
  573   \}\par
  574   if (server->arg("sn") != "") \{\par
  575     DEBUG_WM(F("static netmask"));\par
  576     DEBUG_WM(server->arg("sn"));\par
  577     String sn = server->arg("sn");\par
  578     optionalIPFromString(&_sta_static_sn, sn.c_str());\par
  579   \}\par
  580 \par
  581   String page = FPSTR(HTTP_HEAD);\par
  582   page.replace("\{v\}", "Credentials Saved");\par
  583   page += FPSTR(HTTP_SCRIPT);\par
  584   page += FPSTR(HTTP_STYLE);\par
  585   page += _customHeadElement;\par
  586   page += FPSTR(HTTP_HEAD_END);\par
  587   page += FPSTR(HTTP_SAVED);\par
  588   page += FPSTR(HTTP_END);\par
  589 \par
  590   server->send(200, "text/html", page);\par
  591 \par
  592   DEBUG_WM(F("Sent wifi save page"));\par
  593 \par
  594   connect = true; //signal ready to connect/reset\par
  595 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a2a8c2b60aa86dfdeab8a1a90f7122dc7_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a2a8c2b60aa86dfdeab8a1a90f7122dc7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIp\:WiFiManager}
{\xe \v WiFiManager\:isIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::isIp (String  {\i str}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is this an IP? \par
}{
Definition at line 801 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   801                                     \{\par
  802   for (int i = 0; i < str.length(); i++) \{\par
  803     int c = str.charAt(i);\par
  804     if (c != '.' && (c < '0' || c > '9')) \{\par
  805       return false;\par
  806     \}\par
  807   \}\par
  808   return true;\par
  809 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a9c78a8774f746ec22a99d03a53baa607_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v optionalIPFromString\:WiFiManager}
{\xe \v WiFiManager\:optionalIPFromString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > auto WiFiManager::optionalIPFromString (T *  {\i obj}, const char *  {\i s}) -> decltype(  obj->fromString(s)  ) {\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file WiFiManagerReadFileButton.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   192                                                                                          \{\par
  193       return  obj->fromString(s);\par
  194     \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a6a94f08eb43e0871932556a4ccfa11b7_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v optionalIPFromString\:WiFiManager}
{\xe \v WiFiManager\:optionalIPFromString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto WiFiManager::optionalIPFromString (  {\i ...}) -> bool {\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 195 of file WiFiManagerReadFileButton.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195                                            \{\par
  196       DEBUG_WM("NO fromString METHOD ON IPAddress, you need ESP8266 core 2.1.0 or newer for Custom IP configuration to work.");\par
  197       return false;\par
  198     \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_aa248b818eee0423b14a88c637f7c4637_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetSettings\:WiFiManager}
{\xe \v WiFiManager\:resetSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::resetSettings ()}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 318 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   318                                 \{\par
  319   DEBUG_WM(F("settings invalidated"));\par
  320   DEBUG_WM(F("THIS MAY CAUSE AP NOT TO START UP PROPERLY. YOU NEED TO COMMENT IT OUT AFTER ERASING THE DATA."));\par
  321   WiFi.disconnect(true);\par
  322   //delay(200);\par
  323 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a0027749816b6c66bc845d7c5db760a33_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setAPCallback\:WiFiManager}
{\xe \v WiFiManager\:setAPCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setAPCallback (void(*)({\b WiFiManager} *)  {\i func})}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 758 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   758                                                                           \{\par
  759   _apcallback = func;\par
  760 \}\par
}
}
{\xe \v setAPStaticIPConfig\:WiFiManager}
{\xe \v WiFiManager\:setAPStaticIPConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setAPStaticIPConfig (IPAddress  {\i ip}, IPAddress  {\i gw}, IPAddress  {\i sn})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 340 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   340                                                                               \{\par
  341   _ap_static_ip = ip;\par
  342   _ap_static_gw = gw;\par
  343   _ap_static_sn = sn;\par
  344 \}\par
}
}
{\xe \v setBreakAfterConfig\:WiFiManager}
{\xe \v WiFiManager\:setBreakAfterConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setBreakAfterConfig (boolean  {\i shouldBreak})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 356 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   356                                                          \{\par
  357   _shouldBreakAfterConfig = shouldBreak;\par
  358 \}\par
}
}
{\xe \v setConfigPortalTimeout\:WiFiManager}
{\xe \v WiFiManager\:setConfigPortalTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setConfigPortalTimeout (unsigned long  {\i seconds})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 328 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   328                                                               \{\par
  329   _configPortalTimeout = seconds * 1000;\par
  330 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a904006cb4d2c769e93bfdef336853766_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setConnectTimeout\:WiFiManager}
{\xe \v WiFiManager\:setConnectTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setConnectTimeout (unsigned long  {\i seconds})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 332 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   332                                                          \{\par
  333   _connectTimeout = seconds * 1000;\par
  334 \}\par
}
}
{\xe \v setCustomHeadElement\:WiFiManager}
{\xe \v WiFiManager\:setCustomHeadElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setCustomHeadElement (const char *  {\i element})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 768 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   768                                                           \{\par
  769   _customHeadElement = element;\par
  770 \}\par
}
}
{\xe \v setDebugOutput\:WiFiManager}
{\xe \v WiFiManager\:setDebugOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setDebugOutput (boolean  {\i debug})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 336 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   336                                               \{\par
  337   _debug = debug;\par
  338 \}\par
}
}
{\xe \v setMinimumSignalQuality\:WiFiManager}
{\xe \v WiFiManager\:setMinimumSignalQuality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setMinimumSignalQuality (int  {\i quality} = {\f2 8})}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 352 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   352                                                      \{\par
  353   _minimumQuality = quality;\par
  354 \}\par
}
}
{\xe \v setRemoveDuplicateAPs\:WiFiManager}
{\xe \v WiFiManager\:setRemoveDuplicateAPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setRemoveDuplicateAPs (boolean  {\i removeDuplicates})}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 773 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   773                                                                 \{\par
  774   _removeDuplicateAPs = removeDuplicates;\par
  775 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a4dd1dbf4f22900f226a3897b88155212_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setSaveConfigCallback\:WiFiManager}
{\xe \v WiFiManager\:setSaveConfigCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setSaveConfigCallback (void(*)(void)  {\i func})}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 763 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   763                                                             \{\par
  764   _savecallback = func;\par
  765 \}\par
}
}
{\xe \v setSTAStaticIPConfig\:WiFiManager}
{\xe \v WiFiManager\:setSTAStaticIPConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setSTAStaticIPConfig (IPAddress  {\i ip}, IPAddress  {\i gw}, IPAddress  {\i sn})}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 346 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   346                                                                                \{\par
  347   _sta_static_ip = ip;\par
  348   _sta_static_gw = gw;\par
  349   _sta_static_sn = sn;\par
  350 \}\par
}
}
{\xe \v setTimeout\:WiFiManager}
{\xe \v WiFiManager\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setTimeout (unsigned long  {\i seconds})}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 324 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   324                                                   \{\par
  325   setConfigPortalTimeout(seconds);\par
  326 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_aa6493d59c284ff245edb767ff684756d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_aa6493d59c284ff245edb767ff684756d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setupConfigPortal\:WiFiManager}
{\xe \v WiFiManager\:setupConfigPortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::setupConfigPortal (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75                                     \{\par
   76   dnsServer.reset(new DNSServer());\par
   77   server.reset(new ESP8266WebServer(80));\par
   78 \par
   79   DEBUG_WM(F(""));\par
   80   _configPortalStart = millis();\par
   81 \par
   82   DEBUG_WM(F("Configuring access point... "));\par
   83   DEBUG_WM(_apName);\par
   84   if (_apPassword != NULL) \{\par
   85     if (strlen(_apPassword) < 8 || strlen(_apPassword) > 63) \{\par
   86       // fail passphrase to short or long!\par
   87       DEBUG_WM(F("Invalid AccessPoint password. Ignoring"));\par
   88       _apPassword = NULL;\par
   89     \}\par
   90     DEBUG_WM(_apPassword);\par
   91   \}\par
   92 \par
   93   //optional soft ip config\par
   94   if (_ap_static_ip) \{\par
   95     DEBUG_WM(F("Custom AP IP/GW/Subnet"));\par
   96     WiFi.softAPConfig(_ap_static_ip, _ap_static_gw, _ap_static_sn);\par
   97   \}\par
   98 \par
   99   if (_apPassword != NULL) \{\par
  100     WiFi.softAP(_apName, _apPassword);//password option\par
  101   \} else \{\par
  102     WiFi.softAP(_apName);\par
  103   \}\par
  104 \par
  105   delay(500); // Without delay I've seen the IP address blank\par
  106   DEBUG_WM(F("AP IP address: "));\par
  107   DEBUG_WM(WiFi.softAPIP());\par
  108 \par
  109   /* Setup the DNS server redirecting all the domains to the apIP */\par
  110   dnsServer->setErrorReplyCode(DNSReplyCode::NoError);\par
  111   dnsServer->start(DNS_PORT, "*", WiFi.softAPIP());\par
  112 \par
  113   /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\par
  114   server->on("/", std::bind(&WiFiManager::handleRoot, this));\par
  115   server->on("/wifi", std::bind(&WiFiManager::handleWifi, this, true));\par
  116   server->on("/0wifi", std::bind(&WiFiManager::handleWifi, this, false));\par
  117   server->on("/wifisave", std::bind(&WiFiManager::handleWifiSave, this));\par
  118   server->on("/i", std::bind(&WiFiManager::handleInfo, this));\par
  119   server->on("/r", std::bind(&WiFiManager::handleReset, this));\par
  120   //server->on("/generate_204", std::bind(&WiFiManager::handle204, this));  //Android/Chrome OS captive portal check.\par
  121   server->on("/fwlink", std::bind(&WiFiManager::handleRoot, this));  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\par
  122   server->on("/sensorsData.csv", std::bind(&WiFiManager::handleFileRead, this,"/sensorsData.csv"));\par
  123   server->onNotFound (std::bind(&WiFiManager::handleNotFound, this));\par
  124   server->begin(); // Web server start\par
  125   DEBUG_WM(F("HTTP server started"));\par
  126 \par
  127 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a1743325d0dd86d011df96b22d2a0ddd6_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a1743325d0dd86d011df96b22d2a0ddd6_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startConfigPortal\:WiFiManager}
{\xe \v WiFiManager\:startConfigPortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::startConfigPortal ()}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   155                                        \{\par
  156   String ssid = "ESP" + String(ESP.getChipId());\par
  157   return startConfigPortal(ssid.c_str(), NULL);\par
  158 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_ad781751307f7f623956126096a09a545_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startConfigPortal\:WiFiManager}
{\xe \v WiFiManager\:startConfigPortal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::startConfigPortal (char const *  {\i apName}, char const *  {\i apPassword} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   160                                                                                   \{\par
  161   //setup AP\par
  162   WiFi.mode(WIFI_AP_STA);\par
  163   DEBUG_WM("SET AP STA");\par
  164 \par
  165   _apName = apName;\par
  166   _apPassword = apPassword;\par
  167 \par
  168   //notify we entered AP mode\par
  169   if ( _apcallback != NULL) \{\par
  170     _apcallback(this);\par
  171   \}\par
  172 \par
  173   connect = false;\par
  174   setupConfigPortal();\par
  175 \par
  176   while (_configPortalTimeout == 0 || millis() < _configPortalStart + _configPortalTimeout) \{\par
  177     //DNS\par
  178     dnsServer->processNextRequest();\par
  179     //HTTP\par
  180     server->handleClient();\par
  181 \par
  182 \par
  183     if (connect) \{\par
  184       connect = false;\par
  185       delay(2000);\par
  186       DEBUG_WM(F("Connecting to new AP"));\par
  187 \par
  188       // using user-provided  _ssid, _pass in place of system-stored ssid and pass\par
  189       if (connectWifi(_ssid, _pass) != WL_CONNECTED) \{\par
  190         DEBUG_WM(F("Failed to connect."));\par
  191       \} else \{\par
  192         //connected\par
  193         WiFi.mode(WIFI_STA);\par
  194         //notify that configuration has changed and any optional parameters should be saved\par
  195         if ( _savecallback != NULL) \{\par
  196           //todo: check if any custom parameters actually exist, and check if they really changed maybe\par
  197           _savecallback();\par
  198         \}\par
  199         break;\par
  200       \}\par
  201 \par
  202       if (_shouldBreakAfterConfig) \{\par
  203         //flag set to exit after config after trying to connect\par
  204         //notify that configuration has changed and any optional parameters should be saved\par
  205         if ( _savecallback != NULL) \{\par
  206           //todo: check if any custom parameters actually exist, and check if they really changed maybe\par
  207           _savecallback();\par
  208         \}\par
  209         break;\par
  210       \}\par
  211     \}\par
  212     yield();\par
  213   \}\par
  214 \par
  215   server.reset();\par
  216   dnsServer.reset();\par
  217 \par
  218   return  WiFi.status() == WL_CONNECTED;\par
  219 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_afaca5021edffb4d9a5bd39f7b0f7a686_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startWPS\:WiFiManager}
{\xe \v WiFiManager\:startWPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManager::startWPS (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 288 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   288                            \{\par
  289   DEBUG_WM("START WPS");\par
  290   WiFi.beginWPSConfig();\par
  291   DEBUG_WM("END WPS");\par
  292 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_abcc403fc26a47f7a111d1271f1d0869e_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_abcc403fc26a47f7a111d1271f1d0869e_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v toStringIp\:WiFiManager}
{\xe \v WiFiManager\:toStringIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::toStringIp (IPAddress  {\i ip}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IP to String? \par
}{
Definition at line 812 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   812                                            \{\par
  813   String res = "";\par
  814   for (int i = 0; i < 3; i++) \{\par
  815     res += String((ip >> (8 * i)) & 0xFF) + ".";\par
  816   \}\par
  817   res += String(((ip >> 8 * 3)) & 0xFF);\par
  818   return res;\par
  819 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a8dfd64cefecbdf26242b16eca335c20b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v waitForConnectResult\:WiFiManager}
{\xe \v WiFiManager\:waitForConnectResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t WiFiManager::waitForConnectResult (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   265                                           \{\par
  266   if (_connectTimeout == 0) \{\par
  267     return WiFi.waitForConnectResult();\par
  268   \} else \{\par
  269     DEBUG_WM (F("Waiting for connection result with time out"));\par
  270     unsigned long start = millis();\par
  271     boolean keepConnecting = true;\par
  272     uint8_t status;\par
  273     while (keepConnecting) \{\par
  274       status = WiFi.status();\par
  275       if (millis() > start + _connectTimeout) \{\par
  276         keepConnecting = false;\par
  277         DEBUG_WM (F("Connection timed out"));\par
  278       \}\par
  279       if (status == WL_CONNECTED || status == WL_CONNECT_FAILED) \{\par
  280         keepConnecting = false;\par
  281       \}\par
  282       delay(100);\par
  283     \}\par
  284     return status;\par
  285   \}\par
  286 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a89a3f33997aa662ad223d6c150c1eede_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/dc8/class_wi_fi_manager_a89a3f33997aa662ad223d6c150c1eede_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ap_static_gw\:WiFiManager}
{\xe \v WiFiManager\:_ap_static_gw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_ap_static_gw{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _ap_static_ip\:WiFiManager}
{\xe \v WiFiManager\:_ap_static_ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_ap_static_ip{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _ap_static_sn\:WiFiManager}
{\xe \v WiFiManager\:_ap_static_sn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_ap_static_sn{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _apcallback\:WiFiManager}
{\xe \v WiFiManager\:_apcallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* WiFiManager::_apcallback) ({\b WiFiManager} *) = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 183 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _apName\:WiFiManager}
{\xe \v WiFiManager\:_apName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManager::_apName = "no-net"{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _apPassword\:WiFiManager}
{\xe \v WiFiManager\:_apPassword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManager::_apPassword = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _configPortalStart\:WiFiManager}
{\xe \v WiFiManager\:_configPortalStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long WiFiManager::_configPortalStart = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _configPortalTimeout\:WiFiManager}
{\xe \v WiFiManager\:_configPortalTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long WiFiManager::_configPortalTimeout = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _connectTimeout\:WiFiManager}
{\xe \v WiFiManager\:_connectTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long WiFiManager::_connectTimeout = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _customHeadElement\:WiFiManager}
{\xe \v WiFiManager\:_customHeadElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManager::_customHeadElement = ""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _debug\:WiFiManager}
{\xe \v WiFiManager\:_debug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_debug = true{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 181 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _minimumQuality\:WiFiManager}
{\xe \v WiFiManager\:_minimumQuality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::_minimumQuality = -1{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _params\:WiFiManager}
{\xe \v WiFiManager\:_params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WiFiManagerParameter}* WiFiManager::_params[{\b WIFI_MANAGER_MAX_PARAMS}]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _paramsCount\:WiFiManager}
{\xe \v WiFiManager\:_paramsCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::_paramsCount = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _pass\:WiFiManager}
{\xe \v WiFiManager\:_pass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::_pass = ""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _removeDuplicateAPs\:WiFiManager}
{\xe \v WiFiManager\:_removeDuplicateAPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_removeDuplicateAPs = true{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _savecallback\:WiFiManager}
{\xe \v WiFiManager\:_savecallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* WiFiManager::_savecallback) (void) = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 184 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _shouldBreakAfterConfig\:WiFiManager}
{\xe \v WiFiManager\:_shouldBreakAfterConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_shouldBreakAfterConfig = false{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _ssid\:WiFiManager}
{\xe \v WiFiManager\:_ssid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String WiFiManager::_ssid = ""{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _sta_static_gw\:WiFiManager}
{\xe \v WiFiManager\:_sta_static_gw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_sta_static_gw{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _sta_static_ip\:WiFiManager}
{\xe \v WiFiManager\:_sta_static_ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_sta_static_ip{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _sta_static_sn\:WiFiManager}
{\xe \v WiFiManager\:_sta_static_sn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IPAddress WiFiManager::_sta_static_sn{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _tryWPS\:WiFiManager}
{\xe \v WiFiManager\:_tryWPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::_tryWPS = false{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v connect\:WiFiManager}
{\xe \v WiFiManager\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
boolean WiFiManager::connect{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 180 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v DNS_PORT\:WiFiManager}
{\xe \v WiFiManager\:DNS_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const byte WiFiManager::DNS_PORT = 53{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 173 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v dnsServer\:WiFiManager}
{\xe \v WiFiManager\:dnsServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::unique_ptr<DNSServer> WiFiManager::dnsServer{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v server\:WiFiManager}
{\xe \v WiFiManager\:server}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::unique_ptr<ESP8266WebServer> WiFiManager::server{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v status\:WiFiManager}
{\xe \v WiFiManager\:status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManager::status = WL_IDLE_STATUS{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 154 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WiFiManagerParameter Class Reference\par \pard\plain 
{\tc\tcl2 \v WiFiManagerParameter}
{\xe \v WiFiManagerParameter}
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
\par
{
{\f2 #include <WiFiManagerReadFileButton.h>}}\par
Collaboration diagram for WiFiManagerParameter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d83/class_wi_fi_manager_parameter__coll__graph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} (const char *custom)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} (const char *id, const char *placeholder, const char *defaultValue, int length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WiFiManagerParameter} (const char *id, const char *placeholder, const char *defaultValue, int length, const char *custom)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getID} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getValue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getPlaceholder} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getValueLength} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getCustomHTML} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (const char *id, const char *placeholder, const char *defaultValue, int length, const char *custom)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _placeholder}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b _value}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b _customHTML}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WiFiManager}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 43 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManagerParameter::WiFiManagerParameter (const char *  {\i custom})}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    17                                                              \{\par
   18   _id = NULL;\par
   19   _placeholder = NULL;\par
   20   _length = 0;\par
   21   _value = NULL;\par
   22 \par
   23   _customHTML = custom;\par
   24 \}\par
}
}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManagerParameter::WiFiManagerParameter (const char *  {\i id}, const char *  {\i placeholder}, const char *  {\i defaultValue}, int  {\i length})}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    26                                                                                                                         \{\par
   27   init(id, placeholder, defaultValue, length, "");\par
   28 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a8e55ac907530d04ab60d30045e1382a1_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManagerParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WiFiManagerParameter::WiFiManagerParameter (const char *  {\i id}, const char *  {\i placeholder}, const char *  {\i defaultValue}, int  {\i length}, const char *  {\i custom})}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30                                                                                                                                             \{\par
   31   init(id, placeholder, defaultValue, length, custom);\par
   32 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a45967e1d29d52f5fc8e47e99cb693b98_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getCustomHTML\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getCustomHTML}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getCustomHTML ()}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61                                                 \{\par
   62   return _customHTML;\par
   63 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a596273c189eb40107500cee3ad31b13b_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getID\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getID ()}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52                                         \{\par
   53   return _id;\par
   54 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_af57919615418fff788310ba9cc2664d8_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getPlaceholder\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getPlaceholder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getPlaceholder ()}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55                                                  \{\par
   56   return _placeholder;\par
   57 \}\par
}
}
{\xe \v getValue\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * WiFiManagerParameter::getValue ()}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49                                            \{\par
   50   return _value;\par
   51 \}\par
}
}
{\xe \v getValueLength\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:getValueLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManagerParameter::getValueLength ()}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    58                                          \{\par
   59   return _length;\par
   60 \}\par
}
}
{\xe \v init\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WiFiManagerParameter::init (const char *  {\i id}, const char *  {\i placeholder}, const char *  {\i defaultValue}, int  {\i length}, const char *  {\i custom}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file WiFiManagerReadFileButton.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    34                                                                                                                                  \{\par
   35   _id = id;\par
   36   _placeholder = placeholder;\par
   37   _length = length;\par
   38   _value = new char[length + 1];\par
   39   for (int i = 0; i < length; i++) \{\par
   40     _value[i] = 0;\par
   41   \}\par
   42   if (defaultValue != NULL) \{\par
   43     strncpy(_value, defaultValue, length);\par
   44   \}\par
   45 \par
   46   _customHTML = custom;\par
   47 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d08/class_wi_fi_manager_parameter_a137b764027d3851a428f3ab185a5660f_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v WiFiManager\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:WiFiManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b WiFiManager}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _customHTML\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_customHTML}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManagerParameter::_customHTML{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _id\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManagerParameter::_id{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _length\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WiFiManagerParameter::_length{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _placeholder\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_placeholder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* WiFiManagerParameter::_placeholder{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file WiFiManagerReadFileButton.h.}\par
}
{\xe \v _value\:WiFiManagerParameter}
{\xe \v WiFiManagerParameter\:_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* WiFiManagerParameter::_value{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/{\b WiFiManagerReadFileButton.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/README.md}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/README.md}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.cpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Source file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "CoolBoard.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <Wire.h>}\par
{\f2 #include <memory>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoard.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d9d/_cool_board_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Source file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoard.cpp}
{\xe \v CoolBoard.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolBoard.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoard.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolFileSystem.h"}\par
{\f2 #include "CoolBoardSensors.h"}\par
{\f2 #include "CoolBoardLed.h"}\par
{\f2 #include "CoolTime.h"}\par
{\f2 #include "CoolMQTT.h"}\par
{\f2 #include "Jetpack.h"}\par
{\f2 #include "Irene3000.h"}\par
{\f2 #include "ExternalSensors.h"}\par
{\f2 #include "CoolWifi.h"}\par
{\f2 #include "CoolBoardActor.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoard.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d32/_cool_board_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/de0/_cool_board_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoard}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoard} and all of Its functions. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoard} Header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "CoolBoardActor.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardActor.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d36/_cool_board_actor_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoardActor.cpp}
{\xe \v CoolBoardActor.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolBoardActor.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardActor.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardActor.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d6d/_cool_board_actor_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d07/_cool_board_actor_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoardActor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b CoolBoardActor}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardActor::state}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardActor} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.cpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <NeoPixelBus.h>}\par
{\f2 #include "CoolBoardLed.h"}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardLed.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d71/_cool_board_led_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoardLed.cpp}
{\xe \v CoolBoardLed.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolBoardLed.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardLed.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include <NeoPixelBus.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardLed.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d68/_cool_board_led_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/df4/_cool_board_led_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoardLed}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the led in the Sensor Board. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardLed} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "CoolBoardSensors.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardSensors.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/dd0/_cool_board_sensors_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolBoardSensors.cpp}
{\xe \v CoolBoardSensors.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolBoardSensors.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolBoardSensors.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "internals/CoolSI114X.h"}\par
{\f2 #include "internals/CoolSparkFunBME280.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolBoardSensors.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d6/d72/_cool_board_sensors_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/daf/_cool_board_sensors_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolBoardSensors}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the On-Board Sensors. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::lightActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoolBoardSensors::airActive}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolBoardSensors} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <FS.h>}\par
{\f2 #include "CoolFileSystem.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolFileSystem.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/dc8/_cool_file_system_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolFileSystem.cpp}
{\xe \v CoolFileSystem.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolFileSystem.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolFileSystem.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolFileSystem.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d26/_cool_file_system_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/deb/_cool_file_system_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolFileSystem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the file system. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolFileSystem} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include "CoolMQTT.h"}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolMQTT.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d20/_cool_m_q_t_t_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolMQTT.cpp}
{\xe \v CoolMQTT.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolMQTT.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolMQTT.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include "internals/CoolPubSubClient.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolMQTT.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d5c/_cool_m_q_t_t_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d91/_cool_m_q_t_t_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolMQTT}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the mqtt client. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolMQTT} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "CoolTime.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "TimeLib.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolTime.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d9d/_cool_time_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolTime.cpp}
{\xe \v CoolTime.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolTime.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolTime.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "TimeLib.h"}\par
{\f2 #include <WiFiUdp.h>}\par
{\f2 #include <DS1337RTC.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolTime.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "de/d60/_cool_time_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d65/_cool_time_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolTime}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the DS1337 RTC . }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NTP_PACKET_SIZE}\~ 48\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolTime} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v NTP_PACKET_SIZE\:CoolTime.h}
{\xe \v CoolTime.h\:NTP_PACKET_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NTP_PACKET_SIZE\~ 48}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolTime.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.cpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include <ESP8266WiFiMulti.h>}\par
{\f2 #include "internals/WiFiManagerReadFileButton.h"}\par
{\f2 #include <CoolWifi.h>}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolWifi.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/dff/_cool_wifi_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:CoolWifi.cpp}
{\xe \v CoolWifi.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolWifi.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/CoolWifi.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include <ESP8266WiFiMulti.h>}\par
{\f2 #include <DNSServer.h>}\par
{\f2 #include <ESP8266WebServer.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolWifi.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d94/_cool_wifi_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d2b/_cool_wifi_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolWifi}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the WiFi connection . }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CoolWifi} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensor.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensor.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensor.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "internals/CoolNDIR_I2C.h"}\par
{\f2 #include <DallasTemperature.h>}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ExternalSensor.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/df9/_external_sensor_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/d63/_external_sensor_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BaseExternalSensor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a generic external Sensor it is a way to access real external sensor methods through run Time polymorphism. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensor< T >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class SensorClass> class External Sensor: Derived class from {\b BaseExternalSensor}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensor< NDIR_I2C >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b NDIR_I2C} Specialization Class This is the template specialization for the {\b NDIR_I2C} CO2 sensor. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensor< DallasTemperature >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DallasTemperature Specialization Class This is the template specialization for the Dallas Temperature sensor. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUGExternal}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensor} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUGExternal\:ExternalSensor.h}
{\xe \v ExternalSensor.h\:DEBUGExternal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUGExternal\~ 0}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file ExternalSensor.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.cpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "Wire.h"}\par
{\f2 #include "OneWire.h"}\par
{\f2 #include "ExternalSensors.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "ExternalSensor.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ExternalSensors.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d80/_external_sensors_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OneWire {\b oneWire} (0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:ExternalSensors.cpp}
{\xe \v ExternalSensors.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file ExternalSensors.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v oneWire\:ExternalSensors.cpp}
{\xe \v ExternalSensors.cpp\:oneWire}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
OneWire oneWire (0 )}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d09/_external_sensors_8cpp_af39fa3dad1ba161b384c0b26b8145e65_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/ExternalSensors.h}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "ExternalSensor.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ExternalSensors.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d97/_external_sensors_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d76/_external_sensors_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalSensors}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class handles the external sensors run time defintion , configuartion and actions. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExternalSensors::sensor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ExternalSensors} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.cpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
{\f2 #include "CoolAdafruit_ADS1015.h"}\par
{\f2 #include <Wire.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolAdafruit_ADS1015.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d37/_cool_adafruit___a_d_s1015_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint8_t {\b i2cread} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b i2cwrite} (uint8_t x)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b writeRegister} (uint8_t i2cAddress, uint8_t reg, uint16_t value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint16_t {\b readRegister} (uint8_t i2cAddress, uint8_t reg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v i2cread\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:i2cread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static uint8_t i2cread (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }}\par
{
Definition at line 36 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    36                              \{\par
   37   #if ARDUINO >= 100\par
   38   return Wire.read();\par
   39   #else\par
   40   return Wire.receive();\par
   41   #endif\par
   42 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_af89e2442d757f6ec8100c473022f6701_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v i2cwrite\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:i2cwrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void i2cwrite (uint8_t  {\i x}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract away platform differences in Arduino wire library. }}\par
{
Definition at line 49 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49                                 \{\par
   50   #if ARDUINO >= 100\par
   51   Wire.write((uint8_t)x);\par
   52   #else\par
   53   Wire.send(x);\par
   54   #endif\par
   55 \}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a6db5edba66e20bba6d5b421c2789af54_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readRegister\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:readRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static uint16_t readRegister (uint8_t  {\i i2cAddress}, uint8_t  {\i reg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }}\par
{
Definition at line 75 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75                                                               \{\par
   76   Wire.beginTransmission(i2cAddress);\par
   77   i2cwrite(ADS1015_REG_POINTER_CONVERT);\par
   78   Wire.endTransmission();\par
   79   Wire.requestFrom(i2cAddress, (uint8_t)2);\par
   80   return ((i2cread() << 8) | i2cread());  \par
   81 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a319539381b7551b2f83a92b0b596e97d_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a319539381b7551b2f83a92b0b596e97d_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v writeRegister\:CoolAdafruit_ADS1015.cpp}
{\xe \v CoolAdafruit_ADS1015.cpp\:writeRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void writeRegister (uint8_t  {\i i2cAddress}, uint8_t  {\i reg}, uint16_t  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16-bits to the specified destination register. }}\par
{
Definition at line 62 of file CoolAdafruit_ADS1015.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    62                                                                            \{\par
   63   Wire.beginTransmission(i2cAddress);\par
   64   i2cwrite((uint8_t)reg);\par
   65   i2cwrite((uint8_t)(value>>8));\par
   66   i2cwrite((uint8_t)(value & 0xFF));\par
   67   Wire.endTransmission();\par
   68 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a00ef55774dfb93dd0a7bf561d8451b71_cgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/daa/_cool_adafruit___a_d_s1015_8cpp_a00ef55774dfb93dd0a7bf561d8451b71_icgraph.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolAdafruit_ADS1015.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolAdafruit_ADS1015.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d26/_cool_adafruit___a_d_s1015_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d2/db3/_cool_adafruit___a_d_s1015_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Adafruit_ADS1015}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Adafruit_ADS1115}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_ADDRESS}\~ (0x48)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_CONVERSIONDELAY}\~ (1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1115_CONVERSIONDELAY}\~ (8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_MASK}\~ (0x03)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_CONVERT}\~ (0x00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_CONFIG}\~ (0x01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_LOWTHRESH}\~ (0x02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_POINTER_HITHRESH}\~ (0x03)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_MASK}\~ (0x8000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_SINGLE}\~ (0x8000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_BUSY}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_OS_NOTBUSY}\~ (0x8000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_MASK}\~ (0x7000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_0_1}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_0_3}\~ (0x1000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_1_3}\~ (0x2000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_DIFF_2_3}\~ (0x3000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_0}\~ (0x4000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_1}\~ (0x5000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_2}\~ (0x6000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MUX_SINGLE_3}\~ (0x7000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_MASK}\~ (0x0E00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_6_144V}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_4_096V}\~ (0x0200)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_2_048V}\~ (0x0400)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_1_024V}\~ (0x0600)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_0_512V}\~ (0x0800)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_PGA_0_256V}\~ (0x0A00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MODE_MASK}\~ (0x0100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MODE_CONTIN}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_MODE_SINGLE}\~ (0x0100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_MASK}\~ (0x00E0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_128SPS}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_250SPS}\~ (0x0020)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_490SPS}\~ (0x0040)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_920SPS}\~ (0x0060)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_1600SPS}\~ (0x0080)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_2400SPS}\~ (0x00A0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_DR_3300SPS}\~ (0x00C0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CMODE_MASK}\~ (0x0010)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CMODE_TRAD}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CMODE_WINDOW}\~ (0x0010)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CPOL_MASK}\~ (0x0008)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CPOL_ACTVLOW}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CPOL_ACTVHI}\~ (0x0008)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CLAT_MASK}\~ (0x0004)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CLAT_NONLAT}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CLAT_LATCH}\~ (0x0004)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_MASK}\~ (0x0003)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_1CONV}\~ (0x0000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_2CONV}\~ (0x0001)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_4CONV}\~ (0x0002)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADS1015_REG_CONFIG_CQUE_NONE}\~ (0x0003)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b adsGain_t} \{ {\b GAIN_TWOTHIRDS} = ADS1015_REG_CONFIG_PGA_6_144V, 
{\b GAIN_ONE} = ADS1015_REG_CONFIG_PGA_4_096V, 
{\b GAIN_TWO} = ADS1015_REG_CONFIG_PGA_2_048V, 
{\b GAIN_FOUR} = ADS1015_REG_CONFIG_PGA_1_024V, 
{\b GAIN_EIGHT} = ADS1015_REG_CONFIG_PGA_0_512V, 
{\b GAIN_SIXTEEN} = ADS1015_REG_CONFIG_PGA_0_256V
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ADS1015_ADDRESS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_ADDRESS\~ (0x48)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_CONVERSIONDELAY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_CONVERSIONDELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_CONVERSIONDELAY\~ (1)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CLAT_LATCH\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CLAT_LATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CLAT_LATCH\~ (0x0004)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CLAT_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CLAT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CLAT_MASK\~ (0x0004)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CLAT_NONLAT\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CLAT_NONLAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CLAT_NONLAT\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CMODE_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CMODE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CMODE_MASK\~ (0x0010)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CMODE_TRAD\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CMODE_TRAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CMODE_TRAD\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CMODE_WINDOW\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CMODE_WINDOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CMODE_WINDOW\~ (0x0010)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CPOL_ACTVHI\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CPOL_ACTVHI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CPOL_ACTVHI\~ (0x0008)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CPOL_ACTVLOW\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CPOL_ACTVLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CPOL_ACTVLOW\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CPOL_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CPOL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CPOL_MASK\~ (0x0008)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_1CONV\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_1CONV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_1CONV\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_2CONV\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_2CONV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_2CONV\~ (0x0001)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_4CONV\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_4CONV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_4CONV\~ (0x0002)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_MASK\~ (0x0003)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_CQUE_NONE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_CQUE_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_CQUE_NONE\~ (0x0003)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_128SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_128SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_128SPS\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_1600SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_1600SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_1600SPS\~ (0x0080)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_2400SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_2400SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_2400SPS\~ (0x00A0)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_250SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_250SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_250SPS\~ (0x0020)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_3300SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_3300SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_3300SPS\~ (0x00C0)}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_490SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_490SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_490SPS\~ (0x0040)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_920SPS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_920SPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_920SPS\~ (0x0060)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_DR_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_DR_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_DR_MASK\~ (0x00E0)}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MODE_CONTIN\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MODE_CONTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MODE_CONTIN\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MODE_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MODE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MODE_MASK\~ (0x0100)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MODE_SINGLE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MODE_SINGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MODE_SINGLE\~ (0x0100)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_0_1\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_0_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_0_1\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_0_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_0_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_0_3\~ (0x1000)}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_1_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_1_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_1_3\~ (0x2000)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_DIFF_2_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_DIFF_2_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_DIFF_2_3\~ (0x3000)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_MASK\~ (0x7000)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_0\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_0\~ (0x4000)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_1\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_1\~ (0x5000)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_2\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_2\~ (0x6000)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_MUX_SINGLE_3\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_MUX_SINGLE_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_MUX_SINGLE_3\~ (0x7000)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_BUSY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_BUSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_BUSY\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_MASK\~ (0x8000)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_NOTBUSY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_NOTBUSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_NOTBUSY\~ (0x8000)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_OS_SINGLE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_OS_SINGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_OS_SINGLE\~ (0x8000)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_0_256V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_0_256V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_0_256V\~ (0x0A00)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_0_512V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_0_512V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_0_512V\~ (0x0800)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_1_024V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_1_024V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_1_024V\~ (0x0600)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_2_048V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_2_048V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_2_048V\~ (0x0400)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_4_096V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_4_096V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_4_096V\~ (0x0200)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_6_144V\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_6_144V}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_6_144V\~ (0x0000)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_CONFIG_PGA_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_CONFIG_PGA_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_CONFIG_PGA_MASK\~ (0x0E00)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_CONFIG\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_CONFIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_CONFIG\~ (0x01)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_CONVERT\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_CONVERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_CONVERT\~ (0x00)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_HITHRESH\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_HITHRESH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_HITHRESH\~ (0x03)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_LOWTHRESH\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_LOWTHRESH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_LOWTHRESH\~ (0x02)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1015_REG_POINTER_MASK\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1015_REG_POINTER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1015_REG_POINTER_MASK\~ (0x03)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolAdafruit_ADS1015.h.}\par
}
{\xe \v ADS1115_CONVERSIONDELAY\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:ADS1115_CONVERSIONDELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADS1115_CONVERSIONDELAY\~ (8)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolAdafruit_ADS1015.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v adsGain_t\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:adsGain_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b adsGain_t}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v GAIN_TWOTHIRDS\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_TWOTHIRDS}
{\qr GAIN_TWOTHIRDS{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\cell }{\cell }{\row }
{\xe \v GAIN_ONE\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_ONE}
{\qr GAIN_ONE{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\cell }{\cell }{\row }
{\xe \v GAIN_TWO\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_TWO}
{\qr GAIN_TWO{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{\cell }{\row }
{\xe \v GAIN_FOUR\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_FOUR}
{\qr GAIN_FOUR{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{\cell }{\row }
{\xe \v GAIN_EIGHT\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_EIGHT}
{\qr GAIN_EIGHT{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
{\xe \v GAIN_SIXTEEN\:CoolAdafruit_ADS1015.h}
{\xe \v CoolAdafruit_ADS1015.h\:GAIN_SIXTEEN}
{\qr GAIN_SIXTEEN{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\cell }{\cell }{\row }
}
\par
{
Definition at line 109 of file CoolAdafruit_ADS1015.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   110 \{\par
  111   GAIN_TWOTHIRDS    = ADS1015_REG_CONFIG_PGA_6_144V,\par
  112   GAIN_ONE          = ADS1015_REG_CONFIG_PGA_4_096V,\par
  113   GAIN_TWO          = ADS1015_REG_CONFIG_PGA_2_048V,\par
  114   GAIN_FOUR         = ADS1015_REG_CONFIG_PGA_1_024V,\par
  115   GAIN_EIGHT        = ADS1015_REG_CONFIG_PGA_0_512V,\par
  116   GAIN_SIXTEEN      = ADS1015_REG_CONFIG_PGA_0_256V\par
  117 \} adsGain_t;\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.cpp}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Wire.h>}\par
{\f2 #include "CoolNDIR_I2C.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolNDIR_I2C.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d4e/_cool_n_d_i_r___i2_c_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RHR}\~ (0x00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THR}\~ (0X00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IER}\~ (0X01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FCR}\~ (0X02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IIR}\~ (0X02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LCR}\~ (0X03)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MCR}\~ (0X04)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LSR}\~ (0X05)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MSR}\~ (0X06)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPR}\~ (0X07)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR}\~ (0X06)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TLR}\~ (0X07)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TXLVL}\~ (0X08)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RXLVL}\~ (0X09)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IODIR}\~ (0X0A)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IOSTATE}\~ (0X0B)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IOINTENA}\~ (0X0C)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IOCONTROL}\~ (0X0E)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EFCR}\~ (0X0F)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DLL}\~ (0x00)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DLH}\~ (0X01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EFR}\~ (0X02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XON1}\~ (0X04)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XON2}\~ (0X05)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XOFF1}\~ (0X06)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XOFF2}\~ (0X07)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SC16IS750_CRYSTCAL_FREQ}\~ (14745600UL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RECEIVE_TIMEOUT}\~ (100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WIRE}\~ Wire\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DLH\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:DLH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DLH\~ (0X01)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v DLL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:DLL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DLL\~ (0x00)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v EFCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:EFCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EFCR\~ (0X0F)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v EFR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:EFR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EFR\~ (0X02)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v FCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:FCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FCR\~ (0X02)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IER\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IER\~ (0X01)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IIR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IIR\~ (0X02)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IOCONTROL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IOCONTROL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IOCONTROL\~ (0X0E)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IODIR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IODIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IODIR\~ (0X0A)}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IOINTENA\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IOINTENA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IOINTENA\~ (0X0C)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v IOSTATE\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:IOSTATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IOSTATE\~ (0X0B)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v LCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:LCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LCR\~ (0X03)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v LSR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:LSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LSR\~ (0X05)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v MCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:MCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MCR\~ (0X04)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v MSR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:MSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSR\~ (0X06)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v RECEIVE_TIMEOUT\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:RECEIVE_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RECEIVE_TIMEOUT\~ (100)}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v RHR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:RHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RHR\~ (0x00)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v RXLVL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:RXLVL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RXLVL\~ (0X09)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v SC16IS750_CRYSTCAL_FREQ\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:SC16IS750_CRYSTCAL_FREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SC16IS750_CRYSTCAL_FREQ\~ (14745600UL)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v SPR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:SPR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPR\~ (0X07)}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v TCR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:TCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR\~ (0X06)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v THR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:THR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THR\~ (0X00)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v TLR\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:TLR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TLR\~ (0X07)}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v TXLVL\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:TXLVL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TXLVL\~ (0X08)}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v WIRE\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:WIRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WIRE\~ Wire}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XOFF1\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XOFF1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XOFF1\~ (0X06)}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XOFF2\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XOFF2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XOFF2\~ (0X07)}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XON1\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XON1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XON1\~ (0X04)}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolNDIR_I2C.cpp.}\par
}
{\xe \v XON2\:CoolNDIR_I2C.cpp}
{\xe \v CoolNDIR_I2C.cpp\:XON2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XON2\~ (0X05)}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolNDIR_I2C.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolNDIR_I2C.h}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d5f/_cool_n_d_i_r___i2_c_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NDIR_I2C}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.cpp}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolPubSubClient.h"}\par
{\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolPubSubClient.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d86/_cool_pub_sub_client_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_HEADER_VERSION_LENGTH}\~ 7\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MQTT_HEADER_VERSION_LENGTH\:CoolPubSubClient.cpp}
{\xe \v CoolPubSubClient.cpp\:MQTT_HEADER_VERSION_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_HEADER_VERSION_LENGTH\~ 7}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolPubSubClient.h}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "IPAddress.h"}\par
{\f2 #include "Client.h"}\par
{\f2 #include "Stream.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolPubSubClient.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d35/_cool_pub_sub_client_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d9e/_cool_pub_sub_client_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolPubSubClient}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_VERSION_3_1}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_VERSION_3_1_1}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_VERSION}\~ {\b MQTT_VERSION_3_1_1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_MAX_PACKET_SIZE}\~ 128\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_KEEPALIVE}\~ 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_SOCKET_TIMEOUT}\~ 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECTION_TIMEOUT}\~ -4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECTION_LOST}\~ -3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_FAILED}\~ -2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_DISCONNECTED}\~ -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECTED}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_BAD_PROTOCOL}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_BAD_CLIENT_ID}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_UNAVAILABLE}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_BAD_CREDENTIALS}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CONNECT_UNAUTHORIZED}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTCONNECT}\~ 1 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTCONNACK}\~ 2 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBLISH}\~ 3 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBACK}\~ 4 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBREC}\~ 5 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBREL}\~ 6 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBCOMP}\~ 7 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTSUBSCRIBE}\~ 8 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTSUBACK}\~ 9 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTUNSUBSCRIBE}\~ 10 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTUNSUBACK}\~ 11 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPINGREQ}\~ 12 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPINGRESP}\~ 13 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTDISCONNECT}\~ 14 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTReserved}\~ 15 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS0}\~ (0 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS1}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS2}\~ (2 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_CALLBACK_SIGNATURE}\~ void (*callback)(char*, uint8_t*, unsigned int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MQTT_CALLBACK_SIGNATURE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CALLBACK_SIGNATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CALLBACK_SIGNATURE\~ void (*callback)(char*, uint8_t*, unsigned int)}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_BAD_CLIENT_ID\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_BAD_CLIENT_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_BAD_CLIENT_ID\~ 2}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_BAD_CREDENTIALS\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_BAD_CREDENTIALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_BAD_CREDENTIALS\~ 4}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_BAD_PROTOCOL\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_BAD_PROTOCOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_BAD_PROTOCOL\~ 1}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_FAILED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_FAILED\~ -2}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_UNAUTHORIZED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_UNAUTHORIZED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_UNAUTHORIZED\~ 5}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECT_UNAVAILABLE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECT_UNAVAILABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECT_UNAVAILABLE\~ 3}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECTED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECTED\~ 0}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECTION_LOST\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECTION_LOST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECTION_LOST\~ -3}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_CONNECTION_TIMEOUT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_CONNECTION_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_CONNECTION_TIMEOUT\~ -4}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_DISCONNECTED\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_DISCONNECTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_DISCONNECTED\~ -1}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_KEEPALIVE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_KEEPALIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_KEEPALIVE\~ 15}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_MAX_PACKET_SIZE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_MAX_PACKET_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_MAX_PACKET_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_SOCKET_TIMEOUT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_SOCKET_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_SOCKET_TIMEOUT\~ 15}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_VERSION\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_VERSION\~ {\b MQTT_VERSION_3_1_1}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_VERSION_3_1\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_VERSION_3_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_VERSION_3_1\~ 3}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTT_VERSION_3_1_1\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTT_VERSION_3_1_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_VERSION_3_1_1\~ 4}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTCONNACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTCONNACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTCONNACK\~ 2 << 4}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTCONNECT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTCONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTCONNECT\~ 1 << 4}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTDISCONNECT\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTDISCONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTDISCONNECT\~ 14 << 4}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPINGREQ\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPINGREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPINGREQ\~ 12 << 4}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPINGRESP\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPINGRESP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPINGRESP\~ 13 << 4}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBACK\~ 4 << 4}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBCOMP\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBCOMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBCOMP\~ 7 << 4}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBLISH\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBLISH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBLISH\~ 3 << 4}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBREC\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBREC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBREC\~ 5 << 4}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTPUBREL\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTPUBREL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBREL\~ 6 << 4}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTQOS0\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTQOS0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS0\~ (0 << 1)}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTQOS1\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTQOS1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS1\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTQOS2\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTQOS2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS2\~ (2 << 1)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTReserved\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTReserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTReserved\~ 15 << 4}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTSUBACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTSUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTSUBACK\~ 9 << 4}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTSUBSCRIBE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTSUBSCRIBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTSUBSCRIBE\~ 8 << 4}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTUNSUBACK\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTUNSUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTUNSUBACK\~ 11 << 4}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolPubSubClient.h.}\par
}
{\xe \v MQTTUNSUBSCRIBE\:CoolPubSubClient.h}
{\xe \v CoolPubSubClient.h\:MQTTUNSUBSCRIBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTUNSUBSCRIBE\~ 10 << 4}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolPubSubClient.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.cpp}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolSI114X.h"}\par
{\f2 #include "Wire.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSI114X.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d51/_cool_s_i114_x_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSI114X.h}
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSI114X.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d0d/_cool_s_i114_x_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d23/_cool_s_i114_x_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoolSI114X}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_QUERY}\~ 0X80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_SET}\~ 0XA0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_NOP}\~ 0X0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_RESET}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_BUSADDR}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_FORCE}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_GET_CAL}\~ 0X12\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_FORCE}\~ 0X06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSALS_FORCE}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_PAUSE}\~ 0X09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_PAUSE}\~ 0X0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSALS_PAUSE}\~ 0XB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_AUTO}\~ 0X0D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_AUTO}\~ 0X0E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSALS_AUTO}\~ 0X0F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PART_ID}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_REV_ID}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_SEQ_ID}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_INT_CFG}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_ENABLE}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_MODE1}\~ 0x05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_MODE2}\~ 0x06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_HW_KEY}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_MEAS_RATE0}\~ 0X08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_MEAS_RATE1}\~ 0X09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_RATE}\~ 0X0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_LED21}\~ 0X0F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_LED3}\~ 0X10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF0}\~ 0X13\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF1}\~ 0X14\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF2}\~ 0X15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_UCOEFF3}\~ 0X16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_WR}\~ 0X17\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_COMMAND}\~ 0X18\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_RESPONSE}\~ 0X20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQ_STATUS}\~ 0X21\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_DATA0}\~ 0X22\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_DATA1}\~ 0X23\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_DATA0}\~ 0X24\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_DATA1}\~ 0X25\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS1_DATA0}\~ 0X26\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS1_DATA1}\~ 0X27\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS2_DATA0}\~ 0X28\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS2_DATA1}\~ 0X29\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS3_DATA0}\~ 0X2A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS3_DATA1}\~ 0X2B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_AUX_DATA0_UVINDEX0}\~ 0X2C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_AUX_DATA1_UVINDEX1}\~ 0X2D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_RD}\~ 0X2E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHIP_STAT}\~ 0X30\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_I2C_ADDR}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENUV}\~ 0x80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENAUX}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENALSIR}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENALSVIS}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENPS1}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENPS2}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_CHLIST_ENPS3}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ENCODE}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_ENCODE}\~ 0X06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS1_ADCMUX}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS2_ADCMUX}\~ 0X08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS3_ADCMUX}\~ 0X09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ADC_COUNTER}\~ 0X0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ADC_GAIN}\~ 0X0B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PS_ADC_MISC}\~ 0X0C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_MUX}\~ 0X0E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_AUX_ADC_MUX}\~ 0X0F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_ADC_COUNTER}\~ 0X10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_ADC_GAIN}\~ 0X11\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_VIS_ADC_MISC}\~ 0X12\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_REC}\~ 0X1C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_COUNTER}\~ 0X1D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_GAIN}\~ 0X1E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ALS_IR_ADC_MISC}\~ 0X1F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_SMALL_IR}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_VISIABLE}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_LARGE_IR}\~ 0x03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_NO}\~ 0x06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_GND}\~ 0x25\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_TEMPERATURE}\~ 0x65\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADCMUX_VDD}\~ 0x75\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_NONE}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_LED1}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_LED2}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS1_LED3}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_NONE}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_LED1}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_LED2}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED12_SELECT_PS2_LED3}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_NONE}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_LED1}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_LED2}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_PSLED3_SELECT_PS2_LED3}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV1}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV2}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV4}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV8}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV16}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_GAIN_DIV32}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_5MA}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_11MA}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_22MA}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_LED_CURRENT_45MA}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_1ADCCLK}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_7ADCCLK}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_15ADCCLK}\~ 0X02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_31ADCCLK}\~ 0X03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_63ADCCLK}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_127ADCCLK}\~ 0X05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_255ADCCLK}\~ 0X06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_COUNTER_511ADCCLK}\~ 0X07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_LOWRANGE}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_HIGHRANGE}\~ 0X20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY}\~ 0X00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADC_MISC_ADC_RAWADC}\~ 0X04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_INT_CFG_INTOE}\~ 0X01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_ALS}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_PS1}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_PS2}\~ 0x08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_IRQEN_PS3}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CoolSI114X_ADDR}\~ 0x60\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CoolSI114X_ADC_COUNTER_127ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_127ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_127ADCCLK\~ 0X05}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_15ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_15ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_15ADCCLK\~ 0X02}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_1ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_1ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_1ADCCLK\~ 0X00}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_255ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_255ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_255ADCCLK\~ 0X06}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_31ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_31ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_31ADCCLK\~ 0X03}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_511ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_511ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_511ADCCLK\~ 0X07}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_63ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_63ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_63ADCCLK\~ 0X04}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_COUNTER_7ADCCLK\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_COUNTER_7ADCCLK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_COUNTER_7ADCCLK\~ 0X01}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV1\~ 0X00}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV16\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV16\~ 0X04}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV2\~ 0X01}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV32\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV32\~ 0X05}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV4\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV4\~ 0X02}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_GAIN_DIV8\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_GAIN_DIV8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_GAIN_DIV8\~ 0X03}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_ADC_NORMALPROXIMITY\~ 0X00}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_ADC_RAWADC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_ADC_RAWADC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_ADC_RAWADC\~ 0X04}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_HIGHRANGE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_HIGHRANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_HIGHRANGE\~ 0X20}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADC_MISC_LOWRANGE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADC_MISC_LOWRANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADC_MISC_LOWRANGE\~ 0X00}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_GND\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_GND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_GND\~ 0x25}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_LARGE_IR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_LARGE_IR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_LARGE_IR\~ 0x03}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_NO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_NO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_NO\~ 0x06}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_SMALL_IR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_SMALL_IR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_SMALL_IR\~ 0x00}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_TEMPERATURE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_TEMPERATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_TEMPERATURE\~ 0x65}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_VDD\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_VDD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_VDD\~ 0x75}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADCMUX_VISIABLE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADCMUX_VISIABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADCMUX_VISIABLE\~ 0x02}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ADDR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ADDR\~ 0x60}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 162 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_AUTO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_AUTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_AUTO\~ 0X0E}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_ENCODE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_ENCODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_ENCODE\~ 0X06}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_FORCE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_FORCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_FORCE\~ 0X06}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_COUNTER\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_COUNTER\~ 0X1D}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_GAIN\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_GAIN\~ 0X1E}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_MISC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_MISC\~ 0X1F}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_ADC_MUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_ADC_MUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_ADC_MUX\~ 0X0E}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_DATA0\~ 0X24}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_IR_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_IR_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_IR_DATA1\~ 0X25}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_PAUSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_PAUSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_PAUSE\~ 0X0A}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_ADC_COUNTER\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_ADC_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_ADC_COUNTER\~ 0X10}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_ADC_GAIN\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_ADC_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_ADC_GAIN\~ 0X11}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_ADC_MISC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_ADC_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_ADC_MISC\~ 0X12}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_DATA0\~ 0X22}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_ALS_VIS_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_ALS_VIS_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_ALS_VIS_DATA1\~ 0X23}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_AUX_ADC_MUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_AUX_ADC_MUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_AUX_ADC_MUX\~ 0X0F}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_AUX_DATA0_UVINDEX0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_AUX_DATA0_UVINDEX0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_AUX_DATA0_UVINDEX0\~ 0X2C}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_AUX_DATA1_UVINDEX1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_AUX_DATA1_UVINDEX1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_AUX_DATA1_UVINDEX1\~ 0X2D}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_BUSADDR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_BUSADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_BUSADDR\~ 0X02}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHIP_STAT\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHIP_STAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHIP_STAT\~ 0X30}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST\~ 0X01}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENALSIR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENALSIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENALSIR\~ 0x20}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENALSVIS\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENALSVIS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENALSVIS\~ 0x10}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENAUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENAUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENAUX\~ 0x40}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENPS1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENPS1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENPS1\~ 0x01}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENPS2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENPS2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENPS2\~ 0x02}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENPS3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENPS3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENPS3\~ 0x04}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_CHLIST_ENUV\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_CHLIST_ENUV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_CHLIST_ENUV\~ 0x80}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_COMMAND\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_COMMAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_COMMAND\~ 0X18}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_GET_CAL\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_GET_CAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_GET_CAL\~ 0X12}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_HW_KEY\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_HW_KEY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_HW_KEY\~ 0X07}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_I2C_ADDR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_I2C_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_I2C_ADDR\~ 0X00}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_INT_CFG\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_INT_CFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_INT_CFG\~ 0X03}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_INT_CFG_INTOE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_INT_CFG_INTOE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_INT_CFG_INTOE\~ 0X01}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_ENABLE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_ENABLE\~ 0X04}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_MODE1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_MODE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_MODE1\~ 0x05}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_MODE2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_MODE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_MODE2\~ 0x06}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQ_STATUS\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQ_STATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQ_STATUS\~ 0X21}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_ALS\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_ALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_ALS\~ 0x01}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_PS1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_PS1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_PS1\~ 0x04}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 158 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_PS2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_PS2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_PS2\~ 0x08}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 159 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_IRQEN_PS3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_IRQEN_PS3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_IRQEN_PS3\~ 0x10}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_11MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_11MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_11MA\~ 0X02}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_22MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_22MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_22MA\~ 0X03}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_45MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_45MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_45MA\~ 0X04}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_CURRENT_5MA\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_CURRENT_5MA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_CURRENT_5MA\~ 0X01}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_LED_REC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_LED_REC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_LED_REC\~ 0X1C}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_MEAS_RATE0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_MEAS_RATE0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_MEAS_RATE0\~ 0X08}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_MEAS_RATE1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_MEAS_RATE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_MEAS_RATE1\~ 0X09}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_NOP\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_NOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_NOP\~ 0X0}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PART_ID\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PART_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PART_ID\~ 0X00}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS1_ADCMUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS1_ADCMUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS1_ADCMUX\~ 0X07}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS1_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS1_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS1_DATA0\~ 0X26}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS1_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS1_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS1_DATA1\~ 0X27}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS2_ADCMUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS2_ADCMUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS2_ADCMUX\~ 0X08}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS2_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS2_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS2_DATA0\~ 0X28}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS2_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS2_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS2_DATA1\~ 0X29}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS3_ADCMUX\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS3_ADCMUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS3_ADCMUX\~ 0X09}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS3_DATA0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS3_DATA0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS3_DATA0\~ 0X2A}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS3_DATA1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS3_DATA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS3_DATA1\~ 0X2B}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ADC_COUNTER\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ADC_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ADC_COUNTER\~ 0X0A}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ADC_GAIN\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ADC_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ADC_GAIN\~ 0X0B}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ADC_MISC\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ADC_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ADC_MISC\~ 0X0C}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_AUTO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_AUTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_AUTO\~ 0X0D}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_ENCODE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_ENCODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_ENCODE\~ 0X05}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_FORCE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_FORCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_FORCE\~ 0X05}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_LED21\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_LED21}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_LED21\~ 0X0F}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_LED3\~ 0X10}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_PAUSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_PAUSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_PAUSE\~ 0X09}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PS_RATE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PS_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PS_RATE\~ 0X0A}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSALS_AUTO\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSALS_AUTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSALS_AUTO\~ 0X0F}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSALS_FORCE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSALS_FORCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSALS_FORCE\~ 0X07}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSALS_PAUSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSALS_PAUSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSALS_PAUSE\~ 0XB}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT\~ 0X02}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_LED1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_LED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_LED1\~ 0x01}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_LED2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_LED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_LED2\~ 0x02}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_LED3\~ 0x04}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS1_NONE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS1_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS1_NONE\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_LED1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_LED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_LED1\~ 0x10}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_LED2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_LED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_LED2\~ 0x20}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_LED3\~ 0x40}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED12_SELECT_PS2_NONE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED12_SELECT_PS2_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED12_SELECT_PS2_NONE\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT\~ 0X03}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_LED1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_LED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_LED1\~ 0x10}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_LED2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_LED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_LED2\~ 0x20}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_LED3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_LED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_LED3\~ 0x40}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_PSLED3_SELECT_PS2_NONE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_PSLED3_SELECT_PS2_NONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_PSLED3_SELECT_PS2_NONE\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_QUERY\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_QUERY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_QUERY\~ 0X80}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_RD\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_RD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_RD\~ 0X2E}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_RESET\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_RESET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_RESET\~ 0X01}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_RESPONSE\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_RESPONSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_RESPONSE\~ 0X20}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_REV_ID\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_REV_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_REV_ID\~ 0X01}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_SEQ_ID\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_SEQ_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_SEQ_ID\~ 0X02}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_SET\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_SET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_SET\~ 0XA0}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF0\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF0\~ 0X13}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF1\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF1\~ 0X14}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF2\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF2\~ 0X15}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_UCOEFF3\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_UCOEFF3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_UCOEFF3\~ 0X16}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolSI114X.h.}\par
}
{\xe \v CoolSI114X_WR\:CoolSI114X.h}
{\xe \v CoolSI114X.h\:CoolSI114X_WR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CoolSI114X_WR\~ 0X17}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolSI114X.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.cpp}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoolSparkFunBME280.h"}\par
{\f2 #include "stdint.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include "Wire.h"}\par
{\f2 #include "SPI.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSparkFunBME280.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/dcb/_cool_spark_fun_b_m_e280_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/CoolSparkFunBME280.h}
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "stdint.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for CoolSparkFunBME280.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d3f/_cool_spark_fun_b_m_e280_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d44/_cool_spark_fun_b_m_e280_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SensorSettings}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SensorCalibration}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BME280}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b I2C_MODE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPI_MODE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T1_LSB_REG}\~ 0x88\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T1_MSB_REG}\~ 0x89\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T2_LSB_REG}\~ 0x8A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T2_MSB_REG}\~ 0x8B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T3_LSB_REG}\~ 0x8C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_T3_MSB_REG}\~ 0x8D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P1_LSB_REG}\~ 0x8E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P1_MSB_REG}\~ 0x8F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P2_LSB_REG}\~ 0x90\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P2_MSB_REG}\~ 0x91\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P3_LSB_REG}\~ 0x92\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P3_MSB_REG}\~ 0x93\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P4_LSB_REG}\~ 0x94\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P4_MSB_REG}\~ 0x95\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P5_LSB_REG}\~ 0x96\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P5_MSB_REG}\~ 0x97\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P6_LSB_REG}\~ 0x98\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P6_MSB_REG}\~ 0x99\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P7_LSB_REG}\~ 0x9A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P7_MSB_REG}\~ 0x9B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P8_LSB_REG}\~ 0x9C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P8_MSB_REG}\~ 0x9D\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P9_LSB_REG}\~ 0x9E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_P9_MSB_REG}\~ 0x9F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H1_REG}\~ 0xA1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CHIP_ID_REG}\~ 0xD0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_RST_REG}\~ 0xE0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H2_LSB_REG}\~ 0xE1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H2_MSB_REG}\~ 0xE2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H3_REG}\~ 0xE3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H4_MSB_REG}\~ 0xE4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H4_LSB_REG}\~ 0xE5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H5_MSB_REG}\~ 0xE6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DIG_H6_REG}\~ 0xE7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_HUMIDITY_REG}\~ 0xF2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STAT_REG}\~ 0xF3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_MEAS_REG}\~ 0xF4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CONFIG_REG}\~ 0xF5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESSURE_MSB_REG}\~ 0xF7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESSURE_LSB_REG}\~ 0xF8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESSURE_XLSB_REG}\~ 0xF9\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMPERATURE_MSB_REG}\~ 0xFA\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMPERATURE_LSB_REG}\~ 0xFB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMPERATURE_XLSB_REG}\~ 0xFC\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_HUMIDITY_MSB_REG}\~ 0xFD\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_HUMIDITY_LSB_REG}\~ 0xFE\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BME280_CHIP_ID_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CHIP_ID_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CHIP_ID_REG\~ 0xD0}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_CONFIG_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CONFIG_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CONFIG_REG\~ 0xF5}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_CTRL_HUMIDITY_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CTRL_HUMIDITY_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_HUMIDITY_REG\~ 0xF2}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_CTRL_MEAS_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_CTRL_MEAS_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_MEAS_REG\~ 0xF4}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H1_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H1_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H1_REG\~ 0xA1}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H2_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H2_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H2_LSB_REG\~ 0xE1}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H2_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H2_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H2_MSB_REG\~ 0xE2}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H3_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H3_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H3_REG\~ 0xE3}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H4_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H4_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H4_LSB_REG\~ 0xE5}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H4_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H4_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H4_MSB_REG\~ 0xE4}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H5_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H5_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H5_MSB_REG\~ 0xE6}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_H6_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_H6_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_H6_REG\~ 0xE7}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P1_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P1_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P1_LSB_REG\~ 0x8E}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P1_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P1_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P1_MSB_REG\~ 0x8F}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P2_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P2_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P2_LSB_REG\~ 0x90}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P2_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P2_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P2_MSB_REG\~ 0x91}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P3_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P3_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P3_LSB_REG\~ 0x92}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P3_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P3_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P3_MSB_REG\~ 0x93}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P4_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P4_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P4_LSB_REG\~ 0x94}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P4_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P4_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P4_MSB_REG\~ 0x95}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P5_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P5_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P5_LSB_REG\~ 0x96}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P5_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P5_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P5_MSB_REG\~ 0x97}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P6_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P6_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P6_LSB_REG\~ 0x98}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P6_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P6_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P6_MSB_REG\~ 0x99}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P7_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P7_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P7_LSB_REG\~ 0x9A}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P7_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P7_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P7_MSB_REG\~ 0x9B}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P8_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P8_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P8_LSB_REG\~ 0x9C}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P8_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P8_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P8_MSB_REG\~ 0x9D}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P9_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P9_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P9_LSB_REG\~ 0x9E}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_P9_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_P9_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_P9_MSB_REG\~ 0x9F}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T1_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T1_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T1_LSB_REG\~ 0x88}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T1_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T1_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T1_MSB_REG\~ 0x89}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T2_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T2_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T2_LSB_REG\~ 0x8A}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T2_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T2_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T2_MSB_REG\~ 0x8B}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T3_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T3_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T3_LSB_REG\~ 0x8C}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_DIG_T3_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_DIG_T3_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DIG_T3_MSB_REG\~ 0x8D}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_HUMIDITY_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_HUMIDITY_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_HUMIDITY_LSB_REG\~ 0xFE}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_HUMIDITY_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_HUMIDITY_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_HUMIDITY_MSB_REG\~ 0xFD}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_PRESSURE_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_PRESSURE_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESSURE_LSB_REG\~ 0xF8}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_PRESSURE_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_PRESSURE_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESSURE_MSB_REG\~ 0xF7}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_PRESSURE_XLSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_PRESSURE_XLSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESSURE_XLSB_REG\~ 0xF9}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_RST_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_RST_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_RST_REG\~ 0xE0}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_STAT_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_STAT_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STAT_REG\~ 0xF3}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_TEMPERATURE_LSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_TEMPERATURE_LSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMPERATURE_LSB_REG\~ 0xFB}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_TEMPERATURE_MSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_TEMPERATURE_MSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMPERATURE_MSB_REG\~ 0xFA}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file CoolSparkFunBME280.h.}\par
}
{\xe \v BME280_TEMPERATURE_XLSB_REG\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:BME280_TEMPERATURE_XLSB_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMPERATURE_XLSB_REG\~ 0xFC}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file CoolSparkFunBME280.h.}\par
}
{\xe \v I2C_MODE\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:I2C_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define I2C_MODE\~ 0}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file CoolSparkFunBME280.h.}\par
}
{\xe \v SPI_MODE\:CoolSparkFunBME280.h}
{\xe \v CoolSparkFunBME280.h\:SPI_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPI_MODE\~ 1}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file CoolSparkFunBME280.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/parse.js File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/parse.js}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/parse.js}
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/template.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/template.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/extras/template.h}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char HTTP_HEAD [] {\b PROGMEM} = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\"content=\\"width=device-width,initial-scale=1,user-scalable=no\\"/><title>\{v\}</title>"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PROGMEM\:template.h}
{\xe \v template.h\:PROGMEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char HTTP_END [] PROGMEM = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\"content=\\"width=device-width,initial-scale=1,user-scalable=no\\"/><title>\{v\}</title>"}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1 of file template.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.cpp}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "WiFiManagerReadFileButton.h"}\par
{\f2 #include "ArduinoJson.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for WiFiManagerReadFileButton.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d8/d2c/_wi_fi_manager_read_file_button_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/internals/WiFiManagerReadFileButton.h}
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ESP8266WiFi.h>}\par
{\f2 #include <ESP8266WebServer.h>}\par
{\f2 #include <DNSServer.h>}\par
{\f2 #include <memory>}\par
{\f2 #include "user_interface.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for WiFiManagerReadFileButton.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d99/_wi_fi_manager_read_file_button_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d5b/_wi_fi_manager_read_file_button_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WiFiManagerParameter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WiFiManager}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WIFI_MANAGER_MAX_PARAMS}\~ 10\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char HTTP_HEAD [] {\b PROGMEM} = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, user-scalable=no\\"/><title>\{v\}</title>"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v WIFI_MANAGER_MAX_PARAMS\:WiFiManagerReadFileButton.h}
{\xe \v WiFiManagerReadFileButton.h\:WIFI_MANAGER_MAX_PARAMS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WIFI_MANAGER_MAX_PARAMS\~ 10}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file WiFiManagerReadFileButton.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PROGMEM\:WiFiManagerReadFileButton.h}
{\xe \v WiFiManagerReadFileButton.h\:PROGMEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char HTTP_END [] PROGMEM = "<!DOCTYPE html><html lang=\\"en\\"><head><meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, user-scalable=no\\"/><title>\{v\}</title>"}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file WiFiManagerReadFileButton.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/irene3000.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/irene3000.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/irene3000.cpp}
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include <Arduino.h>}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <Irene3000.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for irene3000.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da5/irene3000_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:irene3000.cpp}
{\xe \v irene3000.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file irene3000.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Irene3000.h}
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "internals/CoolAdafruit_ADS1015.h"}\par
{\f2 #include <Arduino.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Irene3000.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "df/d34/_irene3000_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d86/_irene3000_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Irene3000}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is provided to manage the {\b Irene3000} Ph/Temperature Shield. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::parameters_T}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Irene3000::state}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADC_MAXIMUM_VALUE}\~ 32767\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REFERENCE_VOLTAGE_GAIN_4}\~ 1.024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b V_GAIN_2}\~ 0.0625\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b V_GAIN_4}\~ 0.03125\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b V_GAIN_8}\~ 0.015625\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Write_Check}\~ 0x1234\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b button}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b temp}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b freeAdc}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ph}\~ 3\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Irene3000} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ADC_MAXIMUM_VALUE\:Irene3000.h}
{\xe \v Irene3000.h\:ADC_MAXIMUM_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADC_MAXIMUM_VALUE\~ 32767}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file Irene3000.h.}\par
}
{\xe \v button\:Irene3000.h}
{\xe \v Irene3000.h\:button}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define button\~ 0}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file Irene3000.h.}\par
}
{\xe \v freeAdc\:Irene3000.h}
{\xe \v Irene3000.h\:freeAdc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define freeAdc\~ 2}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file Irene3000.h.}\par
}
{\xe \v ph\:Irene3000.h}
{\xe \v Irene3000.h\:ph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ph\~ 3}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file Irene3000.h.}\par
}
{\xe \v REFERENCE_VOLTAGE_GAIN_4\:Irene3000.h}
{\xe \v Irene3000.h\:REFERENCE_VOLTAGE_GAIN_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REFERENCE_VOLTAGE_GAIN_4\~ 1.024}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file Irene3000.h.}\par
}
{\xe \v temp\:Irene3000.h}
{\xe \v Irene3000.h\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define temp\~ 1}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file Irene3000.h.}\par
}
{\xe \v V_GAIN_2\:Irene3000.h}
{\xe \v Irene3000.h\:V_GAIN_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define V_GAIN_2\~ 0.0625}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file Irene3000.h.}\par
}
{\xe \v V_GAIN_4\:Irene3000.h}
{\xe \v Irene3000.h\:V_GAIN_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define V_GAIN_4\~ 0.03125}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file Irene3000.h.}\par
}
{\xe \v V_GAIN_8\:Irene3000.h}
{\xe \v Irene3000.h\:V_GAIN_8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define V_GAIN_8\~ 0.015625}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file Irene3000.h.}\par
}
{\xe \v Write_Check\:Irene3000.h}
{\xe \v Irene3000.h\:Write_Check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Write_Check\~ 0x1234}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file Irene3000.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.cpp}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.cpp}
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Source File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FS.h"}\par
{\f2 #include "Arduino.h"}\par
{\f2 #include "ArduinoJson.h"}\par
{\f2 #include "Jetpack.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Jetpack.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d5/d45/_jetpack_8cpp__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Source File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:Jetpack.cpp}
{\xe \v Jetpack.cpp\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG\~ 0}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file Jetpack.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.h}
{\xe \v /home/ashiroji/Arduino/libraries/CoolBoard/src/Jetpack.h}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Header File. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Arduino.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Jetpack.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d77/_jetpack_8h__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d4b/_jetpack_8h__dep__incl.svg" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Jetpack}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class manages the {\b Jetpack} shield. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Jetpack::state}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Jetpack} Header File. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mehdi Zemzem \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 27/06/2017 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid La Cool Co SAS \par
MIT license Copyright (c) 2017 La Cool Co SAS\par
}Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}